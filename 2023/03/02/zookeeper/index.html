

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid5.png">
  <link rel="icon" href="/img/fluid5.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Zbiao">
  <meta name="keywords" content="">
  
    <meta name="description" content="1、ZooKeeper介绍 分布式和集群的区别： 集群和分布式是两个完全不同的概念。 举个例子，比如有个秒杀系统，并发量太大单机承受不住，那加几台服务器也 一样 提供秒杀服务，这个时候就是 Cluster 集群  但现在换一种方式，将一个秒杀服务拆分成多个子服务，然后将这些子服务部署在不同的服务器上，这时候就是**Distributed 分布式** 。  ZooKeeper 是一个开源的分布式协调">
<meta property="og:type" content="article">
<meta property="og:title" content="ZooKeeper">
<meta property="og:url" content="https://bigotry-zb.github.io.git/2023/03/02/zookeeper/index.html">
<meta property="og:site_name" content="Zbiao | 多吃一点">
<meta property="og:description" content="1、ZooKeeper介绍 分布式和集群的区别： 集群和分布式是两个完全不同的概念。 举个例子，比如有个秒杀系统，并发量太大单机承受不住，那加几台服务器也 一样 提供秒杀服务，这个时候就是 Cluster 集群  但现在换一种方式，将一个秒杀服务拆分成多个子服务，然后将这些子服务部署在不同的服务器上，这时候就是**Distributed 分布式** 。  ZooKeeper 是一个开源的分布式协调">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bigotry-zb.github.io.git/2023/03/02/zookeeper/image-20230302173101166.png">
<meta property="og:image" content="https://bigotry-zb.github.io.git/2023/03/02/zookeeper/image-20230302173222937.png">
<meta property="og:image" content="https://bigotry-zb.github.io.git/2023/03/02/zookeeper/image-20230302162430964.png">
<meta property="og:image" content="https://bigotry-zb.github.io.git/2023/03/02/zookeeper/image-20230302163706474.png">
<meta property="og:image" content="https://bigotry-zb.github.io.git/2023/03/02/zookeeper/image-20230302164051516.png">
<meta property="og:image" content="https://bigotry-zb.github.io.git/2023/03/02/zookeeper/image-20230302174807920.png">
<meta property="og:image" content="https://bigotry-zb.github.io.git/2023/03/02/zookeeper/image-20230303180714366.png">
<meta property="og:image" content="https://bigotry-zb.github.io.git/2023/03/02/zookeeper/image-20230303182505315.png">
<meta property="og:image" content="https://bigotry-zb.github.io.git/2023/03/02/zookeeper/image-20230303185806065.png">
<meta property="og:image" content="https://bigotry-zb.github.io.git/2023/03/02/zookeeper/image-20230303190618796.png">
<meta property="og:image" content="https://bigotry-zb.github.io.git/2023/03/02/zookeeper/image-20230303190655094.png">
<meta property="article:published_time" content="2023-03-02T07:39:14.000Z">
<meta property="article:modified_time" content="2023-03-05T03:20:44.774Z">
<meta property="article:author" content="Zbiao">
<meta property="article:tag" content="java">
<meta property="article:tag" content="SpringBoot">
<meta property="article:tag" content="配置文件">
<meta property="article:tag" content="日志">
<meta property="article:tag" content="中间件">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://bigotry-zb.github.io.git/2023/03/02/zookeeper/image-20230302173101166.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>ZooKeeper - Zbiao | 多吃一点</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/toubudaziji.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/gundongtiao.css# 滚动条颜色.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"bigotry-zb.github.io.git","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":true,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>ZBiao&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default3.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="ZooKeeper"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-02 15:39" pubdate>
          2023年3月2日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          115 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="后端"
        id="heading-e778d61ae403fbb16e643ebfd764d320" role="tab" data-toggle="collapse" href="#collapse-e778d61ae403fbb16e643ebfd764d320"
        aria-expanded="true"
      >
        后端
        <span class="list-group-count">(5)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-e778d61ae403fbb16e643ebfd764d320"
           role="tabpanel" aria-labelledby="heading-e778d61ae403fbb16e643ebfd764d320">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2022/11/11/rabbitmq/" title="RabbitMQ"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">RabbitMQ</span>
        </a>
      
    
      
      
        <a href="/2022/10/17/springboot-shu-ju-ku/" title="SpringBoot-数据库"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">SpringBoot-数据库</span>
        </a>
      
    
      
      
        <a href="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/" title="SpringBoot-配置文件以及日志"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">SpringBoot-配置文件以及日志</span>
        </a>
      
    
      
      
        <a href="/2023/03/02/zookeeper/" title="ZooKeeper"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">ZooKeeper</span>
        </a>
      
    
      
      
        <a href="/2022/09/20/chang-jian-jia-gou-mo-shi/" title="常见架构模式"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">常见架构模式</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">ZooKeeper</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="1、ZooKeeper介绍">1、ZooKeeper介绍</h2>
<p><strong>分布式和集群的区别：</strong></p>
<p>集群和分布式是两个完全不同的概念。</p>
<p>举个例子，比如有个秒杀系统，并发量太大单机承受不住，那加几台服务器也 <strong>一样</strong> 提供秒杀服务，这个时候就是 <strong><code>Cluster</code> 集群</strong></p>
<p><img src="/2023/03/02/zookeeper/image-20230302173101166.png" srcset="/img/loading.gif" lazyload alt="集群"></p>
<p>但现在换一种方式，将一个秒杀服务拆分成多个子服务，然后将这些子服务部署在不同的服务器上，这时候就是**<code>Distributed</code> 分布式** 。</p>
<p><img src="/2023/03/02/zookeeper/image-20230302173222937.png" srcset="/img/loading.gif" lazyload alt="分布式"></p>
<p>ZooKeeper 是一个开源的<strong>分布式协调服务</strong>，它的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p>
<blockquote>
<p>原语：操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断。</p>
</blockquote>
<p><strong>ZooKeeper 为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</strong></p>
<p><strong>ZooKeeper 将数据保存在内存中，性能是非常棒的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。</strong></p>
<p>ZooKeeper特点：</p>
<ol>
<li><strong>顺序一致性：</strong> 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li>
<li><strong>原子性：</strong> 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li>
<li><strong>单一系统映像 ：</strong> 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li>
<li><strong>可靠性：</strong> 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li>
</ol>
<p>典型应用场景：</p>
<ol>
<li><strong>分布式锁</strong> ： 通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放锁。</li>
<li><strong>命名服务</strong> ：可以通过 ZooKeeper 的顺序节点生成全局唯一 ID</li>
<li><strong>数据发布/订阅</strong> ：通过 <strong>Watcher 机制</strong> 可以很方便地实现数据发布/订阅。当你将数据发布到 ZooKeeper 被监听的节点上，其他机器可通过监听 ZooKeeper 上节点的变化来实现配置的动态更新。</li>
</ol>
<p>这些功能的实现基本都得益于 ZooKeeper 可以保存数据的功能，但是 ZooKeeper 不适合保存大量数据。</p>
<p>用到ZooKeeper的著名开源项目：<strong>Kafka</strong> 、<strong>Hbase</strong> 、<strong>Hadoop</strong></p>
<h2 id="2、ZooKeeper基本概念">2、ZooKeeper基本概念</h2>
<h3 id="1、数据模型">1、数据模型</h3>
<p>ZooKeeper 数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数据可以是数字、字符串或者是二级制序列。并且。每个节点还可以拥有 N 个子节点，最上层是根节点以“/”来代表。每个数据节点在 ZooKeeper 中被称为 <strong>znode</strong>，它是 ZooKeeper 中数据的最小单元。并且，每个 znode 都一个唯一的路径标识。</p>
<p>注意：<strong>ZooKeeper 主要是用来协调服务的，而不是用来存储业务数据的，所以不要放比较大的数据在 znode 上，ZooKeeper 给出的上限是每个结点的数据大小最大是 1M。</strong></p>
<p><img src="/2023/03/02/zookeeper/image-20230302162430964.png" srcset="/img/loading.gif" lazyload alt></p>
<p>每个znode都有自己的<code>节点类型</code>和<code>节点状态</code>。</p>
<ol>
<li>节点类型：
<ul>
<li>持久节点：一旦创建就一直存在，直到将其删除。</li>
<li>临时节点：临时节点的生命周期是与 <strong>客户端会话</strong> 绑定的，<strong>会话消失则节点消失</strong> 。临时节点 <strong>只能做叶子节点</strong> ，不能创建子节点。</li>
<li>持久顺序节点：一个父节点可以为其子节点 <strong>维护一个创建的先后顺序</strong> ，这个顺序体现在 <strong>节点名称</strong> 上，是节点名称后自动添加一个由 10 位数字组成的数字串，从 0 开始计数。比如 <code>/node1/app0000000001</code> 、<code>/node1/app0000000002</code> 。</li>
<li>临时顺序节点：父节点可以创建一个维持了顺序的临时节点(和前面的持久顺序性节点一样)。</li>
</ul>
</li>
<li>节点状态：
<ul>
<li><code>czxid</code>：<code>Created ZXID</code>，该数据节点被 <strong>创建</strong> 时的事务ID。</li>
<li><code>mzxid</code>：<code>Modified ZXID</code>，节点 <strong>最后一次被更新时</strong> 的事务ID。</li>
<li><code>ctime</code>：<code>Created Time</code>，该节点被创建的时间。</li>
<li><code>mtime</code>： <code>Modified Time</code>，该节点最后一次被修改的时间。</li>
<li><code>version</code>：节点的版本号。</li>
<li><code>cversion</code>：<strong>子节点</strong> 的版本号。</li>
<li><code>aversion</code>：节点的 <code>ACL</code> 版本号。</li>
<li><code>ephemeralOwner</code>：创建该节点的会话的 <code>sessionID</code> ，如果该节点为持久节点，该值为0。</li>
<li><code>dataLength</code>：节点数据内容的长度。</li>
<li><code>numChildre</code>：该节点的子节点个数，如果为临时节点为0。</li>
<li><code>pzxid</code>：该节点子节点列表最后一次被修改时的事务ID，注意是子节点的 <strong>列表</strong> ，不是内容</li>
</ul>
</li>
</ol>
<p>对应于每个 znode，ZooKeeper 都会为其维护一个叫作 <strong>Stat</strong> 的数据结构，Stat 中记录了这个 znode 的三个相关的版本：</p>
<ul>
<li><strong>dataVersion</strong> ：当前 znode 节点的版本号</li>
<li><strong>cversion</strong> ： 当前 znode 子节点的版本</li>
<li><strong>aclVersion</strong> ： 当前 znode 的 ACL 的版本</li>
</ul>
<h3 id="2、会话">2、会话</h3>
<p>zk客户端和服务端是通过TCP长连接维持的会话机制，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watcher 事件通知。可以理解为保持连接状态。</p>
<p>在 <code>zookeeper</code> 中，会话有对应的事件，比如 <code>CONNECTION_LOSS 连接丢失事件</code> 、<code>SESSION_MOVED 会话转移事件</code> 、<code>SESSION_EXPIRED 会话超时失效事件</code> 。</p>
<p>Session 有一个属性叫做：<code>sessionTimeout</code> ，代表会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在<code>sessionTimeout</code>规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p>
<p>在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 <code>sessionID</code>，无论是哪台服务器为客户端分配的 <code>sessionID</code>，都要务必保证全局唯一。</p>
<h3 id="3、ACL">3、ACL</h3>
<p><code>ACL</code> 为 <code>Access Control Lists</code> ，它是一种权限控制，类似于UNIX文件系统的权限控制。共有五种权限，分别如下：</p>
<ul>
<li><code>CREATE</code> ：创建子节点的权限。</li>
<li><code>READ</code>：获取节点数据和子节点列表的权限。</li>
<li><code>WRITE</code>：更新节点数据的权限。</li>
<li><code>DELETE</code>：删除子节点的权限。</li>
<li><code>ADMIN</code>：设置节点 ACL 的权限。</li>
</ul>
<p><strong>CREATE</strong> 和 <strong>DELETE</strong> 这两种权限都是针对 <strong>子节点</strong> 的权限控制。</p>
<p>对于身份认证，提供了以下几种方式：</p>
<ul>
<li><strong>world</strong> ： 默认方式，所有用户都可无条件访问。</li>
<li><strong>auth</strong> :不使用任何 id，代表任何已认证的用户。</li>
<li><strong>digest</strong> :用户名:密码认证方式： <em>username:password</em> 。</li>
<li><strong>ip</strong> : 对指定 ip 进行限制。</li>
</ul>
<h3 id="4、Watcher机制">4、Watcher机制</h3>
<p>Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p>
<p><img src="/2023/03/02/zookeeper/image-20230302163706474.png" srcset="/img/loading.gif" lazyload alt="Watcher机制"></p>
<h2 id="3、ZooKeeper集群">3、ZooKeeper集群</h2>
<p>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的</p>
<p><img src="/2023/03/02/zookeeper/image-20230302164051516.png" srcset="/img/loading.gif" lazyload alt="ZooKeeper架构图"></p>
<p>组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过 <strong>ZAB 协议</strong>（ZooKeeper Atomic Broadcast）来保持数据的一致性。</p>
<p><strong>最典型集群模式： Master/Slave 模式（主备模式）</strong>。在这种模式中，通常 Master 服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。</p>
<h3 id="1、集群角色">1、集群角色</h3>
<p>ZooKeeper 中没有选择传统的 Master/Slave 概念，而是引入了 Leader、Follower 和 Observer 三种角色。</p>
<p>ZooKeeper 集群中的所有机器通过一个 <strong>Leader 选举过程</strong> 来选定一台称为 “<strong>Leader</strong>” 的机器。</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Leader</td>
<td>为客户端提供读和写的服务，负责投票的发起和决议，更新系统状态。</td>
</tr>
<tr>
<td>Follower</td>
<td>为客户端提供读服务，如果是写服务则转发给 Leader。参与选举过程中的投票。</td>
</tr>
<tr>
<td>Observer</td>
<td>为客户端提供读服务，如果是写服务则转发给 Leader。不参与选举过程中的投票，也不参与“过半写成功”策略。在不影响写性能的情况下提升集群的读性能。此角色于 ZooKeeper3.3 系列新增的角色。</td>
</tr>
</tbody>
</table>
<p>当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，就会进入 Leader 选举过程，这个过程会选举产生新的 Leader 服务器。</p>
<p>选举过程大致如下：</p>
<ol>
<li><strong>Leader election（选举阶段）</strong>：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。</li>
<li><strong>Discovery（发现阶段）</strong> ：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。</li>
<li><strong>Synchronization（同步阶段）</strong> :同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后 准 leader 才会成为真正的 leader。</li>
<li><strong>Broadcast（广播阶段）</strong> :到了这个阶段，ZooKeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。</li>
</ol>
<h3 id="2、ZooKeeper-集群中的服务器状态">2、ZooKeeper 集群中的服务器状态</h3>
<p><strong>LOOKING</strong> ：寻找 Leader。</p>
<p><strong>LEADING</strong> ：Leader 状态，对应的节点为 Leader。</p>
<p><strong>FOLLOWING</strong> ：Follower 状态，对应的节点为 Follower。</p>
<p><strong>OBSERVING</strong> ：Observer 状态，对应节点为 Observer，该节点不参与 Leader 选举。</p>
<h3 id="3、ZooKeeper-集群数最好是奇数台">3、ZooKeeper 集群数最好是奇数台</h3>
<p>首先明确一点，ZooKeeper 集群在宕掉几个 ZooKeeper 服务器之后，如果剩下的 ZooKeeper 服务器个数大于宕掉的个数的话整个 ZooKeeper 才依然可用。也就是说，2n和2n - 1的容忍度是一样的，都是n - 1。好比我们有 5 台，那么最大允许宕掉 2 台 ZooKeeper 服务器，如果我们有 6 台的的时候也同样只允许宕掉 2 台。所以何必增加一个不必要的ZooKeeper 呢？</p>
<h3 id="4、ZooKeeper-选举的过半机制防止脑裂">4、ZooKeeper 选举的过半机制防止脑裂</h3>
<p><strong>脑裂是什么？</strong></p>
<p>对于一个集群，通常多台机器会部署在不同机房，来提高这个集群的可用性。若发生机房间的网络故障，导致机房间网络不同，从而被割裂成几个小集群，这时候集群各自选主就会导致“脑裂”。当网络恢复后，会发现有好几个leader，这种现象就叫脑裂。</p>
<p>举例：比如现在有一个由 6 台服务器所组成的一个集群，部署在了 2 个机房，每个机房 3 台。正常情况下只有 1 个 leader，但是当两个机房中间网络断开的时候，每个机房的 3 台服务器都会认为另一个机房的 3 台服务器下线，而选出自己的 leader 并对外提供服务。若没有过半机制，当网络恢复的时候会发现有 2 个 leader。这将会带来数据性一致的问题。</p>
<p><strong>过半机制为何能防止脑裂？</strong></p>
<p>少于等于一半是不可能产生leader的，所以要分机房的话，必有一方小于一半，或者二者都是一半，于是产生不了脑裂。、</p>
<h2 id="4、一致性问题">4、一致性问题</h2>
<p>设计一个分布式系统必定会遇到一个问题—— <strong>因为分区容忍性（partition tolerance）的存在，就必定要求我们需要在系统可用性（availability）和数据一致性（consistency）中做出权衡</strong> 。这就是著名的 <code>CAP</code> 定理。</p>
<p>而为了解决数据一致性问题，在科学家和程序员的不断探索中，就出现了很多的一致性协议和算法。比如 2PC（两阶段提交），3PC（三阶段提交），Paxos算法等等。</p>
<p><strong>拜占庭将军问题</strong> 。它意指 <strong>在不可靠信道上试图通过消息传递的方式达到一致性是不可能的</strong>， 所以所有的一致性算法的 <strong>必要前提</strong> 就是安全可靠的消息通道。</p>
<h3 id="1、2PC（两阶段提交）">1、2PC（两阶段提交）</h3>
<p>两阶段提交是一种保证分布式系统数据一致性的协议，现在很多数据库都是采用的两阶段提交协议来完成 <strong>分布式事务</strong> 的处理。</p>
<blockquote>
<p>分布式事务有什么问题？</p>
<p>还是上述的例子，秒杀系统的下订单和加积分两个系统，此时下完订单会发个消息给积分系统，告知积分系统应该加积分了。若仅仅发个消息也不收回复，那么如何得知积分系统加积分还是没加呢？若是积分系统收到了，返回订单系统response，但中间出现网络波动，回复消息没有发送成功，订单系统是否会认为积分系统消息接收失败？是否会回滚事务？但此时积分系统是成功收到消息的，它就会去处理消息然后给用户增加积分，这个时候就会出现积分加了但是订单没下成功。</p>
</blockquote>
<p>所以我们所需要解决的是在分布式系统中，整个调用链中，我们所有服务的数据处理要么都成功要么都失败，即所有服务的 <strong>原子性问题</strong> 。</p>
<p>两阶段提交中，涉及到两个角色，协调者和参与者。</p>
<p>第一阶段：当要执行一个分布式事务的时候，事务发起者首先向协调者发起事务请求，然后协调者会给所有参与者发送 <code>prepare</code> 请求（其中包括事务内容）告诉参与者你们需要执行事务了，如果能执行我发的事务内容那么就先执行但不提交，执行后请给我回复。然后参与者收到 <code>prepare</code> 消息后，他们会开始执行事务（但不提交），并将 <code>Undo</code> 和 <code>Redo</code> 信息记入事务日志中，之后参与者就向协调者反馈是否准备好了。</p>
<p>第二阶段：主要是协调者根据参与者反馈的情况来决定接下来是否可以进行事务的提交操作，即提交事务或者回滚事务。</p>
<p><strong>所有的参与者</strong> 都返回了准备好了的消息，这个时候就进行事务的提交，协调者此时会给所有的参与者发送 <strong><code>Commit</code> 请求</strong> ，当参与者收到 <code>Commit</code> 请求的时候会执行前面执行的事务的 <strong>提交操作</strong> ，提交完毕之后将给协调者发送提交成功的响应。</p>
<p>而如果在第一阶段并不是所有参与者都返回了准备好了的消息，那么此时协调者将会给所有参与者发送 <strong>回滚事务的 <code>rollback</code> 请求</strong>，参与者收到之后将会 <strong>回滚它在第一阶段所做的事务处理</strong> ，然后再将处理情况返回给协调者，最终协调者收到响应后便给事务发起者返回处理失败的结果。</p>
<p><img src="/2023/03/02/zookeeper/image-20230302174807920.png" srcset="/img/loading.gif" lazyload alt></p>
<p>但是两阶段提交会有许多问题：</p>
<p><strong>单点故障问题</strong>，如果协调者挂了那么整个系统都处于不可用的状态了。</p>
<p><strong>阻塞问题</strong>，即当协调者发送 <code>prepare</code> 请求，参与者收到之后如果能处理那么它将会进行事务的处理但并不提交，这个时候会一直占用着资源不释放，如果此时协调者挂了，那么这些资源都不会再释放了，这会极大影响性能。</p>
<p><strong>数据不一致问题</strong>，比如当第二阶段，协调者只发送了一部分的 <code>commit</code> 请求就挂了，那么也就意味着，收到消息的参与者会进行事务的提交，而后面没收到的则不会进行事务提交，那么这时候就会产生数据不一致性问题。</p>
<h3 id="2、3PC（三阶段提交）">2、3PC（三阶段提交）</h3>
<p>因为2PC存在的一系列问题，比如单点，容错机制缺陷等等，从而产生了 <strong>3PC（三阶段提交）</strong> 。</p>
<ol>
<li><strong>CanCommit阶段</strong>：协调者向所有参与者发送 <code>CanCommit</code> 请求，参与者收到请求后会根据自身情况查看是否能执行事务，如果可以则返回 YES 响应并进入预备状态，否则返回 NO 。</li>
<li><strong>PreCommit阶段</strong>：协调者根据参与者返回的响应来决定是否可以进行下面的 <code>PreCommit</code> 操作。如果上面参与者返回的都是 YES，那么协调者将向所有参与者发送 <code>PreCommit</code> 预提交请求，参与者收到预提交请求后，会进行事务的执行操作，并将 <code>Undo</code> 和 <code>Redo</code> 信息写入事务日志中 ，最后如果参与者顺利执行了事务则给协调者返回成功的响应。<br>
如果在第一阶段协调者收到了 <strong>任何一个 NO</strong> 的信息，或者 <strong>在一定时间内</strong> 并没有收到全部的参与者的响应，那么就会中断事务，它会向所有参与者发送中断请求（abort），参与者收到中断请求之后会立即中断事务，或者在一定时间内没有收到协调者的请求，它也会中断事务。</li>
<li><strong>DoCommit阶段</strong>：如果协调者收到了所有参与者在 <code>PreCommit</code> 阶段的 YES 响应，那么协调者将会给所有参与者发送 <code>DoCommit</code> 请求，参与者收到 <code>DoCommit</code> 请求后则会进行事务的提交工作，完成后则会给协调者返回响应，协调者收到所有参与者返回的事务提交成功的响应之后则完成事务。<br>
若协调者在 <code>PreCommit</code> 阶段 收到了任何一个 NO 或者在一定时间内没有收到所有参与者的响应 ，那么就会进行中断请求的发送，参与者收到中断请求后则会 通过上面记录的回滚日志来进行事务的回滚操作，并向协调者反馈回滚状况，协调者收到参与者返回的消息后，中断事务。</li>
</ol>
<p><img src="/2023/03/02/zookeeper/image-20230303180714366.png" srcset="/img/loading.gif" lazyload alt></p>
<p>3PC 在很多地方进行了超时中断的处理，比如协调者在指定时间内为收到全部的确认消息则进行事务中断的处理，这样能 减少同步阻塞的时间。</p>
<blockquote>
<p><strong><code>3PC</code> 在 <code>DoCommit</code> 阶段参与者如未收到协调者发送的提交事务的请求，它会在一定时间内进行事务的提交</strong>。</p>
</blockquote>
<p>总之，<code>3PC</code> 通过一系列的超时机制很好的缓解了阻塞问题，但是最重要的一致性并没有得到根本的解决。</p>
<p>解决一致性问题还需要靠Paxos算法。</p>
<h3 id="3、Paxos算法">3、Paxos算法</h3>
<p><code>Paxos</code> 算法是基于<strong>消息传递且具有高度容错特性的一致性算法</strong>，是目前公认的解决分布式一致性问题最有效的算法之一，<strong>其解决的问题就是在分布式系统中如何就某个值（决议）达成一致</strong> 。</p>
<p>在Paxos中有三个角色，分别是Proposer提案者<code>、</code>Acceptor表决者<code>、</code>Learner学习者。Paxos算法和2PC一样，有两个阶段。</p>
<p>阶段一：prepare阶段</p>
<p>Proposer提案者：负责提出 <code>proposal</code>，每个提案者在提出提案时都会首先获取到一个 <strong>具有全局唯一性的、递增的提案编号N</strong>，即在整个集群中是唯一的编号 N，然后将该编号赋予其要提出的提案，在<strong>第一阶段是只将提案编号发送给所有的表决者</strong>。</p>
<p>Acceptor表决者：每个表决者在 <code>accept</code> 某提案后，会将该提案编号N记录在本地，这样每个表决者中保存的已经被 accept 的提案中会存在一个<strong>编号最大的提案</strong>，其编号假设为 <code>maxN</code>。每个表决者仅会 <code>accept</code> 编号大于自己本地 <code>maxN</code> 的提案，在批准提案时表决者会将以前接受过的最大编号的提案作为响应反馈给 <code>Proposer</code></p>
<p><img src="/2023/03/02/zookeeper/image-20230303182505315.png" srcset="/img/loading.gif" lazyload alt></p>
<p>阶段二：accept阶段</p>
<p>当一个提案被 Proposer 提出后，如果 <code>Proposer</code> 收到了超过半数的 <code>Acceptor</code> 的批准（<code>Proposer</code> 本身同意），那么此时 <code>Proposer</code> 会给所有的 <code>Acceptor</code> 发送真正的提案（你可以理解为第一阶段为试探），这个时候 <code>Proposer</code> 就会发送提案的内容和提案编号。</p>
<p>表决者收到提案请求后会再次比较本身已经批准过的最大提案编号和该提案编号，如果该提案编号 <strong>大于等于</strong> 已经批准过的最大提案编号，那么就 <code>accept</code> 该提案（此时执行提案内容但不提交），随后将情况返回给 <code>Proposer</code> 。如果不满足则不回应或者返回 NO 。</p>
<p>当 <code>Proposer</code> 收到超过半数的 <code>accept</code> ，那么它这个时候会向所有的 <code>acceptor</code> 发送提案的提交请求。这个时候需要<strong>向未批准的 <code>acceptor</code> 发送提案内容和提案编号并让它无条件执行和提交</strong>，而对于前面已经批准过该提案的 <code>acceptor</code> 来说 仅仅需要发送该提案的编号 ，让 <code>acceptor</code> 执行提交就行了。</p>
<p>而如果 <code>Proposer</code> 如果没有收到超过半数的 <code>accept</code> 那么它将会将 <strong>递增</strong> 该 <code>Proposal</code> 的编号，然后 <strong>重新进入 <code>Prepare</code> 阶段</strong> 。</p>
<p>所以这时候就出现了Paxos算法的死循环问题：</p>
<p>比如：提案者P1提出一个方案M1，完成准备工作，且acceptor又批准M1，但提案者P2也提出一个方案M2，也完成准备工作。因为此时出现了M2，M2比M1大，所以 P1 自增方案变为 M3 重新进入 准备 阶段，于是P2也要变，无休无止的永远提案下去，这就是 paxos 算法的死循环问题。</p>
<p>如何解决？很简单，<strong>就允许一个能提案</strong> 就行了。</p>
<h2 id="5、ZAB协议和Paxos算法">5、ZAB协议和Paxos算法</h2>
<p>Paxos 算法应该可以说是 ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos 算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。</p>
<p>ZAB 协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为 Zookeeper 设计的崩溃可恢复的原子消息广播算法。</p>
<p>ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</p>
<p>ZAB 协议包括两种基本的模式</p>
<p><strong>崩溃恢复</strong> ：当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出恢复模式。其中，<strong>所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和 Leader 服务器的数据状态保持一致</strong>。</p>
<p><strong>消息广播</strong> ：<strong>当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。</strong> 当一台同样遵守 ZAB 协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</p>
<blockquote>
<p>ZooKeeper 底层其实只提供了两个功能：① 管理（存储、读取）用户程序提交的数据；② 为用户程序提供数据节点监听服务。</p>
</blockquote>
<h2 id="6、典型应用场景">6、典型应用场景</h2>
<h3 id="1、选主">1、选主</h3>
<p>可以 <strong>让多个客户端创建一个指定的节点</strong> ，创建成功的就是 <code>master</code>。我们可以 <strong>让其他不是 <code>master</code> 的节点监听节点的状态</strong> ，比如说我们监听这个临时节点的父节点，如果子节点个数变了就代表 <code>master</code> 挂了，这个时候我们 <strong>触发回调函数进行重新选举</strong> ，或者我们直接监听节点的状态，我们可以通过节点是否已经失去连接来判断 <code>master</code> 是否挂了等等。</p>
<p><img src="/2023/03/02/zookeeper/image-20230303185806065.png" srcset="/img/loading.gif" lazyload alt></p>
<p>总的来说，完全可以 <strong>利用 临时节点、节点状态 和 <code>watcher</code> 来实现选主的功能</strong>，临时节点主要用来选举，节点状态和<code>watcher</code> 可以用来判断 <code>master</code> 的活性和进行重新选举。</p>
<h3 id="2、分布式锁">2、分布式锁</h3>
<p>分布式锁的实现方式有很多种，比如 <code>Redis</code> 、数据库 、<code>zookeeper</code> 等。</p>
<p>zk在高并发的情况下保证节点创建的全局唯一性，可以实现互斥锁，又因为能在分布式的情况下，所以能实现分布式锁呗。</p>
<p>如何实现？</p>
<p>首先肯定是如何获取锁，因为创建节点的唯一性，我们可以让多个客户端同时创建一个临时节点，<strong>创建成功的就说明获取到了锁</strong> 。然后没有获取到锁的客户端也像上面选主的非主节点创建一个 <code>watcher</code> 进行节点状态的监听，如果这个互斥锁被释放了（可能获取锁的客户端宕机了，或者那个客户端主动释放了锁）可以调用回调函数重新获得锁。</p>
<p>也可以使用<code>zookeeper</code> 同时实现 <strong>共享锁和独占锁</strong> 。</p>
<p>这个时候我规定所有创建节点必须有序，当你是读请求（要获取共享锁）的话，如果 <strong>没有比自己更小的节点，或比自己小的节点都是读请求</strong> ，则可以获取到读锁，然后就可以开始读了。<strong>若比自己小的节点中有写请求</strong> ，则当前客户端无法获取到读锁，只能等待前面的写请求完成。</p>
<p>如果你是写请求（获取独占锁），若 <strong>没有比自己更小的节点</strong> ，则表示当前客户端可以直接获取到写锁，对数据进行修改。若发现 <strong>有比自己更小的节点，无论是读操作还是写操作，当前客户端都无法获取到写锁</strong> ，等待所有前面的操作完成。</p>
<p>这就很好地同时实现了共享锁和独占锁，当然还有优化的地方，比如当一个锁得到释放它会通知所有等待的客户端从而造成 <strong>羊群效应</strong> 。此时可以通过让等待的节点只监听他们前面的节点。</p>
<h3 id="3、命名服务">3、命名服务</h3>
<p>如何给一个对象设置ID，可能都会想到 <code>UUID</code>，但是 <code>UUID</code> 最大的问题就在于它太长了。那么在条件允许的情况下，可以使用 <code>zookeeper</code> 来实现呢。</p>
<p>之前提到过 <code>zookeeper</code> 是通过 <strong>树形结构</strong> 来存储数据节点的，那也就是说，对于每个节点的 <strong>全路径</strong>，它必定是唯一的，就可以使用节点的全路径作为命名方式。</p>
<h3 id="4、集群管理和注册中心">4、集群管理和注册中心</h3>
<p>若是需要了解整个集群中有多少机器在工作，想对集群中的每台机器的运行时状态进行数据采集，对集群中机器进行上下线操作等等。</p>
<p><code>zookeeper</code> 天然支持的 <code>watcher</code> 和 临时节点能很好的实现这些需求。我们可以为每条机器创建临时节点，并监控其父节点，如果子节点列表有变动（我们可能创建删除了临时节点），那么我们可以使用在其父节点绑定的 <code>watcher</code> 进行状态监控和回调。</p>
<p><img src="/2023/03/02/zookeeper/image-20230303190618796.png" srcset="/img/loading.gif" lazyload alt></p>
<p>至于注册中心也很简单，我们同样也是让 <strong>服务提供者</strong> 在 <code>zookeeper</code> 中创建一个临时节点并且将自己的 <code>ip、port、调用方式</code> 写入节点，当 <strong>服务消费者</strong> 需要进行调用的时候会 <strong>通过注册中心找到相应的服务的地址列表(IP端口什么的)</strong> ，并缓存到本地(方便以后调用)，当消费者调用服务时，不会再去请求注册中心，而是直接通过负载均衡算法从地址列表中取一个服务提供者的服务器调用服务。</p>
<p>当服务提供者的某台服务器宕机或下线时，相应的地址会从服务提供者地址列表中移除。同时，注册中心会将新的服务地址列表发送给服务消费者的机器并缓存在消费者本机。</p>
<p><img src="/2023/03/02/zookeeper/image-20230303190655094.png" srcset="/img/loading.gif" lazyload alt></p>
<h2 id="7、ZooKeeper常用命令">7、ZooKeeper常用命令</h2>
<h3 id="1、常用命令">1、常用命令</h3>
<p>1、创建节点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">[zk: 127.0.0.1:2181(CONNECTED) 34] create /node1 “node1”<br></code></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">[zk: 127.0.0.1:2181(CONNECTED) 1] create /node1/node1.1 123<br>Created /node1/node1.1<br></code></pre></td></tr></table></figure>
<p>2、更新节点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">[zk: 127.0.0.1:2181(CONNECTED) 11] <span class="hljs-built_in">set</span> /node1 <span class="hljs-string">&quot;set node1&quot;</span><br></code></pre></td></tr></table></figure>
<p>3、或许节点</p>
<p>get命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> node1<br>cZxid = 0x47<br>ctime = Sun Jan 20 10:22:59 CST 2019<br>mZxid = 0x4b<br>mtime = Sun Jan 20 10:41:10 CST 2019<br>pZxid = 0x4a<br>cversion = 1<br>dataVersion = 1<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 9<br>numChildren = 1<br></code></pre></td></tr></table></figure>
<p>4、查看某个目录下的子节点</p>
<p>通过 <code>ls</code> 命令查看根目录下的节点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">[zk: 127.0.0.1:2181(CONNECTED) 37] <span class="hljs-built_in">ls</span> /<br>[dubbo, ZooKeeper, node1]<br></code></pre></td></tr></table></figure>
<p>通过 <code>ls</code> 命令查看 node1 目录下的节点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">[zk: 127.0.0.1:2181(CONNECTED) 5] <span class="hljs-built_in">ls</span> /node1<br>[node1.1]<br></code></pre></td></tr></table></figure>
<p>5、查看节点状态</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">[zk: 127.0.0.1:2181(CONNECTED) 10] <span class="hljs-built_in">stat</span> /node1<br>cZxid = 0x47<br>ctime = Sun Jan 20 10:22:59 CST 2019<br>mZxid = 0x47<br>mtime = Sun Jan 20 10:22:59 CST 2019<br>pZxid = 0x4a<br>cversion = 1<br>dataVersion = 0<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 11<br>numChildren = 1<br></code></pre></td></tr></table></figure>
<p>6、查看节点信息和状态</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">[zk: 127.0.0.1:2181(CONNECTED) 7] ls2 /node1<br>[node1.1]<br>cZxid = 0x47<br>ctime = Sun Jan 20 10:22:59 CST 2019<br>mZxid = 0x47<br>mtime = Sun Jan 20 10:22:59 CST 2019<br>pZxid = 0x4a<br>cversion = 1<br>dataVersion = 0<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 11<br>numChildren = 1<br></code></pre></td></tr></table></figure>
<p><code>ls2</code> 命令更像是 <code>ls</code> 命令和 <code>stat</code> 命令的结合。</p>
<p>7、删除节点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">[zk: 127.0.0.1:2181(CONNECTED) 3] delete /node1/node1.1<br></code></pre></td></tr></table></figure>
<h3 id="2、Curator简单使用">2、Curator简单使用</h3>
<p>先导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="1、连接-ZooKeeper-客户端">1、连接 ZooKeeper 客户端</h4>
<p>通过 <code>CuratorFrameworkFactory</code> 创建 <code>CuratorFramework</code> 对象，然后再调用 <code>CuratorFramework</code> 对象的 <code>start()</code> 方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BASE_SLEEP_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_RETRIES</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// Retry strategy. Retry 3 times, and will increase the sleep time between retries.</span><br><span class="hljs-type">RetryPolicy</span> <span class="hljs-variable">retryPolicy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(BASE_SLEEP_TIME, MAX_RETRIES);<br><span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">zkClient</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory.builder()<br>    <span class="hljs-comment">// the server to connect to (can be a server list)</span><br>    .connectString(<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>)<br>    .retryPolicy(retryPolicy)<br>    .build();<br>zkClient.start();<br></code></pre></td></tr></table></figure>
<ul>
<li><code>baseSleepTimeMs</code>：重试之间等待的初始时间</li>
<li><code>maxRetries</code> ：最大重试次数</li>
<li><code>connectString</code> ：要连接的服务器列表</li>
<li><code>retryPolicy</code> ：重试策略</li>
</ul>
<h4 id="2、创建节点">2、创建节点</h4>
<p>创建持久化节点：（下面两种方式均可）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意:下面的代码会报错</span><br>zkClient.create().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<br>zkClient.create().withMode(CreateMode.PERSISTENT).forPath(<span class="hljs-string">&quot;/node1/00002&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>报错原因是node1节点未创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().forPath(<span class="hljs-string">&quot;/node1&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>执行完上述代码后就不会报错。</p>
<p>推荐下面这行代码，<strong><code>creatingParentsIfNeeded()</code> 可以保证父节点不存在的时候自动创建父节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>创建临时节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>创建节点并指定数据内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>.getBytes());<br>zkClient.getData().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<span class="hljs-comment">//获取节点的数据内容，获取到的是 byte数组</span><br></code></pre></td></tr></table></figure>
<p>检测节点是否创建成功：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.checkExists().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<span class="hljs-comment">//不为null的话，说明节点创建成功</span><br></code></pre></td></tr></table></figure>
<h4 id="3、删除节点">3、删除节点</h4>
<p>删除一个子节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.delete().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>删除一个节点以及其下的所有子节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.delete().deletingChildrenIfNeeded().forPath(<span class="hljs-string">&quot;/node1&quot;</span>);<br></code></pre></td></tr></table></figure>
<h4 id="4、获取-更新节点数据内容">4、获取/更新节点数据内容</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>.getBytes());<br>zkClient.getData().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<span class="hljs-comment">//获取节点的数据内容</span><br>zkClient.setData().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>,<span class="hljs-string">&quot;c++&quot;</span>.getBytes());<span class="hljs-comment">//更新节点数据内容</span><br></code></pre></td></tr></table></figure>
<h4 id="5、获取某个节点的所有子节点路径">5、获取某个节点的所有子节点路径</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; childrenPaths = zkClient.getChildren().forPath(<span class="hljs-string">&quot;/node1&quot;</span>);<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%90%8E%E7%AB%AF/" class="category-chain-item">后端</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/java/">#java</a>
      
        <a href="/tags/SpringBoot/">#SpringBoot</a>
      
        <a href="/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">#配置文件</a>
      
        <a href="/tags/%E6%97%A5%E5%BF%97/">#日志</a>
      
        <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">#中间件</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>ZooKeeper</div>
      <div>https://bigotry-zb.github.io.git/2023/03/02/zookeeper/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Zbiao</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年3月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/07/mongodb/" title="MongoDB">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MongoDB</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/11/30/dui/" title="堆">
                        <span class="hidden-mobile">堆</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <span>Copyright © 2022</span> <i class="iconfont icon-love"></i> <span>ZBiao’s Blog</span>

    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="/js/diy/timeDate.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/jingtaisidai.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiantiao.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiaoxingxing.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
