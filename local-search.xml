<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MongoDB</title>
    <link href="/2023/03/07/mongodb/"/>
    <url>/2023/03/07/mongodb/</url>
    
    <content type="html"><![CDATA[<h2 id="1、MongoDB简介">1、MongoDB简介</h2><p>NoSQL(NoSQL = Not Only SQL)，即反SQL运动，指的是非关系型的数据库，是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。NoSQL的拥护者们提倡运用非关系型的数据存储，相对于目前铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入</p><p>为什幺使用NoSQL :</p><p>1、对数据库高并发读写。</p><p>2、对海量数据的高效率存储和访问。</p><p>3、对数据库的高可扩展性和高可用性。</p><p>弱点：</p><p>1、数据库事务一致性需求</p><p>2、数据库的写实时性和读实时性需求</p><p>3、对复杂的SQL查询，特别是多表关联查询的需求</p><p>MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。</p><p>在高负载的情况下，添加更多的节点，可以保证服务器性能。</p><p>MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p><p>MongoDB 特点：</p><ol><li>面向文档存储的数据库，操作起来比较简单和容易。</li><li>可以在MongoDB记录中设置任何属性的索引 (如：FirstName=“Sameer”,Address=“8 Gandhi Road”)来实现更快的排序。</li><li>可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。</li><li>如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。</li><li>Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。</li><li>MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。</li><li>Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。</li><li>Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。</li><li>Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。</li><li>MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。</li><li>MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。</li></ol><h2 id="2、安装MongoDB">2、安装MongoDB</h2><p>1、拉取镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull mongo:latest<br></code></pre></td></tr></table></figure><p>2、创建和启动容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d --restart=always -p 27017:27017 --name mymongo -v /data/db:/data/db -d mongo<br></code></pre></td></tr></table></figure><p>3、进入容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it mymongo/bin/bash <br></code></pre></td></tr></table></figure><p>4、使用MongoDB客户端进行操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mongo <br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">&gt; show dbs <span class="hljs-comment">#查询所有的数据库</span><br>admin 0.000GB <br>config 0.000GB <br><span class="hljs-built_in">local</span> 0.000GB <br></code></pre></td></tr></table></figure><h2 id="3、MongoDB-概念解析">3、MongoDB 概念解析</h2><p>mongodb中基本的概念是文档、集合、数据库。</p><table><thead><tr><th>SQL术语/概念</th><th>MongoDB术语/概念</th><th>解释/说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表/集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行/文档</td></tr><tr><td>column</td><td>field</td><td>数据字段/域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td></td><td>表连接,MongoDB不支持</td></tr><tr><td>primary key</td><td>primary key</td><td>主键,MongoDB自动将_id字段设置为主键</td></tr></tbody></table><p>一个对应关系的例子：</p><p><img src="/2023/03/07/mongodb/image-20230307143204066.png" alt></p><h3 id="1、数据库">1、数据库</h3><p>一个mongodb中可以建立多个数据库。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>db.help();</td><td>Help查看命令提示</td></tr><tr><td>use test</td><td>如果数据库不存在，则创建数据库，否则切换到指定数据库</td></tr><tr><td>show dbs;</td><td>查询所有数据库</td></tr><tr><td>db.dropDatabase();</td><td>删除当前使用数据库</td></tr><tr><td>db.getName();</td><td>查看当前使用的数据库</td></tr><tr><td>db.stats();</td><td>显示当前db状态</td></tr><tr><td>db.version();</td><td>当前db版本</td></tr></tbody></table><h3 id="2、文档">2、文档</h3><p>文档是一组键值(key-value)对(即BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。</p><p><strong>特点：</strong></p><p>1、文档中的键/值对是有序的。</p><p>2、文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</p><p>3、MongoDB区分类型和大小写。</p><p>4、MongoDB的文档不能有重复的键。</p><p>5、文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</p><p><strong>文档键命名规范：</strong></p><p>1、键不能含有\0 (空字符)。这个字符用来表示键的结尾。</p><p>2、.和$有特别的意义，只有在特定环境下才能使用。</p><p>3、以下划线&quot;_&quot;开头的键是保留的(不是严格要求的)。</p><h3 id="3、集合">3、集合</h3><p>集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。</p><p>集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。</p><p>1、 创建一个集合（table)</p><p>db.createCollection( “collName”);</p><p>2、 得到指定名称的集合（table )</p><p>db.getCollection(“user”);</p><h3 id="4、MongoDB数据类型">4、MongoDB数据类型</h3><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>String</td><td>字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</td></tr><tr><td>Integer</td><td>整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</td></tr><tr><td>Boolean</td><td>布尔值。用于存储布尔值（真/假）。</td></tr><tr><td>Double</td><td>双精度浮点值。用于存储浮点值。</td></tr><tr><td>Min/Max keys</td><td>将一个值与 BSON（二进制的  JSON）元素的最低值和最高值相对比。</td></tr><tr><td>Arrays</td><td>用于将数组或列表或多个值存储为一个键。</td></tr><tr><td>Timestamp</td><td>时间戳。记录文档修改或添加的具体时间。</td></tr><tr><td>Object</td><td>用于内嵌文档。</td></tr><tr><td>Null</td><td>用于创建空值。</td></tr><tr><td>Symbol</td><td>符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td></tr><tr><td>Date</td><td>日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td></tr><tr><td>Object ID</td><td>对象 ID。用于创建文档的  ID。</td></tr><tr><td>Binary Data</td><td>二进制数据。用于存储二进制数据。</td></tr><tr><td>Code</td><td>代码类型。用于在文档中存储 JavaScript 代码。</td></tr><tr><td>Regular expression</td><td>正则表达式类型。用于存储正则表达式。</td></tr></tbody></table><h3 id="5、应用场景">5、应用场景</h3><p><strong>适用场景</strong>：</p><p>1、网站数据：Mongo非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。</p><p>2、缓存：由于性能很高，Mongo也适合作为信息基础设施的缓存层。在系统重启之后，由M ongo搭建的持久化缓存层可以避免下层的数据源过载。</p><p>3、大尺寸，低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵， 在此之前，很多时候程序员往往会选择传统的文件进行存储。</p><p>4、高伸缩性的场景：Mongo非常适合由数十或数百台服务器组成的数据库。</p><p>5、用于对象及 JSON数据的存储：Mongo的BSON数据格式非常适合文档化格式的存储及查询。</p><p><strong>不适用场合</strong>：</p><p>1、高度事务性的系统：例如银行或会计系统。传统的关系型数据库目前还是<code>更适用于需要大量原子性复杂事务的应用程序</code>。</p><p>2、传统的商业智能应用：针对特定问题的BI数据库会对产生高度优化的查询方式。对于此类应用，数据仓库可能是更合适的选择。</p><h2 id="4、MongoDB常用操作">4、MongoDB常用操作</h2><h3 id="1、插入">1、插入</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">&gt; db.User.save(&#123;name:<span class="hljs-string">&#x27;zhangsan&#x27;</span>,age:21,sex:<span class="hljs-literal">true</span>&#125;)<br>&gt; db.User.<span class="hljs-function"><span class="hljs-title">find</span></span>()<br>&#123;<span class="hljs-string">&quot;_id&quot;</span>: Objectld(<span class="hljs-string">&quot;4f69e680c9106ee2ec95da66&quot;</span>), <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: 21,<span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-literal">true</span>&#125;<br></code></pre></td></tr></table></figure><p>_id组合 : Objectld是 _id的默认类型。Objectld使用12字节的存储空间，每个字节二位十六进制数字， 是一个24位的字符串</p><p><img src="/2023/03/07/mongodb/image-20230307144815982.png" alt></p><ol><li><p>时间戳：时间不断变化的</p></li><li><p>机器：主机的唯_标识码。通常是机器主机名的散列值，这样可以确保不同主机 生成不同的Objectld ,不产生冲突。</p></li><li><p>PID:为了确保在同一台机器上并发的多个进程产生的Objectld是唯一的，所以加上进程标识符(PID).</p></li><li><p>计数器：前9个字节保证了同一秒钟不同机器不同进程产生的Objectld是唯一的。 后3个字节就是一个自动增加的计数器，确保相同进程同一秒产生的Objectld也是不一样。同一秒最多允许每个进程拥有IS 777 2托个不同的Objectld。</p></li></ol><h3 id="2、查询">2、查询</h3><p>1、where</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># select * from User where name = &#x27;zhangsan&#x27;</span><br>&gt; db.User.find(&#123;name:<span class="hljs-string">&quot;zhangsan&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><p>2、FIELDS</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># select name, age from User where age = 21</span><br>&gt; db.User.find(&#123;age:21&#125;, &#123;<span class="hljs-string">&#x27;name&#x27;</span>:1, <span class="hljs-string">&#x27;age&#x27;</span>:1&#125;)<br></code></pre></td></tr></table></figure><p>3、SORT</p><p>在 MongoDB 中使用 sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># select * from User order by age</span><br>&gt; db.User.find().<span class="hljs-built_in">sort</span>(&#123;age:1&#125;)<br></code></pre></td></tr></table></figure><p>4、SUCE</p><p>在 MongoDB 中使用 limit()方法来读取指定数量的数据，skip()方法来跳过指定数量的数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># select * from User skip 2 limit 3</span><br>&gt; db.User.find().skip(0).<span class="hljs-built_in">limit</span>(3)<br></code></pre></td></tr></table></figure><p>5、IN</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># select * from User where age in (21, 26, 32)</span><br>&gt; db.User.find(&#123;age:&#123;<span class="hljs-variable">$in</span>:[21,26,32]&#125;&#125;)<br></code></pre></td></tr></table></figure><p>6、COUNT</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># select count(*) from User where age &gt;20</span><br>&gt; db.User.find(&#123;age:&#123;<span class="hljs-variable">$gt</span>:20&#125;&#125;).count()<br></code></pre></td></tr></table></figure><p>7、0R</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># select * from User where age = 21 or age = 28</span><br>&gt; db.User.find(&#123;<span class="hljs-variable">$or</span>:[&#123;age:21&#125;, &#123;age:28&#125;]&#125;)<br></code></pre></td></tr></table></figure><h3 id="3、更新">3、更新</h3><p>可直接用类似T-SQL条件表达式更新，或用SaveO更新从数据库返回到文档对象。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># update Userset age = 100, sex = 0 where name = &#x27;user1&#x27;</span><br>&gt; db.User.update(&#123;name:<span class="hljs-string">&quot;zhangsan&quot;</span>&#125;, &#123;<span class="hljs-variable">$set</span>:&#123;age:100, sex:0&#125;&#125;)<br></code></pre></td></tr></table></figure><p>Update()有几个参数需要注意。</p><p>db.collection.update(criteria, objNew, upsert, mult)</p><p>criteria:需要更新的条件表达式</p><p>objNew:更新表达式</p><p>upsert:如FI标记录不存在，是否插入新文档。</p><p>multi:是否更新多个文档。</p><h3 id="4、删除">4、删除</h3><p>删除后的文档不可恢复</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">&gt; db.User.remove(<span class="hljs-built_in">id</span>)<br><span class="hljs-comment"># 移除对应id的行</span><br>&gt; db.User.remove(&#123;&#125;)<br><span class="hljs-comment"># 移除所有</span><br></code></pre></td></tr></table></figure><h3 id="5、聚合">5、聚合</h3><p>MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)</p><p>举个例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sh">&gt;db.article.insert(&#123;<br>    title: <span class="hljs-string">&#x27;MongoDB Overview&#x27;</span>, <br>   description: <span class="hljs-string">&#x27;MongoDB is no sql database&#x27;</span>,<br>   by_user: <span class="hljs-string">&#x27;runoob.com&#x27;</span>,<br>   url: <span class="hljs-string">&#x27;http://www.runoob.com&#x27;</span>,<br>   tags: [<span class="hljs-string">&#x27;mongodb&#x27;</span>, <span class="hljs-string">&#x27;database&#x27;</span>, <span class="hljs-string">&#x27;NoSQL&#x27;</span>],<br>   likes: 100<br>&#125;)<br>&gt;db.article.insert(&#123;<br>   title: <span class="hljs-string">&#x27;NoSQL Overview&#x27;</span>, <br>   description: <span class="hljs-string">&#x27;No sql database is very fast&#x27;</span>,<br>   by_user: <span class="hljs-string">&#x27;runoob.com&#x27;</span>,<br>   url: <span class="hljs-string">&#x27;http://www.runoob.com&#x27;</span>,<br>   tags: [<span class="hljs-string">&#x27;mongodb&#x27;</span>, <span class="hljs-string">&#x27;database&#x27;</span>, <span class="hljs-string">&#x27;NoSQL&#x27;</span>],<br>   likes: 10<br>&#125;)<br>&gt;db.article.insert(&#123;<br>   title: <span class="hljs-string">&#x27;Neo4j Overview&#x27;</span>, <br>   description: <span class="hljs-string">&#x27;Neo4j is no sql database&#x27;</span>,<br>   by_user: <span class="hljs-string">&#x27;Neo4j&#x27;</span>,<br>   url: <span class="hljs-string">&#x27;http://www.neo4j.com&#x27;</span>,<br>   tags: [<span class="hljs-string">&#x27;neo4j&#x27;</span>, <span class="hljs-string">&#x27;database&#x27;</span>, <span class="hljs-string">&#x27;NoSQL&#x27;</span>],<br>   likes: 750<br>&#125;)<br></code></pre></td></tr></table></figure><p>统计sum：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># select by_user, count(*) from article group by by_user</span><br>&gt; db.article.aggregate([&#123;<span class="hljs-variable">$group</span> : &#123;_id : <span class="hljs-string">&quot;<span class="hljs-variable">$by_user</span>&quot;</span>, num_tutorial : &#123;<span class="hljs-variable">$sum</span> : 1&#125;&#125;&#125;])<br><br>&#123;<br><span class="hljs-string">&quot;result&quot;</span> : [<br>      &#123;<br><span class="hljs-string">&quot;_id&quot;</span> : <span class="hljs-string">&quot;runoob.com&quot;</span>,<br><span class="hljs-string">&quot;num_tutorial&quot;</span> : 2<br>      &#125;,<br>      &#123;<br><span class="hljs-string">&quot;_id&quot;</span> : <span class="hljs-string">&quot;Neo4j&quot;</span>,<br><span class="hljs-string">&quot;num_tutorial&quot;</span> : 1<br>      &#125;<br>   ],<br><span class="hljs-string">&quot;ok&quot;</span> : 1<br>&#125;<br></code></pre></td></tr></table></figure><p>常见的聚合表达式：</p><table><thead><tr><th><strong>表达式</strong></th><th><strong>描述</strong></th><th><strong>实例</strong></th></tr></thead><tbody><tr><td>$sum</td><td>计算总和。</td><td>db.mycol.aggregate([{$group  : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])</td></tr><tr><td>$avg</td><td>计算平均值</td><td>db.mycol.aggregate([{$group  : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])</td></tr><tr><td>$min</td><td>获取集合中所有文档对应值得最小值。</td><td>db.mycol.aggregate([{$group  : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])</td></tr><tr><td>$max</td><td>获取集合中所有文档对应值得最大值。</td><td>db.mycol.aggregate([{$group  : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])</td></tr><tr><td>$push</td><td>在结果文档中插入值到一个数组中。</td><td>db.mycol.aggregate([{$group  : {_id : “$by_user”, url : {$push: “$url”}}}])</td></tr><tr><td>$addToSet</td><td>在结果文档中插入值到一个数组中，但不创建副本。</td><td>db.mycol.aggregate([{$group  : {_id : “$by_user”, url : {$addToSet : “$url”}}}])</td></tr><tr><td>$first</td><td>根据资源文档的排序获取第一个文档数据。</td><td>db.mycol.aggregate([{$group  : {_id : “$by_user”, first_url : {$first : “$url”}}}])</td></tr><tr><td>$last</td><td>根据资源文档的排序获取最后一个文档数据</td><td>db.mycol.aggregate([{$group  : {_id : “$by_user”, last_url : {$last : “$url”}}}])</td></tr></tbody></table><h3 id="6、索引">6、索引</h3><p>索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。</p><p>这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。</p><p>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构。</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">&gt;db.User.createIndex(&#123;<span class="hljs-string">&quot;name&quot;</span>:1&#125;)<br></code></pre></td></tr></table></figure><p>语法中 name值为要创建的索引字段，1 为指定按升序创建索引，如果想按降序来创建索引指定为 -1 即可</p><h2 id="5、Spring-boot集成mongodb">5、Spring boot集成mongodb</h2><p>spring-data-mongodb提供了MongoTemplate与MongoRepository两种方式访问mongodb，MongoRepository操作简单，MongoTemplate操作灵活，我们在项目中可以灵活适用这两种方式操作mongodb，MongoRepository的缺点是不够灵活，MongoTemplate正好可以弥补不足。</p><p>1、引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、修改配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mongodb:</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span> <span class="hljs-comment"># mongodb的连接地址</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">27017</span> <span class="hljs-comment"># mongodb的连接端口号</span><br>  <span class="hljs-attr">database:</span> <span class="hljs-string">port</span> <span class="hljs-comment"># mongodb的连接的数据库</span><br></code></pre></td></tr></table></figure><h3 id="1、-基于MongoTemplate-开发CRUD">1、 基于MongoTemplate 开发CRUD</h3><p>1、添加实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Document(&quot;User&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br> <span class="hljs-meta">@Id</span><br> <span class="hljs-keyword">private</span> String id;<br> <span class="hljs-keyword">private</span> String name;<br> <span class="hljs-keyword">private</span> Integer age;<br> <span class="hljs-keyword">private</span> String email;<br> <span class="hljs-keyword">private</span> String createDate;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、实现</p><p>常用方法<br>mongoTemplate.findAll(User.class): 查询User文档的全部数据<br>mongoTemplate.findById(<id>, User.class): 查询User文档id为id的数据<br>mongoTemplate.find(query, User.class);: 根据query内的查询条件查询<br>mongoTemplate.upsert(query, update, User.class): 修改<br>mongoTemplate.remove(query, User.class): 删除<br>mongoTemplate.insert(User): 新增</id></p><p>Query对象<br>1、创建一个query对象（用来封装所有条件对象)，再创建一个criteria对象（用来构建条件）<br>2、 精准条件：criteria.and(“key”).is(“条件”)<br>模糊条件：criteria.and(“key”).regex(“条件”)<br>3、封装条件：query.addCriteria(criteria)<br>4、大于（创建新的criteria）：Criteria gt = Criteria.where(“key”).gt（“条件”）<br>小于（创建新的criteria）：Criteria lt = Criteria.where(“key”).lt（“条件”）<br>5、Query.addCriteria(new Criteria().andOperator(gt,lt));<br>6、一个query中只能有一个andOperator()。其参数也可以是Criteria数组。<br>7、排序 ：query.with（new Sort(Sort.Direction.ASC, “age”). and(new Sort(Sort.Direction.DESC, “date”)))</p><p>3、测试类进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DemomogoApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MongoTemplate mongoTemplate;<br><br>    <span class="hljs-comment">//添加</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setAge(<span class="hljs-number">20</span>);<br>        user.setName(<span class="hljs-string">&quot;test&quot;</span>);<br>        user.setEmail(<span class="hljs-string">&quot;4932200@qq.com&quot;</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> mongoTemplate.insert(user);<br>        System.out.println(user1);<br>    &#125;<br>    <br>    <span class="hljs-comment">//条件查询</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Query</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Query</span>(Criteria<br>                .where(<span class="hljs-string">&quot;name&quot;</span>).is(<span class="hljs-string">&quot;test&quot;</span>)<br>                .and(<span class="hljs-string">&quot;age&quot;</span>).is(<span class="hljs-number">20</span>));<br>        List&lt;User&gt; userList = mongoTemplate.find(query, User.class);<br>        System.out.println(userList);<br>    &#125;<br><br>    <span class="hljs-comment">//修改</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mongoTemplate.findById(<span class="hljs-string">&quot;5ffbfa2ac290f356edf9b5aa&quot;</span>, User.class);<br>        user.setName(<span class="hljs-string">&quot;test_1&quot;</span>);<br>        user.setAge(<span class="hljs-number">25</span>);<br>        user.setEmail(<span class="hljs-string">&quot;493220990@qq.com&quot;</span>);<br>        <span class="hljs-type">Query</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Query</span>(Criteria.where(<span class="hljs-string">&quot;_id&quot;</span>).is(user.getId()));<br>        <span class="hljs-type">Update</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Update</span>();<br>        update.set(<span class="hljs-string">&quot;name&quot;</span>, user.getName());<br>        update.set(<span class="hljs-string">&quot;age&quot;</span>, user.getAge());<br>        update.set(<span class="hljs-string">&quot;email&quot;</span>, user.getEmail());<br>        <span class="hljs-type">UpdateResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> mongoTemplate.upsert(query, update, User.class);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> result.getModifiedCount();<br>        System.out.println(count);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、基于MongoRepository开发CRUD">2、基于MongoRepository开发CRUD</h3><p>Spring Data提供了对mongodb数据访问的支持，我们只需要继承MongoRepository类，按照Spring Data规范就可以了</p><p>1、不是随便声明的，而需要符合一定的规范<br>2、 查询方法以find | read | get开头<br>3、 涉及条件查询时，条件的属性用条件关键字连接<br>4、 要注意的是：条件属性首字母需要大写<br>5、 支持属性的级联查询，但若当前类有符合条件的属性则优先使用，而不使用级联属性,若需要使用级联属性，则属性之间使用_强制进行连接</p><p>添加com.zb.mongodb.repository.UserRepository类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zb.mongodb.repository;<br><br><span class="hljs-keyword">import</span> com.zb.mongodb.entity.User;<br><span class="hljs-keyword">import</span> org.springframework.data.mongodb.repository.MongoRepository;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MongoRepository</span>&lt;User, String&gt; &#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>添加测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DemomogoApplicationTests1</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserRepository userRepository;<br><br>    <span class="hljs-comment">//添加</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setAge(<span class="hljs-number">20</span>);<br>        user.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br>        user.setEmail(<span class="hljs-string">&quot;3332200@qq.com&quot;</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> userRepository.save(user);<br>    &#125;<br>    <br>     <span class="hljs-comment">//条件查询</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br>        user.setAge(<span class="hljs-number">20</span>);<br>        Example&lt;User&gt; userExample = Example.of(user);<br>        List&lt;User&gt; userList = userRepository.findAll(userExample);<br>        System.out.println(userList);<br>    &#125;<br><br>    <span class="hljs-comment">//模糊查询</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findUsersLikeName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//创建匹配器，即如何使用查询条件</span><br>        <span class="hljs-type">ExampleMatcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> ExampleMatcher.matching() <span class="hljs-comment">//构建对象</span><br>                .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING) <span class="hljs-comment">//改变默认字符串匹配方式：模糊查询</span><br>                .withIgnoreCase(<span class="hljs-literal">true</span>); <span class="hljs-comment">//改变默认大小写忽略方式：忽略大小写</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setName(<span class="hljs-string">&quot;三&quot;</span>);<br>        Example&lt;User&gt; userExample = Example.of(user, matcher);<br>        List&lt;User&gt; userList = userRepository.findAll(userExample);<br>        System.out.println(userList);<br>    &#125;<br><br>    <span class="hljs-comment">//分页查询</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findUsersPage</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Sort</span> <span class="hljs-variable">sort</span> <span class="hljs-operator">=</span> Sort.by(Sort.Direction.DESC, <span class="hljs-string">&quot;age&quot;</span>);<br><span class="hljs-comment">//0为第一页</span><br>        <span class="hljs-type">Pageable</span> <span class="hljs-variable">pageable</span> <span class="hljs-operator">=</span> PageRequest.of(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, sort);<br><span class="hljs-comment">//创建匹配器，即如何使用查询条件</span><br>        <span class="hljs-type">ExampleMatcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> ExampleMatcher.matching() <span class="hljs-comment">//构建对象</span><br>                .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING) <span class="hljs-comment">//改变默认字符串匹配方式：模糊查询</span><br>                .withIgnoreCase(<span class="hljs-literal">true</span>); <span class="hljs-comment">//改变默认大小写忽略方式：忽略大小写</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setName(<span class="hljs-string">&quot;三&quot;</span>);<br>        Example&lt;User&gt; userExample = Example.of(user, matcher);<br><span class="hljs-comment">//创建实例</span><br>        Example&lt;User&gt; example = Example.of(user, matcher);<br>        Page&lt;User&gt; pages = userRepository.findAll(example, pageable);<br>        System.out.println(pages);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、实例">3、实例</h3><p>1、先添加model</p><p>2、添加Repository</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HospitalRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MongoRepository</span>&lt;Hospital,String&gt; &#123;<br>    <br>&#125; <br></code></pre></td></tr></table></figure><p>3、添加service接口及实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HospitalService</span> &#123;<br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 上传医院信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> paramMap</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Map&lt;String, Object&gt; paramMap)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HospitalServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HospitalService</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> HospitalRepository hospitalRepository;<br><br>    <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Map&lt;String, Object&gt; paramMap)</span> &#123;<br>log.info(JSONObject.toJSONString(paramMap));<br>  <span class="hljs-type">Hospital</span> <span class="hljs-variable">hospital</span> <span class="hljs-operator">=</span> JSONObject.parseObject(JSONObject.toJSONString(paramMap),Hospital.class);<br>   <span class="hljs-comment">//判断是否存在</span><br><span class="hljs-type">Hospital</span> <span class="hljs-variable">targetHospital</span> <span class="hljs-operator">=</span> hospitalRepository.getHospitalByHoscode(hospital.getHoscode());<br><span class="hljs-keyword">if</span>(<span class="hljs-literal">null</span> != targetHospital) &#123;<br>      hospital.setStatus(targetHospital.getStatus());<br>      hospital.setCreateTime(targetHospital.getCreateTime());<br>      hospital.setUpdateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>      hospital.setIsDeleted(<span class="hljs-number">0</span>);<br>hospitalRepository.save(hospital);<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//0：未上线 1：已上线</span><br>hospital.setStatus(<span class="hljs-number">0</span>);<br>      hospital.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>      hospital.setUpdateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>      hospital.setIsDeleted(<span class="hljs-number">0</span>);<br>hospitalRepository.save(hospital);<br>   &#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>4、添加controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(tags = &quot;医院管理API接口&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/api/hosp&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiController</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> HospitalService hospitalService;<br><br>    <span class="hljs-meta">@ApiOperation(value = &quot;上传医院&quot;)</span><br><span class="hljs-meta">@PostMapping(&quot;saveHospital&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">saveHospital</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>      Map&lt;String, Object&gt; paramMap = HttpRequestHelper.switchMap(request.getParameterMap());<br>hospitalService.save(paramMap);<br><span class="hljs-keyword">return</span> Result.ok();<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>数据库</tag>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZooKeeper</title>
    <link href="/2023/03/02/zookeeper/"/>
    <url>/2023/03/02/zookeeper/</url>
    
    <content type="html"><![CDATA[<h2 id="1、ZooKeeper介绍">1、ZooKeeper介绍</h2><p><strong>分布式和集群的区别：</strong></p><p>集群和分布式是两个完全不同的概念。</p><p>举个例子，比如有个秒杀系统，并发量太大单机承受不住，那加几台服务器也 <strong>一样</strong> 提供秒杀服务，这个时候就是 <strong><code>Cluster</code> 集群</strong></p><p><img src="/2023/03/02/zookeeper/image-20230302173101166.png" alt="集群"></p><p>但现在换一种方式，将一个秒杀服务拆分成多个子服务，然后将这些子服务部署在不同的服务器上，这时候就是**<code>Distributed</code> 分布式** 。</p><p><img src="/2023/03/02/zookeeper/image-20230302173222937.png" alt="分布式"></p><p>ZooKeeper 是一个开源的<strong>分布式协调服务</strong>，它的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p><blockquote><p>原语：操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断。</p></blockquote><p><strong>ZooKeeper 为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</strong></p><p><strong>ZooKeeper 将数据保存在内存中，性能是非常棒的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。</strong></p><p>ZooKeeper特点：</p><ol><li><strong>顺序一致性：</strong> 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li><li><strong>原子性：</strong> 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li><li><strong>单一系统映像 ：</strong> 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li><li><strong>可靠性：</strong> 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li></ol><p>典型应用场景：</p><ol><li><strong>分布式锁</strong> ： 通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放锁。</li><li><strong>命名服务</strong> ：可以通过 ZooKeeper 的顺序节点生成全局唯一 ID</li><li><strong>数据发布/订阅</strong> ：通过 <strong>Watcher 机制</strong> 可以很方便地实现数据发布/订阅。当你将数据发布到 ZooKeeper 被监听的节点上，其他机器可通过监听 ZooKeeper 上节点的变化来实现配置的动态更新。</li></ol><p>这些功能的实现基本都得益于 ZooKeeper 可以保存数据的功能，但是 ZooKeeper 不适合保存大量数据。</p><p>用到ZooKeeper的著名开源项目：<strong>Kafka</strong> 、<strong>Hbase</strong> 、<strong>Hadoop</strong></p><h2 id="2、ZooKeeper基本概念">2、ZooKeeper基本概念</h2><h3 id="1、数据模型">1、数据模型</h3><p>ZooKeeper 数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数据可以是数字、字符串或者是二级制序列。并且。每个节点还可以拥有 N 个子节点，最上层是根节点以“/”来代表。每个数据节点在 ZooKeeper 中被称为 <strong>znode</strong>，它是 ZooKeeper 中数据的最小单元。并且，每个 znode 都一个唯一的路径标识。</p><p>注意：<strong>ZooKeeper 主要是用来协调服务的，而不是用来存储业务数据的，所以不要放比较大的数据在 znode 上，ZooKeeper 给出的上限是每个结点的数据大小最大是 1M。</strong></p><p><img src="/2023/03/02/zookeeper/image-20230302162430964.png" alt></p><p>每个znode都有自己的<code>节点类型</code>和<code>节点状态</code>。</p><ol><li>节点类型：<ul><li>持久节点：一旦创建就一直存在，直到将其删除。</li><li>临时节点：临时节点的生命周期是与 <strong>客户端会话</strong> 绑定的，<strong>会话消失则节点消失</strong> 。临时节点 <strong>只能做叶子节点</strong> ，不能创建子节点。</li><li>持久顺序节点：一个父节点可以为其子节点 <strong>维护一个创建的先后顺序</strong> ，这个顺序体现在 <strong>节点名称</strong> 上，是节点名称后自动添加一个由 10 位数字组成的数字串，从 0 开始计数。比如 <code>/node1/app0000000001</code> 、<code>/node1/app0000000002</code> 。</li><li>临时顺序节点：父节点可以创建一个维持了顺序的临时节点(和前面的持久顺序性节点一样)。</li></ul></li><li>节点状态：<ul><li><code>czxid</code>：<code>Created ZXID</code>，该数据节点被 <strong>创建</strong> 时的事务ID。</li><li><code>mzxid</code>：<code>Modified ZXID</code>，节点 <strong>最后一次被更新时</strong> 的事务ID。</li><li><code>ctime</code>：<code>Created Time</code>，该节点被创建的时间。</li><li><code>mtime</code>： <code>Modified Time</code>，该节点最后一次被修改的时间。</li><li><code>version</code>：节点的版本号。</li><li><code>cversion</code>：<strong>子节点</strong> 的版本号。</li><li><code>aversion</code>：节点的 <code>ACL</code> 版本号。</li><li><code>ephemeralOwner</code>：创建该节点的会话的 <code>sessionID</code> ，如果该节点为持久节点，该值为0。</li><li><code>dataLength</code>：节点数据内容的长度。</li><li><code>numChildre</code>：该节点的子节点个数，如果为临时节点为0。</li><li><code>pzxid</code>：该节点子节点列表最后一次被修改时的事务ID，注意是子节点的 <strong>列表</strong> ，不是内容</li></ul></li></ol><p>对应于每个 znode，ZooKeeper 都会为其维护一个叫作 <strong>Stat</strong> 的数据结构，Stat 中记录了这个 znode 的三个相关的版本：</p><ul><li><strong>dataVersion</strong> ：当前 znode 节点的版本号</li><li><strong>cversion</strong> ： 当前 znode 子节点的版本</li><li><strong>aclVersion</strong> ： 当前 znode 的 ACL 的版本</li></ul><h3 id="2、会话">2、会话</h3><p>zk客户端和服务端是通过TCP长连接维持的会话机制，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watcher 事件通知。可以理解为保持连接状态。</p><p>在 <code>zookeeper</code> 中，会话有对应的事件，比如 <code>CONNECTION_LOSS 连接丢失事件</code> 、<code>SESSION_MOVED 会话转移事件</code> 、<code>SESSION_EXPIRED 会话超时失效事件</code> 。</p><p>Session 有一个属性叫做：<code>sessionTimeout</code> ，代表会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在<code>sessionTimeout</code>规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p><p>在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 <code>sessionID</code>，无论是哪台服务器为客户端分配的 <code>sessionID</code>，都要务必保证全局唯一。</p><h3 id="3、ACL">3、ACL</h3><p><code>ACL</code> 为 <code>Access Control Lists</code> ，它是一种权限控制，类似于UNIX文件系统的权限控制。共有五种权限，分别如下：</p><ul><li><code>CREATE</code> ：创建子节点的权限。</li><li><code>READ</code>：获取节点数据和子节点列表的权限。</li><li><code>WRITE</code>：更新节点数据的权限。</li><li><code>DELETE</code>：删除子节点的权限。</li><li><code>ADMIN</code>：设置节点 ACL 的权限。</li></ul><p><strong>CREATE</strong> 和 <strong>DELETE</strong> 这两种权限都是针对 <strong>子节点</strong> 的权限控制。</p><p>对于身份认证，提供了以下几种方式：</p><ul><li><strong>world</strong> ： 默认方式，所有用户都可无条件访问。</li><li><strong>auth</strong> :不使用任何 id，代表任何已认证的用户。</li><li><strong>digest</strong> :用户名:密码认证方式： <em>username:password</em> 。</li><li><strong>ip</strong> : 对指定 ip 进行限制。</li></ul><h3 id="4、Watcher机制">4、Watcher机制</h3><p>Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p><p><img src="/2023/03/02/zookeeper/image-20230302163706474.png" alt="Watcher机制"></p><h2 id="3、ZooKeeper集群">3、ZooKeeper集群</h2><p>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的</p><p><img src="/2023/03/02/zookeeper/image-20230302164051516.png" alt="ZooKeeper架构图"></p><p>组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过 <strong>ZAB 协议</strong>（ZooKeeper Atomic Broadcast）来保持数据的一致性。</p><p><strong>最典型集群模式： Master/Slave 模式（主备模式）</strong>。在这种模式中，通常 Master 服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。</p><h3 id="1、集群角色">1、集群角色</h3><p>ZooKeeper 中没有选择传统的 Master/Slave 概念，而是引入了 Leader、Follower 和 Observer 三种角色。</p><p>ZooKeeper 集群中的所有机器通过一个 <strong>Leader 选举过程</strong> 来选定一台称为 “<strong>Leader</strong>” 的机器。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>Leader</td><td>为客户端提供读和写的服务，负责投票的发起和决议，更新系统状态。</td></tr><tr><td>Follower</td><td>为客户端提供读服务，如果是写服务则转发给 Leader。参与选举过程中的投票。</td></tr><tr><td>Observer</td><td>为客户端提供读服务，如果是写服务则转发给 Leader。不参与选举过程中的投票，也不参与“过半写成功”策略。在不影响写性能的情况下提升集群的读性能。此角色于 ZooKeeper3.3 系列新增的角色。</td></tr></tbody></table><p>当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，就会进入 Leader 选举过程，这个过程会选举产生新的 Leader 服务器。</p><p>选举过程大致如下：</p><ol><li><strong>Leader election（选举阶段）</strong>：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。</li><li><strong>Discovery（发现阶段）</strong> ：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。</li><li><strong>Synchronization（同步阶段）</strong> :同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后 准 leader 才会成为真正的 leader。</li><li><strong>Broadcast（广播阶段）</strong> :到了这个阶段，ZooKeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。</li></ol><h3 id="2、ZooKeeper-集群中的服务器状态">2、ZooKeeper 集群中的服务器状态</h3><p><strong>LOOKING</strong> ：寻找 Leader。</p><p><strong>LEADING</strong> ：Leader 状态，对应的节点为 Leader。</p><p><strong>FOLLOWING</strong> ：Follower 状态，对应的节点为 Follower。</p><p><strong>OBSERVING</strong> ：Observer 状态，对应节点为 Observer，该节点不参与 Leader 选举。</p><h3 id="3、ZooKeeper-集群数最好是奇数台">3、ZooKeeper 集群数最好是奇数台</h3><p>首先明确一点，ZooKeeper 集群在宕掉几个 ZooKeeper 服务器之后，如果剩下的 ZooKeeper 服务器个数大于宕掉的个数的话整个 ZooKeeper 才依然可用。也就是说，2n和2n - 1的容忍度是一样的，都是n - 1。好比我们有 5 台，那么最大允许宕掉 2 台 ZooKeeper 服务器，如果我们有 6 台的的时候也同样只允许宕掉 2 台。所以何必增加一个不必要的ZooKeeper 呢？</p><h3 id="4、ZooKeeper-选举的过半机制防止脑裂">4、ZooKeeper 选举的过半机制防止脑裂</h3><p><strong>脑裂是什么？</strong></p><p>对于一个集群，通常多台机器会部署在不同机房，来提高这个集群的可用性。若发生机房间的网络故障，导致机房间网络不同，从而被割裂成几个小集群，这时候集群各自选主就会导致“脑裂”。当网络恢复后，会发现有好几个leader，这种现象就叫脑裂。</p><p>举例：比如现在有一个由 6 台服务器所组成的一个集群，部署在了 2 个机房，每个机房 3 台。正常情况下只有 1 个 leader，但是当两个机房中间网络断开的时候，每个机房的 3 台服务器都会认为另一个机房的 3 台服务器下线，而选出自己的 leader 并对外提供服务。若没有过半机制，当网络恢复的时候会发现有 2 个 leader。这将会带来数据性一致的问题。</p><p><strong>过半机制为何能防止脑裂？</strong></p><p>少于等于一半是不可能产生leader的，所以要分机房的话，必有一方小于一半，或者二者都是一半，于是产生不了脑裂。、</p><h2 id="4、一致性问题">4、一致性问题</h2><p>设计一个分布式系统必定会遇到一个问题—— <strong>因为分区容忍性（partition tolerance）的存在，就必定要求我们需要在系统可用性（availability）和数据一致性（consistency）中做出权衡</strong> 。这就是著名的 <code>CAP</code> 定理。</p><p>而为了解决数据一致性问题，在科学家和程序员的不断探索中，就出现了很多的一致性协议和算法。比如 2PC（两阶段提交），3PC（三阶段提交），Paxos算法等等。</p><p><strong>拜占庭将军问题</strong> 。它意指 <strong>在不可靠信道上试图通过消息传递的方式达到一致性是不可能的</strong>， 所以所有的一致性算法的 <strong>必要前提</strong> 就是安全可靠的消息通道。</p><h3 id="1、2PC（两阶段提交）">1、2PC（两阶段提交）</h3><p>两阶段提交是一种保证分布式系统数据一致性的协议，现在很多数据库都是采用的两阶段提交协议来完成 <strong>分布式事务</strong> 的处理。</p><blockquote><p>分布式事务有什么问题？</p><p>还是上述的例子，秒杀系统的下订单和加积分两个系统，此时下完订单会发个消息给积分系统，告知积分系统应该加积分了。若仅仅发个消息也不收回复，那么如何得知积分系统加积分还是没加呢？若是积分系统收到了，返回订单系统response，但中间出现网络波动，回复消息没有发送成功，订单系统是否会认为积分系统消息接收失败？是否会回滚事务？但此时积分系统是成功收到消息的，它就会去处理消息然后给用户增加积分，这个时候就会出现积分加了但是订单没下成功。</p></blockquote><p>所以我们所需要解决的是在分布式系统中，整个调用链中，我们所有服务的数据处理要么都成功要么都失败，即所有服务的 <strong>原子性问题</strong> 。</p><p>两阶段提交中，涉及到两个角色，协调者和参与者。</p><p>第一阶段：当要执行一个分布式事务的时候，事务发起者首先向协调者发起事务请求，然后协调者会给所有参与者发送 <code>prepare</code> 请求（其中包括事务内容）告诉参与者你们需要执行事务了，如果能执行我发的事务内容那么就先执行但不提交，执行后请给我回复。然后参与者收到 <code>prepare</code> 消息后，他们会开始执行事务（但不提交），并将 <code>Undo</code> 和 <code>Redo</code> 信息记入事务日志中，之后参与者就向协调者反馈是否准备好了。</p><p>第二阶段：主要是协调者根据参与者反馈的情况来决定接下来是否可以进行事务的提交操作，即提交事务或者回滚事务。</p><p><strong>所有的参与者</strong> 都返回了准备好了的消息，这个时候就进行事务的提交，协调者此时会给所有的参与者发送 <strong><code>Commit</code> 请求</strong> ，当参与者收到 <code>Commit</code> 请求的时候会执行前面执行的事务的 <strong>提交操作</strong> ，提交完毕之后将给协调者发送提交成功的响应。</p><p>而如果在第一阶段并不是所有参与者都返回了准备好了的消息，那么此时协调者将会给所有参与者发送 <strong>回滚事务的 <code>rollback</code> 请求</strong>，参与者收到之后将会 <strong>回滚它在第一阶段所做的事务处理</strong> ，然后再将处理情况返回给协调者，最终协调者收到响应后便给事务发起者返回处理失败的结果。</p><p><img src="/2023/03/02/zookeeper/image-20230302174807920.png" alt></p><p>但是两阶段提交会有许多问题：</p><p><strong>单点故障问题</strong>，如果协调者挂了那么整个系统都处于不可用的状态了。</p><p><strong>阻塞问题</strong>，即当协调者发送 <code>prepare</code> 请求，参与者收到之后如果能处理那么它将会进行事务的处理但并不提交，这个时候会一直占用着资源不释放，如果此时协调者挂了，那么这些资源都不会再释放了，这会极大影响性能。</p><p><strong>数据不一致问题</strong>，比如当第二阶段，协调者只发送了一部分的 <code>commit</code> 请求就挂了，那么也就意味着，收到消息的参与者会进行事务的提交，而后面没收到的则不会进行事务提交，那么这时候就会产生数据不一致性问题。</p><h3 id="2、3PC（三阶段提交）">2、3PC（三阶段提交）</h3><p>因为2PC存在的一系列问题，比如单点，容错机制缺陷等等，从而产生了 <strong>3PC（三阶段提交）</strong> 。</p><ol><li><strong>CanCommit阶段</strong>：协调者向所有参与者发送 <code>CanCommit</code> 请求，参与者收到请求后会根据自身情况查看是否能执行事务，如果可以则返回 YES 响应并进入预备状态，否则返回 NO 。</li><li><strong>PreCommit阶段</strong>：协调者根据参与者返回的响应来决定是否可以进行下面的 <code>PreCommit</code> 操作。如果上面参与者返回的都是 YES，那么协调者将向所有参与者发送 <code>PreCommit</code> 预提交请求，参与者收到预提交请求后，会进行事务的执行操作，并将 <code>Undo</code> 和 <code>Redo</code> 信息写入事务日志中 ，最后如果参与者顺利执行了事务则给协调者返回成功的响应。<br>如果在第一阶段协调者收到了 <strong>任何一个 NO</strong> 的信息，或者 <strong>在一定时间内</strong> 并没有收到全部的参与者的响应，那么就会中断事务，它会向所有参与者发送中断请求（abort），参与者收到中断请求之后会立即中断事务，或者在一定时间内没有收到协调者的请求，它也会中断事务。</li><li><strong>DoCommit阶段</strong>：如果协调者收到了所有参与者在 <code>PreCommit</code> 阶段的 YES 响应，那么协调者将会给所有参与者发送 <code>DoCommit</code> 请求，参与者收到 <code>DoCommit</code> 请求后则会进行事务的提交工作，完成后则会给协调者返回响应，协调者收到所有参与者返回的事务提交成功的响应之后则完成事务。<br>若协调者在 <code>PreCommit</code> 阶段 收到了任何一个 NO 或者在一定时间内没有收到所有参与者的响应 ，那么就会进行中断请求的发送，参与者收到中断请求后则会 通过上面记录的回滚日志来进行事务的回滚操作，并向协调者反馈回滚状况，协调者收到参与者返回的消息后，中断事务。</li></ol><p><img src="/2023/03/02/zookeeper/image-20230303180714366.png" alt></p><p>3PC 在很多地方进行了超时中断的处理，比如协调者在指定时间内为收到全部的确认消息则进行事务中断的处理，这样能 减少同步阻塞的时间。</p><blockquote><p><strong><code>3PC</code> 在 <code>DoCommit</code> 阶段参与者如未收到协调者发送的提交事务的请求，它会在一定时间内进行事务的提交</strong>。</p></blockquote><p>总之，<code>3PC</code> 通过一系列的超时机制很好的缓解了阻塞问题，但是最重要的一致性并没有得到根本的解决。</p><p>解决一致性问题还需要靠Paxos算法。</p><h3 id="3、Paxos算法">3、Paxos算法</h3><p><code>Paxos</code> 算法是基于<strong>消息传递且具有高度容错特性的一致性算法</strong>，是目前公认的解决分布式一致性问题最有效的算法之一，<strong>其解决的问题就是在分布式系统中如何就某个值（决议）达成一致</strong> 。</p><p>在Paxos中有三个角色，分别是Proposer提案者<code>、</code>Acceptor表决者<code>、</code>Learner学习者。Paxos算法和2PC一样，有两个阶段。</p><p>阶段一：prepare阶段</p><p>Proposer提案者：负责提出 <code>proposal</code>，每个提案者在提出提案时都会首先获取到一个 <strong>具有全局唯一性的、递增的提案编号N</strong>，即在整个集群中是唯一的编号 N，然后将该编号赋予其要提出的提案，在<strong>第一阶段是只将提案编号发送给所有的表决者</strong>。</p><p>Acceptor表决者：每个表决者在 <code>accept</code> 某提案后，会将该提案编号N记录在本地，这样每个表决者中保存的已经被 accept 的提案中会存在一个<strong>编号最大的提案</strong>，其编号假设为 <code>maxN</code>。每个表决者仅会 <code>accept</code> 编号大于自己本地 <code>maxN</code> 的提案，在批准提案时表决者会将以前接受过的最大编号的提案作为响应反馈给 <code>Proposer</code></p><p><img src="/2023/03/02/zookeeper/image-20230303182505315.png" alt></p><p>阶段二：accept阶段</p><p>当一个提案被 Proposer 提出后，如果 <code>Proposer</code> 收到了超过半数的 <code>Acceptor</code> 的批准（<code>Proposer</code> 本身同意），那么此时 <code>Proposer</code> 会给所有的 <code>Acceptor</code> 发送真正的提案（你可以理解为第一阶段为试探），这个时候 <code>Proposer</code> 就会发送提案的内容和提案编号。</p><p>表决者收到提案请求后会再次比较本身已经批准过的最大提案编号和该提案编号，如果该提案编号 <strong>大于等于</strong> 已经批准过的最大提案编号，那么就 <code>accept</code> 该提案（此时执行提案内容但不提交），随后将情况返回给 <code>Proposer</code> 。如果不满足则不回应或者返回 NO 。</p><p>当 <code>Proposer</code> 收到超过半数的 <code>accept</code> ，那么它这个时候会向所有的 <code>acceptor</code> 发送提案的提交请求。这个时候需要<strong>向未批准的 <code>acceptor</code> 发送提案内容和提案编号并让它无条件执行和提交</strong>，而对于前面已经批准过该提案的 <code>acceptor</code> 来说 仅仅需要发送该提案的编号 ，让 <code>acceptor</code> 执行提交就行了。</p><p>而如果 <code>Proposer</code> 如果没有收到超过半数的 <code>accept</code> 那么它将会将 <strong>递增</strong> 该 <code>Proposal</code> 的编号，然后 <strong>重新进入 <code>Prepare</code> 阶段</strong> 。</p><p>所以这时候就出现了Paxos算法的死循环问题：</p><p>比如：提案者P1提出一个方案M1，完成准备工作，且acceptor又批准M1，但提案者P2也提出一个方案M2，也完成准备工作。因为此时出现了M2，M2比M1大，所以 P1 自增方案变为 M3 重新进入 准备 阶段，于是P2也要变，无休无止的永远提案下去，这就是 paxos 算法的死循环问题。</p><p>如何解决？很简单，<strong>就允许一个能提案</strong> 就行了。</p><h2 id="5、ZAB协议和Paxos算法">5、ZAB协议和Paxos算法</h2><p>Paxos 算法应该可以说是 ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos 算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。</p><p>ZAB 协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为 Zookeeper 设计的崩溃可恢复的原子消息广播算法。</p><p>ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</p><p>ZAB 协议包括两种基本的模式</p><p><strong>崩溃恢复</strong> ：当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出恢复模式。其中，<strong>所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和 Leader 服务器的数据状态保持一致</strong>。</p><p><strong>消息广播</strong> ：<strong>当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。</strong> 当一台同样遵守 ZAB 协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</p><blockquote><p>ZooKeeper 底层其实只提供了两个功能：① 管理（存储、读取）用户程序提交的数据；② 为用户程序提供数据节点监听服务。</p></blockquote><h2 id="6、典型应用场景">6、典型应用场景</h2><h3 id="1、选主">1、选主</h3><p>可以 <strong>让多个客户端创建一个指定的节点</strong> ，创建成功的就是 <code>master</code>。我们可以 <strong>让其他不是 <code>master</code> 的节点监听节点的状态</strong> ，比如说我们监听这个临时节点的父节点，如果子节点个数变了就代表 <code>master</code> 挂了，这个时候我们 <strong>触发回调函数进行重新选举</strong> ，或者我们直接监听节点的状态，我们可以通过节点是否已经失去连接来判断 <code>master</code> 是否挂了等等。</p><p><img src="/2023/03/02/zookeeper/image-20230303185806065.png" alt></p><p>总的来说，完全可以 <strong>利用 临时节点、节点状态 和 <code>watcher</code> 来实现选主的功能</strong>，临时节点主要用来选举，节点状态和<code>watcher</code> 可以用来判断 <code>master</code> 的活性和进行重新选举。</p><h3 id="2、分布式锁">2、分布式锁</h3><p>分布式锁的实现方式有很多种，比如 <code>Redis</code> 、数据库 、<code>zookeeper</code> 等。</p><p>zk在高并发的情况下保证节点创建的全局唯一性，可以实现互斥锁，又因为能在分布式的情况下，所以能实现分布式锁呗。</p><p>如何实现？</p><p>首先肯定是如何获取锁，因为创建节点的唯一性，我们可以让多个客户端同时创建一个临时节点，<strong>创建成功的就说明获取到了锁</strong> 。然后没有获取到锁的客户端也像上面选主的非主节点创建一个 <code>watcher</code> 进行节点状态的监听，如果这个互斥锁被释放了（可能获取锁的客户端宕机了，或者那个客户端主动释放了锁）可以调用回调函数重新获得锁。</p><p>也可以使用<code>zookeeper</code> 同时实现 <strong>共享锁和独占锁</strong> 。</p><p>这个时候我规定所有创建节点必须有序，当你是读请求（要获取共享锁）的话，如果 <strong>没有比自己更小的节点，或比自己小的节点都是读请求</strong> ，则可以获取到读锁，然后就可以开始读了。<strong>若比自己小的节点中有写请求</strong> ，则当前客户端无法获取到读锁，只能等待前面的写请求完成。</p><p>如果你是写请求（获取独占锁），若 <strong>没有比自己更小的节点</strong> ，则表示当前客户端可以直接获取到写锁，对数据进行修改。若发现 <strong>有比自己更小的节点，无论是读操作还是写操作，当前客户端都无法获取到写锁</strong> ，等待所有前面的操作完成。</p><p>这就很好地同时实现了共享锁和独占锁，当然还有优化的地方，比如当一个锁得到释放它会通知所有等待的客户端从而造成 <strong>羊群效应</strong> 。此时可以通过让等待的节点只监听他们前面的节点。</p><h3 id="3、命名服务">3、命名服务</h3><p>如何给一个对象设置ID，可能都会想到 <code>UUID</code>，但是 <code>UUID</code> 最大的问题就在于它太长了。那么在条件允许的情况下，可以使用 <code>zookeeper</code> 来实现呢。</p><p>之前提到过 <code>zookeeper</code> 是通过 <strong>树形结构</strong> 来存储数据节点的，那也就是说，对于每个节点的 <strong>全路径</strong>，它必定是唯一的，就可以使用节点的全路径作为命名方式。</p><h3 id="4、集群管理和注册中心">4、集群管理和注册中心</h3><p>若是需要了解整个集群中有多少机器在工作，想对集群中的每台机器的运行时状态进行数据采集，对集群中机器进行上下线操作等等。</p><p><code>zookeeper</code> 天然支持的 <code>watcher</code> 和 临时节点能很好的实现这些需求。我们可以为每条机器创建临时节点，并监控其父节点，如果子节点列表有变动（我们可能创建删除了临时节点），那么我们可以使用在其父节点绑定的 <code>watcher</code> 进行状态监控和回调。</p><p><img src="/2023/03/02/zookeeper/image-20230303190618796.png" alt></p><p>至于注册中心也很简单，我们同样也是让 <strong>服务提供者</strong> 在 <code>zookeeper</code> 中创建一个临时节点并且将自己的 <code>ip、port、调用方式</code> 写入节点，当 <strong>服务消费者</strong> 需要进行调用的时候会 <strong>通过注册中心找到相应的服务的地址列表(IP端口什么的)</strong> ，并缓存到本地(方便以后调用)，当消费者调用服务时，不会再去请求注册中心，而是直接通过负载均衡算法从地址列表中取一个服务提供者的服务器调用服务。</p><p>当服务提供者的某台服务器宕机或下线时，相应的地址会从服务提供者地址列表中移除。同时，注册中心会将新的服务地址列表发送给服务消费者的机器并缓存在消费者本机。</p><p><img src="/2023/03/02/zookeeper/image-20230303190655094.png" alt></p><h2 id="7、ZooKeeper常用命令">7、ZooKeeper常用命令</h2><h3 id="1、常用命令">1、常用命令</h3><p>1、创建节点</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">[zk: 127.0.0.1:2181(CONNECTED) 34] create /node1 “node1”<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">[zk: 127.0.0.1:2181(CONNECTED) 1] create /node1/node1.1 123<br>Created /node1/node1.1<br></code></pre></td></tr></table></figure><p>2、更新节点</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">[zk: 127.0.0.1:2181(CONNECTED) 11] <span class="hljs-built_in">set</span> /node1 <span class="hljs-string">&quot;set node1&quot;</span><br></code></pre></td></tr></table></figure><p>3、或许节点</p><p>get命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> node1<br>cZxid = 0x47<br>ctime = Sun Jan 20 10:22:59 CST 2019<br>mZxid = 0x4b<br>mtime = Sun Jan 20 10:41:10 CST 2019<br>pZxid = 0x4a<br>cversion = 1<br>dataVersion = 1<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 9<br>numChildren = 1<br></code></pre></td></tr></table></figure><p>4、查看某个目录下的子节点</p><p>通过 <code>ls</code> 命令查看根目录下的节点</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">[zk: 127.0.0.1:2181(CONNECTED) 37] <span class="hljs-built_in">ls</span> /<br>[dubbo, ZooKeeper, node1]<br></code></pre></td></tr></table></figure><p>通过 <code>ls</code> 命令查看 node1 目录下的节点</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">[zk: 127.0.0.1:2181(CONNECTED) 5] <span class="hljs-built_in">ls</span> /node1<br>[node1.1]<br></code></pre></td></tr></table></figure><p>5、查看节点状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">[zk: 127.0.0.1:2181(CONNECTED) 10] <span class="hljs-built_in">stat</span> /node1<br>cZxid = 0x47<br>ctime = Sun Jan 20 10:22:59 CST 2019<br>mZxid = 0x47<br>mtime = Sun Jan 20 10:22:59 CST 2019<br>pZxid = 0x4a<br>cversion = 1<br>dataVersion = 0<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 11<br>numChildren = 1<br></code></pre></td></tr></table></figure><p>6、查看节点信息和状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">[zk: 127.0.0.1:2181(CONNECTED) 7] ls2 /node1<br>[node1.1]<br>cZxid = 0x47<br>ctime = Sun Jan 20 10:22:59 CST 2019<br>mZxid = 0x47<br>mtime = Sun Jan 20 10:22:59 CST 2019<br>pZxid = 0x4a<br>cversion = 1<br>dataVersion = 0<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 11<br>numChildren = 1<br></code></pre></td></tr></table></figure><p><code>ls2</code> 命令更像是 <code>ls</code> 命令和 <code>stat</code> 命令的结合。</p><p>7、删除节点</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">[zk: 127.0.0.1:2181(CONNECTED) 3] delete /node1/node1.1<br></code></pre></td></tr></table></figure><h3 id="2、Curator简单使用">2、Curator简单使用</h3><p>先导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1、连接-ZooKeeper-客户端">1、连接 ZooKeeper 客户端</h4><p>通过 <code>CuratorFrameworkFactory</code> 创建 <code>CuratorFramework</code> 对象，然后再调用 <code>CuratorFramework</code> 对象的 <code>start()</code> 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BASE_SLEEP_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_RETRIES</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// Retry strategy. Retry 3 times, and will increase the sleep time between retries.</span><br><span class="hljs-type">RetryPolicy</span> <span class="hljs-variable">retryPolicy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(BASE_SLEEP_TIME, MAX_RETRIES);<br><span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">zkClient</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory.builder()<br>    <span class="hljs-comment">// the server to connect to (can be a server list)</span><br>    .connectString(<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>)<br>    .retryPolicy(retryPolicy)<br>    .build();<br>zkClient.start();<br></code></pre></td></tr></table></figure><ul><li><code>baseSleepTimeMs</code>：重试之间等待的初始时间</li><li><code>maxRetries</code> ：最大重试次数</li><li><code>connectString</code> ：要连接的服务器列表</li><li><code>retryPolicy</code> ：重试策略</li></ul><h4 id="2、创建节点">2、创建节点</h4><p>创建持久化节点：（下面两种方式均可）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意:下面的代码会报错</span><br>zkClient.create().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<br>zkClient.create().withMode(CreateMode.PERSISTENT).forPath(<span class="hljs-string">&quot;/node1/00002&quot;</span>);<br></code></pre></td></tr></table></figure><p>报错原因是node1节点未创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().forPath(<span class="hljs-string">&quot;/node1&quot;</span>);<br></code></pre></td></tr></table></figure><p>执行完上述代码后就不会报错。</p><p>推荐下面这行代码，<strong><code>creatingParentsIfNeeded()</code> 可以保证父节点不存在的时候自动创建父节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<br></code></pre></td></tr></table></figure><p>创建临时节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<br></code></pre></td></tr></table></figure><p>创建节点并指定数据内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>.getBytes());<br>zkClient.getData().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<span class="hljs-comment">//获取节点的数据内容，获取到的是 byte数组</span><br></code></pre></td></tr></table></figure><p>检测节点是否创建成功：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.checkExists().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<span class="hljs-comment">//不为null的话，说明节点创建成功</span><br></code></pre></td></tr></table></figure><h4 id="3、删除节点">3、删除节点</h4><p>删除一个子节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.delete().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<br></code></pre></td></tr></table></figure><p>删除一个节点以及其下的所有子节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.delete().deletingChildrenIfNeeded().forPath(<span class="hljs-string">&quot;/node1&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="4、获取-更新节点数据内容">4、获取/更新节点数据内容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>.getBytes());<br>zkClient.getData().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<span class="hljs-comment">//获取节点的数据内容</span><br>zkClient.setData().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>,<span class="hljs-string">&quot;c++&quot;</span>.getBytes());<span class="hljs-comment">//更新节点数据内容</span><br></code></pre></td></tr></table></figure><h4 id="5、获取某个节点的所有子节点路径">5、获取某个节点的所有子节点路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; childrenPaths = zkClient.getChildren().forPath(<span class="hljs-string">&quot;/node1&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>配置文件</tag>
      
      <tag>日志</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2022/11/30/dui/"/>
    <url>/2022/11/30/dui/</url>
    
    <content type="html"><![CDATA[<h1>一、堆</h1><h2 id="1、概念">1、概念</h2><p>队列是一种先进先出（FIFO）的数据结构，但是有些情况下，操作的数据可能带有优先级，一般出队列时，可能需要优先级高的元素先出队列，在这种情况下使用队列就不行了，比如玩王者的时候突然女朋友一通电话，游戏屏幕瞬间被电话占领，这时候就应该优先处理电话。</p><p>在这种情况下，我们的数据结构应该提供两个最基本的操作，一个是返回最高优先级对象，一个是添加新对象，这种数据结构就是优先级队列（PriorityQueue）。</p><p>PriorityQueue 的底层是堆，堆的底层是数组。</p><p>Java集合框架中提供了<strong>PriorityQueue</strong>和<strong>PriorityBlockingQueue</strong>两种类型的优先级队列，PriorityQueue是<strong>线程不安全</strong>的，PriorityBlockingQueue是<strong>线程安全</strong>的，这里主要使用PriorityQueue。</p><ul><li>PriorityQueue中放置的元素必须要能够比较大小 （只有实现了 Comparable 和 Comparator 接口的类才能比较大小），不能插入无法比较大小的对象，否则会抛出 ClassCastException 异常</li><li>不能插入 null 对象，否则会抛出 NullPointerException 异常</li><li>没有容量限制，可以插入任意多个元素，其内部可以自动扩容</li><li>插入和删除元素的时间复杂度均为 O(log2N)</li><li>PriorityQueue底层使用了堆数据结构</li></ul><h2 id="2、常用接口">2、常用接口</h2><table><thead><tr><th>函数名</th><th style="text-align:center">功能介绍</th></tr></thead><tbody><tr><td>boolean offer(E e)</td><td style="text-align:center">插入元素 e，插入成功返回 true，如果 e 对象为空，抛出 NullPointerException 异常，时间复杂度为 O(log2N) ，注意：空间不够时会自动扩容</td></tr><tr><td>E peek()</td><td style="text-align:center">获取优先级最高的元素，如果优先级队列为空，返回 null</td></tr><tr><td>E poll()</td><td style="text-align:center">移除优先级最高的元素并返回，如果优先级队列为空，返回 null</td></tr><tr><td>int size()</td><td style="text-align:center">获取有效元素的个数</td></tr><tr><td>void clean()</td><td style="text-align:center">清空</td></tr><tr><td>boolean isEmpty()</td><td style="text-align:center">检测优先级队列是否为空，空返回 true</td></tr></tbody></table><h2 id="3、通过数组实现小顶堆">3、通过数组实现小顶堆</h2><p>参考链接：<a href="https://www.cnblogs.com/CarpenterLee/p/5488070.html">深入理解Java PriorityQueue </a></p><p><strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，<strong>元素大小的评判可以通过元素本身的自然顺序（*natural ordering*），也可以通过构造时传入的比较器</strong>（<em>Comparator</em>，类似于C++的仿函数）。</p><p>Java中<em>PriorityQueue</em>实现了<em>Queue</em>接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为<em>PriorityQueue</em>的底层实现。</p><p><img src="/2022/11/30/dui/image-20221130145800596.png" alt></p><p>父节点和子节点的编号是有联系的：</p><ol><li>leftNo = parentNo*2+1</li><li>rightNo = parentNo*2+2</li><li>parentNo = (nodeNo-1)/2</li></ol><p>所以可以用数组来存储堆，可以轻易计算出某个节点的父节点以及子节点的下标。</p><p><em>PriorityQueue</em>的<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是<em>log(N)</em>。</p><h3 id="1、add-和offer">1、add()和offer()</h3><p>以上图为例，假如现在要插入节点的值4，要做两件事，一件事是将4放在数组末尾，另一件事就是调整，将4调整至合适的位置。</p><p>过程如下：</p><p><img src="/2022/11/30/dui/image-20221130150159033.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//offer(E e)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)<span class="hljs-comment">//不允许放入null元素</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    modCount++;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size;<br>    <span class="hljs-keyword">if</span> (i &gt;= queue.length)<br>        grow(i + <span class="hljs-number">1</span>);<span class="hljs-comment">//自动扩容</span><br>    size = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<span class="hljs-comment">//队列原来为空，这是插入的第一个元素</span><br>        queue[<span class="hljs-number">0</span>] = e;<br>    <span class="hljs-keyword">else</span><br>        siftUp(i, e);<span class="hljs-comment">//调整</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>siftUp(int k, E x)</code>方法，该方法用于插入元素<code>x</code>并维持堆的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//siftUp()</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUp</span><span class="hljs-params">(<span class="hljs-type">int</span> k, E x)</span> &#123;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-comment">//parentNo = (nodeNo-1)/2</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> queue[parent];<br>        <span class="hljs-keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="hljs-number">0</span>)<span class="hljs-comment">//调用比较器的比较方法</span><br>            <span class="hljs-keyword">break</span>;<br>        queue[k] = e;<br>        k = parent;<br>    &#125;<br>    queue[k] = x;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层与当前点的<code>parent</code>进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p><hr><h3 id="2、element-和peek">2、element()和peek()</h3><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回<code>null</code>。</p><p><img src="/2022/11/30/dui/image-20221130150628437.png" alt></p><p>直接返回3即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//peek()</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> (E) queue[<span class="hljs-number">0</span>];<span class="hljs-comment">//0下标处的那个元素就是最小的那个</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、remove-和poll">3、remove()和poll()</h3><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。</p><p><img src="/2022/11/30/dui/image-20221130150734479.png" alt></p><p>删除掉第一个之后，将最后一个元素放到第一个的位置上，然后往下调整</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> --size;<br>    modCount++;<br>    <span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (E) queue[<span class="hljs-number">0</span>];<span class="hljs-comment">//0下标处的那个元素就是最小的那个</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (E) queue[s];<br>    queue[s] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)<br>        siftDown(<span class="hljs-number">0</span>, x);<span class="hljs-comment">//调整</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层向下与当前点的左右孩子中较小的那个交换，直到<code>x</code>小于或等于左右孩子中的任何一个为止</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//siftDown()</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftDown</span><span class="hljs-params">(<span class="hljs-type">int</span> k, E x)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> size &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k &lt; half) &#123;<br>    <span class="hljs-comment">//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> (k &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<span class="hljs-comment">//leftNo = parentNo*2+1</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> queue[child];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> child + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (right &lt; size &amp;&amp;<br>            comparator.compare((E) c, (E) queue[right]) &gt; <span class="hljs-number">0</span>)<br>            c = queue[child = right];<br>        <span class="hljs-keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        queue[k] = c;<span class="hljs-comment">//然后用c取代原来的值</span><br>        k = child;<br>    &#125;<br>    queue[k] = x;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2022/11/11/rabbitmq/"/>
    <url>/2022/11/11/rabbitmq/</url>
    
    <content type="html"><![CDATA[<h1>1、消息队列</h1><h2 id="1、什么是MQ">1、什么是MQ</h2><p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。</p><h2 id="2、MQ的优势">2、MQ的优势</h2><h3 id="1-流量消峰">1.流量消峰</h3><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正 常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p><h3 id="2-应用解耦">2.应用解耦</h3><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p><p><img src="/2022/11/11/rabbitmq/image-20221111190440644.png" alt></p><h3 id="3-异步处理">3.异步处理</h3><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可 以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消 息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用 做这些操作。A 服务还能及时的得到异步处理成功的消息。</p><p><img src="/2022/11/11/rabbitmq/image-20221111190551875.png" alt></p><h2 id="3、多种MQ">3、多种MQ</h2><h3 id="1、ActiveMQ">1、ActiveMQ</h3><p><a href="https://blog.csdn.net/liuyuanq123/article/details/79109218">ActiveMQ详细入门使用教程</a></p><p>优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据</p><p>缺点：官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。</p><h3 id="2、Kafka">2、Kafka</h3><p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为<code>大数据</code>而生的消息中间件， 以其<code>百万级 TPS</code> 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</p><p>优点: 性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是<code>吞吐量高</code>。时效性 ms 级可用性非 常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采 用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持： 功能 较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及<code>日志采集</code>被大规模使用</p><p>缺点：Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消 息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，<code>社区更新较慢</code>；</p><h3 id="3、RocketMQ">3、RocketMQ</h3><p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。</p><p>优点:单机吞吐量十万级,可用性非常高，分布式架构,消息可以做到 0 丢失,MQ 功能较为完善，还是分布式的，扩展性好,支持 10 亿级别的消息堆积，不会因为堆积导致性能下降,源码是 java 我们可以自己阅 读源码，定制自己公司的 MQ</p><p>缺点：支持的客户端语言不多，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在MQ 核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码</p><h3 id="4、RabbitMQ">4、RabbitMQ</h3><p>2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最 主流的消息中间件之一。</p><p>优点:由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易 用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高</p><blockquote><p>官网：<a href="https://www.rabbitmq.com/news.html">https://www.rabbitmq.com/news.html</a></p></blockquote><p>缺点：商业版需要收费,学习成本较高</p><h2 id="4、如何选择使用哪种MQ">4、如何选择使用哪种MQ</h2><h3 id="1、Kafka">1、Kafka</h3><p>Kafka 主要特点是基于Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集 和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能， 肯定是首选 kafka 了。</p><h3 id="2、RocketMQ">2、RocketMQ</h3><p>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削 峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务 场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p><h3 id="3、RabbitMQ">3、RabbitMQ</h3><p>结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分 方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 RabbitMQ。</p><h2 id="5、RabbitMQ">5、RabbitMQ</h2><p>RabbitMQ 是一个消息中间件：它接受并转发消息。</p><h3 id="1、核心概念">1、核心概念</h3><h4 id="1、生产者">1、生产者</h4><p>产生数据发送消息的程序是生产者</p><h4 id="2、交换机">2、交换机</h4><p>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推 送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p><h4 id="3、队列">3、队列</h4><p>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存 储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可 以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p><h4 id="4、消费者">4、消费者</h4><p>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费 者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p><h3 id="2、工作原理">2、工作原理</h3><p><img src="/2022/11/11/rabbitmq/image-20221111191823094.png" alt></p><p><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p><p><strong>Connection</strong>：publisher／consumer 和 broker 之间的 TCP 连接</p><p><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程 序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销</p><h3 id="3、核心部分">3、核心部分</h3><p><img src="/2022/11/11/rabbitmq/image-20221111192022450.png" alt></p><h3 id="4、安装">4、安装</h3><p>参考<a href="https://blog.csdn.net/qq_45173404/article/details/116429302">RabbitMQ超详细安装教程（Linux）</a></p><h1>2、Hello World</h1><p>在下图中，“ P”是我们的生产者，“ C”是我们的消费者。中间的框是一个队列-RabbitMQ 代 表使用者保留的消息缓冲区</p><p><img src="/2022/11/11/rabbitmq/image-20221111192322099.png" alt></p><h2 id="1、导入依赖">1、导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--rabbitmq 依赖客户端--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--操作文件流的一个依赖--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2、生产者关键代码">2、生产者关键代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个连接工厂</span><br><span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>factory.setHost(<span class="hljs-string">&quot;xx.xx.xx.xx&quot;</span>);<br>factory.setUsername(<span class="hljs-string">&quot;guest&quot;</span>);<br>factory.setPassword(<span class="hljs-string">&quot;guest&quot;</span>);<br><span class="hljs-comment">//channel 实现了自动 close 接口 自动关闭 不需要显示关闭</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel()) &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * 生成一个队列</span><br><span class="hljs-comment">      * 1.队列名称</span><br><span class="hljs-comment">      * 2.队列里面的消息是否持久化 默认消息存储在内存中</span><br><span class="hljs-comment">      * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费</span><br><span class="hljs-comment">      * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除</span><br><span class="hljs-comment">      * 5.其他参数</span><br><span class="hljs-comment">      */</span><br>channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zbiao is a cool guy&quot;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * 发送一个消息</span><br><span class="hljs-comment">      * 1.发送到那个交换机</span><br><span class="hljs-comment">      * 2.路由的 key 是哪个</span><br><span class="hljs-comment">      * 3.其他的参数信息</span><br><span class="hljs-comment">      * 4.发送消息的消息体</span><br><span class="hljs-comment">      */</span><br>    channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, message.getBytes());<br>    System.out.println(<span class="hljs-string">&quot;消息发送完毕&quot;</span>);<br></code></pre></td></tr></table></figure><p>思路就是：</p><ol><li>先创建一个连接工厂</li><li>在工厂的实例对象设置相关信息，包括服务器的ip地址，以及rabbitmq用户的账号密码</li><li>工厂的实例对象新建连接</li><li>connection常见实例对象channel</li><li>首先声明一个队列，使用channel.queueDeclare()，参数信息详情看注释</li><li>然后再发送消息，channel.basicPublish()，参数信息详情看注释</li></ol><h2 id="3、消费者关键代码">3、消费者关键代码</h2><p>消费者跟生产者类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//推送的消息如何进行消费的接口回调</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag,delivery) -&gt; &#123;<br>            String message= <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            System.out.println(message);<br>        &#125;;<br>        <span class="hljs-comment">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span><br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelCallback</span> <span class="hljs-operator">=</span> (consumerTag) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;消息消费被中断&quot;</span>);<br>        &#125;;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 消费者消费消息</span><br><span class="hljs-comment">         * 1.消费哪个队列</span><br><span class="hljs-comment">         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答</span><br><span class="hljs-comment">         * 3.消费者未成功消费的回调</span><br><span class="hljs-comment">         * 4.消费者取消回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(QUEUE_NAME,<span class="hljs-literal">true</span>,deliverCallback,cancelCallback);<br></code></pre></td></tr></table></figure><p>前面的对channel的实例化跟生产者类似，消费者还需要<code>手动编写回调函数</code></p><h1>3、Work Queues</h1><p>工作队列(又称任务队列)的主要思想是<code>避免立即执行资源密集型任务</code>，而不得不等待它完成。 相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进 程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。</p><h2 id="1、轮训分发消息">1、轮训分发消息</h2><p>在这个案例中我会启动两个工作线程，一个消息发送线程，来看看他们两个工作线程 是如何工作的。</p><p>首先创建一个消息发送线程，代码跟上节类似，其实这里可以将创建channel的过程进行抽取，将其封装为一个工具类，这样就避免多次编写重复代码。在创建两个工作线程，也就是消费者。</p><p>启动消息发送线程，再启动两个工作线程，发送如下数据： AA 、BB、 CC、 DD</p><p>会发现，第一个工作线程接收到 AA 和CC，第二个工作线程接收到BB和DD。</p><p>这就是轮训分发消息。</p><h2 id="2、消息应答">2、消息应答</h2><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成 了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消 息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续 发送给该消费这的消息，因为它无法接收到。</p><p>为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是:<strong>消费者在接收 到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong></p><h3 id="1、自动应答">1、自动应答</h3><p>消息发送后立即被认为已经传送成功，这种模式需要在<code>高吞吐量和数据传输安全性方面做权 衡</code>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失 了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当 然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使 得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在<code>消费者可以高效并以 某种速率能够处理这些消息的情况下使用</code>。</p><p>简单来说就是不太靠谱。。。</p><blockquote><p>消息应答的方法</p></blockquote><p>Channel.basicAck(用于肯定确认)  RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了</p><p>Channel.basicNack(用于否定确认)</p><p>Channel.basicReject(用于否定确认)  与 Channel.basicNack 相比少一个参数 不处理该消息了直接拒绝，可以将其丢弃了</p><blockquote><p>Multiple参数详解</p></blockquote><p>手动应答的好处是可以批量应答并且减少网络拥堵</p><p>multiple 的 true 和 false 代表不同意思 ：</p><ul><li>true 代表批量应答 channel 上未应答的消息 比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是8 那么此时 5-8 的这些还未应答的消息都会被确认收到消息应答</li><li>false 同上面相比 只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答</li></ul><p><img src="/2022/11/11/rabbitmq/image-20221111194610086.png" alt></p><blockquote><p>消息自动重新入队</p></blockquote><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息 未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者 可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确 保不会丢失任何消息。</p><h3 id="2、手动应答">2、手动应答</h3><p><code>默认消息采用的是自动应答</code>，所以我们要想实现消息消费过程中不丢失，需要把自动应答改 为手动应答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">DeliverCallback deliverCallback=(consumerTag,delivery) -&gt; &#123;<br>            String message= <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            SleepUtils.sleep(<span class="hljs-number">1</span>);<br>            System.out.println(<span class="hljs-string">&quot;接收到消息:&quot;</span>+message);<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 1.消息标记 tag</span><br><span class="hljs-comment">             * 2.是否批量应答未应答消息</span><br><span class="hljs-comment">             */</span><br>            channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="hljs-literal">false</span>);<br>        &#125;;<br><br><span class="hljs-comment">//采用手动应答</span><br>        <span class="hljs-type">boolean</span> autoAck=<span class="hljs-literal">false</span>;<br>        channel.basicConsume(ACK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag)-&gt;&#123;<br>            System.out.println(consumerTag+<span class="hljs-string">&quot;消费者取消消费接口回调逻辑&quot;</span>);<br>        &#125;);<br></code></pre></td></tr></table></figure><p>消费者的 回调函数中需要增加第9行代码 ，并且将channel.basicConsume()的第二个参数改为 false</p><p>手动应答效果：发送如下数据： AA 、BB、 CC、 DD，将第二个消费者的线程睡30s，正常情况下是C1 收到 AA、CC ，C2收到BB、DD。但是在C2收到DD之前，将C2关掉，那么DD会不会丢失？不会，DD由C1来接收，这就是手动应答</p><h2 id="3、RabbitMQ持久化">3、RabbitMQ持久化</h2><p>刚刚我们已经看到了如何处理任务不丢失的情况，但是如何保障当 RabbitMQ 服务停掉以后消 息生产者发送过来的消息不丢失。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列 和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<code>我们需要将队列和消息都标 记为持久化</code>。</p><h3 id="1、队列持久化">1、队列持久化</h3><p>之前我们创建的队列都是非持久化的，rabbitmq 如果重启的化，该队列就会被删除掉，如果 要队列实现持久化 需要在声明队列的时候把 durable 参数设置为持久化</p><p><img src="/2022/11/11/rabbitmq/image-20221111195627548.png" alt></p><p>这里要注意，要先删掉之前声明的队列，然后再声明持久化队列（若是队列名称一样的话）</p><p>持久化队列后，即使重启RabbitMQ队列也依然在</p><h3 id="2、消息持久化">2、消息持久化</h3><p>要想让消息实现持久化需要在消息生产者修改代码，MessageProperties.PERSISTENT_TEXT_PLAIN 添 加这个属性。</p><p><img src="/2022/11/11/rabbitmq/image-20221111195848961.png" alt></p><p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是 这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。</p><h3 id="3、不公平分发">3、不公平分发</h3><p>轮训分发有一个弊端，在某种特定的场景下并不是很好，若是有两个消费者处理任务，其中一个处理速度非常快，一个处理非常慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间 处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p><p>为了避免这种情况，我们可以设置参数 channel.basicQos(1)；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">prefetchCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>channel.basicQos(prefetchCount);<br></code></pre></td></tr></table></figure><p>意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个 任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完 成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加 新的 worker 或者改变其他存储任务的策略。</p><h3 id="4、预取值">4、预取值</h3><p>存在一个未确认的消息缓冲区，开发人员希望能限制此 缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。这个时候就可以通过使用 basic.qos 方法设 置“预取计数”值来完成的。该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认。</p><p>例如，假设在通道上有 未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时RabbitMQ 将不会在该通道上再传递任何 消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知 这个情况到并再发送一条消息。</p><p>消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高 向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗(<code>随机存取存储器</code>)应该小心使用具有无限预处理 的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的 内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。</p><p>预取值为 1 是最保守的。当然这 将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p><h1>4、发布确认</h1><p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消 息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会 发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了， 如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产 者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p><p>confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道 返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方 法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。</p><h2 id="1、发布确认的策略">1、发布确认的策略</h2><p>发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布 确认，都需要在 channel 上调用该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.confirmSelect();<br></code></pre></td></tr></table></figure><h3 id="1、单个确认发布">1、单个确认发布</h3><p>这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它 被确认发布，后续的消息才能继续发布,waitForConfirmsOrDie(long)这个方法只有在消息被确认 的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p><p>这种确认方式有一个最大的缺点就是:发布速度特别的慢，因为如果没有确认发布的消息就会 阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某 些应用程序来说这可能已经足够了。</p><p>关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-comment">//开启发布确认</span><br>channel.confirmSelect();<br><span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> i + <span class="hljs-string">&quot;&quot;</span>;<br>channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, queueName, <span class="hljs-literal">null</span>, message.getBytes());<br><span class="hljs-comment">//服务端返回 false 或超时时间内未返回，生产者可以消息重发</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> channel.waitForConfirms();<br><span class="hljs-keyword">if</span>(flag)&#123;<br>System.out.println(<span class="hljs-string">&quot;消息发送成功&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>System.out.println(<span class="hljs-string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="hljs-string">&quot;个单独确认消息,耗时&quot;</span> + (end - begin) + <span class="hljs-string">&quot;ms&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="2、批量确认发布">2、批量确认发布</h3><p>先发布一批消息然后一起确认可以极大地 提高吞吐量，当然这种方式的缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种 方案仍然是同步的，也一样阻塞消息的发布。</p><p>关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-comment">//开启发布确认</span><br>channel.confirmSelect();<br><span class="hljs-comment">//批量确认消息大小</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">batchSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-comment">//未确认消息个数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">outstandingMessageCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> i + <span class="hljs-string">&quot;&quot;</span>;<br>channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, queueName, <span class="hljs-literal">null</span>, message.getBytes());<br>outstandingMessageCount++;<br><span class="hljs-keyword">if</span> (outstandingMessageCount == batchSize) <br>&#123;<br>        channel.waitForConfirms();<br>outstandingMessageCount = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//为了确保还有剩余没有确认消息 再次确认</span><br><span class="hljs-keyword">if</span> (outstandingMessageCount &gt; <span class="hljs-number">0</span>) <br>&#123;<br>    channel.waitForConfirms();<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>System.out.println(<span class="hljs-string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="hljs-string">&quot;个批量确认消息,耗时&quot;</span> + (end - begin) + <span class="hljs-string">&quot;ms&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="3、异步确认发布">3、异步确认发布</h3><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功</p><p><img src="/2022/11/11/rabbitmq/image-20221111201143322.png" alt></p><p>关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-comment">//开启发布确认</span><br> channel.confirmSelect();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 线程安全有序的一个哈希表，适用于高并发的情况</span><br><span class="hljs-comment"> * 1.轻松的将序号与消息进行关联</span><br><span class="hljs-comment"> * 2.轻松批量删除条目 只要给到序列号</span><br><span class="hljs-comment"> * 3.支持并发访问</span><br><span class="hljs-comment"> */</span><br>ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentSkipListMap</span>&lt;&gt;();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 确认收到消息的一个回调</span><br><span class="hljs-comment"> * 1.消息序列号</span><br><span class="hljs-comment"> * 2.true 可以确认小于等于当前序列号的消息</span><br><span class="hljs-comment"> * false 确认当前序列号消息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">ConfirmCallback</span> <span class="hljs-variable">ackCallback</span> <span class="hljs-operator">=</span> (sequenceNumber, multiple) -&gt; &#123;<br><span class="hljs-keyword">if</span> (multiple) &#123;<br><span class="hljs-comment">//返回的是小于等于当前序列号的未确认消息 是一个 map</span><br>ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outstandingConfirms.headMap(sequenceNumber, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">//清除该部分未确认消息</span><br> confirmed.clear();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//只清除当前序列号的消息</span><br> outstandingConfirms.remove(sequenceNumber);<br>&#125;<br>&#125;;<br><span class="hljs-type">ConfirmCallback</span> <span class="hljs-variable">nackCallback</span> <span class="hljs-operator">=</span> (sequenceNumber, multiple) -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> outstandingConfirms.get(sequenceNumber);<br>System.out.println(<span class="hljs-string">&quot;发布的消息&quot;</span>+message+<span class="hljs-string">&quot;未被确认，序列号&quot;</span>+sequenceNumber);<br>&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 添加一个异步确认的监听器</span><br><span class="hljs-comment"> * 1.确认收到消息的回调</span><br><span class="hljs-comment"> * 2.未收到消息的回调</span><br><span class="hljs-comment"> */</span><br>channel.addConfirmListener(ackCallback, <span class="hljs-literal">null</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;消息&quot;</span> + i;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* channel.getNextPublishSeqNo()获取下一个消息的序列号</span><br><span class="hljs-comment"> * 通过序列号与消息体进行一个关联</span><br><span class="hljs-comment"> * 全部都是未确认的消息体</span><br><span class="hljs-comment"> */</span><br>outstandingConfirms.put(channel.getNextPublishSeqNo(), message);<br>channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, queueName, <span class="hljs-literal">null</span>, message.getBytes());<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>System.out.println(<span class="hljs-string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="hljs-string">&quot;个异步确认消息,耗时&quot;</span> + (end - begin) + <span class="hljs-string">&quot;ms&quot;</span>);<br></code></pre></td></tr></table></figure><p>如何处理异步未确认消息？</p><p>最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传 递。</p><h2 id="2、以上-3-种发布确认速度对比">2、以上 3 种发布确认速度对比</h2><p>单独发布消息：</p><p>同步等待确认，简单，但吞吐量非常有限。</p><p>批量发布消息 ：</p><p>批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条 消息出现了问题。</p><p>异步处理：</p><p>最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</p><h1>5、交换机</h1><h2 id="1、Exchange">1、Exchange</h2><p>RabbitMQ 消息传递模型的核心思想是: <code>生产者生产的消息从不会直接发送到队列</code>。实际上，通常生产 者甚至都不知道这些消息传递传递到了哪些队列中。</p><p>相反，生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来 自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消 息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p><p><img src="/2022/11/11/rabbitmq/image-20221115165238393.png" alt></p><h2 id="2、Exchange类型">2、Exchange类型</h2><ul><li>直接(direct),</li><li>主题(topic)</li><li>标题(headers) ,</li><li>扇出(fanout)</li></ul><p>还有一种就是默认，也就是无名Exchange，通过空字符串(“”)进行标识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-literal">null</span>, message.getBytes());<br></code></pre></td></tr></table></figure><p>第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实 是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的话</p><h2 id="3、Fanout">3、Fanout</h2><p>Fanout 又称为发布订阅。Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的 所有队列中。</p><p><img src="/2022/11/11/rabbitmq/image-20221115165654132.png" alt></p><p>消费者关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;logs&quot;</span>;<br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtils.getChannel();<br>channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;fanout&quot;</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 生成一个临时的队列 队列的名称是随机的</span><br><span class="hljs-comment"> * 当消费者断开和该队列的连接时 队列自动删除</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br><span class="hljs-comment">//把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串</span><br>channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;等待接收消息,把接收到的消息打印在屏幕........... &quot;</span>);<br><span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;控制台打印接收到的消息&quot;</span>+message);<br>&#125;;<br>channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);<br></code></pre></td></tr></table></figure><blockquote><p>第八行代码为创建临时队列</p></blockquote><p>生产者关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;logs&quot;</span>;<br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtils.getChannel();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 声明一个 exchange</span><br><span class="hljs-comment">* 1.exchange 的名称</span><br><span class="hljs-comment"> * 2.exchange 的类型</span><br><span class="hljs-comment"> */</span><br>channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;fanout&quot;</span>);<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入信息&quot;</span>);<br><span class="hljs-keyword">while</span> (sc.hasNext()) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> sc.nextLine();<br>channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">null</span>, message.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;生产者发出消息&quot;</span> + message);<br>&#125;<br></code></pre></td></tr></table></figure><p>生产者和消费者都指定一个交换机，并且消费者都指定routingKey，无论有几个消费者，只要生产者一发送消息，所有消费者都能接受到消息。</p><h2 id="4、Direct-exchange">4、Direct exchange</h2><p>再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： 队列只对它绑定的交换机的消息感兴趣。绑定用参数：routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码: channel.queueBind(queueName, EXCHANGE_NAME, “routingKey”);绑定之后的 意义由其交换类型决定。</p><p>Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。</p><h3 id="1、直接绑定">1、直接绑定</h3><p><img src="/2022/11/11/rabbitmq/image-20221115170843291.png" alt></p><p>在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green。</p><p>在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 black和green 的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p><h3 id="2、多重绑定">2、多重绑定</h3><p><img src="/2022/11/11/rabbitmq/image-20221115171018692.png" alt></p><p>当然如果 exchange 的绑定类型是direct，但是它绑定的多个队列的 key 如果都相同，在这种情 况下虽然绑定类型是 direct 但是它表现的就和 fanout 有点类似了，就跟广播差不多，如上图所示。</p><p>消费者关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;direct_logs&quot;</span>;<br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtils.getChannel();<br>channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;console&quot;</span>;<br>channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;info&quot;</span>);<br>channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;warning&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;等待接收消息........... &quot;</span>);<br><span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot; 接收绑定键 :&quot;</span>+delivery.getEnvelope().getRoutingKey()+<span class="hljs-string">&quot;, 消息:&quot;</span>+message);<br>&#125;;<br>channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);<br></code></pre></td></tr></table></figure><p>生产者关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;direct_logs&quot;</span>;<br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtils.getChannel();<br>channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入信息&quot;</span>);<br><span class="hljs-keyword">while</span> (sc.hasNext()) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> sc.nextLine();<br>channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;console&quot;</span>, <span class="hljs-literal">null</span>, message.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;生产者发出消息&quot;</span> + message);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>交换机只是设定不同的routingKey 即可</p></blockquote><h2 id="5、Topics">5、Topics</h2><p>尽管使用direct 交换机提高了灵活性，但是它仍然存在局限性。比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 topic 类型</p><p>发送的类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。这些单词可以是任意单词，比如说：“stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit” 这种类型的。当然这个单词列表最多不能超过 255 个字节。</p><p>在这个规则列表中，其中有两个替换符是需要注意的：</p><ol><li>*(星号)可以代替一个单词</li><li>#(井号)可以替代零个或多个单词</li></ol><blockquote><p>Topic匹配案例</p></blockquote><p>下图绑定关系如下</p><p>​Q1–&gt;绑定的是</p><p>​中间带 orange 带 3 个单词的字符串(<em>.orange.</em>)</p><p>​Q2–&gt;绑定的是</p><p>​最后一个单词是 rabbit 的 3 个单词(<em>.</em>.rabbit)</p><p>​第一个单词是 lazy 的多个单词(lazy.#)</p><p><img src="/2022/11/11/rabbitmq/image-20221115171829832.png" alt></p><p>当队列绑定关系是下列这种情况时需要引起注意</p><p><strong>当一个队列绑定键是#,那么这个队列将接收所有数据，就有点像 fanout 了</strong></p><p><strong>如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了</strong></p><p>其实代码都差不多，只是绑定键不同而已</p><p>消费者关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;topic_logs&quot;</span>;<br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtils.getChannel();<br>channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;topic&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;console&quot;</span>;<br>channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;*.orange.*&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;等待接收消息........... &quot;</span>);<br><span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot; 接收绑定键 :&quot;</span>+delivery.getEnvelope().getRoutingKey()+<span class="hljs-string">&quot;, 消息:&quot;</span>+message);<br>&#125;;<br>channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);<br></code></pre></td></tr></table></figure><p>生产者关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;topic_logs&quot;</span>;<br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtils.getChannel();<br>channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;topic&quot;</span>);<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入信息&quot;</span>);<br><span class="hljs-keyword">while</span> (sc.hasNext()) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> sc.nextLine();<br>channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;lazy.orange.elephant&quot;</span>, <span class="hljs-literal">null</span>, message.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;生产者发出消息&quot;</span> + message);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码生产者发出消息后，能被队列 Q1Q2 接收到</p><h1>6、死信队列</h1><h2 id="1、概念">1、概念</h2><p>死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有 后续的处理，就变成了死信，有死信自然就有了死信队列。</p><p>应用场景:为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息 消费发生异常时，将消息投入死信队列中.还有比如说: 用户在商城下单成功并点击去支付后在指定时 间未支付时自动失效</p><h2 id="2、来源">2、来源</h2><ol><li>消息 TTL 过期</li><li>队列达到最大长度(队列满了，无法再添加数据到 mq 中)</li><li>消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false.</li></ol><h2 id="3、Demo">3、Demo</h2><p>代码架构图如下：</p><p><img src="/2022/11/11/rabbitmq/image-20221115211517167.png" alt></p><h3 id="1、消息TTL过期">1、消息TTL过期</h3><p>生产者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> &#123;<br>    <span class="hljs-comment">//普通交换机名称</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NORMAL_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normal_exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getChannel();<br>        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);<br>        <span class="hljs-comment">//设置消息的 TTL 时间 , 单位是ms</span><br>        AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties().builder().expiration(<span class="hljs-string">&quot;10000&quot;</span>).build();<br>        <span class="hljs-comment">//该信息是用作演示队列个数限制</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;<span class="hljs-number">11</span> ; i++) &#123;<br>            String message=<span class="hljs-string">&quot;info&quot;</span>+i;<br>            channel.basicPublish(NORMAL_EXCHANGE,<span class="hljs-string">&quot;zhangsan&quot;</span>, properties, message.getBytes());<br>            System.out.println(<span class="hljs-string">&quot;生产者发送消息:&quot;</span>+message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者C1代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer01</span> &#123;<br>    <span class="hljs-comment">//普通交换机名称</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NORMAL_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normal_exchange&quot;</span>;<br>    <span class="hljs-comment">//死信交换机名称</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dead_exchange&quot;</span>;<br>    <span class="hljs-comment">//声明死信队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">deadQueue</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dead-queue&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">normalQueue</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normal-queue&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getChannel();<br>        <span class="hljs-comment">//声明死信和普通交换机 类型为 direct</span><br>        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);<br>        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);<br><br>        channel.queueDeclare(deadQueue, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//死信队列绑定死信交换机与 routingkey</span><br>        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="hljs-string">&quot;lisi&quot;</span>);<br>        <span class="hljs-comment">//正常队列绑定死信队列信息</span><br>        Map&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 设置过期时间</span><br>        <span class="hljs-comment">//params.put(&quot;x-message-ttl&quot;, 100000);</span><br>        <span class="hljs-comment">//params.put(&quot;x-max-length&quot;, 6);</span><br>        <span class="hljs-comment">//正常队列设置死信交换机 参数 key 是固定值</span><br>        params.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);<br>        <span class="hljs-comment">//正常队列设置死信 routing-key 参数 key 是固定值</span><br>        params.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="hljs-string">&quot;lisi&quot;</span>);<br><br>        channel.queueDeclare(normalQueue, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, params);<br>        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;等待接收消息........... &quot;</span>);<br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            <span class="hljs-keyword">if</span> (message.equals(<span class="hljs-string">&quot;info5&quot;</span>)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Consumer01 接收到消息&quot;</span>+message+<span class="hljs-string">&quot;:此消息被拒绝&quot;</span>);<br>                channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Consumer01 接收到消息&quot;</span>+message);<br>                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>            &#125;<br><br>        &#125;;<br>        <span class="hljs-comment">// 开启手动应答</span><br>        channel.basicConsume(normalQueue, <span class="hljs-literal">false</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者需要定义两个交换机，两个队列。第22行到第28行为设置从正常队列到死信队列的映射。</p><p>结果就是关闭C1，生产者发送十条正常消息，会发现死信队列里面堆积了十条消息，这是启动C2即可消费十条消息。</p><h3 id="2、队列达到最大长度">2、队列达到最大长度</h3><p>生产者代码不变</p><p>消费者加上限制最大长度的代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>params.put(<span class="hljs-string">&quot;x-max-length&quot;</span>, <span class="hljs-number">6</span>);<br>channel.queueDeclare(normalQueue, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, params);<br></code></pre></td></tr></table></figure><p>同样的操作，启动并关闭C1，生产者发送十条消息，会发现正常队列里堆积六条消息，死信队列里面堆积四条消息，启动C1和C2可分别消费消息。</p><h3 id="3、消息被拒">3、消息被拒</h3><p>生产者代码不变</p><p>消费者C1代码只需将某条消息拒绝即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>    <span class="hljs-keyword">if</span> (message.equals(<span class="hljs-string">&quot;info5&quot;</span>)) &#123;<br>         System.out.println(<span class="hljs-string">&quot;Consumer01 接收到消息&quot;</span>+message+<span class="hljs-string">&quot;:此消息被拒绝&quot;</span>);<br>         channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>         System.out.println(<span class="hljs-string">&quot;Consumer01 接收到消息&quot;</span>+message);<br>         channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 开启手动应答</span><br>channel.basicConsume(normalQueue, <span class="hljs-literal">false</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>注意，要开启手动应答，也就是第12行代码第二个参数改为false;</p></blockquote><p>最后会发现，拒绝的那条消息，也就是上述代码中的&quot;info5&quot;进入到了死信队列，开启C2即可消费。</p><h1>7、延迟队列</h1><p>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。</p><h2 id="1、延迟队列使用场景">1、延迟队列使用场景</h2><ol><li>订单在十分钟之内未支付则自动取消</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。</li><li>用户注册成功后，如果三天内没有登陆则进行短信提醒。</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员。</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li></ol><p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；看起来似乎 使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？</p><p>如果 数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支 付的账单，确实也是一个可行的方案。</p><p>但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万 级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单 的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p><p><img src="/2022/11/11/rabbitmq/image-20221116165636746.png" alt></p><h2 id="2、RabbitMQ中的TTL">2、RabbitMQ中的TTL</h2><p>TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有 消息的最大存活时间，单位是毫秒。换句话说，如果一条消息设置了 TTL 属性或者进入了设置TTL 属性的队列，那么这条消息如果在TTL 设置的时间内没有被消费，则会成为&quot;死信&quot;。如果同时配置了队列的TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。</p><h3 id="1、消息设置TTL">1、消息设置TTL</h3><p><img src="/2022/11/11/rabbitmq/image-20221116170029495.png" alt></p><h3 id="2、队列设置TTL">2、队列设置TTL</h3><p><img src="/2022/11/11/rabbitmq/image-20221116170042720.png" alt></p><h3 id="3、区别">3、区别</h3><p>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队 列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者 之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；另外，还需 要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以 直接投递该消息到消费者，否则该消息将会被丢弃。</p><h2 id="3、整合SpringBoot">3、整合SpringBoot</h2><p>1、创建项目</p><p>2、导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!--RabbitMQ 依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--swagger--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--RabbitMQ 测试依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.amqp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-rabbit-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、修改配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">spring.rabbitmq.host=xx.xx.xx.xx</span><br><span class="hljs-string">spring.rabbitmq.port=5672</span><br><span class="hljs-string">spring.rabbitmq.username=admin</span><br><span class="hljs-string">spring.rabbitmq.password=123</span><br></code></pre></td></tr></table></figure><p>配置rabbitmq相关信息</p><p>4、添加Swagger配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;<br><span class="hljs-keyword">import</span> springfox.documentation.service.ApiInfo;<br><span class="hljs-keyword">import</span> springfox.documentation.service.Contact;<br><span class="hljs-keyword">import</span> springfox.documentation.spi.DocumentationType;<br><span class="hljs-keyword">import</span> springfox.documentation.spring.web.plugins.Docket;<br><span class="hljs-keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">webApiConfig</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>            .groupName(<span class="hljs-string">&quot;webApi&quot;</span>)<br>.apiInfo(webApiInfo())<br>.select()<br>            .build();<br>&#125;<br><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">webApiInfo</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>.title(<span class="hljs-string">&quot;rabbitmq 接口文档&quot;</span>)<br>.description(<span class="hljs-string">&quot;本文档描述了 rabbitmq 微服务接口定义&quot;</span>)<br>.version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>.contact(<span class="hljs-keyword">new</span> <span class="hljs-string">&quot;1551388580@qq.com&quot;</span>))<br>.build();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、队列TTL">4、队列TTL</h2><h3 id="1、架构图">1、架构图</h3><p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交 换机 Y，它们的类型都是direct，创建一个死信队列 QD，它们的绑定关系如下：</p><p><img src="/2022/11/11/rabbitmq/image-20221116170644518.png" alt></p><h3 id="2、配置类">2、配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TtlQueueConfig</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">X_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;X&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_A</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QA&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_B</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QB&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Y&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_LETTER_QUEUE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QD&quot;</span>;<br><span class="hljs-comment">// 声明 xExchange</span><br><span class="hljs-meta">@Bean(&quot;xExchange&quot;)</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">xExchange</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(X_EXCHANGE);<br>&#125;<br><span class="hljs-comment">// 声明 xExchange</span><br><span class="hljs-meta">@Bean(&quot;yExchange&quot;)</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">yExchange</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(Y_DEAD_LETTER_EXCHANGE);<br>&#125;<br><span class="hljs-comment">//声明队列 A ttl 为 10s 并绑定到对应的死信交换机</span><br>    <span class="hljs-meta">@Bean(&quot;queueA&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueA</span><span class="hljs-params">()</span>&#123;<br>Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">3</span>);<br><span class="hljs-comment">//声明当前队列绑定的死信交换机</span><br>args.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);<br><span class="hljs-comment">//声明当前队列的死信路由 key</span><br>args.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="hljs-string">&quot;YD&quot;</span>);<br><span class="hljs-comment">//声明队列的 TTL</span><br>args.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>, <span class="hljs-number">10000</span>);<br><span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(args).build();<br>&#125;<br><span class="hljs-comment">// 声明队列 A 绑定 X 交换机</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueaBindingX</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;<br><span class="hljs-keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="hljs-string">&quot;XA&quot;</span>);<br>&#125;<br><span class="hljs-comment">//声明队列 B ttl 为 40s 并绑定到对应的死信交换机</span><br><span class="hljs-meta">@Bean(&quot;queueB&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueB</span><span class="hljs-params">()</span>&#123;<br>Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">3</span>);<br><span class="hljs-comment">//声明当前队列绑定的死信交换机</span><br>args.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);<br><span class="hljs-comment">//声明当前队列的死信路由 key</span><br>args.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="hljs-string">&quot;YD&quot;</span>);<br><span class="hljs-comment">//声明队列的 TTL</span><br>args.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>, <span class="hljs-number">40000</span>);<br><span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(args).build();<br>&#125;<br><span class="hljs-comment">//声明队列 B 绑定 X 交换机</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queuebBindingX</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueB&quot;)</span> Queue queue1B,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;<br><span class="hljs-keyword">return</span> BindingBuilder.bind(queue1B).to(xExchange).with(<span class="hljs-string">&quot;XB&quot;</span>);<br>&#125;<br><span class="hljs-comment">//声明死信队列 QD</span><br><span class="hljs-meta">@Bean(&quot;queueD&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueD</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(DEAD_LETTER_QUEUE);<br>&#125;<br><span class="hljs-comment">//声明死信队列 QD 绑定关系</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">deadLetterBindingQAD</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span>&#123;<br><span class="hljs-keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="hljs-string">&quot;YD&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、生产者代码">3、生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RequestMapping(&quot;ttl&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendMsgController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><span class="hljs-meta">@GetMapping(&quot;sendMsg/&#123;message&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String message)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,发送一条信息给两个 TTL 队列:&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), message);<br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;XA&quot;</span>, <span class="hljs-string">&quot;消息来自 ttl 为 10S 的队列: &quot;</span>+message);<br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;XB&quot;</span>, <span class="hljs-string">&quot;消息来自 ttl 为 40S 的队列: &quot;</span>+message);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、消费者代码">4、消费者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLetterQueueConsumer</span> &#123;<br><span class="hljs-meta">@RabbitListener(queues = &quot;QD&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveD</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody());<br>log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,收到死信队列信息&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().toString(), msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发起一个请求：<a href="http://localhost:8080/ttl/sendMsg/%E5%98%BB%E5%98%BB%E5%98%BB">http://localhost:8080/ttl/sendMsg/嘻嘻嘻</a></p><p><img src="/2022/11/11/rabbitmq/image-20221116203557955.png" alt></p><p>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。</p><p>不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加TTL 为一个小时的队列，如果是预定会议室然 后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p><p>可以将之抽象出来，留下ttl时间。</p><h2 id="5、延时队列优化">5、延时队列优化</h2><h3 id="1、架构图-v2">1、架构图</h3><p><img src="/2022/11/11/rabbitmq/image-20221116203836634.png" alt></p><p>如图，新增一个队列QC，不设置TTL时间</p><h3 id="2、配置类-v2">2、配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgTtlQueueConfig</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Y&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_C</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QC&quot;</span>;<br><span class="hljs-comment">//声明队列 C 死信交换机</span><br><span class="hljs-meta">@Bean(&quot;queueC&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueB</span><span class="hljs-params">()</span>&#123;<br>Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">3</span>);<br><span class="hljs-comment">//声明当前队列绑定的死信交换机</span><br>args.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);<br><span class="hljs-comment">//声明当前队列的死信路由 key</span><br>args.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="hljs-string">&quot;YD&quot;</span>);<br><span class="hljs-comment">//没有声明 TTL 属性</span><br><span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(args).build();<br>&#125;<br><span class="hljs-comment">//声明队列 B 绑定 X 交换机</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queuecBindingX</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;<br><span class="hljs-keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="hljs-string">&quot;XC&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、生产者代码-v2">3、生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String message,<span class="hljs-meta">@PathVariable</span> String ttlTime)</span> &#123;<br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;XC&quot;</span>, message, correlationData -&gt;&#123;<br>        correlationData.getMessageProperties().setExpiration(ttlTime);<br><span class="hljs-keyword">return</span> correlationData;<br>&#125;);<br>log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,发送一条时长&#123;&#125;毫秒 TTL 信息给队列 C:&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),ttlTime, message);<br>&#125;<br></code></pre></td></tr></table></figure><p>发起请求：</p><p><a href="http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendExpirationMsg/你好</a> 1/20000</p><p><a href="http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendExpirationMsg/你好</a> 2/2000</p><p>结果看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消 息可能并不会按时“死亡“，因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。</p><p>也就是说，虽然第一个沉睡了20s，第二个沉睡了2s，但是仍然是先消费死信队列中的“你好 1”，再消费死信队列中的“你好 2”</p><h2 id="6、Rabbitmq-插件实现延迟队列">6、Rabbitmq 插件实现延迟队列</h2><p>上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的TTL 时间 及时死亡，就无法设计成一个通用的延时队列。</p><h3 id="1、安装延时插件队列">1、安装延时插件队列</h3><p>安装过程参考：<a href="https://blog.csdn.net/Dong_Zi8/article/details/116021223">Linux安装RabbitMQ+延迟插件</a></p><p><img src="/2022/11/11/rabbitmq/image-20221116204649783.png" alt></p><h3 id="2、架构图">2、架构图</h3><p>在这里新增了一个队列delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下:</p><p><img src="/2022/11/11/rabbitmq/image-20221116204723589.png" alt></p><h3 id="3、配置类">3、配置类</h3><p>在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制 消息传递后并 不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才 投递到目标队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayedQueueConfig</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.queue&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.exchange&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.routingkey&quot;</span>;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">delayedQueue</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(DELAYED_QUEUE_NAME);<br>&#125;<br><span class="hljs-comment">//自定义交换机 我们在这里定义的是一个延迟交换机</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> CustomExchange <span class="hljs-title function_">delayedExchange</span><span class="hljs-params">()</span> &#123; <br>        Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">//自定义交换机的类型</span><br>args.put(<span class="hljs-string">&quot;x-delayed-type&quot;</span>, <span class="hljs-string">&quot;direct&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomExchange</span>(DELAYED_EXCHANGE_NAME, <span class="hljs-string">&quot;x-delayed-message&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, args);<br>&#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">bindingDelayedQueue</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue queue,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange delayedExchange)</span> &#123;<br><span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、生产者代码">4、生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.exchange&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.routingkey&quot;</span>;<br><span class="hljs-meta">@GetMapping(&quot;sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String message,<span class="hljs-meta">@PathVariable</span> Integer delayTime)</span> &#123;<br>rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, message,<br>correlationData -&gt;&#123;correlationData.getMessageProperties().setDelay(delayTime);<br><span class="hljs-keyword">return</span> correlationData;<br>    &#125;);<br>log.info(<span class="hljs-string">&quot; 当前时间：&#123;&#125;, 发送一条延迟&#123;&#125;毫秒的信息给队列 delayed.queue:&#123;&#125;&quot;</span>, newDate(),delayTime, message);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、消费者代码">5、消费者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.queue&quot;</span>;<br><span class="hljs-meta">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveDelayedQueue</span><span class="hljs-params">(Message message)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span><br><span class="hljs-title class_">String</span>(message.getBody());<br>log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,收到延时队列的消息：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().toString(), msg);<br>&#125;<br></code></pre></td></tr></table></figure><p>发起请求：</p><p><a href="http://localhost:8080/ttl/sendDelayMsg/come">http://localhost:8080/ttl/sendDelayMsg/come</a> on baby1/20000</p><p><a href="http://localhost:8080/ttl/sendDelayMsg/come">http://localhost:8080/ttl/sendDelayMsg/come</a> on baby2/2000</p><p>结果为第二个消息先被消费掉，符合预期</p><h2 id="7、总结">7、总结</h2><p>延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正 确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。</p><p>当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景</p><h1>8、发布确认高级</h1><p>在生产环境中由于一些不明原因，导致 rabbitmq 重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。那么，如何才能进行 RabbitMQ 的消息可靠投递呢？ 特别是在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息该如何处理呢？</p><h2 id="1、SpringBoot发布确认">1、SpringBoot发布确认</h2><h3 id="1、确认机制方案">1、确认机制方案</h3><p><img src="/2022/11/11/rabbitmq/image-20221118160648725.png" alt></p><h3 id="2、架构图-v2">2、架构图</h3><p><img src="/2022/11/11/rabbitmq/image-20221118160735813.png" alt></p><h3 id="3、配置文件">3、配置文件</h3><p>注意要在配置文件中添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">spring.rabbitmq.publisher-confirm-type=correlated</span><br></code></pre></td></tr></table></figure><ul><li>NONE<br>禁用发布确认模式，是默认值</li><li>CORRELATED<br>发布消息成功到交换器后会触发回调方法</li><li>SIMPLE<br>有两种效果，其一效果和 CORRELATED 值一样会触发回调方法， 其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法 等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">spring.rabbitmq.host=xx.xx.xx.xx</span><br><span class="hljs-string">spring.rabbitmq.port=5672</span><br><span class="hljs-string">spring.rabbitmq.username=xxx</span><br><span class="hljs-string">spring.rabbitmq.password=xxx</span><br><span class="hljs-string">spring.rabbitmq.publisher-confirm-type=correlated</span><br></code></pre></td></tr></table></figure><h3 id="4、配置类">4、配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfirmConfig</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;confirm.exchange&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;confirm.queue&quot;</span>;<br><span class="hljs-comment">//声明业务 Exchange</span><br><span class="hljs-meta">@Bean(&quot;confirmExchange&quot;)</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">confirmExchange</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(CONFIRM_EXCHANGE_NAME);<br>&#125;<br><span class="hljs-comment">// 声明确认队列</span><br><span class="hljs-meta">@Bean(&quot;confirmQueue&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">confirmQueue</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();<br>&#125;<br><span class="hljs-comment">// 声明确认队列绑定关系</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBinding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span>&#123;<br><span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">&quot;key1&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、生产者">5、生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/confirm&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;confirm.exchange&quot;</span>;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> MyCallBack myCallBack;<br><span class="hljs-comment">//依赖注入 rabbitTemplate 之后再设置它的回调对象</span><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>rabbitTemplate.setConfirmCallback(myCallBack);<br>&#125;<br><span class="hljs-meta">@GetMapping(&quot;sendMessage/&#123;message&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String message)</span>&#123;<br>    <span class="hljs-comment">//指定消息 id 为 1</span><br>CorrelationData correlationData1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>String routingKey=<span class="hljs-string">&quot;key1&quot;</span>;<br>rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME,routingKey,message+routingKey,correlationData1);<br>CorrelationData correlationData2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>routingKey=<span class="hljs-string">&quot;key2&quot;</span>;<br>rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME,routingKey,message+routingKey,correlationData2);<br>log.info(<span class="hljs-string">&quot;发送消息内容:&#123;&#125;&quot;</span>,message);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、回调接口">6、回调接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RabbitTemplate</span>.ConfirmCallback &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 交换机不管是否收到消息的一个回调方法</span><br><span class="hljs-comment"> * CorrelationData</span><br><span class="hljs-comment">* 消息相关数据</span><br><span class="hljs-comment"> * ack</span><br><span class="hljs-comment">* 交换机是否收到消息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-type">boolean</span> ack, String cause)</span> &#123;<br>        String id=correlationData!=<span class="hljs-literal">null</span>?correlationData.getId():<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">if</span>(ack)&#123;<br>log.info(<span class="hljs-string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>,id);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>log.info(<span class="hljs-string">&quot;交换机还未收到 id 为:&#123;&#125;消息,由于原因:&#123;&#125;&quot;</span>,id,cause);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7、消费者">7、消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;confirm.queue&quot;</span>;<br><span class="hljs-meta">@RabbitListener(queues =CONFIRM_QUEUE_NAME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveMsg</span><span class="hljs-params">(Message message)</span>&#123; <br>    String msg=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody());<br>log.info(<span class="hljs-string">&quot;接受到队列 confirm.queue 消息:&#123;&#125;&quot;</span>,msg);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8、结果">8、结果</h3><p><img src="/2022/11/11/rabbitmq/image-20221118161441008.png" alt></p><p>可以看到，发送了两条消息，第一条消息的 RoutingKey 为 “key1”，第二条消息的 RoutingKey 为 “key2”，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为 第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条 消息被直接丢弃了。</p><h2 id="2、回退消息">2、回退消息</h2><h3 id="1、Mandatory-参数">1、Mandatory 参数</h3><p>**在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如 果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。**那么如何 让无法被路由的消息帮我想办法处理一下？通过设置 mandatory 参 数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</p><h3 id="2、生产者">2、生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageProducer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RabbitTemplate</span>.ConfirmCallback, RabbitTemplate.ReturnCallback&#123;<br>    <span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><span class="hljs-comment">//rabbitTemplate 注入之后就设置该值</span><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>rabbitTemplate.setConfirmCallback(<span class="hljs-built_in">this</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* true：</span><br><span class="hljs-comment">* 交换机无法将消息进行路由时，会将该消息返回给生产者</span><br><span class="hljs-comment">* false：</span><br><span class="hljs-comment">* 如果发现消息无法进行路由，则直接丢弃</span><br><span class="hljs-comment">*/</span><br>rabbitTemplate.setMandatory(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">//设置回退消息交给谁处理</span><br>rabbitTemplate.setReturnCallback(<span class="hljs-built_in">this</span>);<br>&#125;<br><span class="hljs-meta">@GetMapping(&quot;sendMessage&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message)</span>&#123;<br><span class="hljs-comment">//让消息绑定一个 id 值</span><br><span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());<br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;confirm.exchange&quot;</span>,<span class="hljs-string">&quot;key1&quot;</span>,message+<span class="hljs-string">&quot;key1&quot;</span>,correlationData1);<br>log.info(<span class="hljs-string">&quot;发送消息 id 为:&#123;&#125;内容为&#123;&#125;&quot;</span>,correlationData1.getId(),message+<span class="hljs-string">&quot;key1&quot;</span>);<br><span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());<br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;confirm.exchange&quot;</span>,<span class="hljs-string">&quot;key2&quot;</span>,message+<span class="hljs-string">&quot;key2&quot;</span>,correlationData2);<br>log.info(<span class="hljs-string">&quot;发送消息 id 为:&#123;&#125;内容为&#123;&#125;&quot;</span>,correlationData2.getId(),message+<span class="hljs-string">&quot;key2&quot;</span>);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-type">boolean</span> ack, String cause)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> correlationData != <span class="hljs-literal">null</span> ? correlationData.getId() : <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">if</span> (ack) &#123;<br>log.info(<span class="hljs-string">&quot;交换机收到消息确认成功, id:&#123;&#125;&quot;</span>, id);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.error(<span class="hljs-string">&quot;消息 id:&#123;&#125;未成功投递到交换机,原因是:&#123;&#125;&quot;</span>, id, cause);<br>&#125;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnedMessage</span><span class="hljs-params">(Message message, <span class="hljs-type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;<br>log.info(<span class="hljs-string">&quot;消息:&#123;&#125;被服务器退回，退回原因:&#123;&#125;, 交换机是:&#123;&#125;, 路由 key:&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()),replyText, exchange, routingKey);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、回调接口">3、回调接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RabbitTemplate</span>.ConfirmCallback,RabbitTemplate.ReturnCallback &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 交换机不管是否收到消息的一个回调方法</span><br><span class="hljs-comment"> * CorrelationData</span><br><span class="hljs-comment">* 消息相关数据</span><br><span class="hljs-comment"> * ack</span><br><span class="hljs-comment">* 交换机是否收到消息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-type">boolean</span> ack, String cause)</span> &#123;<br>        String id=correlationData!=<span class="hljs-literal">null</span>?correlationData.getId():<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">if</span>(ack)&#123;<br>log.info(<span class="hljs-string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>,id);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>log.info(<span class="hljs-string">&quot;交换机还未收到 id 为:&#123;&#125;消息,由于原因:&#123;&#125;&quot;</span>,id,cause);<br>&#125;<br>&#125;<br><span class="hljs-comment">//当消息无法路由的时候的回调方法</span><br> <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnedMessage</span><span class="hljs-params">(Message message, <span class="hljs-type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;<br>log.error(<span class="hljs-string">&quot; 消 息 &#123;&#125;, 被 交 换 机 &#123;&#125; 退 回 ， 退 回 原 因 :&#123;&#125;, 路 由 key:&#123;&#125;&quot;</span>,<span class="hljs-keyword">new</span><br><span class="hljs-title class_">String</span>(message.getBody()),exchange,replyText,routingKey);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、结果">4、结果</h3><p><img src="/2022/11/11/rabbitmq/image-20221118162140632.png" alt></p><h2 id="3、备份交换机">3、备份交换机</h2><p>有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的 复杂性，该怎么做呢？</p><p>前面在设置死信队列的文章中提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。</p><p>备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就 是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备 份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定 的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进 入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。</p><h3 id="1、架构图-v3">1、架构图</h3><p><img src="/2022/11/11/rabbitmq/image-20221118162724651.png" alt></p><h3 id="2、修改配置类">2、修改配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfirmConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;confirm.exchange&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;confirm.queue&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">BACKUP_EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;backup.exchange&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">BACKUP_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;backup.queue&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">WARNING_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;warning.queue&quot;</span>;<br><span class="hljs-comment">// 声明确认队列</span><br> <span class="hljs-meta">@Bean(&quot;confirmQueue&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">confirmQueue</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();<br>&#125;<br><span class="hljs-comment">//声明确认队列绑定关系</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBinding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span>&#123;<br><span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">&quot;key1&quot;</span>);<br>&#125;<br><span class="hljs-comment">//声明备份 Exchange</span><br><span class="hljs-meta">@Bean(&quot;backupExchange&quot;)</span><br><span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title function_">backupExchange</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FanoutExchange</span>(BACKUP_EXCHANGE_NAME);<br>&#125;<br><span class="hljs-comment">//声明确认 Exchange 交换机的备份交换机</span><br> <span class="hljs-meta">@Bean(&quot;confirmExchange&quot;)</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">confirmExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ExchangeBuilder</span> <span class="hljs-variable">exchangeBuilder</span> <span class="hljs-operator">=</span> ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME).durable(<span class="hljs-literal">true</span>)<br><span class="hljs-comment">//设置该交换机的备份交换机</span><br> .withArgument(<span class="hljs-string">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE_NAME);<br><span class="hljs-keyword">return</span> (DirectExchange)exchangeBuilder.build();<br>&#125;<br><span class="hljs-comment">// 声明警告队列</span><br> <span class="hljs-meta">@Bean(&quot;warningQueue&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">warningQueue</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();<br>&#125;<br><span class="hljs-comment">// 声明报警队列绑定关系</span><br> <span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">warningBinding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue queue,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span>&#123;<br><span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(backupExchange);<br>&#125;<br><span class="hljs-comment">// 声明备份队列</span><br> <span class="hljs-meta">@Bean(&quot;backQueue&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">backQueue</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();<br>&#125;<br><span class="hljs-comment">// 声明备份队列绑定关系</span><br> <span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">backupBinding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;backQueue&quot;)</span> Queue queue,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span>&#123;<br><span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(backupExchange);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、报警消费者">3、报警消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WarningConsumer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">WARNING_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;warning.queue&quot;</span>;<br><span class="hljs-meta">@RabbitListener(queues = WARNING_QUEUE_NAME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveWarningMsg</span><span class="hljs-params">(Message message)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody());<br>log.error(<span class="hljs-string">&quot;报警发现不可路由消息：&#123;&#125;&quot;</span>, msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、结果-v2">4、结果</h3><p>注意重新启动项目的时候需要把原来的confirm.exchange 删除，因为我们修改了其绑定属性。</p><p><img src="/2022/11/11/rabbitmq/image-20221118163131576.png" alt></p><p>mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是备份交换机优先级高。</p><h1>9、幂等性、优先级队列、惰性队列</h1><h2 id="1、幂等性">1、幂等性</h2><p>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常， 此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱 了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误 立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等</p><p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但 实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p><p>怎么解决消息重复消费的问题呢？MQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消 息时用该 id 先判断该消息是否已消费过。</p><p>在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性， 这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。业界主流的幂等性有两种操作:</p><ol><li>唯一 ID+指纹码机制,利用数据库主键去重<br>指纹码:我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基 本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存 在数据库中,优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数 据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。</li><li>利用 redis 的原子性去实现<br>利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费</li></ol><h2 id="2、优先级队列">2、优先级队列</h2><p>为什么要有优先级队列，假如在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单,淘宝会及时将订单推送给我们，如 果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能，但是，tmall 商家对我们来说，肯定是要分大客户和小客户，比如像苹果，小米这样大商家一年起码能给我们创 造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经后端系统是使用 redis 来存 放的定时轮询，redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 RabbitMQ 进行改造和优化,如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。</p><blockquote><p>如何添加优先级队列</p></blockquote><p>1、声明队列</p><p>2、队列中代码添加优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>params.put(<span class="hljs-string">&quot;x-max-priority&quot;</span>, <span class="hljs-number">10</span>);<br>channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, params);<br></code></pre></td></tr></table></figure><p>3、消息中代码添加优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties().builder().priority(<span class="hljs-number">5</span>).build();<br></code></pre></td></tr></table></figure><p>4、发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());<br></code></pre></td></tr></table></figure><h2 id="3、惰性队列">3、惰性队列</h2><p>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消 费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持 更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致 使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p><p>默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中， 这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留 一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的 时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候。</p><blockquote><p>队列的两种模式</p></blockquote><p>队列具备两种模式：default 和 lazy。默认的为default 模式，在3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。 如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</p><p>在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。下面示 例中演示了一个惰性队列的声明细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br>args.put(<span class="hljs-string">&quot;x-queue-mode&quot;</span>, <span class="hljs-string">&quot;lazy&quot;</span>);<br>channel.queueDeclare(<span class="hljs-string">&quot;myqueue&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, args);<br></code></pre></td></tr></table></figure><blockquote><p>内存开销对比</p></blockquote><p><img src="/2022/11/11/rabbitmq/image-20221118171159028.png" alt></p><p>在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅 占用 1.5MB</p><h1>10、RabbitMQ集群</h1><h2 id="1、使用集群的原因">1、使用集群的原因</h2><p>如果 RabbitMQ 服务器遇到内存崩溃、机器掉电或者主板故障等情况，该怎么办？单台 RabbitMQ 服务器可以满足每秒 1000 条消息的吞吐量，那么如果应用需要 RabbitMQ 服务满足每秒 10 万条消息的吞吐量呢？购买昂贵的服务器来增强单机 RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是 解决实际问题的关键。</p><p>集群搭建可参考：<a href="https://cloud.tencent.com/developer/article/1923650">RabbitMQ集群搭建</a></p><h2 id="2、镜像队列">2、镜像队列</h2><p>如果 RabbitMQ 集群中只有一个 Broker 节点，那么该节点的失效将导致整体服务的临时性不可用，并 且也可能会导致消息的丢失。可以将所有消息都设置为持久化，并且对应队列的durable属性也设置为true，但 是这样仍然无法避免由于缓存导致的问题：因为消息在发送之后和被写入磁盘井执行刷盘动作之间存在一 个短暂却会产生问题的时间窗。通过 publisherconfirm 机制能够确保客户端知道哪些消息己经存入磁盘，尽 管如此，一般不希望遇到因单点故障导致的服务不可用。</p><p>引入镜像队列(Mirror Queue)的机制，可以将队列镜像到集群中的其他 Broker 节点之上，如果集群中 的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性。</p><h2 id="3、Haproxy-Keepalive-实现高可用负载均衡">3、Haproxy+Keepalive 实现高可用负载均衡</h2><h3 id="1、架构图-v4">1、架构图</h3><p><img src="/2022/11/11/rabbitmq/image-20221118191312087.png" alt></p><h3 id="2、实现">2、实现</h3><p>HAProxy 提供高可用性、负载均衡及基于TCPHTTP 应用的代理，支持虚拟主机，它是免费、快速并 且可靠的一种解决方案，包括 Twitter,Reddit,StackOverflow,GitHub 在内的多家知名互联网公司在使用。 HAProxy 实现了一种事件驱动、单一进程模型，此模型支持非常大的井发连接数。</p><p>扩展 nginx,lvs,haproxy 之间的区别: <a href="http://www.ha97.com/5646.html">http://www.ha97.com/5646.html</a></p><p>试想如果前面配置的 HAProxy 主机突然宕机或者网卡失效，那么虽然 RbbitMQ 集群没有任何故障但是 对于外界的客户端来说所有的连接都会被断开结果将是灾难性的为了确保负载均衡服务的可靠性同样显得 十分重要，这里就要引入 Keepalived 它能够通过自身健康检查、资源接管功能做高可用(双机热备)，实现 故障转移.</p><p>参考链接：<a href="http://www.yunweipai.com/40460.html#:~:text=%E9%80%9A%E8%BF%87%E6%9C%8D%E5%8A%A1%E4%BB%A3%E7%90%86%E5%B0%86%E6%B5%81%E9%87%8F%E7%94%B1%E5%89%8D%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%87%B3%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8A%82%E7%82%B9%E4%B8%8A%E3%80%82%201.3,Keepalived%E5%92%8CHAProxy%E7%BB%84%E5%90%88%20%E7%94%B1%E4%BA%8EHAProxy%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%B1Keepalived%E6%9D%A5%E4%B8%BAHAProxy%E6%8F%90%E4%BE%9B%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%8D%E5%8A%A1%EF%BC%8C%E8%80%8CHAProxy%E6%8F%90%E4%BE%9B%E5%9B%9B%E5%B1%82%E6%88%96%E4%B8%83%E5%B1%82%E9%AB%98%E6%80%A7%E8%83%BD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8F%8A%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%EF%BC%8C%E4%B8%A4%E8%80%85%E5%85%B1%E5%90%8C%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%8C%E7%BB%93%E6%9E%84%E5%A6%82%E5%9B%BE1%E6%89%80%E7%A4%BA%E3%80%82">用 Keepalived+HAProxy 实现高可用负载均衡的配置方法</a></p><h2 id="4、Federation-Exchange">4、Federation Exchange</h2><p>(broker 北京)，(broker 深圳)彼此之间相距甚远，网络延迟是一个不得不面对的问题。有一个在北京 的业务(Client 北京) 需要连接(broker 北京)，向其中的交换器 exchangeA 发送消息，此时的网络延迟很小， (Client 北京)可以迅速将消息发送至 exchangeA 中，就算在开启了 publisherconfirm 机制或者事务机制的情 况下，也可以迅速收到确认信息。此时又有个在深圳的业务(Client 深圳)需要向 exchangeA 发送消息， 那 么(Client 深圳) (broker 北京)之间有很大的网络延迟，(Client 深圳) 将发送消息至 exchangeA 会经历一定 的延迟，尤其是在开启了 publisherconfirm 机制或者事务机制的情况下，(Client 深圳) 会等待很长的延迟 时间来接收(broker 北京)的确认信息，进而必然造成这条发送线程的性能降低，甚至造成一定程度上的阻 塞。</p><p>将业务(Client 深圳)部署到北京的机房可以解决这个问题，但是如果(Client 深圳)调用的另些服务都部 署在深圳，那么又会引发新的时延问题，总不见得将所有业务全部部署在一个机房，那么容灾又何以实现？ 这里 使用 Federation 插件就可以很好地解决这个问题。</p><p><img src="/2022/11/11/rabbitmq/image-20221118191639111.png" alt></p><p><img src="/2022/11/11/rabbitmq/image-20221118192134598.png" alt></p><h2 id="5、Federation-Queue">5、Federation Queue</h2><p>联邦队列可以在多个 Broker 节点(或者集群)之间为单个队列提供均衡负载的功能。一个联邦队列可以 连接一个或者多个上游队列(upstream queue)，并从这些上游队列中获取消息以满足本地消费者消费消息 的需求。</p><p>参考链接：<a href="https://blog.csdn.net/qq_41157896/article/details/114646866">rabbitMQ插件Federation配置（数据同步）</a></p><h2 id="6、Shovel">6、Shovel</h2><p>Federation 具备的数据转发功能类似，Shovel 够可靠、持续地从一个 Broker 中的队列(作为源端，即 source)拉取数据并转发至另一个 Broker 中的交换器(作为目的端，即 destination)。作为源端的队列和作为 目的端的交换器可以同时位于同一个 Broker，也可以位于不同的 Broker 上。Shovel 可以翻译为&quot;铲子&quot;，是 一种比较形象的比喻，这个&quot;铲子&quot;可以将消息从一方&quot;铲子&quot;另一方。Shovel 行为就像优秀的客户端应用程 序能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理。</p><p><img src="/2022/11/11/rabbitmq/image-20221118192105876.png" alt></p><p>参考链接：<a href="https://cloud.tencent.com/developer/article/1469332">RabbitMQ Shovel</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM-04-虚拟机栈</title>
    <link href="/2022/10/31/jvm-04-xu-ni-ji-zhan/"/>
    <url>/2022/10/31/jvm-04-xu-ni-ji-zhan/</url>
    
    <content type="html"><![CDATA[<h1>1、虚拟机栈概述</h1><h2 id="1、虚拟机栈的出现背景">1、虚拟机栈的出现背景</h2><ol><li>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。</li><li>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令</li></ol><h2 id="2、内存中的栈和堆">2、内存中的栈和堆</h2><ol><li>首先栈是运行时的单位，而堆是存储的单位。</li><li>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ol><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031170753668.png" alt></p><h2 id="3、虚拟机栈基本内容">3、虚拟机栈基本内容</h2><blockquote><p>Java虚拟机栈是什么？</p></blockquote><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<strong>对应着一次次的Java方法调用</strong>，栈是线程私有的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StackTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StackTest</span>();<br>        test.methodA();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>        methodB();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031171651921.png" alt></p><blockquote><p>虚拟机栈的生命周期</p></blockquote><p>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</p><blockquote><p>虚拟机栈的作用</p></blockquote><p>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。</p><p>局部变量，它是相比于成员变量来说的（或属性）</p><p>基本数据类型变量 VS 引用类型变量（类、数组、接口）</p><h2 id="4、虚拟机栈的特点">4、虚拟机栈的特点</h2><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li><li>JVM直接对Java栈的操作只有两个：<ul><li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li><li>执行结束后的<strong>出栈</strong>工作</li></ul></li><li>对于栈来说不存在垃圾回收问题<ul><li>栈不需要GC，但是可能存在OOM（异常）</li></ul></li></ul><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031171930120.png" alt></p><h2 id="5、虚拟机栈的异常">5、虚拟机栈的异常</h2><p>栈中可能出现哪些异常？</p><ul><li>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。<ul><li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong> 异常。（栈溢出）</li><li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。（内存溢出）</li></ul></li></ul><h2 id="6、设置栈内存大小">6、设置栈内存大小</h2><blockquote><p>官方文档：<a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a></p></blockquote><p>可以使用参数 <strong>-Xss</strong> 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><p>The following examples set the thread stack size to 1024 KB in different units:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xss1m<br>-Xss1024k<br>-Xss1048576<br></code></pre></td></tr></table></figure><h3 id="举例">举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackErrorTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(count);<br>        count++;<br>        main(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>没设置参数前的部分结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">11404</span><br><span class="hljs-number">11405</span><br><span class="hljs-number">11406</span><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.StackOverflowError<br>at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:<span class="hljs-number">691</span>)<br></code></pre></td></tr></table></figure><p>说明栈在11406这个深度溢出了</p><p>设置栈参数后，（可参考<a href="https://www.jianshu.com/p/909a906ec14b">Idea调节栈参数</a>）</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031181051063.png" alt></p><p>部分输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2474</span><br><span class="hljs-number">2475</span><br><span class="hljs-number">2476</span><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.StackOverflowError<br>at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:<span class="hljs-number">77</span>)<br></code></pre></td></tr></table></figure><h1>2、栈的存储单位</h1><h2 id="1、栈中存储什么">1、栈中存储什么</h2><ul><li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在</li><li>在这个线程上正在执行的<code>每个方法都各自对应一个栈帧</code>（Stack Frame）。</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ul><h2 id="2、栈运行原理">2、栈运行原理</h2><ul><li>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</li></ul><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031181732230.png" alt></p><ol><li><p><strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。栈是各自私有的。</p></li><li><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p></li><li><p>Java方法有两种返回函数的方式。</p><ul><li>一种是正常的函数返回，使用return指令。</li><li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。</li></ul><p>但不管使用哪种方式，都会导致栈帧被弹出。</p></li></ol><h2 id="3、栈帧的内部结构">3、栈帧的内部结构</h2><p>每个栈帧中存储着：</p><ul><li><code>局部变量表（Local Variables）</code></li><li><code>操作数栈（Operand Stack）（或表达式栈）</code></li><li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031183936694.png" alt></p><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031184012273.png" alt></p><h1>3、局部变量表</h1><h2 id="1、局部变量表">1、局部变量表</h2><ol><li>局部变量表也被称之为局部变量数组或本地变量表</li><li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。<ul><li>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</li><li>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li></ul></li><li>局部变量表中的变量只在当前方法调用中有效。<ul><li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li><li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul></li></ol><p>下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalVariablesTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LocalVariablesTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVariablesTest</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        test.test1();<br>    &#125;<br><br>    <span class="hljs-comment">//练习：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStatic</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">LocalVariablesTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVariablesTest</span>();<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(count);<br>        <span class="hljs-comment">//因为this变量不存在于当前方法的局部变量表中！！</span><br><span class="hljs-comment">//        System.out.println(this.count);</span><br>    &#125;<br><br>    <span class="hljs-comment">//关于Slot的使用的理解</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LocalVariablesTest</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.count = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;atguigu.com&quot;</span>;<br>        test2(date, name1);<br>        System.out.println(date + name1);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test2</span><span class="hljs-params">(Date dateP, String name2)</span> &#123;<br>        dateP = <span class="hljs-literal">null</span>;<br>        name2 = <span class="hljs-string">&quot;songhongkang&quot;</span>;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">weight</span> <span class="hljs-operator">=</span> <span class="hljs-number">130.5</span>;<span class="hljs-comment">//占据两个slot</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">gender</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span>;<br>        <span class="hljs-keyword">return</span> dateP + name2;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.count++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            b = a + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031190546496.png" alt></p><p>看完字节码后，可得结论：局部变量表所需的容量大小是在<code>编译期</code>确定下来的。</p><p>用jclasslib来看字节码，以main方法为例来讲解。</p><p>1、0-15 也就是有16行字节码</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031191240599.png" alt></p><p>2、方法异常信息表</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031191307715.png" alt></p><p>3、Misc</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031191327591.png" alt></p><p>4、行号表</p><p>Java代码的行号和字节码指令行号的对应关系</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031191415540.png" alt></p><p>5、注意：生效行数和剩余有效行数都是针对于字节码文件的行数</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031191440509.png" alt></p><p>1、图中圈的东西表示该局部变量的作用域</p><p>2、Start PC==11表示在字节码的11行开始生效，也就是Java代码对应的第15行。而声明int num在java代码的是第14行，说明是从声明的下一行开始生效</p><p>3、Length== 5表示局部变量剩余有效行数，main方法字节码指令总共有16行，从11行开始生效，那么剩下就是16-11 ==5。</p><p>4、<code>Ljava/lang/String</code> 前面的L表示引用类型</p><h2 id="2、关于slot">2、关于slot</h2><ul><li>参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</li><li>局部变量表，<strong>最基本的存储单元是Slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li><li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型占用两个slot（1ong和double）。<ul><li>byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true</li><li>long和double则占据两个slot</li></ul></li><li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</li><li>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</li><li>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）</li></ul><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101155101775.png" alt></p><h2 id="3、slot代码示例">3、slot代码示例</h2><p><strong>this 存放在 index = 0 的位置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-built_in">this</span>.count++;<br>   &#125;<br></code></pre></td></tr></table></figure><p>局部变量表：this 存放在 index = 0 的位置</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101161423898.png" alt></p><p><strong>64位的类型（1ong和double）占用两个slot</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test2</span><span class="hljs-params">(Date dateP, String name2)</span> &#123;<br>      dateP = <span class="hljs-literal">null</span>;<br>      name2 = <span class="hljs-string">&quot;songhongkang&quot;</span>;<br>      <span class="hljs-type">double</span> <span class="hljs-variable">weight</span> <span class="hljs-operator">=</span> <span class="hljs-number">130.5</span>;<span class="hljs-comment">//占据两个slot</span><br>      <span class="hljs-type">char</span> <span class="hljs-variable">gender</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span>;<br>      <span class="hljs-keyword">return</span> dateP + name2;<br>  &#125;<br></code></pre></td></tr></table></figure><p>weight 为 double 类型，index 直接从 3 蹦到了 5</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101161537765.png" alt></p><h2 id="4、slot的重复使用">4、slot的重复使用</h2><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        b = a + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>局部变量c重用了局部变量b的slot位置</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101161714299.png" alt></p><h2 id="5、静态变量与局部变量的对比">5、静态变量与局部变量的对比</h2><p>java变量的分类：<br>1、按照数据类型分：① 基本数据类型  ② 引用数据类型<br>2、按照在类中声明的位置分：<br>2-1、成员变量：在使用前，都经历过默认初始化赋值<br>2-1-1、类变量: linking的prepare阶段：给类变量默认赋值<br>—&gt; initial阶段：给类变量显式赋值即静态代码块赋值<br>2-1-2、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值<br>2-2、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</p><ul><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li><li>我们知道成员变量有两次初始化的机会**，**第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li><li>和类变量初始化不同的是，<strong>局部变量表不存在系统初始化的过程</strong>，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li></ul><ol><li>在栈帧中，<code>与性能调优关系最为密切的部分就是前面提到的局部变量表</code>。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li><li><code>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</code></li></ol><h1>4、操作数栈</h1><h2 id="1、操作数栈">1、操作数栈</h2><ol><li><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</p></li><li><p>操作数栈，在方法执行过程中，<strong>根据字节码指令，往栈中写入数据或提取数据</strong>，即入栈（push）和 出栈（pop）</p><ul><li><p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。</p></li><li><p>比如：执行复制、交换、求和等操作</p></li></ul></li></ol><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101162841002.png" alt></p><h2 id="2、操作数栈作用">2、操作数栈作用</h2><ol><li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</li><li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。</li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</li><li>栈中的任何一个元素都是可以任意的Java数据类型<ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<strong>只不过操作数栈是用数组这个结构来实现的而已</strong></li><li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</li><li>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</li></ol><h1>5、代码追踪</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddOperation</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//byte、short、char、boolean：都以int型来保存</span><br>       <span class="hljs-type">byte</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j;<br><br>      <span class="hljs-comment">// int m = 800;</span><br><br>   &#125;<br></code></pre></td></tr></table></figure><p>字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> bipush <span class="hljs-number">15</span><br> <span class="hljs-number">2</span> istore_1<br> <span class="hljs-number">3</span> bipush <span class="hljs-number">8</span><br> <span class="hljs-number">5</span> istore_2<br> <span class="hljs-number">6</span> iload_1<br> <span class="hljs-number">7</span> iload_2<br> <span class="hljs-number">8</span> iadd<br> <span class="hljs-number">9</span> istore_3<br><span class="hljs-number">10</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101164637529.png" alt></p><p>1、执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101164809868.png" alt></p><p>2、执行完后，PC寄存器往下移，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置（istore_1），可以看到局部变量表的已经增加了一个元素。并且操作数栈为空了</p><blockquote><p>为什么局部变量表索引从 1 开始，是因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this</p></blockquote><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101164929145.png" alt></p><p>3、PC下移，指向下一行。操作数8也入栈，同时执行store操作，存入局部变量表中</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101165011427.png" alt></p><p>4、然后从局部变量表中，依次将数据放在操作数栈中，等待执行 add 操作</p><p>iload_1：取出局部变量表中索引为1的数据入操作数栈</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101165030381.png" alt></p><p>5、将操作数栈的两个元素相加，并存储在局部变量表3的位置</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101165049259.png" alt></p><p><strong>类型转换问题</strong></p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101170200451.png" alt></p><p>因为 8 可以存放在 byte 类型中，所以压入操作数栈的类型为 byte ，而不是 int ，所以执行的字节码指令为 bipush 8。但是存储在局部变量的时候，会转成 int 类型的变量：istore_4</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101170304921.png" alt></p><p>m改成800之后，byte存储不了，就成了short型，sipush 800</p><p><strong>如果被调用的方法带有返回值，返回值入操作数栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> m + n;<br>      <span class="hljs-keyword">return</span> k;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetSum</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">//获取上一个栈桢返回的结果，并保存在操作数栈中</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> getSum();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>getSum() 方法字节码指令：最后带着个 ireturn</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101170433423.png" alt></p><p>testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值()</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101170531591.png" alt></p><h1>6、栈顶缓存技术(可能未实现？)</h1><p><strong>栈顶缓存技术：Top Of Stack Cashing</strong></p><ol><li>前面提过，基于栈式架构的虚拟机所使用的<code>零地址指令</code>更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读/写次数多，效率不高。</li><li>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</strong></li><li>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</li></ol><h1>7、动态链接</h1><p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p><ul><li>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicLinkingTest</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;methodA()....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;methodB()....&quot;</span>);<br><br>        methodA();<br><br>        num++;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>对应的字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter05/com/atguigu/java1/DynamicLinkingTest.<span class="hljs-keyword">class</span><br>  <span class="hljs-title class_">Last</span> modified <span class="hljs-number">2020</span>-<span class="hljs-number">11</span>-<span class="hljs-number">10</span>; size <span class="hljs-number">712</span> bytes<br>  MD5 checksum e56913c945f897c7ee6c0a608629bca8<br>  Compiled from <span class="hljs-string">&quot;DynamicLinkingTest.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.atguigu.java1.DynamicLinkingTest<br>  minor version: <span class="hljs-number">0</span><br>  major version: <span class="hljs-number">52</span><br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">9.</span>#<span class="hljs-number">23</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = Fieldref           #<span class="hljs-number">8.</span>#<span class="hljs-number">24</span>         <span class="hljs-comment">// com/atguigu/java1/DynamicLinkingTest.num:I</span><br>   #<span class="hljs-number">3</span> = Fieldref           #<span class="hljs-number">25.</span>#<span class="hljs-number">26</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span><br>   #<span class="hljs-number">4</span> = String             #<span class="hljs-number">27</span>            <span class="hljs-comment">// methodA()....</span><br>   #<span class="hljs-number">5</span> = Methodref          #<span class="hljs-number">28.</span>#<span class="hljs-number">29</span>        <span class="hljs-comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>   #<span class="hljs-number">6</span> = String             #<span class="hljs-number">30</span>            <span class="hljs-comment">// methodB()....</span><br>   #<span class="hljs-number">7</span> = Methodref          #<span class="hljs-number">8.</span>#<span class="hljs-number">31</span>         <span class="hljs-comment">// com/atguigu/java1/DynamicLinkingTest.methodA:()V</span><br>   #<span class="hljs-number">8</span> = Class              #<span class="hljs-number">32</span>            <span class="hljs-comment">// com/atguigu/java1/DynamicLinkingTest</span><br>   #<span class="hljs-number">9</span> = Class              #<span class="hljs-number">33</span>            <span class="hljs-comment">// java/lang/Object</span><br>  #<span class="hljs-number">10</span> = Utf8               num<br>  #<span class="hljs-number">11</span> = Utf8               I<br>  #<span class="hljs-number">12</span> = Utf8               &lt;init&gt;<br>  #<span class="hljs-number">13</span> = Utf8               ()V<br>  #<span class="hljs-number">14</span> = Utf8               Code<br>  #<span class="hljs-number">15</span> = Utf8               LineNumberTable<br>  #<span class="hljs-number">16</span> = Utf8               LocalVariableTable<br>  #<span class="hljs-number">17</span> = Utf8               <span class="hljs-built_in">this</span><br>  #<span class="hljs-number">18</span> = Utf8               Lcom/atguigu/java1/DynamicLinkingTest;<br>  #<span class="hljs-number">19</span> = Utf8               methodA<br>  #<span class="hljs-number">20</span> = Utf8               methodB<br>  #<span class="hljs-number">21</span> = Utf8               SourceFile<br>  #<span class="hljs-number">22</span> = Utf8               DynamicLinkingTest.java<br>  #<span class="hljs-number">23</span> = NameAndType        #<span class="hljs-number">12</span>:#<span class="hljs-number">13</span>        <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  #<span class="hljs-number">24</span> = NameAndType        #<span class="hljs-number">10</span>:#<span class="hljs-number">11</span>        <span class="hljs-comment">// num:I</span><br>  #<span class="hljs-number">25</span> = Class              #<span class="hljs-number">34</span>            <span class="hljs-comment">// java/lang/System</span><br>  #<span class="hljs-number">26</span> = NameAndType        #<span class="hljs-number">35</span>:#<span class="hljs-number">36</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>  #<span class="hljs-number">27</span> = Utf8               <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>....<br>  #<span class="hljs-number">28</span> = Class              #<span class="hljs-number">37</span>            <span class="hljs-comment">// java/io/PrintStream</span><br>  #<span class="hljs-number">29</span> = NameAndType        #<span class="hljs-number">38</span>:#<span class="hljs-number">39</span>        <span class="hljs-comment">// println:(Ljava/lang/String;)V</span><br>  #<span class="hljs-number">30</span> = Utf8               <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>....<br>  #<span class="hljs-number">31</span> = NameAndType        #<span class="hljs-number">19</span>:#<span class="hljs-number">13</span>        <span class="hljs-comment">// methodA:()V</span><br>  #<span class="hljs-number">32</span> = Utf8               com/atguigu/java1/DynamicLinkingTest<br>  #<span class="hljs-number">33</span> = Utf8               java/lang/Object<br>  #<span class="hljs-number">34</span> = Utf8               java/lang/System<br>  #<span class="hljs-number">35</span> = Utf8               out<br>  #<span class="hljs-number">36</span> = Utf8               Ljava/io/PrintStream;<br>  #<span class="hljs-number">37</span> = Utf8               java/io/PrintStream<br>  #<span class="hljs-number">38</span> = Utf8               println<br>  #<span class="hljs-number">39</span> = Utf8               (Ljava/lang/String;)V<br>&#123;<br>  <span class="hljs-type">int</span> num;<br>    descriptor: I<br>    flags:<br><br>  <span class="hljs-keyword">public</span> com.atguigu.java1.DynamicLinkingTest();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: aload_0<br>         <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span><br>         <span class="hljs-number">7</span>: putfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field num:I</span><br>        <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">9</span>: <span class="hljs-number">4</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">11</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String methodA()....</span><br>         <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">12</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">13</span>: <span class="hljs-number">8</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// String methodB()....</span><br>         <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>         <span class="hljs-number">8</span>: aload_0<br>         <span class="hljs-number">9</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method methodA:()V</span><br>        <span class="hljs-number">12</span>: aload_0<br>        <span class="hljs-number">13</span>: dup<br>        <span class="hljs-number">14</span>: getfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field num:I</span><br>        <span class="hljs-number">17</span>: iconst_1<br>        <span class="hljs-number">18</span>: iadd<br>        <span class="hljs-number">19</span>: putfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field num:I</span><br>        <span class="hljs-number">22</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">16</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">18</span>: <span class="hljs-number">8</span><br>        line <span class="hljs-number">20</span>: <span class="hljs-number">12</span><br>        line <span class="hljs-number">21</span>: <span class="hljs-number">22</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">23</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;<br>&#125;<br>SourceFile: <span class="hljs-string">&quot;DynamicLinkingTest.java&quot;</span><br></code></pre></td></tr></table></figure><p>1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？</p><p>2、往上面翻，找到常量池的定义：<code>#7 = Methodref #8.#31</code></p><ul><li>先找 #8 ：<ul><li><code>#8 = Class #32</code> ：去找 #32</li><li><code>#32 = Utf8 com/atguigu/java1/DynamicLinkingTest</code></li><li>结论：通过 #8 我们找到了 <code>DynamicLinkingTest</code> 这个类</li></ul></li><li>再来找 #31：<ul><li><code>#31 = NameAndType #19:#13</code> ：去找 #19 和 #13</li><li><code>#19 = Utf8 methodA</code> ：方法名为 methodA</li><li><code>#13 = Utf8 ()V</code> ：方法没有形参，返回值为 void</li></ul></li></ul><p>3、结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用</p><p>4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101190630536.png" alt></p><p><strong>为什么要用常量池呢？</strong></p><ol><li>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</li><li>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C-《程艾影》</title>
    <link href="/2022/10/28/c-cheng-ai-ying/"/>
    <url>/2022/10/28/c-cheng-ai-ying/</url>
    
    <content type="html"><![CDATA[<center>《程艾影》</center><p><img src="/2022/10/28/c-cheng-ai-ying/image-20221028201426573.png" alt></p><p>capo = 5</p><p>前奏-主歌-副歌-间歇-主歌-副歌-哼唱-副歌-主歌-尾奏</p><p><img src="/2022/10/28/c-cheng-ai-ying/image-20221028201251237.png" alt></p><p><img src="/2022/10/28/c-cheng-ai-ying/image-20221028201315318.png" alt></p><p><img src="/2022/10/28/c-cheng-ai-ying/image-20221028201340211.png" alt></p><blockquote><p>曲谱来源于小兵er</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>吉他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>吉他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C-《夜空中最亮的星》</title>
    <link href="/2022/10/28/c-ye-kong-zhong-zui-liang-de-xing/"/>
    <url>/2022/10/28/c-ye-kong-zhong-zui-liang-de-xing/</url>
    
    <content type="html"><![CDATA[<center>《夜空中最亮的星》</center><p>原调B | 选调A | capo = 2</p><p><img src="/2022/10/28/c-ye-kong-zhong-zui-liang-de-xing/image-20221028194640928.png" alt></p><p><img src="/2022/10/28/c-ye-kong-zhong-zui-liang-de-xing/image-20221028194753369.png" alt></p><blockquote><p>曲谱来源于趣谈音乐</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>吉他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>吉他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM-03-运行时数据区</title>
    <link href="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/"/>
    <url>/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/</url>
    
    <content type="html"><![CDATA[<h1>1、运行时数据区概述及线程</h1><h2 id="1、概述">1、概述</h2><p>运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027165103294.png" alt></p><p>当我们通过前面的：类的加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027165118280.png" alt></p><p>类比一下也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品。</p><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027165152827.png" alt></p><h2 id="2、运行时数据区结构">2、运行时数据区结构</h2><h3 id="1、运行时数据区和内存">1、运行时数据区和内存</h3><ol><li>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</li><li>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</li></ol><p>下图源于阿里巴巴手册jdk8</p><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027170903919.png" alt></p><h3 id="2、线程的内存空间">2、线程的内存空间</h3><ol><li>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区：其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</li><li>灰色的为单独线程私有的，红色的为多个线程共享的。即：<ul><li>线程独有：独立包括程序计数器、栈、本地方法栈</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul></li></ol><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027171302313.png" alt></p><h3 id="3、Runtime类">3、Runtime类</h3><p><strong>每个JVM只有一个Runtime实例</strong>。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境（运行时数据区）。</p><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027171346233.png" alt></p><h2 id="3、线程">3、线程</h2><h3 id="1、JVM线程">1、JVM线程</h3><ol><li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li><li>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射<ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li></ul></li><li>操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</li></ol><h3 id="2、JVM系统线程">2、JVM系统线程</h3><ul><li>如果使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[])</code>的main线程以及所有这个main线程自己创建的线程。</li><li>这些主要的后台系统线程在Hotspot JVM里主要是以下几个（了解）：</li></ul><ol><li><strong>虚拟机线程</strong>：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li><li><strong>周期任务线程</strong>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li><li><strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持</li><li><strong>编译线程</strong>：这种线程在运行时会将字节码编译成到本地代码</li><li><strong>信号调度线程</strong>：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li></ol><h1>2、程序计数器(PC寄存器)</h1><h2 id="1、PC寄存器介绍">1、PC寄存器介绍</h2><blockquote><p>官方文档网址：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p></blockquote><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027194012157.png" alt></p><ol><li>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，<strong>寄存器存储指令相关的现场信息</strong>。CPU只有把数据装载到寄存器才能够运行。</li><li>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<code>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</code>。</li><li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li><li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</li><li>它是<strong>程序控制流</strong>的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何OutofMemoryError（溢出）情况的区域。</li></ol><h2 id="2、PC寄存器的作用">2、PC寄存器的作用</h2><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。</p><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027194401567.png" alt></p><h2 id="3、例子">3、例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PCRegisterTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>        System.out.println(i);<br>        System.out.println(k);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看字节码</p><blockquote><p>看字节码的方法：<a href="https://blog.csdn.net/21aspnet/article/details/88351875">https://blog.csdn.net/21aspnet/article/details/88351875</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter04/com/atguigu/java/PCRegisterTest.<span class="hljs-keyword">class</span><br>  <span class="hljs-title class_">Last</span> modified <span class="hljs-number">2020</span>-<span class="hljs-number">11</span>-<span class="hljs-number">2</span>; size <span class="hljs-number">675</span> bytes<br>  MD5 checksum 53b3ef104479ec9e9b7ce5319e5881d3<br>  Compiled from <span class="hljs-string">&quot;PCRegisterTest.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.atguigu.java.PCRegisterTest<br>  minor version: <span class="hljs-number">0</span><br>  major version: <span class="hljs-number">52</span><br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">6.</span>#<span class="hljs-number">26</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = String             #<span class="hljs-number">27</span>            <span class="hljs-comment">// abc</span><br>   #<span class="hljs-number">3</span> = Fieldref           #<span class="hljs-number">28.</span>#<span class="hljs-number">29</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span><br>   #<span class="hljs-number">4</span> = Methodref          #<span class="hljs-number">30.</span>#<span class="hljs-number">31</span>        <span class="hljs-comment">// java/io/PrintStream.println:(I)V</span><br>   #<span class="hljs-number">5</span> = Class              #<span class="hljs-number">32</span>            <span class="hljs-comment">// com/atguigu/java/PCRegisterTest</span><br>   #<span class="hljs-number">6</span> = Class              #<span class="hljs-number">33</span>            <span class="hljs-comment">// java/lang/Object</span><br>   #<span class="hljs-number">7</span> = Utf8               &lt;init&gt;<br>   #<span class="hljs-number">8</span> = Utf8               ()V<br>   #<span class="hljs-number">9</span> = Utf8               Code<br>  #<span class="hljs-number">10</span> = Utf8               LineNumberTable<br>  #<span class="hljs-number">11</span> = Utf8               LocalVariableTable<br>  #<span class="hljs-number">12</span> = Utf8               <span class="hljs-built_in">this</span><br>  #<span class="hljs-number">13</span> = Utf8               Lcom/atguigu/java/PCRegisterTest;<br>  #<span class="hljs-number">14</span> = Utf8               main<br>  #<span class="hljs-number">15</span> = Utf8               ([Ljava/lang/String;)V<br>  #<span class="hljs-number">16</span> = Utf8               args<br>  #<span class="hljs-number">17</span> = Utf8               [Ljava/lang/String;<br>  #<span class="hljs-number">18</span> = Utf8               i<br>  #<span class="hljs-number">19</span> = Utf8               I<br>  #<span class="hljs-number">20</span> = Utf8               j<br>  #<span class="hljs-number">21</span> = Utf8               k<br>  #<span class="hljs-number">22</span> = Utf8               s<br>  #<span class="hljs-number">23</span> = Utf8               Ljava/lang/String;<br>  #<span class="hljs-number">24</span> = Utf8               SourceFile<br>  #<span class="hljs-number">25</span> = Utf8               PCRegisterTest.java<br>  #<span class="hljs-number">26</span> = NameAndType        #<span class="hljs-number">7</span>:#<span class="hljs-number">8</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  #<span class="hljs-number">27</span> = Utf8               abc<br>  #<span class="hljs-number">28</span> = Class              #<span class="hljs-number">34</span>            <span class="hljs-comment">// java/lang/System</span><br>  #<span class="hljs-number">29</span> = NameAndType        #<span class="hljs-number">35</span>:#<span class="hljs-number">36</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>  #<span class="hljs-number">30</span> = Class              #<span class="hljs-number">37</span>            <span class="hljs-comment">// java/io/PrintStream</span><br>  #<span class="hljs-number">31</span> = NameAndType        #<span class="hljs-number">38</span>:#<span class="hljs-number">39</span>        <span class="hljs-comment">// println:(I)V</span><br>  #<span class="hljs-number">32</span> = Utf8               com/atguigu/java/PCRegisterTest<br>  #<span class="hljs-number">33</span> = Utf8               java/lang/Object<br>  #<span class="hljs-number">34</span> = Utf8               java/lang/System<br>  #<span class="hljs-number">35</span> = Utf8               out<br>  #<span class="hljs-number">36</span> = Utf8               Ljava/io/PrintStream;<br>  #<span class="hljs-number">37</span> = Utf8               java/io/PrintStream<br>  #<span class="hljs-number">38</span> = Utf8               println<br>  #<span class="hljs-number">39</span> = Utf8               (I)V<br>&#123;<br>  <span class="hljs-keyword">public</span> com.atguigu.java.PCRegisterTest();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java/PCRegisterTest;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>         <span class="hljs-number">2</span>: istore_1<br>         <span class="hljs-number">3</span>: bipush        <span class="hljs-number">20</span><br>         <span class="hljs-number">5</span>: istore_2<br>         <span class="hljs-number">6</span>: iload_1<br>         <span class="hljs-number">7</span>: iload_2<br>         <span class="hljs-number">8</span>: iadd<br>         <span class="hljs-number">9</span>: istore_3<br>        <span class="hljs-number">10</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String abc</span><br>        <span class="hljs-number">12</span>: astore        <span class="hljs-number">4</span><br>        <span class="hljs-number">14</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>        <span class="hljs-number">17</span>: iload_1<br>        <span class="hljs-number">18</span>: invokevirtual #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(I)V</span><br>        <span class="hljs-number">21</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>        <span class="hljs-number">24</span>: iload_3<br>        <span class="hljs-number">25</span>: invokevirtual #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(I)V</span><br>        <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">10</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">11</span>: <span class="hljs-number">3</span><br>        line <span class="hljs-number">12</span>: <span class="hljs-number">6</span><br>        line <span class="hljs-number">14</span>: <span class="hljs-number">10</span><br>        line <span class="hljs-number">15</span>: <span class="hljs-number">14</span><br>        line <span class="hljs-number">16</span>: <span class="hljs-number">21</span><br>        line <span class="hljs-number">18</span>: <span class="hljs-number">28</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">29</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>            <span class="hljs-number">3</span>      <span class="hljs-number">26</span>     <span class="hljs-number">1</span>     i   I<br>            <span class="hljs-number">6</span>      <span class="hljs-number">23</span>     <span class="hljs-number">2</span>     j   I<br>           <span class="hljs-number">10</span>      <span class="hljs-number">19</span>     <span class="hljs-number">3</span>     k   I<br>           <span class="hljs-number">14</span>      <span class="hljs-number">15</span>     <span class="hljs-number">4</span>     s   Ljava/lang/String;<br>&#125;<br>SourceFile: <span class="hljs-string">&quot;PCRegisterTest.java&quot;</span><br></code></pre></td></tr></table></figure><p>左边的数字代表<strong>指令地址（指令偏移）</strong>，即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令</p><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027194950557.png" alt></p><h2 id="4、🔺两个注意点">4、🔺两个注意点</h2><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？<strong>或者问</strong>为什么使用 PC 寄存器来记录当前线程的执行地址呢？</strong></p><ol><li>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</li><li>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</li></ol><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027195119590.png" alt></p><p><strong>PC寄存器为什么被设定为私有的？</strong></p><ol><li>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li><li>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li><li>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</li></ol><blockquote><p>注意并行和并发，不是一个概念</p><p>并行：  串行</p><p>并发：  一个核，快速执行，看起来像并发</p></blockquote><h2 id="5、CPU时间片">5、CPU时间片</h2><ol><li>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</li><li>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</li><li>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，<strong>每个程序轮流执行</strong>。</li></ol><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027195216420.png" alt></p><h1>3、本地方法接口</h1><h2 id="1、本地方法">1、本地方法</h2><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221031165301758.png" alt></p><ol><li>简单地讲，<strong>一个Native Method是一个Java调用非Java代码的接囗</strong>一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern 告知C++编译器去调用一个C的函数。</li><li>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</li><li>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</li><li>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</li></ol><h2 id="2、举例">2、举例</h2><p>标识符native可以与其它java标识符连用，但是abstract除外</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IHaveNatives</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Native1</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">Native2</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">float</span> <span class="hljs-title function_">Native3</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Native4</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ary)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、为什么有-Native-Method的存在？">3、为什么有 Native Method的存在？</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><h3 id="1、与java环境外交互">1、与java环境外交互</h3><p><strong>有时Java应用需要与Java外面的硬件环境交互，这是本地方法存在的主要原因</strong>。可以想想Java需要与一些<strong>底层系统</strong>，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><h3 id="2、与操作系统的交互">2、与操作系统的交互</h3><ol><li>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。</li><li>然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。</li><li><strong>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的</strong>。</li><li>还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li></ol><h3 id="3、Sun’s-Java">3、Sun’s Java</h3><ol><li>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。</li><li>例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li></ol><h3 id="4、本地方法的现状">4、本地方法的现状</h3><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等。</p><h1>4、本地方法栈</h1><ol><li><strong>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</li><li>本地方法栈，也是线程私有的。</li><li>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul></li><li>本地方法一般是使用C语言或C++语言实现的。</li><li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</li></ol><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221031170046976.png" alt></p><p>说明：</p><ol><li>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。<ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存</li></ul></li><li>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</li><li>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>emoji</title>
    <link href="/2022/10/25/emoji/"/>
    <url>/2022/10/25/emoji/</url>
    
    <content type="html"><![CDATA[<p>People</p><table><thead><tr><th>:bowtie: <code>:bowtie:</code></th><th>😄 <code>:smile:</code></th><th>😆 <code>:laughing:</code></th></tr></thead><tbody><tr><td>😊 <code>:blush:</code></td><td>😃 <code>:smiley:</code></td><td>☺️ <code>:relaxed:</code></td></tr><tr><td>😏 <code>:smirk:</code></td><td>😍 <code>:heart_eyes:</code></td><td>😘 <code>:kissing_heart:</code></td></tr><tr><td>😚 <code>:kissing_closed_eyes:</code></td><td>😳 <code>:flushed:</code></td><td>😌 <code>:relieved:</code></td></tr><tr><td>😆 <code>:satisfied:</code></td><td>😁 <code>:grin:</code></td><td>😉 <code>:wink:</code></td></tr><tr><td>😜 <code>:stuck_out_tongue_winking_eye:</code></td><td>😝 <code>:stuck_out_tongue_closed_eyes:</code></td><td>😀 <code>:grinning:</code></td></tr><tr><td>😗 <code>:kissing:</code></td><td>😙 <code>:kissing_smiling_eyes:</code></td><td>😛 <code>:stuck_out_tongue:</code></td></tr><tr><td>😴 <code>:sleeping:</code></td><td>😟 <code>:worried:</code></td><td>😦 <code>:frowning:</code></td></tr><tr><td>😧 <code>:anguished:</code></td><td>😮 <code>:open_mouth:</code></td><td>😬 <code>:grimacing:</code></td></tr><tr><td>😕 <code>:confused:</code></td><td>😯 <code>:hushed:</code></td><td>😑 <code>:expressionless:</code></td></tr><tr><td>😒 <code>:unamused:</code></td><td>😅 <code>:sweat_smile:</code></td><td>😓 <code>:sweat:</code></td></tr><tr><td>😥 <code>:disappointed_relieved:</code></td><td>😩 <code>:weary:</code></td><td>😔 <code>:pensive:</code></td></tr><tr><td>😞 <code>:disappointed:</code></td><td>😖 <code>:confounded:</code></td><td>😨 <code>:fearful:</code></td></tr><tr><td>😰 <code>:cold_sweat:</code></td><td>😣 <code>:persevere:</code></td><td>😢 <code>:cry:</code></td></tr><tr><td>😭 <code>:sob:</code></td><td>😂 <code>:joy:</code></td><td>😲 <code>:astonished:</code></td></tr><tr><td>😱 <code>:scream:</code></td><td>:neckbeard: <code>:neckbeard:</code></td><td>😫 <code>:tired_face:</code></td></tr><tr><td>😠 <code>:angry:</code></td><td>😡 <code>:rage:</code></td><td>😤 <code>:triumph:</code></td></tr><tr><td>😪 <code>:sleepy:</code></td><td>😋 <code>:yum:</code></td><td>😷 <code>:mask:</code></td></tr><tr><td>😎 <code>:sunglasses:</code></td><td>😵 <code>:dizzy_face:</code></td><td>👿 <code>:imp:</code></td></tr><tr><td>😈 <code>:smiling_imp:</code></td><td>😐 <code>:neutral_face:</code></td><td>😶 <code>:no_mouth:</code></td></tr><tr><td>😇 <code>:innocent:</code></td><td>👽 <code>:alien:</code></td><td>💛 <code>:yellow_heart:</code></td></tr><tr><td>💙 <code>:blue_heart:</code></td><td>💜 <code>:purple_heart:</code></td><td>❤️ <code>:heart:</code></td></tr><tr><td>💚 <code>:green_heart:</code></td><td>💔 <code>:broken_heart:</code></td><td>💓 <code>:heartbeat:</code></td></tr><tr><td>💗 <code>:heartpulse:</code></td><td>💕 <code>:two_hearts:</code></td><td>💞 <code>:revolving_hearts:</code></td></tr><tr><td>💘 <code>:cupid:</code></td><td>💖 <code>:sparkling_heart:</code></td><td>✨ <code>:sparkles:</code></td></tr><tr><td>⭐ <code>:star:</code></td><td>🌟 <code>:star2:</code></td><td>💫 <code>:dizzy:</code></td></tr><tr><td>💥 <code>:boom:</code></td><td>💥 <code>:collision:</code></td><td>💢 <code>:anger:</code></td></tr><tr><td>❗ <code>:exclamation:</code></td><td>❓ <code>:question:</code></td><td>❕ <code>:grey_exclamation:</code></td></tr><tr><td>❔ <code>:grey_question:</code></td><td>💤 <code>:zzz:</code></td><td>💨 <code>:dash:</code></td></tr><tr><td>💦 <code>:sweat_drops:</code></td><td>🎶 <code>:notes:</code></td><td>🎵 <code>:musical_note:</code></td></tr><tr><td>🔥 <code>:fire:</code></td><td>💩 <code>:hankey:</code></td><td>💩 <code>:poop:</code></td></tr><tr><td>💩 <code>:shit:</code></td><td>👍 <code>:+1:</code></td><td>👍 <code>:thumbsup:</code></td></tr><tr><td>👎 <code>:-1:</code></td><td>👎 <code>:thumbsdown:</code></td><td>👌 <code>:ok_hand:</code></td></tr><tr><td>👊 <code>:punch:</code></td><td>👊 <code>:facepunch:</code></td><td>✊ <code>:fist:</code></td></tr><tr><td>✌️ <code>:v:</code></td><td>👋 <code>:wave:</code></td><td>✋ <code>:hand:</code></td></tr><tr><td>✋ <code>:raised_hand:</code></td><td>👐 <code>:open_hands:</code></td><td>☝️ <code>:point_up:</code></td></tr><tr><td>👇 <code>:point_down:</code></td><td>👈 <code>:point_left:</code></td><td>👉 <code>:point_right:</code></td></tr><tr><td>🙌 <code>:raised_hands:</code></td><td>🙏 <code>:pray:</code></td><td>👆 <code>:point_up_2:</code></td></tr><tr><td>👏 <code>:clap:</code></td><td>💪 <code>:muscle:</code></td><td>🤘 <code>:metal:</code></td></tr><tr><td>🖕 <code>:fu:</code></td><td>🚶 <code>:walking:</code></td><td>🏃 <code>:runner:</code></td></tr><tr><td>🏃 <code>:running:</code></td><td>👫 <code>:couple:</code></td><td>👪 <code>:family:</code></td></tr><tr><td>👬 <code>:two_men_holding_hands:</code></td><td>👭 <code>:two_women_holding_hands:</code></td><td>💃 <code>:dancer:</code></td></tr><tr><td>👯 <code>:dancers:</code></td><td>🙆‍♀️ <code>:ok_woman:</code></td><td>🙅 <code>:no_good:</code></td></tr><tr><td>💁 <code>:information_desk_person:</code></td><td>🙋 <code>:raising_hand:</code></td><td>👰‍♀️ <code>:bride_with_veil:</code></td></tr><tr><td>:person_with_pouting_face: <code>:person_with_pouting_face:</code></td><td>:person_frowning: <code>:person_frowning:</code></td><td>🙇 <code>:bow:</code></td></tr><tr><td>💏 <code>:couplekiss:</code></td><td>💑 <code>:couple_with_heart:</code></td><td>💆 <code>:massage:</code></td></tr><tr><td>💇 <code>:haircut:</code></td><td>💅 <code>:nail_care:</code></td><td>👦 <code>:boy:</code></td></tr><tr><td>👧 <code>:girl:</code></td><td>👩 <code>:woman:</code></td><td>👨 <code>:man:</code></td></tr><tr><td>👶 <code>:baby:</code></td><td>👵 <code>:older_woman:</code></td><td>👴 <code>:older_man:</code></td></tr><tr><td>:person_with_blond_hair: <code>:person_with_blond_hair:</code></td><td>👲 <code>:man_with_gua_pi_mao:</code></td><td>👳‍♂️ <code>:man_with_turban:</code></td></tr><tr><td>👷 <code>:construction_worker:</code></td><td>👮 <code>:cop:</code></td><td>👼 <code>:angel:</code></td></tr><tr><td>👸 <code>:princess:</code></td><td>😺 <code>:smiley_cat:</code></td><td>😸 <code>:smile_cat:</code></td></tr><tr><td>😻 <code>:heart_eyes_cat:</code></td><td>😽 <code>:kissing_cat:</code></td><td>😼 <code>:smirk_cat:</code></td></tr><tr><td>🙀 <code>:scream_cat:</code></td><td>😿 <code>:crying_cat_face:</code></td><td>😹 <code>:joy_cat:</code></td></tr><tr><td>😾 <code>:pouting_cat:</code></td><td>👹 <code>:japanese_ogre:</code></td><td>👺 <code>:japanese_goblin:</code></td></tr><tr><td>🙈 <code>:see_no_evil:</code></td><td>🙉 <code>:hear_no_evil:</code></td><td>🙊 <code>:speak_no_evil:</code></td></tr><tr><td>💂‍♂️ <code>:guardsman:</code></td><td>💀 <code>:skull:</code></td><td>🐾 <code>:feet:</code></td></tr><tr><td>👄 <code>:lips:</code></td><td>💋 <code>:kiss:</code></td><td>💧 <code>:droplet:</code></td></tr><tr><td>👂 <code>:ear:</code></td><td>👀 <code>:eyes:</code></td><td>👃 <code>:nose:</code></td></tr><tr><td>👅 <code>:tongue:</code></td><td>💌 <code>:love_letter:</code></td><td>👤 <code>:bust_in_silhouette:</code></td></tr><tr><td>👥 <code>:busts_in_silhouette:</code></td><td>💬 <code>:speech_balloon:</code></td><td>💭 <code>:thought_balloon:</code></td></tr><tr><td>:feelsgood: <code>:feelsgood:</code></td><td>:finnadie: <code>:finnadie:</code></td><td>:goberserk: <code>:goberserk:</code></td></tr><tr><td>:godmode: <code>:godmode:</code></td><td>:hurtrealbad: <code>:hurtrealbad:</code></td><td>:rage1: <code>:rage1:</code></td></tr><tr><td>:rage2: <code>:rage2:</code></td><td>:rage3: <code>:rage3:</code></td><td>:rage4: <code>:rage4:</code></td></tr><tr><td>:suspect: <code>:suspect:</code></td><td>:trollface: <code>:trollface:</code></td><td></td></tr></tbody></table><p>Nature</p><table><thead><tr><th>☀️ <code>:sunny:</code></th><th>☔ <code>:umbrella:</code></th><th>☁️ <code>:cloud:</code></th></tr></thead><tbody><tr><td>❄️ <code>:snowflake:</code></td><td>⛄ <code>:snowman:</code></td><td>⚡ <code>:zap:</code></td></tr><tr><td>🌀 <code>:cyclone:</code></td><td>🌁 <code>:foggy:</code></td><td>🌊 <code>:ocean:</code></td></tr><tr><td>🐱 <code>:cat:</code></td><td>🐶 <code>:dog:</code></td><td>🐭 <code>:mouse:</code></td></tr><tr><td>🐹 <code>:hamster:</code></td><td>🐰 <code>:rabbit:</code></td><td>🐺 <code>:wolf:</code></td></tr><tr><td>🐸 <code>:frog:</code></td><td>🐯 <code>:tiger:</code></td><td>🐨 <code>:koala:</code></td></tr><tr><td>🐻 <code>:bear:</code></td><td>🐷 <code>:pig:</code></td><td>🐽 <code>:pig_nose:</code></td></tr><tr><td>🐮 <code>:cow:</code></td><td>🐗 <code>:boar:</code></td><td>🐵 <code>:monkey_face:</code></td></tr><tr><td>🐒 <code>:monkey:</code></td><td>🐴 <code>:horse:</code></td><td>🐎 <code>:racehorse:</code></td></tr><tr><td>🐫 <code>:camel:</code></td><td>🐑 <code>:sheep:</code></td><td>🐘 <code>:elephant:</code></td></tr><tr><td>🐼 <code>:panda_face:</code></td><td>🐍 <code>:snake:</code></td><td>🐦 <code>:bird:</code></td></tr><tr><td>🐤 <code>:baby_chick:</code></td><td>🐥 <code>:hatched_chick:</code></td><td>🐣 <code>:hatching_chick:</code></td></tr><tr><td>🐔 <code>:chicken:</code></td><td>🐧 <code>:penguin:</code></td><td>🐢 <code>:turtle:</code></td></tr><tr><td>🐛 <code>:bug:</code></td><td>🐝 <code>:honeybee:</code></td><td>🐜 <code>:ant:</code></td></tr><tr><td>🪲 <code>:beetle:</code></td><td>🐌 <code>:snail:</code></td><td>🐙 <code>:octopus:</code></td></tr><tr><td>🐠 <code>:tropical_fish:</code></td><td>🐟 <code>:fish:</code></td><td>🐳 <code>:whale:</code></td></tr><tr><td>🐋 <code>:whale2:</code></td><td>🐬 <code>:dolphin:</code></td><td>🐄 <code>:cow2:</code></td></tr><tr><td>🐏 <code>:ram:</code></td><td>🐀 <code>:rat:</code></td><td>🐃 <code>:water_buffalo:</code></td></tr><tr><td>🐅 <code>:tiger2:</code></td><td>🐇 <code>:rabbit2:</code></td><td>🐉 <code>:dragon:</code></td></tr><tr><td>🐐 <code>:goat:</code></td><td>🐓 <code>:rooster:</code></td><td>🐕 <code>:dog2:</code></td></tr><tr><td>🐖 <code>:pig2:</code></td><td>🐁 <code>:mouse2:</code></td><td>🐂 <code>:ox:</code></td></tr><tr><td>🐲 <code>:dragon_face:</code></td><td>🐡 <code>:blowfish:</code></td><td>🐊 <code>:crocodile:</code></td></tr><tr><td>🐪 <code>:dromedary_camel:</code></td><td>🐆 <code>:leopard:</code></td><td>🐈 <code>:cat2:</code></td></tr><tr><td>🐩 <code>:poodle:</code></td><td>🐾 <code>:paw_prints:</code></td><td>💐 <code>:bouquet:</code></td></tr><tr><td>🌸 <code>:cherry_blossom:</code></td><td>🌷 <code>:tulip:</code></td><td>🍀 <code>:four_leaf_clover:</code></td></tr><tr><td>🌹 <code>:rose:</code></td><td>🌻 <code>:sunflower:</code></td><td>🌺 <code>:hibiscus:</code></td></tr><tr><td>🍁 <code>:maple_leaf:</code></td><td>🍃 <code>:leaves:</code></td><td>🍂 <code>:fallen_leaf:</code></td></tr><tr><td>🌿 <code>:herb:</code></td><td>🍄 <code>:mushroom:</code></td><td>🌵 <code>:cactus:</code></td></tr><tr><td>🌴 <code>:palm_tree:</code></td><td>🌲 <code>:evergreen_tree:</code></td><td>🌳 <code>:deciduous_tree:</code></td></tr><tr><td>🌰 <code>:chestnut:</code></td><td>🌱 <code>:seedling:</code></td><td>🌼 <code>:blossom:</code></td></tr><tr><td>🌾 <code>:ear_of_rice:</code></td><td>🐚 <code>:shell:</code></td><td>🌐 <code>:globe_with_meridians:</code></td></tr><tr><td>🌞 <code>:sun_with_face:</code></td><td>🌝 <code>:full_moon_with_face:</code></td><td>🌚 <code>:new_moon_with_face:</code></td></tr><tr><td>🌑 <code>:new_moon:</code></td><td>🌒 <code>:waxing_crescent_moon:</code></td><td>🌓 <code>:first_quarter_moon:</code></td></tr><tr><td>🌔 <code>:waxing_gibbous_moon:</code></td><td>🌕 <code>:full_moon:</code></td><td>🌖 <code>:waning_gibbous_moon:</code></td></tr><tr><td>🌗 <code>:last_quarter_moon:</code></td><td>🌘 <code>:waning_crescent_moon:</code></td><td>🌜 <code>:last_quarter_moon_with_face:</code></td></tr><tr><td>🌛 <code>:first_quarter_moon_with_face:</code></td><td>🌔 <code>:moon:</code></td><td>🌍 <code>:earth_africa:</code></td></tr><tr><td>🌎 <code>:earth_americas:</code></td><td>🌏 <code>:earth_asia:</code></td><td>🌋 <code>:volcano:</code></td></tr><tr><td>🌌 <code>:milky_way:</code></td><td>⛅ <code>:partly_sunny:</code></td><td>:octocat: <code>:octocat:</code></td></tr><tr><td>:squirrel: <code>:squirrel:</code></td><td></td><td></td></tr></tbody></table><p>Objects</p><table><thead><tr><th>🎍 <code>:bamboo:</code></th><th>💝 <code>:gift_heart:</code></th><th>🎎 <code>:dolls:</code></th></tr></thead><tbody><tr><td>🎒 <code>:school_satchel:</code></td><td>🎓 <code>:mortar_board:</code></td><td>🎏 <code>:flags:</code></td></tr><tr><td>🎆 <code>:fireworks:</code></td><td>🎇 <code>:sparkler:</code></td><td>🎐 <code>:wind_chime:</code></td></tr><tr><td>🎑 <code>:rice_scene:</code></td><td>🎃 <code>:jack_o_lantern:</code></td><td>👻 <code>:ghost:</code></td></tr><tr><td>🎅 <code>:santa:</code></td><td>🎄 <code>:christmas_tree:</code></td><td>🎁 <code>:gift:</code></td></tr><tr><td>🔔 <code>:bell:</code></td><td>🔕 <code>:no_bell:</code></td><td>🎋 <code>:tanabata_tree:</code></td></tr><tr><td>🎉 <code>:tada:</code></td><td>🎊 <code>:confetti_ball:</code></td><td>🎈 <code>:balloon:</code></td></tr><tr><td>🔮 <code>:crystal_ball:</code></td><td>💿 <code>:cd:</code></td><td>📀 <code>:dvd:</code></td></tr><tr><td>💾 <code>:floppy_disk:</code></td><td>📷 <code>:camera:</code></td><td>📹 <code>:video_camera:</code></td></tr><tr><td>🎥 <code>:movie_camera:</code></td><td>💻 <code>:computer:</code></td><td>📺 <code>:tv:</code></td></tr><tr><td>📱 <code>:iphone:</code></td><td>☎️ <code>:phone:</code></td><td>☎️ <code>:telephone:</code></td></tr><tr><td>📞 <code>:telephone_receiver:</code></td><td>📟 <code>:pager:</code></td><td>📠 <code>:fax:</code></td></tr><tr><td>💽 <code>:minidisc:</code></td><td>📼 <code>:vhs:</code></td><td>🔉 <code>:sound:</code></td></tr><tr><td>🔈 <code>:speaker:</code></td><td>🔇 <code>:mute:</code></td><td>📢 <code>:loudspeaker:</code></td></tr><tr><td>📣 <code>:mega:</code></td><td>⌛ <code>:hourglass:</code></td><td>⏳ <code>:hourglass_flowing_sand:</code></td></tr><tr><td>⏰ <code>:alarm_clock:</code></td><td>⌚ <code>:watch:</code></td><td>📻 <code>:radio:</code></td></tr><tr><td>📡 <code>:satellite:</code></td><td>➿ <code>:loop:</code></td><td>🔍 <code>:mag:</code></td></tr><tr><td>🔎 <code>:mag_right:</code></td><td>🔓 <code>:unlock:</code></td><td>🔒 <code>:lock:</code></td></tr><tr><td>🔏 <code>:lock_with_ink_pen:</code></td><td>🔐 <code>:closed_lock_with_key:</code></td><td>🔑 <code>:key:</code></td></tr><tr><td>💡 <code>:bulb:</code></td><td>🔦 <code>:flashlight:</code></td><td>🔆 <code>:high_brightness:</code></td></tr><tr><td>🔅 <code>:low_brightness:</code></td><td>🔌 <code>:electric_plug:</code></td><td>🔋 <code>:battery:</code></td></tr><tr><td>📲 <code>:calling:</code></td><td>📧 <code>:email:</code></td><td>📫 <code>:mailbox:</code></td></tr><tr><td>📮 <code>:postbox:</code></td><td>🛀 <code>:bath:</code></td><td>🛁 <code>:bathtub:</code></td></tr><tr><td>🚿 <code>:shower:</code></td><td>🚽 <code>:toilet:</code></td><td>🔧 <code>:wrench:</code></td></tr><tr><td>🔩 <code>:nut_and_bolt:</code></td><td>🔨 <code>:hammer:</code></td><td>💺 <code>:seat:</code></td></tr><tr><td>💰 <code>:moneybag:</code></td><td>💴 <code>:yen:</code></td><td>💵 <code>:dollar:</code></td></tr><tr><td>💷 <code>:pound:</code></td><td>💶 <code>:euro:</code></td><td>💳 <code>:credit_card:</code></td></tr><tr><td>💸 <code>:money_with_wings:</code></td><td>📧 <code>:e-mail:</code></td><td>📥 <code>:inbox_tray:</code></td></tr><tr><td>📤 <code>:outbox_tray:</code></td><td>✉️ <code>:envelope:</code></td><td>📨 <code>:incoming_envelope:</code></td></tr><tr><td>📯 <code>:postal_horn:</code></td><td>📪 <code>:mailbox_closed:</code></td><td>📬 <code>:mailbox_with_mail:</code></td></tr><tr><td>📭 <code>:mailbox_with_no_mail:</code></td><td>🚪 <code>:door:</code></td><td>🚬 <code>:smoking:</code></td></tr><tr><td>💣 <code>:bomb:</code></td><td>🔫 <code>:gun:</code></td><td>🔪 <code>:hocho:</code></td></tr><tr><td>💊 <code>:pill:</code></td><td>💉 <code>:syringe:</code></td><td>📄 <code>:page_facing_up:</code></td></tr><tr><td>📃 <code>:page_with_curl:</code></td><td>📑 <code>:bookmark_tabs:</code></td><td>📊 <code>:bar_chart:</code></td></tr><tr><td>📈 <code>:chart_with_upwards_trend:</code></td><td>📉 <code>:chart_with_downwards_trend:</code></td><td>📜 <code>:scroll:</code></td></tr><tr><td>📋 <code>:clipboard:</code></td><td>📆 <code>:calendar:</code></td><td>📅 <code>:date:</code></td></tr><tr><td>📇 <code>:card_index:</code></td><td>📁 <code>:file_folder:</code></td><td>📂 <code>:open_file_folder:</code></td></tr><tr><td>✂️ <code>:scissors:</code></td><td>📌 <code>:pushpin:</code></td><td>📎 <code>:paperclip:</code></td></tr><tr><td>✒️ <code>:black_nib:</code></td><td>✏️ <code>:pencil2:</code></td><td>📏 <code>:straight_ruler:</code></td></tr><tr><td>📐 <code>:triangular_ruler:</code></td><td>📕 <code>:closed_book:</code></td><td>📗 <code>:green_book:</code></td></tr><tr><td>📘 <code>:blue_book:</code></td><td>📙 <code>:orange_book:</code></td><td>📓 <code>:notebook:</code></td></tr><tr><td>📔 <code>:notebook_with_decorative_cover:</code></td><td>📒 <code>:ledger:</code></td><td>📚 <code>:books:</code></td></tr><tr><td>🔖 <code>:bookmark:</code></td><td>📛 <code>:name_badge:</code></td><td>🔬 <code>:microscope:</code></td></tr><tr><td>🔭 <code>:telescope:</code></td><td>📰 <code>:newspaper:</code></td><td>🏈 <code>:football:</code></td></tr><tr><td>🏀 <code>:basketball:</code></td><td>⚽ <code>:soccer:</code></td><td>⚾ <code>:baseball:</code></td></tr><tr><td>🎾 <code>:tennis:</code></td><td>🎱 <code>:8ball:</code></td><td>🏉 <code>:rugby_football:</code></td></tr><tr><td>🎳 <code>:bowling:</code></td><td>⛳ <code>:golf:</code></td><td>🚵 <code>:mountain_bicyclist:</code></td></tr><tr><td>🚴 <code>:bicyclist:</code></td><td>🏇 <code>:horse_racing:</code></td><td>🏂 <code>:snowboarder:</code></td></tr><tr><td>🏊 <code>:swimmer:</code></td><td>🏄 <code>:surfer:</code></td><td>🎿 <code>:ski:</code></td></tr><tr><td>♠️ <code>:spades:</code></td><td>♥️ <code>:hearts:</code></td><td>♣️ <code>:clubs:</code></td></tr><tr><td>♦️ <code>:diamonds:</code></td><td>💎 <code>:gem:</code></td><td>💍 <code>:ring:</code></td></tr><tr><td>🏆 <code>:trophy:</code></td><td>🎼 <code>:musical_score:</code></td><td>🎹 <code>:musical_keyboard:</code></td></tr><tr><td>🎻 <code>:violin:</code></td><td>👾 <code>:space_invader:</code></td><td>🎮 <code>:video_game:</code></td></tr><tr><td>🃏 <code>:black_joker:</code></td><td>🎴 <code>:flower_playing_cards:</code></td><td>🎲 <code>:game_die:</code></td></tr><tr><td>🎯 <code>:dart:</code></td><td>🀄 <code>:mahjong:</code></td><td>🎬 <code>:clapper:</code></td></tr><tr><td>📝 <code>:memo:</code></td><td>📝 <code>:pencil:</code></td><td>📖 <code>:book:</code></td></tr><tr><td>🎨 <code>:art:</code></td><td>🎤 <code>:microphone:</code></td><td>🎧 <code>:headphones:</code></td></tr><tr><td>🎺 <code>:trumpet:</code></td><td>🎷 <code>:saxophone:</code></td><td>🎸 <code>:guitar:</code></td></tr><tr><td>👞 <code>:shoe:</code></td><td>👡 <code>:sandal:</code></td><td>👠 <code>:high_heel:</code></td></tr><tr><td>💄 <code>:lipstick:</code></td><td>👢 <code>:boot:</code></td><td>👕 <code>:shirt:</code></td></tr><tr><td>👕 <code>:tshirt:</code></td><td>👔 <code>:necktie:</code></td><td>👚 <code>:womans_clothes:</code></td></tr><tr><td>👗 <code>:dress:</code></td><td>🎽 <code>:running_shirt_with_sash:</code></td><td>👖 <code>:jeans:</code></td></tr><tr><td>👘 <code>:kimono:</code></td><td>👙 <code>:bikini:</code></td><td>🎀 <code>:ribbon:</code></td></tr><tr><td>🎩 <code>:tophat:</code></td><td>👑 <code>:crown:</code></td><td>👒 <code>:womans_hat:</code></td></tr><tr><td>👞 <code>:mans_shoe:</code></td><td>🌂 <code>:closed_umbrella:</code></td><td>💼 <code>:briefcase:</code></td></tr><tr><td>👜 <code>:handbag:</code></td><td>👝 <code>:pouch:</code></td><td>👛 <code>:purse:</code></td></tr><tr><td>👓 <code>:eyeglasses:</code></td><td>🎣 <code>:fishing_pole_and_fish:</code></td><td>☕ <code>:coffee:</code></td></tr><tr><td>🍵 <code>:tea:</code></td><td>🍶 <code>:sake:</code></td><td>🍼 <code>:baby_bottle:</code></td></tr><tr><td>🍺 <code>:beer:</code></td><td>🍻 <code>:beers:</code></td><td>🍸 <code>:cocktail:</code></td></tr><tr><td>🍹 <code>:tropical_drink:</code></td><td>🍷 <code>:wine_glass:</code></td><td>🍴 <code>:fork_and_knife:</code></td></tr><tr><td>🍕 <code>:pizza:</code></td><td>🍔 <code>:hamburger:</code></td><td>🍟 <code>:fries:</code></td></tr><tr><td>🍗 <code>:poultry_leg:</code></td><td>🍖 <code>:meat_on_bone:</code></td><td>🍝 <code>:spaghetti:</code></td></tr><tr><td>🍛 <code>:curry:</code></td><td>🍤 <code>:fried_shrimp:</code></td><td>🍱 <code>:bento:</code></td></tr><tr><td>🍣 <code>:sushi:</code></td><td>🍥 <code>:fish_cake:</code></td><td>🍙 <code>:rice_ball:</code></td></tr><tr><td>🍘 <code>:rice_cracker:</code></td><td>🍚 <code>:rice:</code></td><td>🍜 <code>:ramen:</code></td></tr><tr><td>🍲 <code>:stew:</code></td><td>🍢 <code>:oden:</code></td><td>🍡 <code>:dango:</code></td></tr><tr><td>🥚 <code>:egg:</code></td><td>🍞 <code>:bread:</code></td><td>🍩 <code>:doughnut:</code></td></tr><tr><td>🍮 <code>:custard:</code></td><td>🍦 <code>:icecream:</code></td><td>🍨 <code>:ice_cream:</code></td></tr><tr><td>🍧 <code>:shaved_ice:</code></td><td>🎂 <code>:birthday:</code></td><td>🍰 <code>:cake:</code></td></tr><tr><td>🍪 <code>:cookie:</code></td><td>🍫 <code>:chocolate_bar:</code></td><td>🍬 <code>:candy:</code></td></tr><tr><td>🍭 <code>:lollipop:</code></td><td>🍯 <code>:honey_pot:</code></td><td>🍎 <code>:apple:</code></td></tr><tr><td>🍏 <code>:green_apple:</code></td><td>🍊 <code>:tangerine:</code></td><td>🍋 <code>:lemon:</code></td></tr><tr><td>🍒 <code>:cherries:</code></td><td>🍇 <code>:grapes:</code></td><td>🍉 <code>:watermelon:</code></td></tr><tr><td>🍓 <code>:strawberry:</code></td><td>🍑 <code>:peach:</code></td><td>🍈 <code>:melon:</code></td></tr><tr><td>🍌 <code>:banana:</code></td><td>🍐 <code>:pear:</code></td><td>🍍 <code>:pineapple:</code></td></tr><tr><td>🍠 <code>:sweet_potato:</code></td><td>🍆 <code>:eggplant:</code></td><td>🍅 <code>:tomato:</code></td></tr><tr><td>🌽 <code>:corn:</code></td><td></td><td></td></tr></tbody></table><p>Places</p><table><thead><tr><th>🏠 <code>:house:</code></th><th>🏡 <code>:house_with_garden:</code></th><th>🏫 <code>:school:</code></th></tr></thead><tbody><tr><td>🏢 <code>:office:</code></td><td>🏣 <code>:post_office:</code></td><td>🏥 <code>:hospital:</code></td></tr><tr><td>🏦 <code>:bank:</code></td><td>🏪 <code>:convenience_store:</code></td><td>🏩 <code>:love_hotel:</code></td></tr><tr><td>🏨 <code>:hotel:</code></td><td>💒 <code>:wedding:</code></td><td>⛪ <code>:church:</code></td></tr><tr><td>🏬 <code>:department_store:</code></td><td>🏤 <code>:european_post_office:</code></td><td>🌇 <code>:city_sunrise:</code></td></tr><tr><td>🌆 <code>:city_sunset:</code></td><td>🏯 <code>:japanese_castle:</code></td><td>🏰 <code>:european_castle:</code></td></tr><tr><td>⛺ <code>:tent:</code></td><td>🏭 <code>:factory:</code></td><td>🗼 <code>:tokyo_tower:</code></td></tr><tr><td>🗾 <code>:japan:</code></td><td>🗻 <code>:mount_fuji:</code></td><td>🌄 <code>:sunrise_over_mountains:</code></td></tr><tr><td>🌅 <code>:sunrise:</code></td><td>🌠 <code>:stars:</code></td><td>🗽 <code>:statue_of_liberty:</code></td></tr><tr><td>🌉 <code>:bridge_at_night:</code></td><td>🎠 <code>:carousel_horse:</code></td><td>🌈 <code>:rainbow:</code></td></tr><tr><td>🎡 <code>:ferris_wheel:</code></td><td>⛲ <code>:fountain:</code></td><td>🎢 <code>:roller_coaster:</code></td></tr><tr><td>🚢 <code>:ship:</code></td><td>🚤 <code>:speedboat:</code></td><td>⛵ <code>:boat:</code></td></tr><tr><td>⛵ <code>:sailboat:</code></td><td>🚣 <code>:rowboat:</code></td><td>⚓ <code>:anchor:</code></td></tr><tr><td>🚀 <code>:rocket:</code></td><td>✈️ <code>:airplane:</code></td><td>🚁 <code>:helicopter:</code></td></tr><tr><td>🚂 <code>:steam_locomotive:</code></td><td>🚊 <code>:tram:</code></td><td>🚞 <code>:mountain_railway:</code></td></tr><tr><td>🚲 <code>:bike:</code></td><td>🚡 <code>:aerial_tramway:</code></td><td>🚟 <code>:suspension_railway:</code></td></tr><tr><td>🚠 <code>:mountain_cableway:</code></td><td>🚜 <code>:tractor:</code></td><td>🚙 <code>:blue_car:</code></td></tr><tr><td>🚘 <code>:oncoming_automobile:</code></td><td>🚗 <code>:car:</code></td><td>🚗 <code>:red_car:</code></td></tr><tr><td>🚕 <code>:taxi:</code></td><td>🚖 <code>:oncoming_taxi:</code></td><td>🚛 <code>:articulated_lorry:</code></td></tr><tr><td>🚌 <code>:bus:</code></td><td>🚍 <code>:oncoming_bus:</code></td><td>🚨 <code>:rotating_light:</code></td></tr><tr><td>🚓 <code>:police_car:</code></td><td>🚔 <code>:oncoming_police_car:</code></td><td>🚒 <code>:fire_engine:</code></td></tr><tr><td>🚑 <code>:ambulance:</code></td><td>🚐 <code>:minibus:</code></td><td>🚚 <code>:truck:</code></td></tr><tr><td>🚋 <code>:train:</code></td><td>🚉 <code>:station:</code></td><td>🚆 <code>:train2:</code></td></tr><tr><td>🚅 <code>:bullettrain_front:</code></td><td>🚄 <code>:bullettrain_side:</code></td><td>🚈 <code>:light_rail:</code></td></tr><tr><td>🚝 <code>:monorail:</code></td><td>🚃 <code>:railway_car:</code></td><td>🚎 <code>:trolleybus:</code></td></tr><tr><td>🎫 <code>:ticket:</code></td><td>⛽ <code>:fuelpump:</code></td><td>🚦 <code>:vertical_traffic_light:</code></td></tr><tr><td>🚥 <code>:traffic_light:</code></td><td>⚠️ <code>:warning:</code></td><td>🚧 <code>:construction:</code></td></tr><tr><td>🔰 <code>:beginner:</code></td><td>🏧 <code>:atm:</code></td><td>🎰 <code>:slot_machine:</code></td></tr><tr><td>🚏 <code>:busstop:</code></td><td>💈 <code>:barber:</code></td><td>♨️ <code>:hotsprings:</code></td></tr><tr><td>🏁 <code>:checkered_flag:</code></td><td>🎌 <code>:crossed_flags:</code></td><td>🏮 <code>:izakaya_lantern:</code></td></tr><tr><td>🗿 <code>:moyai:</code></td><td>🎪 <code>:circus_tent:</code></td><td>🎭 <code>:performing_arts:</code></td></tr><tr><td>📍 <code>:round_pushpin:</code></td><td>🚩 <code>:triangular_flag_on_post:</code></td><td>🇯🇵 <code>:jp:</code></td></tr><tr><td>🇰🇷 <code>:kr:</code></td><td>🇨🇳 <code>:cn:</code></td><td>🇺🇸 <code>:us:</code></td></tr><tr><td>🇫🇷 <code>:fr:</code></td><td>🇪🇸 <code>:es:</code></td><td>🇮🇹 <code>:it:</code></td></tr><tr><td>🇷🇺 <code>:ru:</code></td><td>🇬🇧 <code>:gb:</code></td><td>🇬🇧 <code>:uk:</code></td></tr><tr><td>🇩🇪 <code>:de:</code></td><td></td><td></td></tr></tbody></table><p>Symbols</p><table><thead><tr><th>1️⃣ <code>:one:</code></th><th>2️⃣ <code>:two:</code></th><th>3️⃣ <code>:three:</code></th></tr></thead><tbody><tr><td>4️⃣ <code>:four:</code></td><td>5️⃣ <code>:five:</code></td><td>6️⃣ <code>:six:</code></td></tr><tr><td>7️⃣ <code>:seven:</code></td><td>8️⃣ <code>:eight:</code></td><td>9️⃣ <code>:nine:</code></td></tr><tr><td>🔟 <code>:keycap_ten:</code></td><td>🔢 <code>:1234:</code></td><td>0️⃣ <code>:zero:</code></td></tr><tr><td>#️⃣ <code>:hash:</code></td><td>🔣 <code>:symbols:</code></td><td>◀️ <code>:arrow_backward:</code></td></tr><tr><td>⬇️ <code>:arrow_down:</code></td><td>▶️ <code>:arrow_forward:</code></td><td>⬅️ <code>:arrow_left:</code></td></tr><tr><td>🔠 <code>:capital_abcd:</code></td><td>🔡 <code>:abcd:</code></td><td>🔤 <code>:abc:</code></td></tr><tr><td>↙️ <code>:arrow_lower_left:</code></td><td>↘️ <code>:arrow_lower_right:</code></td><td>➡️ <code>:arrow_right:</code></td></tr><tr><td>⬆️ <code>:arrow_up:</code></td><td>↖️ <code>:arrow_upper_left:</code></td><td>↗️ <code>:arrow_upper_right:</code></td></tr><tr><td>⏬ <code>:arrow_double_down:</code></td><td>⏫ <code>:arrow_double_up:</code></td><td>🔽 <code>:arrow_down_small:</code></td></tr><tr><td>⤵️ <code>:arrow_heading_down:</code></td><td>⤴️ <code>:arrow_heading_up:</code></td><td>↩️ <code>:leftwards_arrow_with_hook:</code></td></tr><tr><td>↪️ <code>:arrow_right_hook:</code></td><td>↔️ <code>:left_right_arrow:</code></td><td>↕️ <code>:arrow_up_down:</code></td></tr><tr><td>🔼 <code>:arrow_up_small:</code></td><td>🔃 <code>:arrows_clockwise:</code></td><td>🔄 <code>:arrows_counterclockwise:</code></td></tr><tr><td>⏪ <code>:rewind:</code></td><td>⏩ <code>:fast_forward:</code></td><td>ℹ️ <code>:information_source:</code></td></tr><tr><td>🆗 <code>:ok:</code></td><td>🔀 <code>:twisted_rightwards_arrows:</code></td><td>🔁 <code>:repeat:</code></td></tr><tr><td>🔂 <code>:repeat_one:</code></td><td>🆕 <code>:new:</code></td><td>🔝 <code>:top:</code></td></tr><tr><td>🆙 <code>:up:</code></td><td>🆒 <code>:cool:</code></td><td>🆓 <code>:free:</code></td></tr><tr><td>🆖 <code>:ng:</code></td><td>🎦 <code>:cinema:</code></td><td>🈁 <code>:koko:</code></td></tr><tr><td>📶 <code>:signal_strength:</code></td><td>:u5272: <code>:u5272:</code></td><td>:u5408: <code>:u5408:</code></td></tr><tr><td>:u55b6: <code>:u55b6:</code></td><td>:u6307: <code>:u6307:</code></td><td>:u6708: <code>:u6708:</code></td></tr><tr><td>:u6709: <code>:u6709:</code></td><td>🈵 <code>:u6e80:</code></td><td>:u7121: <code>:u7121:</code></td></tr><tr><td>:u7533: <code>:u7533:</code></td><td>:u7a7a: <code>:u7a7a:</code></td><td>:u7981: <code>:u7981:</code></td></tr><tr><td>🈂️ <code>:sa:</code></td><td>🚻 <code>:restroom:</code></td><td>🚹 <code>:mens:</code></td></tr><tr><td>🚺 <code>:womens:</code></td><td>🚼 <code>:baby_symbol:</code></td><td>🚭 <code>:no_smoking:</code></td></tr><tr><td>🅿️ <code>:parking:</code></td><td>♿ <code>:wheelchair:</code></td><td>🚇 <code>:metro:</code></td></tr><tr><td>🛄 <code>:baggage_claim:</code></td><td>🉑 <code>:accept:</code></td><td>🚾 <code>:wc:</code></td></tr><tr><td>🚰 <code>:potable_water:</code></td><td>🚮 <code>:put_litter_in_its_place:</code></td><td>㊙️ <code>:secret:</code></td></tr><tr><td>㊗️ <code>:congratulations:</code></td><td>Ⓜ️ <code>:m:</code></td><td>🛂 <code>:passport_control:</code></td></tr><tr><td>🛅 <code>:left_luggage:</code></td><td>🛃 <code>:customs:</code></td><td>🉐 <code>:ideograph_advantage:</code></td></tr><tr><td>🆑 <code>:cl:</code></td><td>🆘 <code>:sos:</code></td><td>🆔 <code>:id:</code></td></tr><tr><td>🚫 <code>:no_entry_sign:</code></td><td>🔞 <code>:underage:</code></td><td>📵 <code>:no_mobile_phones:</code></td></tr><tr><td>🚯 <code>:do_not_litter:</code></td><td>🚱 <code>:non-potable_water:</code></td><td>🚳 <code>:no_bicycles:</code></td></tr><tr><td>🚷 <code>:no_pedestrians:</code></td><td>🚸 <code>:children_crossing:</code></td><td>⛔ <code>:no_entry:</code></td></tr><tr><td>✳️ <code>:eight_spoked_asterisk:</code></td><td>✴️ <code>:eight_pointed_black_star:</code></td><td>💟 <code>:heart_decoration:</code></td></tr><tr><td>🆚 <code>:vs:</code></td><td>📳 <code>:vibration_mode:</code></td><td>📴 <code>:mobile_phone_off:</code></td></tr><tr><td>💹 <code>:chart:</code></td><td>💱 <code>:currency_exchange:</code></td><td>♈ <code>:aries:</code></td></tr><tr><td>♉ <code>:taurus:</code></td><td>♊ <code>:gemini:</code></td><td>♋ <code>:cancer:</code></td></tr><tr><td>♌ <code>:leo:</code></td><td>♍ <code>:virgo:</code></td><td>♎ <code>:libra:</code></td></tr><tr><td>♏ <code>:scorpius:</code></td><td>♐ <code>:sagittarius:</code></td><td>♑ <code>:capricorn:</code></td></tr><tr><td>♒ <code>:aquarius:</code></td><td>♓ <code>:pisces:</code></td><td>⛎ <code>:ophiuchus:</code></td></tr><tr><td>🔯 <code>:six_pointed_star:</code></td><td>❎ <code>:negative_squared_cross_mark:</code></td><td>🅰️ <code>:a:</code></td></tr><tr><td>🅱️ <code>:b:</code></td><td>🆎 <code>:ab:</code></td><td>🅾️ <code>:o2:</code></td></tr><tr><td>💠 <code>:diamond_shape_with_a_dot_inside:</code></td><td>♻️ <code>:recycle:</code></td><td>🔚 <code>:end:</code></td></tr><tr><td>🔛 <code>:on:</code></td><td>🔜 <code>:soon:</code></td><td>🕐 <code>:clock1:</code></td></tr><tr><td>🕜 <code>:clock130:</code></td><td>🕙 <code>:clock10:</code></td><td>🕥 <code>:clock1030:</code></td></tr><tr><td>🕚 <code>:clock11:</code></td><td>🕦 <code>:clock1130:</code></td><td>🕛 <code>:clock12:</code></td></tr><tr><td>🕧 <code>:clock1230:</code></td><td>🕑 <code>:clock2:</code></td><td>🕝 <code>:clock230:</code></td></tr><tr><td>🕒 <code>:clock3:</code></td><td>🕞 <code>:clock330:</code></td><td>🕓 <code>:clock4:</code></td></tr><tr><td>🕟 <code>:clock430:</code></td><td>🕔 <code>:clock5:</code></td><td>🕠 <code>:clock530:</code></td></tr><tr><td>🕕 <code>:clock6:</code></td><td>🕡 <code>:clock630:</code></td><td>🕖 <code>:clock7:</code></td></tr><tr><td>🕢 <code>:clock730:</code></td><td>🕗 <code>:clock8:</code></td><td>🕣 <code>:clock830:</code></td></tr><tr><td>🕘 <code>:clock9:</code></td><td>🕤 <code>:clock930:</code></td><td>💲 <code>:heavy_dollar_sign:</code></td></tr><tr><td>©️ <code>:copyright:</code></td><td>®️ <code>:registered:</code></td><td>™️ <code>:tm:</code></td></tr><tr><td>❌ <code>:x:</code></td><td>❗ <code>:heavy_exclamation_mark:</code></td><td>‼️ <code>:bangbang:</code></td></tr><tr><td>⁉️ <code>:interrobang:</code></td><td>⭕ <code>:o:</code></td><td>✖️ <code>:heavy_multiplication_x:</code></td></tr><tr><td>➕ <code>:heavy_plus_sign:</code></td><td>➖ <code>:heavy_minus_sign:</code></td><td>➗ <code>:heavy_division_sign:</code></td></tr><tr><td>💮 <code>:white_flower:</code></td><td>💯 <code>:100:</code></td><td>✔️ <code>:heavy_check_mark:</code></td></tr><tr><td>☑️ <code>:ballot_box_with_check:</code></td><td>🔘 <code>:radio_button:</code></td><td>🔗 <code>:link:</code></td></tr><tr><td>➰ <code>:curly_loop:</code></td><td>〰️ <code>:wavy_dash:</code></td><td>〽️ <code>:part_alternation_mark:</code></td></tr><tr><td>🔱 <code>:trident:</code></td><td>:black_square: <code>:black_square:</code></td><td>:white_square: <code>:white_square:</code></td></tr><tr><td>✅ <code>:white_check_mark:</code></td><td>🔲 <code>:black_square_button:</code></td><td>🔳 <code>:white_square_button:</code></td></tr><tr><td>⚫ <code>:black_circle:</code></td><td>⚪ <code>:white_circle:</code></td><td>🔴 <code>:red_circle:</code></td></tr><tr><td>🔵 <code>:large_blue_circle:</code></td><td>🔷 <code>:large_blue_diamond:</code></td><td>🔶 <code>:large_orange_diamond:</code></td></tr><tr><td>🔹 <code>:small_blue_diamond:</code></td><td>🔸 <code>:small_orange_diamond:</code></td><td>🔺 <code>:small_red_triangle:</code></td></tr><tr><td>🔻 <code>:small_red_triangle_down:</code></td><td>:shipit: <code>:shipit:</code></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>资源</category>
      
    </categories>
    
    
    <tags>
      
      <tag>emoji</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM-02-类加载子系统</title>
    <link href="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/"/>
    <url>/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/</url>
    
    <content type="html"><![CDATA[<h2 id="1、类加载子系统">1、类加载子系统</h2><h3 id="1、内存结构概述">1、内存结构概述</h3><h4 id="1、简图">1、简图</h4><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024163558872.png" alt></p><h4 id="2、详细图">2、详细图</h4><p>英文版</p><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024164417433.png" alt></p><p>中文版</p><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024164544639.png" alt></p><h3 id="2、类加载器子系统">2、类加载器子系统</h3><h4 id="1、类加载器子系统的作用">1、类加载器子系统的作用</h4><ol><li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</li><li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine（执行引擎）决定。<br>（比如：别人给你介绍对象，能不能成另说。其中ClassLoader只负责别人介绍对象，能不能成全看你）</li><li><strong>加载的类信息存放于一块称为方法区的内存空间</strong>。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li></ol><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024164911148.png" alt></p><h4 id="2、类加载器ClassLoader角色">2、类加载器ClassLoader角色</h4><ol><li>class file（在下图中就是Car.class文件）存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li><li>class file加载到JVM中，被称为DNA元数据模板（在下图中就是内存中的Car Class），放在方法区。</li><li>在.class文件–&gt;JVM–&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li></ol><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024165223695.png" alt></p><h3 id="3、类加载过程">3、类加载过程</h3><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024165836131.png" alt="类加载过程"></p><h4 id="1、Demo">1、Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloLoader</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;谢谢ClassLoader加载我....&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;你的大恩大德，我下辈子再报！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>加载过程如下：</p><ol><li>执行 main() 方法（静态方法）就需要先加载main方法所在类 HelloLoader</li><li>加载成功，则进行链接、初始化等操作。完成后调用 HelloLoader 类中的静态方法 main</li><li>加载失败则抛出异常</li></ol><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024170014984.png" alt="类加载过程示意图"></p><h4 id="2、加载（Loading）">2、加载（Loading）</h4><p>加载：</p><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li><code>在内存中生成一个代表这个类的java.lang.Class对象</code>，作为方法区这个类的各种数据的访问入口</li></ol><p><code>生成大的class实例是在加载阶段实现的</code></p><p>加载 .class 文件的方式：</p><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用</li><li>从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul><h4 id="3、链接（Linking）">3、链接（Linking）</h4><p>链接又包括三个过程：验证 -&gt; 准备 -&gt; 解析</p><h5 id="1、验证-Verify">1、验证(Verify)</h5><ol><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ol><p>使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE （java），如果出现不合法的字节码文件，那么将会验证不通过。</p><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024171040995.png" alt=".class文件"></p><h5 id="2、准备-Prepare">2、准备(Prepare)</h5><ol><li>为类变量（static变量）分配内存并且设置该类变量的默认初始值，即零值</li><li><code>这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化</code></li><li>注意：<code>这里不会为实例变量分配初始化</code>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</li></ol><blockquote><p>举例</p></blockquote><p>代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloApp</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//prepare：a = 0 ---&gt; initial : a = 1</span><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、解析-Resolve">3、解析(Resolve)</h5><ol><li>将常量池内的<code>符号引用</code>转换为直接引用的过程</li><li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</li></ol><blockquote><p>符号引用：反编译 class 文件后可以查看符号引用，下面带# 的就是符号引用</p></blockquote><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024182616267.png" alt="查看符号引用"></p><h4 id="4、初始化（Initialization）">4、初始化（Initialization）</h4><p>类的初始化时机：</p><ol><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（比如：Class.forName(“com.atguigu.Test”)）</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ol><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即<code>不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）</code></p><h4 id="5、clinit">5、clinit()</h4><ol><li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</li><li>此方法不需定义，是javac编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和静态代码块中的语句合并而来。也就是说，<code>当我们代码中包含static变量的时候，就会有clinit方法</code></li><li><code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</li><li><code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）</li><li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li><li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</li></ol><blockquote><p>IDEA 中安装 JClassLib Bytecode viewer 插件，可以很方便的看字节码。<a href="https://blog.csdn.net/qq_42326620/article/details/122768642">IDEA安装JClass插件</a></p></blockquote><h5 id="1、有static变量">1、有static变量</h5><p>查看下面这个代码的字节码，可以发现有一个<code>&lt;clinit&gt;()</code>方法。</p><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024185101090.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassInitTest</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>   <span class="hljs-keyword">static</span>&#123;<br>       num = <span class="hljs-number">2</span>;<br>       number = <span class="hljs-number">20</span>;<br>       System.out.println(num);<br>       <span class="hljs-comment">//System.out.println(number);//报错：非法的前向引用。</span><br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 1、linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span><br><span class="hljs-comment">    * 2、这里因为静态代码块出现在声明变量语句前面，所以之前被准备阶段为0的number变量会</span><br><span class="hljs-comment">    * 首先被初始化为20，再接着被初始化成10（这也是面试时常考的问题哦）</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(ClassInitTest.num);<span class="hljs-comment">//2</span><br>        System.out.println(ClassInitTest.number);<span class="hljs-comment">//10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&lt;clint字节码&gt;：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> iconst_1<br> <span class="hljs-number">1</span> putstatic #<span class="hljs-number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;<br> <span class="hljs-number">4</span> iconst_2<br> <span class="hljs-number">5</span> putstatic #<span class="hljs-number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;<br> <span class="hljs-number">8</span> bipush <span class="hljs-number">20</span> <span class="hljs-comment">//先赋20</span><br><span class="hljs-number">10</span> putstatic #<span class="hljs-number">5</span> &lt;com/atguigu/java/ClassInitTest.number&gt;<br><span class="hljs-number">13</span> getstatic #<span class="hljs-number">2</span> &lt;java/lang/System.out&gt;<br><span class="hljs-number">16</span> getstatic #<span class="hljs-number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;<br><span class="hljs-number">19</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<br><span class="hljs-number">22</span> bipush <span class="hljs-number">10</span><span class="hljs-comment">//再赋10</span><br><span class="hljs-number">24</span> putstatic #<span class="hljs-number">5</span> &lt;com/atguigu/java/ClassInitTest.number&gt;<br><span class="hljs-number">27</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><blockquote><p>当我们代码中包含static变量的时候，就会有clinit方法</p></blockquote><h5 id="2、无-static-变量">2、无 static 变量</h5><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024185305810.png" alt></p><p>没有clinit是因为没有static变量</p><h5 id="3、构造器">3、构造器</h5><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024185513790.png" alt></p><p>构造器对应的是右边的init()</p><p>在构造器中：</p><ul><li>先将类变量 a 赋值为 10</li><li>再将局部变量赋值为 20</li></ul><h5 id="4、拥有父类的类">4、拥有父类的类</h5><p>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</p><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024185655011.png" alt></p><p>如上代码，加载流程如下：</p><ul><li>首先，执行 main() 方法需要加载 ClinitTest1 类</li><li>获取 Son.B 静态变量，需要加载 Son 类</li><li>Son 类的父类是 Father 类，所以需要先执行 Father 类的加载，再执行 Son 类的加载</li></ul><h5 id="5、同步加锁问题">5、同步加锁问题</h5><p>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadThreadTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;开始&quot;</span>);<br>            <span class="hljs-type">DeadThread</span> <span class="hljs-variable">dead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadThread</span>();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r,<span class="hljs-string">&quot;线程1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r,<span class="hljs-string">&quot;线程2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadThread</span>&#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;初始化当前类&quot;</span>);<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">线程<span class="hljs-number">2</span>开始<br>线程<span class="hljs-number">1</span>开始<br>线程<span class="hljs-number">2</span>初始化当前类<br><br><span class="hljs-regexp">//</span>然后程序卡死了<br></code></pre></td></tr></table></figure><p>程序卡死，分析原因：</p><ul><li>两个线程同时去加载 DeadThread 类，而 DeadThread 类中静态代码块中有一处死循环</li><li>先加载 DeadThread 类的线程抢到了同步锁，然后在类的静态代码块中执行死循环，而另一个线程在等待同步锁的释放</li><li>所以无论哪个线程先执行 DeadThread 类的加载，另外一个类也不会继续执行。（一个类只会被加载一次）</li></ul><h3 id="4、类加载器分类">4、类加载器分类</h3><h4 id="1、概述">1、概述</h4><ol><li>JVM严格来讲支持两种类型的类加载器 。分别为<code>引导类加载器（Bootstrap ClassLoader）</code>和<code>自定义类加载器（User-Defined ClassLoader）</code></li><li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></li><li>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示</li></ol><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024191612814.png" alt></p><p>Optional四者之间的关系是包含关系。不是上层下层，也不是子父类的 继承关系。</p><p><strong>ExtClassLoader</strong></p><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024191738052.png" alt></p><p><strong>AppClassLoader</strong></p><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024191755771.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//获取系统类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">systemClassLoader</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();<br>        System.out.println(systemClassLoader); <span class="hljs-comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><br>        <span class="hljs-comment">//获取其上层：扩展类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">extClassLoader</span> <span class="hljs-operator">=</span> systemClassLoader.getParent();<br>        System.out.println(extClassLoader);<span class="hljs-comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span><br><br>        <span class="hljs-comment">//获取其上层：获取不到引导类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">bootstrapClassLoader</span> <span class="hljs-operator">=</span> extClassLoader.getParent();<br>        System.out.println(bootstrapClassLoader);<span class="hljs-comment">//null</span><br><br>        <span class="hljs-comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ClassLoaderTest.class.getClassLoader();<br>        System.out.println(classLoader);<span class="hljs-comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><br>        <span class="hljs-comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> String.class.getClassLoader();<br>        System.out.println(classLoader1);<span class="hljs-comment">//null</span><br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>我们尝试获取引导类加载器，获取到的值为 null ，这并不代表引导类加载器不存在，<strong>因为引导类加载器右 C/C++ 语言，我们获取不到</strong></li><li>两次获取系统类加载器的值都相同：sun.misc.Launcher$AppClassLoader@18b4aac2 ，这说明<strong>系统类加载器是全局唯一的</strong></li></ul><h4 id="2、虚拟机自带的加载器">2、虚拟机自带的加载器</h4><h5 id="1、启动类加载器">1、启动类加载器</h5><p>启动类加载器（引导类加载器，Bootstrap ClassLoader）</p><ol><li>这个类加载使用<code>C/C++</code>语言实现的，嵌套在JVM内部</li><li>它用来加载Java的核心库<code>（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容）</code>，用于提供JVM自身需要的类</li><li>并不继承自java.lang.ClassLoader，没有父加载器</li><li>加载扩展类和应用程序类加载器，并作为他们的父类加载器</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为<code>java、javax、sun</code>等开头的类</li></ol><h5 id="2、扩展类加载器">2、扩展类加载器</h5><p>扩展类加载器（Extension ClassLoader）</p><ol><li><code>Java语言编写</code>，由sun.misc.Launcher$ExtClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为<code>启动类加载器</code></li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li></ol><h5 id="3、系统类加载器">3、系统类加载器</h5><p>应用程序类加载器（也称为系统类加载器，AppClassLoader）</p><ol><li>Java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为<code>扩展类加载器</code></li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader.getSystemclassLoader()方法可以获取到该类加载器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;**********启动类加载器**************&quot;</span>);<br>        <span class="hljs-comment">//获取BootstrapClassLoader能够加载的api的路径</span><br>        URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();<br>        <span class="hljs-keyword">for</span> (URL element : urLs) &#123;<br>            System.out.println(element.toExternalForm());<br>        &#125;<br>        <span class="hljs-comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Provider.class.getClassLoader();<br>        System.out.println(classLoader);<br><br>        System.out.println(<span class="hljs-string">&quot;***********扩展类加载器*************&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">extDirs</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;java.ext.dirs&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String path : extDirs.split(<span class="hljs-string">&quot;;&quot;</span>)) &#123;<br>            System.out.println(path);<br>        &#125;<br><br>        <span class="hljs-comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> CurveDB.class.getClassLoader();<br>        System.out.println(classLoader1);<span class="hljs-comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">**********启动类加载器**************<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/resources.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/rt.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/sunrsasign.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/jsse.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/jce.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/charsets.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/jfr.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/classes<br><span class="hljs-literal">null</span><br>***********扩展类加载器*************<br>C:\Program Files\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>\jre\lib\ext<br>C:\Windows\Sun\Java\lib\ext<br>sun.misc.Launcher$ExtClassLoader@29453f44<br></code></pre></td></tr></table></figure><h4 id="3、用户自定义类加载器">3、用户自定义类加载器</h4><h5 id="1、何时需要自定义类加载器？">1、何时需要自定义类加载器？</h5><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那为什么还需要自定义类加载器？</p><ul><li>隔离加载类（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间价之间是隔离的）</li><li>修改类加载的方式</li><li>扩展加载源（还可以考虑从数据库中加载类，路由器等等不同的地方）</li><li>防止源码泄漏（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密）</li></ul><h5 id="2、如何自定义类加载器？">2、如何自定义类加载器？</h5><ol><li>开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findclass()方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以<code>直接继承URIClassLoader类</code>，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">byte</span>[] result = getClassFromCustomPath(name);<br>            <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNotFoundException</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//defineClass和findClass搭配使用</span><br>                <span class="hljs-keyword">return</span> defineClass(name, result, <span class="hljs-number">0</span>, result.length);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>(name);<br>    &#125;<br><span class="hljs-comment">//自定义流的获取方式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] getClassFromCustomPath(String name) &#123;<br>        <span class="hljs-comment">//从自定义路径中加载指定类:细节略</span><br>        <span class="hljs-comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CustomClassLoader</span> <span class="hljs-variable">customClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomClassLoader</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-literal">true</span>, customClassLoader);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>            System.out.println(obj.getClass().getClassLoader());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、ClassLoader">4、ClassLoader</h4><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221025162137614.png" alt></p><p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221025162203691.png" alt></p><blockquote><p>获取ClassLoader途径</p></blockquote><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221025162252275.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.</span><br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>).getClassLoader();<br>            System.out.println(classLoader);<br>            <span class="hljs-comment">//2.</span><br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();<br>            System.out.println(classLoader1);<br><br>            <span class="hljs-comment">//3.</span><br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader2</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader().getParent();<br>            System.out.println(classLoader2);<br><br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">null<br>sun.misc.Launcher<span class="hljs-variable">$AppClassLoader</span>@<span class="hljs-number">18</span>b4aac2<br>sun.misc.Launcher<span class="hljs-variable">$ExtClassLoader</span>@<span class="hljs-number">1540</span>e19d<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="5、🔺双亲委派机制">5、🔺双亲委派机制</h3><h4 id="1、双亲委派机制原理">1、双亲委派机制原理</h4><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式</p><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li><li>父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</li></ol><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221025163844593.png" alt></p><blockquote><p>举个通俗的例子：小孩有一个苹果，问妈妈说吃不吃，妈妈一看奶奶还在，就问奶奶吃不吃苹果；奶奶一看苹果有点硬，咬不动于是说不吃，给了妈妈，妈妈一看说苹果有点酸，又给了小孩，小孩说我正好喜欢吃又酸又硬的，于是小孩吃了。</p></blockquote><p>有点像 职责链模式</p><h4 id="2、双亲委派机制代码演示">2、双亲委派机制代码演示</h4><h5 id="1、Demo1">1、Demo1</h5><p>1、自己建立一个 java.lang.String 类，写上 static 代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是自定义的String类的静态代码块&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在另外的程序中加载 String 类，看看加载的 String 类是 JDK 自带的 String 类，还是我们自己编写的 String 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        java.lang.<span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.String();<br>        System.out.println(<span class="hljs-string">&quot;hello,atguigu.com&quot;</span>);<br><br>        <span class="hljs-type">StringTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringTest</span>();<br>        System.out.println(test.getClass().getClassLoader());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hello,atguigu<span class="hljs-selector-class">.com</span><br>sun<span class="hljs-selector-class">.misc</span>.Launcher<span class="hljs-variable">$AppClassLoader</span>@<span class="hljs-number">18</span>b4aac2<br></code></pre></td></tr></table></figure><p>程序并没有输出我们静态代码块中的内容，说明仍然加载的是 JDK 自带的 String 类。</p><p>把刚刚的类改一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是自定义的String类的静态代码块&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//错误: 在类 java.lang.String 中找不到 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello,String&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221025164730203.png" alt></p><p>由于双亲委派机制一直找父类，所以最后找到了Bootstrap ClassLoader，Bootstrap ClassLoader找到的是 JDK 自带的 String 类，在那个String类中并没有 main() 方法，所以就报了上面的错误。</p><h5 id="2、Demo2">2、Demo2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShkStart</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.SecurityException: Prohibited <span class="hljs-keyword">package</span> name: java.lang<br>at java.lang.ClassLoader.preDefineClass(ClassLoader.java:<span class="hljs-number">662</span>)<br>at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="hljs-number">761</span>)<br>at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:<span class="hljs-number">142</span>)<br>at java.net.URLClassLoader.defineClass(URLClassLoader.java:<span class="hljs-number">467</span>)<br>at java.net.URLClassLoader.access$<span class="hljs-number">100</span>(URLClassLoader.java:<span class="hljs-number">73</span>)<br>at java.net.URLClassLoader$<span class="hljs-number">1.</span>run(URLClassLoader.java:<span class="hljs-number">368</span>)<br>at java.net.URLClassLoader$<span class="hljs-number">1.</span>run(URLClassLoader.java:<span class="hljs-number">362</span>)<br>at java.security.AccessController.doPrivileged(Native Method)<br>at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="hljs-number">361</span>)<br>at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="hljs-number">424</span>)<br>at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="hljs-number">335</span>)<br>at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="hljs-number">357</span>)<br>at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:<span class="hljs-number">495</span>)<br>Error: A JNI error has occurred, please check your installation and <span class="hljs-keyword">try</span> again<br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> <br>Process finished with exit code <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>即使类名没有重复，也禁止使用java.lang这种包名。这是一种保护机制</p><h5 id="3、Demo3">3、Demo3</h5><p>当我们加载jdbc.jar 用于实现数据库连接的时候</p><ol><li>我们现在程序中需要用到SPI接口，而SPI接口属于rt.jar包中Java核心api</li><li>然后使用双清委派机制，引导类加载器把rt.jar包加载进来，而rt.jar包中的SPI存在一些接口，接口我们就需要具体的实现类了</li><li>具体的实现类就涉及到了某些第三方的jar包了，比如我们加载SPI的实现类jdbc.jar包【首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的】</li><li>第三方的jar包中的类属于系统类加载器来加载</li><li>从这里面就可以看到SPI核心接口由引导类加载器来加载，SPI具体实现类由系统类加载器来加载</li></ol><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221025164859134.png" alt></p><h4 id="3、双亲委派机制的优势">3、双亲委派机制的优势</h4><ol><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改<ul><li>自定义类：自定义java.lang.String 没有被加载。</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ol><h3 id="6、沙箱安全机制">6、沙箱安全机制</h3><p>自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p><p>简单来说，就是保证引导类加载器负责加载的核心包不会被恶意篡改</p><h3 id="7、如何判断两个class对象是否相同？">7、如何判断两个class对象是否相同？</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ol><li>类的完整类名必须一致，包括包名</li><li><strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong></li></ol><p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要<code>加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</code></p><h3 id="8、对类加载器的引用">8、对类加载器的引用</h3><ol><li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li><li><code>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</code></li><li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的</li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM-01-JVM与Java体系结构</title>
    <link href="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/"/>
    <url>/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/</url>
    
    <content type="html"><![CDATA[<blockquote><p>JVM系列参考了<a href="https://www.bilibili.com/video/BV1PJ411n7xZ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4397d58737f806d687218418438c3de3">尚硅谷的JVM视频教程</a>，以及<a href="https://imlql.cn/categories/JVM/">风祁的时光录的个人博客</a></p></blockquote><p>是否遇到过这些问题？</p><ol><li>运行着的线上系统突然卡死，系统无法访问，甚至直接OOM！</li><li>想解决线上JVM GC问题，但却无从下手。</li><li>新项目上线，对各种JVM参数设置一脸茫然，直接默认吧然后就JJ了。</li><li>每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼。</li></ol><h2 id="1、Java及JVM简介">1、Java及JVM简介</h2><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021162119621.png" alt></p><p>如果我们把核心类库的API比做数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。</p><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021162207599.png" alt></p><p>计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言。</p><p>So，架构师每天都在思考什么？</p><ol><li>应该如何让我的系统更快？</li><li>如何避免系统出现瓶颈？</li></ol><h3 id="1、推荐书目">1、推荐书目</h3><p><strong>官方文档</strong></p><p><strong>英文文档规范</strong>：<a href="https://docs.oracle.com/javase/specs/index.html">https://docs.oracle.com/javase/specs/index.html</a></p><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021162737446.png" alt></p><p><strong>中文书籍：</strong></p><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021162826232.png" alt></p><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021162848622.png" alt></p><h3 id="2、Java-VS-C">2、Java VS C++</h3><ol><li>垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。</li><li>C++语言需要程序员自己来分配内存和回收内存，对于高手来说可能更加舒服，但是对于普通开发者，如果技术实力不够，很容易造成内存泄漏。而Java全部交给JVM进行内存分配和回收，这也是一种趋势，减少程序员的工作量。</li></ol><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021162556628.png" alt></p><h3 id="3、Java生态圈">3、Java生态圈</h3><p>Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p><ol><li>作为一个平台，Java虚拟机扮演着举足轻重的作用<ul><li>Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分</li></ul></li><li>作为一种文化，Java几乎成为了“开源”的代名词。<ul><li>第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。</li><li>就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。</li></ul></li><li>作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。</li></ol><blockquote><p>Java-跨平台的语言</p></blockquote><p>下面这张图就很形象</p><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021163236035.png" alt></p><blockquote><p>JVM-跨语言的平台</p></blockquote><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021163440775.png" alt></p><ul><li>随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现<code>在Java虚拟机平台上运行非Java语言编写的程序</code>。</li><li>Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它<code>只关心“字节码”文件</code>。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</li><li>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：<code>jvm字节码</code>。</li><li>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</li><li>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——<code>Class文件</code>格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</li></ul><blockquote><p>多语言混合编程</p></blockquote><ol><li>Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</li><li>试想一下，在一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。</li><li>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如DaVinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。</li></ol><blockquote><h4 id="Open-JDK和Oracle-JDK">Open JDK和Oracle JDK</h4></blockquote><p>在JDK11之前，Oracle JDK中还会存在一些Open JDK中没有的，闭源的功能。但在JDK11中，我们可以认为Open JDK和Oracle JDK代码实质上已经达到完全一致的程度了。</p><blockquote><p>Java代码执行流程</p></blockquote><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021165300594.png" alt></p><h3 id="4、虚拟机">4、虚拟机</h3><h4 id="1、虚拟机概念">1、虚拟机概念</h4><ul><li><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款<code>软件</code>，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p><ul><li><p>大名鼎鼎的Virtual Box，VMware就属于系统虚拟机，它们完全是对物理计算机硬件的仿真(模拟)，提供了一个可运行完整操作系统的软件平台。</p></li><li><p>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</p></li></ul></li><li><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p></li></ul><h4 id="2、Java虚拟机">2、Java虚拟机</h4><ol><li>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</li><li>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</li><li><strong>Java技术的核心就是Java虚拟机</strong>（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</li></ol><p><strong>作用：</strong></p><p>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p><p><strong>特点：</strong></p><ol><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收功能</li></ol><h3 id="5、JVM位置及整体架构">5、JVM位置及整体架构</h3><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021164330033.png" alt></p><p>JVM是运行在操作系统之上的，它与硬件没有直接的交互</p><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021164401275.png" alt></p><ol><li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</li><li>它采用解释器与即时编译器并存的架构。</li><li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。</li></ol><blockquote><p>下面这张图要会画</p></blockquote><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021164535409.png" alt></p><h3 id="6、JVM的架构模型">6、JVM的架构模型</h3><p>Java编译器输入的指令流基本上是一种<strong>基于栈的指令集架构</strong>，另外一种指令集架构则是<strong>基于寄存器的指令集架构</strong>。</p><blockquote><p>HotSpot是基于栈的指令集架构</p></blockquote><p>具体来说：这两种架构之间的区别：</p><h4 id="1、基于栈的指令集架构">1、基于栈的指令集架构</h4><p>基于栈式架构的特点：</p><ol><li>设计和实现更简单，适用于资源受限的系统；</li><li>避开了寄存器的分配难题：使用零地址指令方式分配</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</li><li>不需要硬件支持，可移植性更好，更好实现跨平台</li></ol><h4 id="2、基于寄存器的指令级架构">2、基于寄存器的指令级架构</h4><p>基于寄存器架构的特点：</p><ol><li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li><li>指令集架构则完全依赖硬件，与硬件的耦合度高，可移植性差</li><li><code>性能优秀和执行更高效</code></li><li><code>花费更少的指令去完成一项操作</code></li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</li></ol><h4 id="3、举例">3、举例</h4><p>执行2+3这种逻辑操作</p><ul><li><p>基于栈的计算流程（以Java虚拟机为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">iconst_2 <span class="hljs-comment">//常量2入栈</span><br>istore_1<br>iconst_3 <span class="hljs-comment">// 常量3入栈</span><br>istore_2<br>iload_1<br>iload_2<br>iadd <span class="hljs-comment">//常量2/3出栈，执行相加</span><br>istore_0 <span class="hljs-comment">// 结果5入栈</span><br></code></pre></td></tr></table></figure></li><li><p>而基于寄存器的计算流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">mov eax,<span class="hljs-number">2</span> <span class="hljs-comment">//将eax寄存器的值设为1</span><br>add eax,<span class="hljs-number">3</span> <span class="hljs-comment">//使eax寄存器的值加3</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="4、JVM架构总结">4、JVM架构总结</h4><ol><li><strong>由于跨平台性的设计，Java的指令都是根据栈来设计的</strong>。不同平台CPU架构不同，所以不能设计为基于寄存器的。<code>栈的优点</code>：跨平台，指令集小，编译器容易实现，<code>缺点</code>是性能比寄存器差一些。</li><li>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpot VM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</li></ol><p>因为基于栈的架构跨平台性好、指令集小，虽然相对于基于寄存器的架构来说，基于栈的架构编译得到的指令更多，执行性能也不如基于寄存器的架构好，但考虑到其跨平台性与移植性，我们还是选用栈的架构</p><h3 id="7、JVM的生命周期">7、JVM的生命周期</h3><h4 id="1、虚拟机的启动">1、虚拟机的启动</h4><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><h4 id="2、虚拟机的执行">2、虚拟机的执行</h4><ol><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序</li><li>程序开始执行时他才运行，程序结束时他就停止</li><li><code>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</code></li></ol><h4 id="3、虚拟机的退出">3、虚拟机的退出</h4><p><code>有如下的几种情况：</code></p><ol><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统用现错误而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或System类的exit()方法，或Runtime类的halt()方法，并且Java安全管理器也允许这次exit()或halt()操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</li></ol><h3 id="8、常见JVM类型">8、常见JVM类型</h3><h4 id="1、Sun-Classic-VM">1、Sun Classic VM</h4><ol><li>早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是<code>世界上第一款商用Java虚拟机</code>，JDK1.4时完全被淘汰。</li><li>这款虚拟机内部只提供解释器，没有即时编译器，因此效率比较低。【即时编译器会把热点代码的本地机器指令缓存起来，那么以后使用热点代码的时候，效率就比较高】</li><li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作，解释器和编译器不能配合工作。<ul><li>我们将字节码指令翻译成机器指令也是需要花时间的，如果只使用JIT，就需要把所有字节码指令都翻译成机器指令，就会导致翻译时间过长，也就是说在程序刚启动的时候，等待时间会很长。</li><li>而解释器就是走到哪，解释到哪。</li></ul></li><li>现在Hotspot内置了此虚拟机。</li></ol><h4 id="2、HotSpot-VM（重点）">2、HotSpot VM（重点）</h4><ol><li><p>HotSpot历史</p><ul><li>最初由一家名为“Longview Technologies”的小公司设计</li><li>1997年，此公司被Sun收购；2009年，Sun公司被甲骨文收购。</li><li>JDK1.3时，HotSpot VM成为默认虚拟机</li></ul></li><li><p>目前</p><p><code>Hotspot占有绝对的市场地位，称霸武林</code></p><ul><li>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</li><li>Sun/oracle JDK和openJDK的默认虚拟机</li></ul></li><li><p>从服务器、桌面到移动端、嵌入式都有应用。</p></li><li><p>名称中的HotSpot指的就是它的<code>热点代码探测技术</code>。</p><ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li><li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li></ul></li></ol><h4 id="3、JRockit（商用三大虚拟机之一）">3、JRockit（商用三大虚拟机之一）</h4><ol><li>专注于服务器端应用：它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</li><li>大量的行业基准测试显示，<code>JRockit JVM是世界上最快的JVM</code>：使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</li><li>优势：全面的Java运行时解决方案组合<ul><li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</li><li>Mission Control服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li></ul></li><li>2008年，JRockit被Oracle收购。</li><li>Oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</li><li>高斯林：目前就职于谷歌，研究人工智能和水下机器人</li></ol><h4 id="4、IBM的J9（商用三大虚拟机之一）">4、IBM的J9（商用三大虚拟机之一）</h4><ol><li>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</li><li>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。</li><li>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。</li><li>2017年左右，IBM发布了开源J9VM，命名为openJ9，交给Eclipse基金会管理，也称为Eclipse OpenJ9</li><li>OpenJDK -&gt; 是JDK开源了，包括了虚拟机</li></ol><h4 id="5、Graal-VM（未来虚拟机）">5、Graal VM（未来虚拟机）</h4><ol><li>2018年4月，Oracle Labs公开了GraalvM，号称 “<strong>Run Programs Faster Anywhere</strong>”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。</li><li>GraalVM在HotSpot VM基础上增强而成的**跨语言全栈虚拟机，可以作为“任何语言”**的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</li><li>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</li><li>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</li><li><code>如果说HotSpot有一天真的被取代，Graalvm希望最大</code>。但是Java的软件生态没有丝毫变化。</li></ol><h4 id="6、其他虚拟机">6、其他虚拟机</h4><ol><li><p>Exact VM</p></li><li><p>KVM和CDC/CLDC Hotspot</p></li><li><p>Azul VM</p></li><li><p>Liquid VM</p></li><li><p>Apache Marmony</p></li><li><p>Micorsoft JVM</p></li><li><p>Taobao JVM</p><ol><li><code>基于OpenJDK开发了自己的定制版本AlibabaJDK</code>，简称AJDK。是整个阿里Java体系的基石。</li><li>基于OpenJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。<ul><li>创新的GCIH（GCinvisible heap）技术实现了off-heap，即<code>将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的</code>。</li><li>GCIH中的<code>对象还能够在多个Java虚拟机进程中实现共享</code></li><li>使用crc32指令实现JvM intrinsic降低JNI的调用开销</li><li>PMU hardware的Java profiling tool和诊断协助功能</li><li>针对大数据场景的ZenGC</li></ul></li><li>taobao vm应用在阿里产品上性能高，<code>硬件严重依赖intel的cpu，损失了兼容性，但提高了性能</code></li></ol><p>目前已经在淘宝、天猫上线，把Oracle官方JvM版本全部替换了。</p></li><li><p>Dalvik VM</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Z-《流行的云》</title>
    <link href="/2022/10/20/z-liu-xing-de-yun/"/>
    <url>/2022/10/20/z-liu-xing-de-yun/</url>
    
    <content type="html"><![CDATA[<p>特殊调弦</p><p><img src="/2022/10/20/z-liu-xing-de-yun/image-20221020103152306.png"></p><p><img src="/2022/10/20/z-liu-xing-de-yun/image-20221020103212498.png"></p><blockquote><p>曲谱来源 元子弹吉他</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>吉他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>吉他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令</title>
    <link href="/2022/10/19/git-chang-yong-ming-ling/"/>
    <url>/2022/10/19/git-chang-yong-ming-ling/</url>
    
    <content type="html"><![CDATA[<h2 id="1、创建版本库"><a href="#1、创建版本库" class="headerlink" title="1、创建版本库"></a>1、创建版本库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> &lt;url&gt; <span class="hljs-comment">#克隆远程版本</span><br><br>$ git init <span class="hljs-comment">#初始化本地版本库</span><br><br>$ git config --global user.name 用户名 <span class="hljs-comment">#设置用户名</span><br><br>$ git config --global user.email 邮箱 <span class="hljs-comment">#设置邮箱</span><br></code></pre></td></tr></table></figure><h2 id="2、修改和提交代码"><a href="#2、修改和提交代码" class="headerlink" title="2、修改和提交代码"></a>2、修改和提交代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status <span class="hljs-comment">#查看状态</span><br><br>$ git diff <span class="hljs-comment">#查看便变更内容</span><br><br>$ git add . <span class="hljs-comment">#跟踪所有改动的文件</span><br><br>$ git add &lt;file&gt; <span class="hljs-comment">#跟踪指定的文件</span><br><br>$ git <span class="hljs-built_in">mv</span> &lt;old&gt; &lt;new&gt; <span class="hljs-comment">#文件改名</span><br><br>$ git <span class="hljs-built_in">rm</span> &lt;file&gt; <span class="hljs-comment">#删除文件</span><br><br>$ git <span class="hljs-built_in">rm</span> --cached file <span class="hljs-comment">#停止跟踪文件但不删除</span><br><br>$ git commit -m <span class="hljs-string">&quot;commit message&quot;</span> <span class="hljs-comment">#提交所有更新过的文件</span><br><br>$ git commit -- amend <span class="hljs-comment">#修改最后一次提交</span><br></code></pre></td></tr></table></figure><h2 id="3、查看历史提交"><a href="#3、查看历史提交" class="headerlink" title="3、查看历史提交"></a>3、查看历史提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git long <span class="hljs-comment">#查看提交历史</span><br><br>$ git <span class="hljs-built_in">log</span> -p &lt;file&gt; <span class="hljs-comment">#查看指定文件的提交历史</span><br><br>$ git blame &lt;file&gt; <span class="hljs-comment">#以列表方式查看指定文件的提交历史</span><br></code></pre></td></tr></table></figure><h2 id="4、撤销"><a href="#4、撤销" class="headerlink" title="4、撤销"></a>4、撤销</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reset --hard HEAD <span class="hljs-comment">#撤销工作目录中所有未提交文件的修改内容</span><br><br>$ git checkout  HEAD file <span class="hljs-comment">#撤销指定的未提交文件的修改内容</span><br><br>$ git revert &lt;commit&gt; <span class="hljs-comment">#撤销指定的提交</span><br></code></pre></td></tr></table></figure><h2 id="5、分支、标签"><a href="#5、分支、标签" class="headerlink" title="5、分支、标签"></a>5、分支、标签</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch <span class="hljs-comment">#显示所有本地分支</span><br><br>$ git checkout &lt;branch/tag&gt; <span class="hljs-comment">#切换到指定分支或标签</span><br><br>$ git branch &lt;new-branch&gt; <span class="hljs-comment">#创建新的分支</span><br><br>$ git branch -d &lt;branch&gt; <span class="hljs-comment"># 删除本地分支</span><br><br>$ git tag <span class="hljs-comment">#列出所有本地标签</span><br><br>$ git tag &lt;tagname&gt; <span class="hljs-comment">#基于最新提交创建标签</span><br><br>$ git tag -d &lt;tagname&gt; <span class="hljs-comment">#删除标签</span><br></code></pre></td></tr></table></figure><h2 id="6、合并与衍合"><a href="#6、合并与衍合" class="headerlink" title="6、合并与衍合"></a>6、合并与衍合</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git merge &lt;branch&gt; <span class="hljs-comment">#合并指定分支到当前分支</span><br><br>$ git rebase &lt;branch&gt; <span class="hljs-comment">#衍合指定分支到当前分支</span><br></code></pre></td></tr></table></figure><h2 id="7、远程操作"><a href="#7、远程操作" class="headerlink" title="7、远程操作"></a>7、远程操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote -v <span class="hljs-comment">#查看远程版本信息</span><br><br>$ git remote show &lt;remote&gt; <span class="hljs-comment"># 查看指定远程版本库的信息</span><br><br>$ git remote add &lt;remote&gt; url <span class="hljs-comment">#添加远程版本库</span><br><br>$ git fetch &lt;remote&gt; <span class="hljs-comment">#从远程获取代码</span><br><br>$ git pull &lt;remote&gt; &lt;branch&gt; <span class="hljs-comment">#下载代码及快速合并</span><br><br>$ git push &lt;remote&gt; &lt;branch&gt; <span class="hljs-comment">#上传代码及快速合并</span><br><br>$ git push &lt;remote&gt; :&lt;branch/tag-name&gt; <span class="hljs-comment">#删除远程分支或标签</span><br><br>$ git push --tags <span class="hljs-comment">#上传所有标签</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nohup什么东西？</title>
    <link href="/2022/10/18/nohup-shi-me-dong-xi/"/>
    <url>/2022/10/18/nohup-shi-me-dong-xi/</url>
    
    <content type="html"><![CDATA[<p>所以nohup是什么东西？</p><p><code>nohup</code>是英语 no hangup 的缩写，是不挂断的意思，也就是指程序不退出，用在系统后台不挂断地运行命令，退出终端不会影响程序的运行。</p><p>在工作中，我们可能经常要在服务器上跑程序，有可能要跑的程序耗时很长，需要运行一段时间，我们希望即使关闭终端，程序不受影响，继续运行。在Linux中的<code>nohup</code>命令可以达到这种效果。</p><h2 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> 命令 参数<br><span class="hljs-built_in">nohup</span> 选项<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">--<span class="hljs-built_in">help</span>     <span class="hljs-comment"># 显示此帮助信息并退出</span><br>--version  <span class="hljs-comment"># 显示版本信息并退出</span><br></code></pre></td></tr></table></figure><h2 id="Demo案例"><a href="#Demo案例" class="headerlink" title="Demo案例"></a>Demo案例</h2><p>准备一个test.py程序，功能是每隔2秒会输出”hello nohup!”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time <br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello nohup!&quot;</span>)<br>    time.sleep(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>然后使用<code>nohup python3 test.py</code>运行。</p><p>使用nohup命令时，程序的输出会默认重定向到一个nohup.out文件下。若是想要输出到指定的文件，则可以另外指定输出文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> python3 test.py &gt; out.txt<br></code></pre></td></tr></table></figure><p>但是现在还做不到让程序在后台运行，如果想要让程序在后台运行的话，可以加上 &amp; </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> python3 test.py &gt; out.txt &amp; <br></code></pre></td></tr></table></figure><p>此时关掉终端再重新打开，使用ps命令查看一下进程，发现程序还在运行。</p><p>这里如果想要把标准错误和标准输出都重定向到指定的out.txt文件中，可以使用<code>2&gt;&amp;1</code>符号，<code>2&gt;&amp;1</code>符号的意思是将将标准错误 2 重定向到标准输出 &amp;1。</p><ul><li>0 stdin (standard input，标准输入)</li><li>1 stdout (standard output，标准输出)</li><li>2 stderr (standard error，标准错误输出)</li></ul><p>具体详情见：<a href>2&gt;&amp;1到底是什么意思？</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> python3 test.py &gt; out.txt 2&gt;&amp;1 &amp; <br></code></pre></td></tr></table></figure><p><code>nohup</code>命令结合<code>&amp;</code>符号可以使进程在后台运行，即使关闭了终端依然不受影响。</p><p>那么如何结束进程呢？</p><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>执行一个<code>kill</code>命令时，实际上是发送了一个信号给系统，让它去结束掉一些不正常的应用进程。 可以使用<code>kill -l</code>命令看到所有信号的列表：</p><p><img src="/2022/10/18/nohup-shi-me-dong-xi/image-20221018215614795.png"></p><p>下面是一些常用信号的含义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">(1)SIGHUP 终端线路挂断，终止进程<br>(2)SIGINT 中断进程（同 Ctrl + C）<br>(3)SIGQUIT 退出进程（同 Ctrl + \）<br>(15)SIGTERM 终止进程<br>(9)SIGKILL 强制终止进程<br>(18)SIGCONT 继续（与SIGSTOP相反， <span class="hljs-built_in">fg</span>/bg命令）<br>(19)SIGSTOP 暂停（同 Ctrl + Z）<br></code></pre></td></tr></table></figure><p>常用到的有15 和 9</p><p>(15)SIGTERM：也就是执行<code>kill -15 pid</code>命令，这里”-15”即代表SIGTERM信号。<br> 注意：SIGTERM是默认选项，也就是说执行<code>kill pid</code>和<code>kill -15 pid</code>是等价的。<br> 执行此指令时操作系统会发送一个SIGTERM信号给对应的程序，当程序接收到该信号后，可以用一段时间来正常关闭，一般会先保存进度并释放资源，然后再停止，也就是不一定会立即停止进程，比如程序正在等待IO，可能就不会立马停止运行。也就是说，(15)SIGTERM信号不是强制停止，是可以被忽略的。</p><p>(9)SIGKILL：也就是执行<code>kill -9 pid</code>命令，这里”-9”即代表SIGKILL信号。<br> 是必杀信号，此信号强制进程立即停止运行。程序不能忽略此信号，而未保存的进度将会丢失，从而可能会影响服务的再次启动，此命令应该慎用。</p><p>kill语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> 信号或选项 pid<br></code></pre></td></tr></table></figure><p>默认信号（当没有指定的时候）是SIGTERM。当它不起作用时，可以使用<code>kill -9 pid</code>命令来强制kill掉一个进程。</p><p>应用的pid可以使用以下的命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef<br>ps -aux<br></code></pre></td></tr></table></figure><p>二者都可以查看到pid</p><p><img src="/2022/10/18/nohup-shi-me-dong-xi/image-20221018215918762.png"></p><p>比如想要kill掉PID为108的进程，只需要执行<code>kill -9 108</code>即可。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>nohup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-数据库</title>
    <link href="/2022/10/17/springboot-shu-ju-ku/"/>
    <url>/2022/10/17/springboot-shu-ju-ku/</url>
    
    <content type="html"><![CDATA[<h2 id="一、spring-boot-集成-Jdbc-Template"><a href="#一、spring-boot-集成-Jdbc-Template" class="headerlink" title="一、spring-boot 集成 Jdbc Template"></a>一、spring-boot 集成 Jdbc Template</h2><p>整体结构：</p><p><img src="/2022/10/17/springboot-shu-ju-ku/image-20221017184658161.png" alt="整体结构"></p><h3 id="1、导入依赖"><a href="#1、导入依赖" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、application-yml"><a href="#2、application-yml" class="headerlink" title="2、application.yml"></a>2、application.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/demo</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/spring-boot-demo?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;serverTimezone=GMT%2B8</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span><br>    <span class="hljs-attr">initialization-mode:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">continue-on-error:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">schema:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;classpath:db/schema.sql&quot;</span><br>    <span class="hljs-attr">data:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;classpath:db/data.sql&quot;</span><br>    <span class="hljs-attr">hikari:</span><br>      <span class="hljs-attr">minimum-idle:</span> <span class="hljs-number">5</span><br>      <span class="hljs-attr">connection-test-query:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">DUAL</span><br>      <span class="hljs-attr">maximum-pool-size:</span> <span class="hljs-number">20</span><br>      <span class="hljs-attr">auto-commit:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">idle-timeout:</span> <span class="hljs-number">30000</span><br>      <span class="hljs-attr">pool-name:</span> <span class="hljs-string">SpringBootDemoHikariCP</span><br>      <span class="hljs-attr">max-lifetime:</span> <span class="hljs-number">60000</span><br>      <span class="hljs-attr">connection-timeout:</span> <span class="hljs-number">30000</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.xkcoding:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h3 id="3、实体类User"><a href="#3、实体类User" class="headerlink" title="3、实体类User"></a>3、实体类User</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Table(name = &quot;orm_user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主键</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Pk</span><br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加密后的密码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加密使用的盐</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String salt;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 邮箱</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String email;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 手机号码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Column(name = &quot;phone_number&quot;)</span><br>    <span class="hljs-keyword">private</span> String phoneNumber;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 状态，-1：逻辑删除，0：禁用，1：启用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer status;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Column(name = &quot;create_time&quot;)</span><br>    <span class="hljs-keyword">private</span> Date createTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上次登录时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Column(name = &quot;last_login_time&quot;)</span><br>    <span class="hljs-keyword">private</span> Date lastLoginTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上次更新时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Column(name = &quot;last_update_time&quot;)</span><br>    <span class="hljs-keyword">private</span> Date lastUpdateTime;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、UserDao继承BaseDao"><a href="#4、UserDao继承BaseDao" class="headerlink" title="4、UserDao继承BaseDao"></a>4、UserDao继承BaseDao</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseDao</span>&lt;User, Long&gt; &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserDao</span><span class="hljs-params">(JdbcTemplate jdbcTemplate)</span> &#123;<br>        <span class="hljs-built_in">super</span>(jdbcTemplate);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 操作影响行数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">insert</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.insert(user, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据主键删除用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 操作影响行数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">delete</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.deleteById(id);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id   主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 操作影响行数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">update</span><span class="hljs-params">(User user, Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.updateById(user, id, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据主键获取用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> id对应的用户</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">selectById</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.findOneById(id);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据查询条件获取用户列表</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户查询条件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">selectUserList</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.findByExample(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、UserServiceImpl实现IUserService接口"><a href="#5、UserServiceImpl实现IUserService接口" class="headerlink" title="5、UserServiceImpl实现IUserService接口"></a>5、UserServiceImpl实现IUserService接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceImpl</span><span class="hljs-params">(UserDao userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户实体</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 保存成功 &#123;<span class="hljs-doctag">@code</span> true&#125; 保存失败 &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">save</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rawPass</span> <span class="hljs-operator">=</span> user.getPassword();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">salt</span> <span class="hljs-operator">=</span> IdUtil.simpleUUID();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> SecureUtil.md5(rawPass + Const.SALT_PREFIX + salt);<br>        user.setPassword(pass);<br>        user.setSalt(salt);<br>        <span class="hljs-keyword">return</span> userDao.insert(user) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 删除成功 &#123;<span class="hljs-doctag">@code</span> true&#125; 删除失败 &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">delete</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> userDao.delete(id) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户实体</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id   主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 更新成功 &#123;<span class="hljs-doctag">@code</span> true&#125; 更新失败 &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">update</span><span class="hljs-params">(User user, Long id)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">exist</span> <span class="hljs-operator">=</span> getUser(id);<br>        <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(user.getPassword())) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rawPass</span> <span class="hljs-operator">=</span> user.getPassword();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">salt</span> <span class="hljs-operator">=</span> IdUtil.simpleUUID();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> SecureUtil.md5(rawPass + Const.SALT_PREFIX + salt);<br>            user.setPassword(pass);<br>            user.setSalt(salt);<br>        &#125;<br>        BeanUtil.copyProperties(user, exist, CopyOptions.create().setIgnoreNullValue(<span class="hljs-literal">true</span>));<br>        exist.setLastUpdateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTime</span>());<br>        <span class="hljs-keyword">return</span> userDao.update(exist, id) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取单个用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 单个用户对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> userDao.findOneById(id);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取用户列表</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户实体</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUser</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> userDao.findByExample(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、结果"><a href="#6、结果" class="headerlink" title="6、结果"></a>6、结果</h3><p><img src="/2022/10/17/springboot-shu-ju-ku/image-20221017184607196.png"></p><h2 id="二、spring-boot-集成原生mybatis"><a href="#二、spring-boot-集成原生mybatis" class="headerlink" title="二、spring-boot 集成原生mybatis"></a>二、spring-boot 集成原生mybatis</h2><p>spring-boot 集成原生mybatis，使用 <a href="https://github.com/mybatis/spring-boot-starter">mybatis-spring-boot-starter</a> 集成</p><h3 id="1、导入依赖-1"><a href="#1、导入依赖-1" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、主启动类"><a href="#2、主启动类" class="headerlink" title="2、主启动类"></a>2、主启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(basePackages = &#123;&quot;com.xkcoding.orm.mybatis.mapper&quot;&#125;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootDemoOrmMybatisApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SpringBootDemoOrmMybatisApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>记得加 @MapperScan 注解</p><h3 id="3、application-yml"><a href="#3、application-yml" class="headerlink" title="3、application.yml"></a>3、application.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/spring-boot-demo?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;serverTimezone=GMT%2B8</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span><br>    <span class="hljs-attr">initialization-mode:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">continue-on-error:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">schema:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;classpath:db/schema.sql&quot;</span><br>    <span class="hljs-attr">data:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;classpath:db/data.sql&quot;</span><br>    <span class="hljs-attr">hikari:</span><br>      <span class="hljs-attr">minimum-idle:</span> <span class="hljs-number">5</span><br>      <span class="hljs-attr">connection-test-query:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">DUAL</span><br>      <span class="hljs-attr">maximum-pool-size:</span> <span class="hljs-number">20</span><br>      <span class="hljs-attr">auto-commit:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">idle-timeout:</span> <span class="hljs-number">30000</span><br>      <span class="hljs-attr">pool-name:</span> <span class="hljs-string">SpringBootDemoHikariCP</span><br>      <span class="hljs-attr">max-lifetime:</span> <span class="hljs-number">60000</span><br>      <span class="hljs-attr">connection-timeout:</span> <span class="hljs-number">30000</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.xkcoding:</span> <span class="hljs-string">debug</span><br>    <span class="hljs-attr">com.xkcoding.orm.mybatis.mapper:</span> <span class="hljs-string">trace</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-comment"># 下划线转驼峰</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mappers/*.xml</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.xkcoding.orm.mybatis.entity</span><br></code></pre></td></tr></table></figure><h3 id="4、UserMapper接口"><a href="#4、UserMapper接口" class="headerlink" title="4、UserMapper接口"></a>4、UserMapper接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询所有用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Select(&quot;SELECT * FROM orm_user&quot;)</span><br>    List&lt;User&gt; <span class="hljs-title function_">selectAllUser</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id查询用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 当前id的用户，不存在则是 &#123;<span class="hljs-doctag">@code</span> null&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Select(&quot;SELECT * FROM orm_user WHERE id = #&#123;id&#125;&quot;)</span><br>    User <span class="hljs-title function_">selectUserById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Long id)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功 - &#123;<span class="hljs-doctag">@code</span> 1&#125; 失败 - &#123;<span class="hljs-doctag">@code</span> 0&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;user&quot;)</span> User user)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功 - &#123;<span class="hljs-doctag">@code</span> 1&#125; 失败 - &#123;<span class="hljs-doctag">@code</span> 0&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Long id)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、UserMapper-xml"><a href="#5、UserMapper-xml" class="headerlink" title="5、UserMapper.xml"></a>5、UserMapper.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.xkcoding.orm.mybatis.mapper.UserMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;saveUser&quot;</span>&gt;</span><br>        INSERT INTO `orm_user` (`name`,<br>                                `password`,<br>                                `salt`,<br>                                `email`,<br>                                `phone_number`,<br>                                `status`,<br>                                `create_time`,<br>                                `last_login_time`,<br>                                `last_update_time`)<br>        VALUES (#&#123;user.name&#125;,<br>                #&#123;user.password&#125;,<br>                #&#123;user.salt&#125;,<br>                #&#123;user.email&#125;,<br>                #&#123;user.phoneNumber&#125;,<br>                #&#123;user.status&#125;,<br>                #&#123;user.createTime&#125;,<br>                #&#123;user.lastLoginTime&#125;,<br>                #&#123;user.lastUpdateTime&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span>&gt;</span><br>        DELETE<br>        FROM `orm_user`<br>        WHERE `id` = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserMapperTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SpringBootDemoOrmMybatisApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectAllUser</span><span class="hljs-params">()</span> &#123;<br>        List&lt;User&gt; userList = userMapper.selectAllUser();<br>        Assert.assertTrue(CollUtil.isNotEmpty(userList));<br>        log.debug(<span class="hljs-string">&quot;【userList】= &#123;&#125;&quot;</span>, userList);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectUserById</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.selectUserById(<span class="hljs-number">1L</span>);<br>        Assert.assertNotNull(user);<br>        log.debug(<span class="hljs-string">&quot;【user】= &#123;&#125;&quot;</span>, user);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">salt</span> <span class="hljs-operator">=</span> IdUtil.fastSimpleUUID();<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> User.builder().name(<span class="hljs-string">&quot;testSave3&quot;</span>).password(SecureUtil.md5(<span class="hljs-string">&quot;123456&quot;</span> + salt)).salt(salt).email(<span class="hljs-string">&quot;testSave3@xkcoding.com&quot;</span>).phoneNumber(<span class="hljs-string">&quot;17300000003&quot;</span>).status(<span class="hljs-number">1</span>).lastLoginTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTime</span>()).createTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTime</span>()).lastUpdateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTime</span>()).build();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> userMapper.saveUser(user);<br>        Assert.assertEquals(<span class="hljs-number">1</span>, i);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> userMapper.deleteById(<span class="hljs-number">1L</span>);<br>        Assert.assertEquals(<span class="hljs-number">1</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7、参考"><a href="#7、参考" class="headerlink" title="7、参考"></a>7、参考</h3><ul><li>Mybatis官方文档：<a href="http://www.mybatis.org/mybatis-3/zh/index.html">http://www.mybatis.org/mybatis-3/zh/index.html</a></li><li>Mybatis官方脚手架文档：<a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></li><li>Mybatis整合Spring Boot官方demo：<a href="https://github.com/mybatis/spring-boot-starter/tree/master/mybatis-spring-boot-samples">https://github.com/mybatis/spring-boot-starter/tree/master/mybatis-spring-boot-samples</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-配置文件以及日志</title>
    <link href="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/"/>
    <url>/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/</url>
    
    <content type="html"><![CDATA[<h2 id="一、多个配置文件的读取"><a href="#一、多个配置文件的读取" class="headerlink" title="一、多个配置文件的读取"></a>一、多个配置文件的读取</h2><p>现在有多个配置文件，运行时要读取其中一个配置文件，怎么选择？</p><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221014172131119.png"></p><p>多个配置文件的读取，在设置好property类后，可以在application中选择要读取的对象，如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/demo</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><p>当要读取 application-dev 时，只需将第七行代码改为dev，当要读取application-prod时，只需将第七行代码改为prod。</p><p>如下是设置为dev的运行结果：</p><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221014172456012.png"></p><h2 id="二、spring-boot-集成-spring-boot-starter-actuator"><a href="#二、spring-boot-集成-spring-boot-starter-actuator" class="headerlink" title="二、spring-boot 集成 spring-boot-starter-actuator"></a>二、spring-boot 集成 spring-boot-starter-actuator</h2><p>actuator用于监控 spring-boot 的启动和运行状态</p><h3 id="1、pom文件"><a href="#1、pom文件" class="headerlink" title="1、pom文件"></a>1、pom文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、application-yml"><a href="#2、application-yml" class="headerlink" title="2、application.yml"></a>2、application.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/demo</span><br><span class="hljs-comment"># 若要访问端点信息，需要配置用户名和密码</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">security:</span><br>    <span class="hljs-attr">user:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">zhaibiao</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>      <br><span class="hljs-attr">management:</span><br>  <span class="hljs-comment"># 端点信息接口使用的端口，为了和主系统接口使用的端口进行分离</span><br>  <span class="hljs-attr">server:</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8090</span><br>    <span class="hljs-attr">servlet:</span><br>      <span class="hljs-attr">context-path:</span> <span class="hljs-string">/sys</span><br>  <span class="hljs-comment"># 端点健康情况，默认值&quot;never&quot;，设置为&quot;always&quot;可以显示硬盘使用情况和线程情况</span><br>  <span class="hljs-attr">endpoint:</span><br>    <span class="hljs-attr">health:</span><br>      <span class="hljs-attr">show-details:</span> <span class="hljs-string">always</span><br>  <span class="hljs-comment"># 设置端点暴露的哪些内容，默认[&quot;health&quot;,&quot;info&quot;]，设置&quot;*&quot;代表暴露所有可访问的端点</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3、端点暴露地址"><a href="#3、端点暴露地址" class="headerlink" title="3、端点暴露地址"></a>3、端点暴露地址</h3><ol><li>打开浏览器，访问：<a href="http://localhost:8090/sys/actuator/mappings">http://localhost:8090/sys/actuator/mappings</a> ，输入用户名(zhaibiao)密码(123456)即可看到所有的mapping信息</li><li>访问：<a href="http://localhost:8090/sys/actuator/beans">http://localhost:8090/sys/actuator/beans</a> ，输入用户名(zhaibiao)密码(123456)即可看到所有 Spring 管理的Bean</li></ol><ul><li>actuator文档：<a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#production-ready">https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#production-ready</a></li></ul><h3 id="4、结果"><a href="#4、结果" class="headerlink" title="4、结果"></a>4、结果</h3><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221017161554284.png" alt="beans"></p><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221017161608902.png" alt="mappings"></p><h2 id="三、spring-boot集成admin"><a href="#三、spring-boot集成admin" class="headerlink" title="三、spring-boot集成admin"></a>三、spring-boot集成admin</h2><h3 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h3><h4 id="1、导入依赖"><a href="#1、导入依赖" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h4><p>服务端配置文件不需要太多配置，端口号即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8000</span><br></code></pre></td></tr></table></figure><h4 id="3、主启动类"><a href="#3、主启动类" class="headerlink" title="3、主启动类"></a>3、主启动类</h4><p>必须要在主启动类上加 <code>@EnableAdminServer</code> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAdminServer</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootDemoAdminServerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SpringBootDemoAdminServerApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h3><h4 id="1、导入依赖-1"><a href="#1、导入依赖-1" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2、配置文件-1"><a href="#2、配置文件-1" class="headerlink" title="2、配置文件"></a>2、配置文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/demo</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-comment"># Spring Boot Admin展示的客户端项目名，不设置，会使用自动生成的随机id</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">spring-boot-demo-admin-client</span><br>  <span class="hljs-attr">boot:</span><br>    <span class="hljs-attr">admin:</span><br>      <span class="hljs-attr">client:</span><br>        <span class="hljs-comment"># Spring Boot Admin 服务端地址</span><br>        <span class="hljs-attr">url:</span> <span class="hljs-string">&quot;http://localhost:8000/&quot;</span><br>        <span class="hljs-attr">instance:</span><br>          <span class="hljs-attr">metadata:</span><br>            <span class="hljs-comment"># 客户端端点信息的安全认证信息</span><br>            <span class="hljs-attr">user.name:</span> <span class="hljs-string">$&#123;spring.security.user.name&#125;</span><br>            <span class="hljs-attr">user.password:</span> <span class="hljs-string">$&#123;spring.security.user.password&#125;</span><br>  <span class="hljs-attr">security:</span><br>    <span class="hljs-attr">user:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">zhaibiao</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoint:</span><br>    <span class="hljs-attr">health:</span><br>      <span class="hljs-comment"># 端点健康情况，默认值&quot;never&quot;，设置为&quot;always&quot;可以显示硬盘使用情况和线程情况</span><br>      <span class="hljs-attr">show-details:</span> <span class="hljs-string">always</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-comment"># 设置端点暴露的哪些内容，默认[&quot;health&quot;,&quot;info&quot;]，设置&quot;*&quot;代表暴露所有可访问的端点</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span><br></code></pre></td></tr></table></figure><h4 id="3、控制类（用来测试）"><a href="#3、控制类（用来测试）" class="headerlink" title="3、控制类（用来测试）"></a>3、控制类（用来测试）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IndexController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(value = &#123;&quot;&quot;, &quot;/&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This is a Spring Boot Admin Client.&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、结果"><a href="#3、结果" class="headerlink" title="3、结果"></a>3、结果</h3><p>运行步骤：</p><ol><li>先启动server服务端，启动管控台服务端程序</li><li>再启动client客户端，注册到服务端</li><li>观察服务端里，客户端程序的运行状态等信息</li></ol><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221017163939849.png" alt="server"></p><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221017164045955.png" alt="client"></p><h2 id="四、spring-boot集成logback"><a href="#四、spring-boot集成logback" class="headerlink" title="四、spring-boot集成logback"></a>四、spring-boot集成logback</h2><p>演示如何使用 logback 记录程序运行过程中的日志，以及如何配置 logback，可以同时生成控制台日志和文件日志记录，文件日志以日期和大小进行拆分生成。</p><h3 id="1、导入依赖-2"><a href="#1、导入依赖-2" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>demo-logback<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、配置文件-2"><a href="#2、配置文件-2" class="headerlink" title="2、配置文件"></a>2、配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/demo</span><br></code></pre></td></tr></table></figure><p>配置端口</p><h3 id="3、logback-spring-xml"><a href="#3、logback-spring-xml" class="headerlink" title="3、logback-spring.xml"></a>3、logback-spring.xml</h3><p>在resources下建立logback-spring.xml用于配置logback</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_ERROR_PATTERN&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;FILE_LOG_PATTERN:-%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125; $&#123;LOG_LEVEL_PATTERN:-%5p&#125; $&#123;PID:- &#125; --- [%t] %-40.40logger&#123;39&#125; %file:%line: %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>INFO<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_INFO&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--如果只是想要 Info 级别的日志，只是过滤 info 还是会输出 Error 日志，因为 Error 的级别高， 所以我们使用下面的策略，可以避免输出 Error 的日志--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--过滤 Error--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>ERROR<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--匹配到就禁止--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--没有匹配到就允许--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。--&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;File&gt;logs/info.demo-logback.log&lt;/File&gt;--&gt;</span><br>  <span class="hljs-comment">&lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>logs/demo-logback/info.created_on_%d&#123;yyyy-MM-dd&#125;.part_%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--只保留最近90天的日志--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>90<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志--&gt;</span><br>   <span class="hljs-comment">&lt;!--&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- maxFileSize:这是活动文件的大小，默认值是10MB,本篇设置为1KB，只是为了演示 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>2MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;--&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;maxFileSize&gt;1KB&lt;/maxFileSize&gt;--&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;/triggeringPolicy&gt;--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处设置字符集 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_ERROR&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--如果只是想要 Error 级别的日志，那么需要过滤一下，默认是 info 级别的，ThresholdFilter--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>Error<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。--&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;File&gt;logs/error.demo-logback.log&lt;/File&gt;--&gt;</span><br>  <span class="hljs-comment">&lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>logs/demo-logback/error.created_on_%d&#123;yyyy-MM-dd&#125;.part_%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--只保留最近90天的日志--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>90<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- maxFileSize:这是活动文件的大小，默认值是10MB,本篇设置为1KB，只是为了演示 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>2MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_ERROR_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处设置字符集 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE_INFO&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE_ERROR&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4、主启动类进行测试"><a href="#4、主启动类进行测试" class="headerlink" title="4、主启动类进行测试"></a>4、主启动类进行测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootDemoLogbackApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(SpringBootDemoLogbackApplication.class, args);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> context.getBeanDefinitionNames().length;<br>        log.trace(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);<br>        log.debug(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);<br>        log.info(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);<br>        log.warn(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);<br>        log.error(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//int j = 1 / i;</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;【SpringBootDemoLogbackApplication】启动异常：&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、结果"><a href="#5、结果" class="headerlink" title="5、结果"></a>5、结果</h3><p>报错日志如下：</p><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221017170557025.png" alt="Error"></p><blockquote><p>TODO</p></blockquote><h2 id="五、spring-boot-使用-AOP-切面的方式记录-web-请求日志"><a href="#五、spring-boot-使用-AOP-切面的方式记录-web-请求日志" class="headerlink" title="五、spring-boot 使用 AOP 切面的方式记录 web 请求日志"></a>五、spring-boot 使用 AOP 切面的方式记录 web 请求日志</h2><h2 id="六、spring-boot-统一异常处理"><a href="#六、spring-boot-统一异常处理" class="headerlink" title="六、spring-boot 统一异常处理"></a>六、spring-boot 统一异常处理</h2>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>配置文件</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>v2-哈希表</title>
    <link href="/2022/10/13/v2-ha-xi-biao/"/>
    <url>/2022/10/13/v2-ha-xi-biao/</url>
    
    <content type="html"><![CDATA[<h1 id="一、理论基础"><a href="#一、理论基础" class="headerlink" title="一、理论基础"></a>一、理论基础</h1><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p><p>哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。</p><p>哈希表能解决什么问题呢？一般哈希表是用来判断一个元素是否出现在元素里。</p><p>例如要查询一个名字是否在这所学校里，要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。</p><h2 id="1、哈希函数"><a href="#1、哈希函数" class="headerlink" title="1、哈希函数"></a>1、哈希函数</h2><p>哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。</p><p>哈希函数通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p><p>但是若是哈希表不够大，而hashCode得到的数值又大于哈希表的长度呢？一般都是用取模来解决这个问题。</p><p>那么问题又来了，若是有很多同学通过hashCode得到的数值都相等呢？这个现象就叫哈希碰撞</p><h2 id="2、哈希碰撞"><a href="#2、哈希碰撞" class="headerlink" title="2、哈希碰撞"></a>2、哈希碰撞</h2><p>如下，小李和小王都映射到索引下标1的位置，产生哈希碰撞。</p><p><img src="/2022/10/13/v2-ha-xi-biao/image-20221013103434324.png"></p><p>解决办法有两个</p><h3 id="1、拉链法"><a href="#1、拉链法" class="headerlink" title="1、拉链法"></a>1、拉链法</h3><p>拉链法简而言之就是产生碰撞时，让发生冲突的元素都储存在链表中。</p><p><img src="/2022/10/13/v2-ha-xi-biao/image-20221013103638804.png"></p><h3 id="2、线性探测法"><a href="#2、线性探测法" class="headerlink" title="2、线性探测法"></a>2、线性探测法</h3><p>线性探测法是当产生冲突时，往下顺延至没有数据的那一位，如下图。</p><p><img src="/2022/10/13/v2-ha-xi-biao/image-20221013103733434.png"></p><p>所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。</p><h2 id="3、常见哈希结构"><a href="#3、常见哈希结构" class="headerlink" title="3、常见哈希结构"></a>3、常见哈希结构</h2><ul><li>数组</li><li>set</li><li>map</li></ul><h2 id="4、常用方法"><a href="#4、常用方法" class="headerlink" title="4、常用方法"></a>4、常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 是否包含关键字</span><br>map.containsKey(keys);<br><span class="hljs-comment">// 添加关键字和值</span><br>map.put(keys, value);<br><span class="hljs-comment">// 获取所有键的值</span><br>map.values();<br><br><span class="hljs-comment">// 字符串转字符数组</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;string&quot;</span>;<br><span class="hljs-type">char</span>[] ch = str.toCharArray();<br><span class="hljs-comment">// 字符数组转字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">keys</span> <span class="hljs-operator">=</span> String.valueOf(ch);<br></code></pre></td></tr></table></figure><h1 id="二、经典题"><a href="#二、经典题" class="headerlink" title="二、经典题"></a>二、经典题</h1><h2 id="1、数组中只出现一次的两个数字"><a href="#1、数组中只出现一次的两个数字" class="headerlink" title="1、数组中只出现一次的两个数字"></a>1、数组中只出现一次的两个数字</h2><p>牛客原题链接：<a href="https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8?tpId=295&tqId=745&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=/exam/oj"><strong>BM52</strong> <strong>数组中只出现一次的两个数字</strong></a></p><h3 id="1、方法一：哈希表"><a href="#1、方法一：哈希表" class="headerlink" title="1、方法一：哈希表"></a>1、方法一：哈希表</h3><p>看到题目，很容易想到用一个哈希表来记录每个数出现的次数，并得到只出现一次的数字</p><p>具体思路如下：</p><p>1、创建一个哈希表</p><p>2、当数组元素没有在哈希表中成为key的时候，put进哈希表，当已存在的时候，则remove掉。</p><p>3、最后哈希表中剩下的key就是只出现一次的数字</p><p>4、遍历key然后返回结果</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] FindNumsAppearOnce (<span class="hljs-type">int</span>[] array) &#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-comment">// 用于返回结果</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 创建一个哈希表</span><br>        HashMap&lt;Integer,Object&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++)&#123;<br>            <span class="hljs-comment">// 如果已经被当作key了，那就直接remove掉</span><br>            <span class="hljs-keyword">if</span>(set.containsKey(array[i]))&#123;<br>                set.remove(array[i],<span class="hljs-literal">null</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 否则就添加进去</span><br>                set.put(array[i],<span class="hljs-literal">null</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 最后拿出来放进返回结果的数组中进行返回</span><br>        <span class="hljs-keyword">for</span>(Integer num:set.keySet())&#123;<br>            res[i++] = num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>当然，时间复杂度和空间复杂度都是O(n)，但是这道题要求是空间复杂度为O(1)，So?</p><h3 id="2、方法二：双指针法"><a href="#2、方法二：双指针法" class="headerlink" title="2、方法二：双指针法"></a>2、方法二：双指针法</h3><p>双指针法的前提是要数组有序，可以用Arrays.sort来对数组进行排序。定义两个指针，若是后一个元素和当前元素不等，说明什么？<code>说明前一个元素只出现了一次</code>。这句话有歧义，可能有人会说我从 1, 1, 2中的第二个位置的1和2进行比较，就说明不了1只出现了一次。这个问题如何解决？很好办，只需要从0开始遍历即可，若是出现后一个元素和当前元素相等，就直接将指针后移两位。这样就解决问题了。</p><p>具体思路如下：</p><ol><li>对原始数组进行排序</li><li>遍历数组，若是 i + 1 等于数组的长度 或者 下一个元素不等于当前元素，就将  i 存入返回数组中，并后移一位；否则后移两位</li></ol><blockquote><p>注意，若是 i + 1 等于数组的长度，说明此时i已经是最后一个元素，直接放入返回数组中即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] FindNumsAppearOnce (<span class="hljs-type">int</span>[] array) &#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-comment">//   双指针法</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        Arrays.sort(array);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">two</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> == array.length || array[i + <span class="hljs-number">1</span>] != array[i]) &#123;<br>                res[two] = array[i];<br>                two++;<br>            &#125;   <br>            <span class="hljs-keyword">else</span><br>                i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3、方法三：位运算"><a href="#3、方法三：位运算" class="headerlink" title="3、方法三：位运算"></a>3、<code>方法三：位运算</code></h3><p>先来了解一下什么叫异或运算</p><p>异或运算是基于二进制的位运算，采用符号XOR或者^来表示，运算规则是就与二进制，如果是同值取0、异值取1。</p><p><code>异或运算的性质</code>：</p><ol><li>交换律 可以任意交换运算因子，结果不变。</li><li>结合律 （a^b）^c=a^(a^c)</li><li>对于任何数x，都有x^x=0,x^0=x,同自己求异或运算为0，同0求异或运算结果为自己</li><li>自反性，A^B^B=A^0=A。这个性质可以用来求哪一个数为一个</li></ol><p>这道题运用的就是第四个性质，自反性</p><blockquote><p>举个例子：</p><p>4 ⊕ 4 = 0，将4化为二进制为 0100</p><p>所以 0100</p><p>异或 0100</p><p>得到 0000</p><p>4 ⊕ 4 ⊕ 5 = 5</p><p>则 0100</p><p> 0100</p><p> 0101</p><p>得到 0101</p><p>我们可以看到上面的运算过程，因为4=4，两者相等异或结果为0。所以0异或任意数都等于任意数。</p></blockquote><p>所以，当只有一个出现了一次的数字的时候，则只需要将全部数进行异或运算，运算结果就剩下了那个只出现一次的数字了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] singleNumber(<span class="hljs-type">int</span>[] nums) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)  <span class="hljs-comment">// 1. 遍历 nums 执行异或运算</span><br>        x ^= num;<br>    <span class="hljs-keyword">return</span> x;            <span class="hljs-comment">// 2. 返回出现一次的数字 x</span><br>&#125;<br></code></pre></td></tr></table></figure><p>问题来了：上述的思想是多个数中找到只出现一次的数字，但是本题是找两个，比如输入 1,4,1,6。最后剩下4⊕6。怎么办？</p><p>那就进行分组嘛，分成两个组。</p><p>但是分组的依据是什么呢？先来看看按奇数偶数分，按奇数偶数分不难实现，只需要将其 &amp;1 即可，原理是奇数的最低位一定是1，偶数的最低位一定是0。但是也不能保证只出现一次的数字正好是一奇一偶，或许人家是两个奇数两个偶数呢？所以按奇数偶数的分法不可行。</p><p>确定分组依据之前，先看一个小例子，比如要区分0100和0110，也就是4和6，怎么区分呢？可以从最低位刚开始不同的位置区分，0100⊕0110 = 0010，那么可以用0010来区分。异或运算<code>正好</code>用的上。</p><p>那么问题就变的很简单，具体思路如下：</p><ol><li>先将全部数进行异或运算，得出最终结果</li><li>找到可以充当分组的数</li><li>分组，同时求出出现一次的数字</li><li>进行非降序排列</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] FindNumsAppearOnce (<span class="hljs-type">int</span>[] array) &#123;<br>        <span class="hljs-comment">// write code here</span><br>    <br>        <span class="hljs-comment">// 先将全部数进行异或运算，得出最终结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : array) &#123;<br>            temp ^= num;<br>        &#125;<br>    <br>        <span class="hljs-comment">// 找到那个可以充当分组去进行与运算的数</span><br>        <span class="hljs-comment">// 从最低位开始找起</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mask</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> ((tmp &amp; mask) == <span class="hljs-number">0</span>) &#123;<br>            mask &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br>    <br>        <span class="hljs-comment">// 进行分组，分成两组，转换为两组 求出现一次的数字 去求</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : array) &#123;<br>            <span class="hljs-keyword">if</span> ((num &amp; mask) == <span class="hljs-number">0</span>) &#123;<br>                a ^= num;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                b ^= num;<br>            &#125;<br>        &#125;<br>    <br>        <span class="hljs-comment">// 因为题目要求小的数放前面，所以这一做个判断</span><br>        <span class="hljs-keyword">if</span> (a &gt; b) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a;<br>            a = b;<br>            b = c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;a, b&#125;;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>第14行的 &lt;&lt; 符号，左移运算符。效果：通过从右侧推入零并让最左边的位脱落来向左移动。比如9 &lt;&lt; 1 等同于 1001 &lt;&lt; 1 ，结果就是0010，换做十进制也就是2</p></blockquote><p>上述的第30到32行的代码，也可以用异或来实现a和b数值的交换。<code>这也是异或性质的运用。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">a = a ^ b    <span class="hljs-comment">// a = a ^ b</span><br>b = a ^ b    <span class="hljs-comment">// b = a ^ b ^ b ,  ==&gt; b = a</span><br>a = a ^ b    <span class="hljs-comment">// a = a ^ b ^ a ,  ==&gt; a = b</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C-《安河桥》</title>
    <link href="/2022/10/09/c-an-he-qiao/"/>
    <url>/2022/10/09/c-an-he-qiao/</url>
    
    <content type="html"><![CDATA[<center>《安河桥》</center><p>原调G | 选调G </p><p><img src="/2022/10/09/c-an-he-qiao/image-20221009170248015.png"></p><p><img src="/2022/10/09/c-an-he-qiao/image-20221009170322004.png"></p><p><img src="/2022/10/09/c-an-he-qiao/image-20221009170357665.png"></p><p><img src="/2022/10/09/c-an-he-qiao/image-20221009170417935.png"></p><p><img src="/2022/10/09/c-an-he-qiao/image-20221009170440876.png"></p><blockquote><p>曲谱来源大树音乐屋</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>吉他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>吉他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C-《成都》</title>
    <link href="/2022/10/09/c-cheng-du/"/>
    <url>/2022/10/09/c-cheng-du/</url>
    
    <content type="html"><![CDATA[<center>《成都》<center><p>原调D | 选调C | capo = 3</p><p><img src="/2022/10/09/c-cheng-du/image-20221009165319957.png" alt></p><p><img src="/2022/10/09/c-cheng-du/image-20221009165406564.png" alt></p><blockquote><p>曲谱来源于趣谈音乐</p></blockquote></center></center>]]></content>
    
    
    <categories>
      
      <category>吉他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>吉他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>v2-数组</title>
    <link href="/2022/10/08/v2-shu-zu/"/>
    <url>/2022/10/08/v2-shu-zu/</url>
    
    <content type="html"><![CDATA[<h1>一、理论基础</h1><p>定义：<strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p><p>需要注意两点：</p><ul><li>数组下标从0开始</li><li>数组内存空间的地址是连续的</li></ul><p>针对二维数组在内存空间的地址是否连续，不同的编程语言的内存管理不同。在C++中二维数组是连续分布的。但在java中二维数组不是连续分布的。</p><p>java中的二维数组可能是如下排列方式：</p><p><img src="/2022/10/08/v2-shu-zu/image-20221008165054951.png" alt></p><p>基本方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;    <span class="hljs-comment">// 长度</span><br>nums[i];  <span class="hljs-comment">// 取值</span><br></code></pre></td></tr></table></figure><h1>二、经典题目（力扣、牛客</h1><h2 id="1、704-二分查找">1、704.二分查找</h2><p>二分查找的前提条件是数组有序，同时还要保证数组无重复元素，因为若是有重复元素，二分查找返回来的索引可能不是唯一的。二分查找需要注意的地方是边界问题，一旦确定好边界，都要按这个规则来，一会是左闭右闭一会是左闭右开，当然绕！</p><p>所以若是看到数组有序且无重复，可以联想二分查找</p><p>二分查找两种写法：</p><ul><li>左闭右闭即[left, right]</li><li>左闭右开即[left, right)</li></ul><h3 id="1、左闭右闭">1、左闭右闭</h3><p>定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right]</strong> 。</p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，同样if (nums[middle] &lt; target) left要赋值为 middle + 1。因为是左闭右闭，所以middle一定已经判断过了，直接跳过即可</li></ul><h3 id="2、左闭右开">2、左闭右开</h3><p>定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right）</strong> 。</p><ul><li>while (left &lt;= right) 要使用 &lt; ，因为left == right是没有有意义的，所以不能使用&lt;=，要使用&lt;</li><li>if (nums[middle] &gt; target) right 要赋值为 middle， if (nums[middle] &lt; target) left要赋值为 middle + 1。</li></ul><p>二者选一个即可，我个人倾向于左闭右闭</p><h3 id="3、相关题目推荐">3、相关题目推荐</h3><ul><li><a href="https://programmercarl.com/0035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html">35.搜索插入位置(opens new window)</a></li><li><a href="https://programmercarl.com/0034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.html">34.在排序数组中查找元素的第一个和最后一个位置(opens new window)</a></li><li>69.x 的平方根</li><li>367.有效的完全平方数</li></ul><h2 id="2、27-移除元素">2、27.移除元素</h2><p>题目要求不能使用额外的数组空间，意味着只能原地操作</p><p>两种方法</p><h3 id="1、暴力法">1、暴力法</h3><p>for循环两次，碰到目标值，就将后面的各个元素往前移动一位</p><p>当然时间复杂度比较高，O(n*2)</p><h3 id="2、双指针法">2、双指针法</h3><p>维持两个指针，一个快一个慢，for循环一次，若不为目标值，将fast所在位置的元素赋值给slow所在位置的元素，同时往后进一位</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (fast = <span class="hljs-number">0</span>; fast &lt; nums.length; fast++) &#123;<br>   <span class="hljs-keyword">if</span>(nums[fast] != val) &#123;<br>       nums[slow++] = nums[fast];<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、相关题目推荐-v2">3、相关题目推荐</h3><ul><li>26.删除排序数组中的重复项</li><li>283.移动零</li><li>844.比较含退格的字符串</li><li>977.有序数组的平方</li></ul><h2 id="3、209-长度最小的子数组">3、209.长度最小的子数组</h2><p>三种方法</p><h3 id="1、暴力法-v2">1、暴力法</h3><p>两层for循环，每遍历一个，就向后相加找到大于target的索引并记录，同时保留一个res来记录最小值</p><p>当然时间复杂度是比较高的，O(n*2)</p><h3 id="2、滑动窗口">2、滑动窗口</h3><p>定义两个指针start和end，并记录sum，若是sum &lt; target，就将end往后++；若是sum &gt;= target，就将start++，并对sum和size做相应操作</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (end &lt; nums.length) &#123;<br>     sum += nums[end];<br>     <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>     min = Math.min(min, end - start + <span class="hljs-number">1</span>);<br>        sum -= nums[start];<br>        start++;<br>     &#125;<br>     end++;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、相关题目推荐-v3">3、相关题目推荐</h3><ul><li><a href="https://leetcode.cn/problems/fruit-into-baskets/">904.水果成篮(opens new window)</a></li><li>==<a href="https://leetcode.cn/problems/minimum-window-substring/">76.最小覆盖子串</a>==【经典】</li></ul><h3 id="4、滑动窗口总结">4、滑动窗口总结</h3><p>滑动窗口有最小滑动窗口模板和最大滑动窗口模板，具体要求看题目要求</p><p>最小滑动窗口模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (j &lt; len)&#123;<br>    判断[i, j]是否满足条件<br>    <span class="hljs-keyword">while</span> (满足条件)&#123;<br>        不断更新结果(注意在<span class="hljs-keyword">while</span>内更新！)<br>        i += <span class="hljs-number">1</span> （最大程度的压缩i，使得滑窗尽可能的小）<br>    &#125;<br>    j += <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (end &lt; nums.length) &#123;<br>     sum += nums[end];<br>     <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>     min = Math.min(min, end - start + <span class="hljs-number">1</span>);<br>        sum -= nums[start];<br>        start++;<br>     &#125;<br>     end++;<br>&#125;<br></code></pre></td></tr></table></figure><p>代表题目为209</p><p>最大滑动窗口模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (j &lt; len)&#123;<br>    判断[i, j]是否满足条件<br>    <span class="hljs-keyword">while</span> (不满足条件)&#123;<br>        i += <span class="hljs-number">1</span> （最大程度的压缩i，使得滑窗尽可能的小）<br>    &#125;<br>    不断更新结果(注意在<span class="hljs-keyword">while</span>内更新！)<br>    j += <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (right &lt; fruits.length) &#123;<br>    map.put(fruits[right], map.getOrDefault(fruits[right], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (map.size() &gt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-comment">// count为水果最大数目，当map大小超过2时，滑窗需前移left;</span><br>       map.put(fruits[left], map.get(fruits[left]) - <span class="hljs-number">1</span>);<br>       <span class="hljs-keyword">if</span> (map.get(fruits[left]) == <span class="hljs-number">0</span>) &#123;<br>            map.remove(fruits[left]);<br>       &#125;<br>       left++;<br>    &#125;<br>    count = Math.max(count, right - left + <span class="hljs-number">1</span>);<br>    right++;<br>&#125;<br></code></pre></td></tr></table></figure><p>代表题目为904</p><h2 id="4、59-螺旋矩阵II">4、59.螺旋矩阵II</h2><p>正确解决二分法是坚持循环不变量原则，这道题也是一样，要么一直左闭右开，要么一直左闭右闭。</p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由此可见，需要定义的变量有：</p><ol><li>返回的数组</li><li>循环次数，每一环为一次，定义这个的目的是控制边界，因为有的时候需要赋值n-1次，有的时候需要赋值n-2次，这个时候就要用到循环次数</li><li>定义起始变量start，每循环一圈就令start++</li><li>定义全局变量i, j</li></ol><h3 id="相关题目推荐">相关题目推荐</h3><ul><li>54.螺旋矩阵</li><li>剑指Offer 29.顺时针打印矩阵</li></ul><h2 id="5、二位数组中的查找（牛客">5、二位数组中的查找（牛客</h2><p>题目链接：<a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=295&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=%2Fexam%2Foj">二位数组中的查找</a></p><h3 id="1、方法一">1、方法一</h3><p>直接二维循环暴力，不多赘述</p><h3 id="2、方法二">2、方法二</h3><p>可以发现，只有当前行有一个元素大于目标值，那么该元素后面的和下面的就不用看了，也肯定大于元素。相当于暴力法的剪枝操作。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span> [][] array)</span> &#123;<br>    <span class="hljs-comment">// 剪枝    </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>                <span class="hljs-keyword">if</span> (array[i][j] == target)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (array[i][j] &gt; target &amp;&amp; col == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (array[i][j] &gt; target) &#123;<br>                    col = j;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3、方法三">3、方法三</h3><p>首先看四个角，左上与右下必定为最小值与最大值，而左下与右上就有规律了：<strong>左下元素大于它上方的元素，小于它右方的元素，右上元素与之相反</strong>。既然左下角元素有这么一种规律，相当于将要查找的部分分成了一个大区间和小区间，每次与左下角元素比较，我们就知道目标值应该在哪部分中，于是可以利用分治思维来做。</p><p>首先以左下角为起点，若是它小于目标元素，则往右移动去找大的，若是他大于目标元素，则往上移动去找小的。若是移动到了矩阵边界也没找到，说明矩阵中不存在目标值。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span> [][] array)</span> &#123;<br>        <span class="hljs-comment">//优先判断特殊</span><br>        <span class="hljs-keyword">if</span>(array.length == <span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> array.length;<br>        <span class="hljs-keyword">if</span>(array[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">//从最左下角的元素开始往左或往上</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; m; )&#123;<br>            <span class="hljs-comment">//元素较大，往上走</span><br>            <span class="hljs-keyword">if</span>(array[i][j] &gt; target)  <br>                i--;<br>            <span class="hljs-comment">//元素较小，往右走</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(array[i][j] &lt; target)<br>                j++;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书笔记</title>
    <link href="/2022/09/27/du-shu-bi-ji/"/>
    <url>/2022/09/27/du-shu-bi-ji/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="b623cffcf457dde8a4a925a5de76f4a67211729d4ba1b0e87bef62f9c2e64917">8f1cbd128789af83855b0654c56affebf269f8ebeab30c7a77e0ad4ee53534abf8127398457cf86c0a224b90ebb981babd3b9be897d78041891daa3f617b8cab38db2f0c759631a4f9efd0d4ab8245ba4a7bbc95f81300c612cd4b417dd90c18c2f1d33e07c6f22142c1f6c0339b43fac635fd6003dc5c96eac2d9c9154950d88ec5127277c234aba901eae0d89636e089f1ea5aad9bb29276f48a4cbd272f9348bc04b52e4c0934df487d08c5d4bbdbc18609161b31bc9b5d227f82f63e6cad564fecd7f44940232104f77c4f87776b435c4d888461eff3c179bb40b2eceb43c359cfa9d316b5f35959cf71140812f656dd0e34e0abdefbae6c8e935303136616c7bcd3f3ae4557753a25aecf793c7851a10d84c1ad923e035a9166126ce6165a746b2af10cc1084861baff6548cfeab4679837e4572ea4be1cbabf72bf4423a3e0e2f5f19d29f9f10282ea04fc5694262a051b1ccfcbd7c0ed58a1b6c0db1d0559bd7cd6c4f219bf2efc3c09d0bc46fe60da3d1199441223587e1e62639384b09630b4d285cf38e5a8c73084ecf0a26246e998e8c90219bfa1fd52525aa73fcde9de5a09c565a3c57e1aa69a13fbd0809424f4e7d367a7373d34976d33b59022effc1b3ca633a6f323756622e56d7bcaa5e0cf088c4ff41b9967ce307568439244dc2845f74dd570960e0c183b117f00ff2c7494c6d922e41e1d15168eee6bc62a6b4fbf200b272144858da49b4752fd88524c6a1a6c89504280af5a2608594867f353c620568e5d0e2e902f989049f34c8b308738e3cbd3d6b339b7c095ae55db010b474c5d16d22cf782254c722bc3b199e07d0a758b79ab381b1311d01b1c769da858b98da8301e0f23b47e04fc2d5090b18e9554f683b7310a547ec15c94951d2570e0d12d6f177a808bde9925a23e47e450d44f7f0f781c2689aa7a480d06b2357e8ea2b95a01c07adda1860efaaeb0aace985527a0a9fa712af992b9dcd912c78169bf9e7018f129a1b2cecf2fecb165f486160922f35688c82eed9cdb34bc10eb2fcd7a756493a0f844d6fd08f9d4014758426820e23847f383b966cde71a04f0f6b87f14a5b8a0fca77557a306e7481979709f5c5c225f0f084bbef65f70be04c0fde7dfbfb1dfc6f14cf44aaf2b5b95c4122686c8065a6977ed355f8f4e648a05cb0ea6dc0643bdc2fc1d2de57dfd4089d7f32a8dd76766df60ee4cfd88e24721f11292f5b1f502f1a72f0497ef36f3c1ac4cb3ee17083248d8c8ca998608701ac0dd8139425e1a9b6f99cf9c3eeac2a06aed83b38a20f73b84b0090a2b8a36c99272737f93885174ab1e87cefdb9a3f2fdffa933e4c795e2adf3903c845ecda24f99e75be87e7b8bf4dbf5ac1226e097ded11ddf7a8f63de1c5e822228fc9b84ed261c449983b82e175c2c5b096d54929dc1c189c73eacd8af898780bd5cca8258fc2cc5abc5b9b369af006f9504e54c82ff73a5298e247417397c5d1c4664a066f1fce2f9801dd32139557941437d8acb596bf3dfd58345e92e9813efdfab7600a35f7013502f6d2cb14539ebe1b0f151ad3920b0917d463a10aceb17a3ff3b8b922f00a09c05d72a5a7a0880e82eaf523458a6d474a2c6e98d0c0c6340f1c9a2c7486af0b97237050ceb7e40c73d0346d79b96ddb3374b14528c391905fd3b7c22b6b58c9f17e7f28404686744d8e9753cf06aca1ca3fcee9142110970d9d602147d4c50501572bbb66203231abffa86dd7d8909e60c3b003addd350272effe4d90625dc7a8d091e8e4ab7c44461419a80cd87dbed723b88a5c4d0d45fef83449c00c943e997f780c3917cd142083e4d7f58f96b78fd4a61b0d666904e9b9e9ed6f9ed65fb799df4820eabc22406f397d783884f0cd8dce42f4ced411fe1f77619708683fbb8672c2d234aa0d81942324cbd0f234622d6776050a137a57025533f1ed330048344113378de2d209a607d61496caf353f958d267f5db13126d8b812ad3139b8a3cafa05ab29488aa907e9f6e8349d9c57cb045aff4d0aaaf20dcd916ff7ffae8cd6a13249c0594c0240e8b170138c56e7536a9ca0becfef3bf9b70fcaa703d9b10359f3d43375a9d419c113fe8cdaebbde1a9930ef2fc0f24b4527ecaa49a1110cd6091463132fbd2abbc880408369060d5c8c69d39a56f98aa26bfef8fd40247b44041b3e57b33afde1865b83360076e6b00b21b5f0722e1b63b5f6a0addc0e2a53bd4ac6161f0fb705dad36ffde6a9ae1e0faabd85586a5b8ee765e473245ad86c1b4edcf809fc70ec8f77a7204c4090fc9048f34d67c8160b1c95c17d2da5af81581cc237b8a760d8e4d048149f3e942fc67ee7cc854a37636bf1b6e04523f3833a492d2849f705e946de1cecf99ad61ad87df6ee1951b63311f031bdc223d2355091ed4ee9ae9d49e0c95fd307a798d749a4fa6c7205411f649e9e6a90282208cfd4e6fcca058a73cee157ab2c60a020ead4bf2550f2e310d2035a303771a7aea9b44af1880659f53c21ed3cd4def1024817f273e980268c34df8ce0c671ce28f25197f907c9076561ae8c7fb3280e2ae4253456cc5cfbf323f72bf400eea4c5d3e0c1a27caea441977e1d347713987c87770b563749621f376713c26500fc16b0aadd86ac88abdf359bc873ea7f8f03a129d71d9963d1d7de394a4671fbf5adb179a2f211a2bca9e66c138e008ff6e80c793ba8e5fcc8624e932865d3f8decf3aadc682ec981171f9938cb177bcb8a3746438d78003b054298fbad9e79e8be90159351cccd96c2aa103e568440863da5b732619bd417bac1ab5ccf81ffca59856b1e144059b40b0ae30b4122202b9cd0763909af9672073cb99034a86ff84a5839f773b41c59ad4565f8eeb645ca911efaf0d0beacd4dab3b7e396b0c5171a4332d002f7e910590fef6c8fe879e7fd83b641ae32aa27adc73d02d4ae3a16ef4bcb376c6171cc76004458e940d02828a37663cf4e34309f52aba8ee30cc624b6d38fd487727a9cd642a9c16314fe91dd48c5d4566c9baf6a3d8ff1db8ae4acc89b2a3aba5bb82bb8526c3687b49ce564769ac0e3d509283f067f036593a4d3370add7239e3fd5e5b3c601b92df1e46a5f9339377b955ed9e58b52aedcf248fbfc2f6c88a5945a721cc2d70d67252e7d70571b66539f811b93c6b8e74e447dad4e63a3fa76c9de17685b5f58539ef6f315632ecff98740d3344f5654f8ae841a294f34b2b80c766d670749d8e31b89814b78801113b14efa0f9f24c669dcb2c93692c00f77ce56b94759adcf4ca3b852ad9033875439288c99a723c0f9b032a554cefbfbbfa63405cdad9b10917dc28dfde6dcb61f344e857caebf1c166145755d0d7429bd3419a801dadc4b4884b7fbed226a76001a2548cdbe63e73c0986e4a74c28ff6e6964e71368c965dc2ef9dd91af4e4f2a4f3f7fcba28eac94c3ac7d851f7bb1255ee28835697e0a6632626ea3f4d27100054d3bb197534fcc0f2dbe868d79f2d7c7a77d5d92e56938ba17fd8d09cfde0f66177a261b61e7d6cac0fbf160f0092f24c1f22702476fa895f2490442717a6d747ee38cb742634a9e527dc128a5bda7e91d2ee0d3fe69c0d4ab0141bf57ccf551cb91b9cce369040a765717b650d3a6f43eceb072e82561f9b8962aa2b71d21fe61882e63371bd56cfa5f52620f673c8c34552e2636b5c4811a81d2d4c246c036b8a988a2dd73f97df70b5bc2e2ff06cac391d69196a40710e30f9f010d5cc6503d6f0b2d81eea1f9f43c0573b601badeb71b421235ff2c4380fd969cf0f2315275fe50185c2f482d149c7170c8bea3f21a12f161a9ce93608c6a76154e9b73ccc10c03e24ed43cdb5f632351be8cbee7cf5e14b2cdeb28ceeb2da842ed0531e42a97bb6997e0430a3fc4a1a74f3b343e4b2e8534e5e277294b95429d21d9df258858af26e6ce94378a7c0e368a52d6d2f3674698da6cac9b3635b3dafbf40895845142c102ce09cbb726722ea63526c143c37e47456d2825b3e6bd1364656104f42ef5509a103bec2f4acb093371c81caf74b23f386914fc7f59b8ccc3da8fe332f0aad11411b8354309a437b1213f2fe52e53d435f209875d80dd36d46f0e7d64cd5b9cb30bc731da8306a951ab82c489aaca1a36c857bb4ca2ae20fbfd942d374184c0cea3d89d9c49635c2b8b36adcd9c680f099434fbf3df68bcb2af7b1bec6754c503b8bc9ce006353f8b686bad96048dabde4fa9edfb3f7b7feb5458e9ce71861a507ca7a90365c55a2bd5becda4bc37d905c3dbd9061ef0a244e1de7eae13f5714b3096b94105754ae5226cee6a9538ee4e0e4fb512df5289f8da7265a1e46f140595fde6155c904ca3928103a51a943d74a796b952ccc03319f2b8aafa65eb9cd2d9a13f8e57f21e47f9b4226bfc0938491b69630bbd43a01c846d46cc8735335c25895c3baf4a1d6ea760870a39277cb9710ef04e5279c1d149f592a0858844f8900ca34b838188c460381db0374f162f075eb370537ca3391d33e4dcbdac0e7d645e94cc9050438290c40966634117393d85031f95e338edbc3e27273b1e0a65e253d0db09b355b838b389d927b240fa3b7861443b3fe416b78c8848d6d84f63e915ba793704d7aebaabb0e857e533d0b006b622328cda30d5ac3a630fd266efaea0f019fc1b1e4169801f9e255e22011c2617ff53f535b93a92845fbfcfa75cffdb64da85ae1650dc5d0822dbec61a812a7f75a70dc4d8630ecafecf036cbc5bb26b195f847cd1b6f2968823fc07770e3b2a167df76ccc66cde0727d03018d361625ee37de06e842248cfdf2573ee88a2c2dacec84a0d48da4793ff06cd3b3747e817c12011672db5791482ea167f00f218c2f10d11157fdb33f6063e9249a924f06050813207aae0b7a20aea84ba1c4109998f46b9b3f278fc301180ec84e65f772be5308039f2e8942a5c15c9e282a42b7b062550b8480723c9773d47bb2b0748543909cdebfbe10fbe5effe14ceefeab561c83097633c1fcb2bd214ce6e162109b9068ac9273f4ecb5754bc0feeb444ace05b2ff3ceb762b78bd2aa7a3744de652ccef6907f18fa7b406bba5f4facc817709604142f08c49fe4804c40e34bd46682fbc4b0ba9d9f6a58790f012fa7c970c62a06275c0cabd07bb5cd2099544b307c06923753d5b787f84ffa8df53cc21d87bce4b83de85762077c7f8887a9cb5d4b8d2b109ee11eb9c97ac108855b7a5c4f08c395db8725e61d6c9f3950020ed40c1c9b571623d059ea94a0de1a51675a4f0959e48480b4c4dbff971610f6f42f36647fad063dfef17d234b2e4c94bed13b0b2a6c1b25abfce422d3f6064ee3928407998b9c792540f86e01731dcf7a7097396644d158749e2d44304a9ec4e87748386f5ba22e3ee9a77c8493276a01cc28797fa48a05951b1f2bce7a20d3bf44c87980cc102e89430c08da49ecbad2218efe778a1550c7790f0253c40aec6f739458e95db8ce84955acb458910071b41bffbecbbd6c1ec6e6812dfe63075e04afbed606f618cdba7ad9faf0ac156d757435c500766bee36fe18eb12e0cc2b78e63e543a2f039776b9f80c4d5cad511a2cc5cd2291e6e8c3c4a9cb0a024ccfdad412956ef32bda5d51677c8b24baba46b25bf0727d55e4384f018f80795e2d06fd38ecd939c613c514e0e25533cb8036c137ef3b3409b466a7249516ae9646ba370fcdf27be6f743f007808e730154fe626400fa6d6dd6f069e0f26b10d239395a2b4509705187de0c2d06e43163f6fde20f0f2ef7be8e72a7515a72f7e9df35fb6750918a748604811106dfd2c7efd486d4b94bb284bfaef066c294e57ac97011e62c6c5e1fb014a0bc0b13528c005c077f050662bb0fd91f1b47505dfdccd310a4ecae18fe454220717722a85de92d9a0f5551f26e48b4f92e310bbff9bf0aa9ff7ff05879fb390476fd96412eaed9997e1f95c9dfc12211712233fef8d1fbf84911ac266c5b3a22ef382de5f6c193479ca739eb26bbc5b1a84e7f6c1619e08fc8d3233a983d499af4469fc4a99d4117ea033ed16a68280620a01261800c4298a3cd9b2f7d20c3b44862bfef4075f9e402a86a7548076d68d3650f8bf5ca3884e997a0db7ba2592f813dedb8e3c45c966edc5e4f56e22c9534152e5feea978fc17b40513c2a381f51e3a489159045b74f456d9177e5df3cab76b2beda259f56f437e172ec47fe907458e6a25f7b439e2686bfdba2bb08a2bde960ae64f3328ab6ef0b19ae7843d7ba228192d49ad79fae69d221f4f032a14cbd01508c9106f39b7c2c0377b03e32fcde71c1f012332f3420c98b32860cf555695caa2a3532057ee651a5814d4369f116f46da4798ac60bde59cf9ed455e8b4bdaecbf02eb8d4e603d2a745428a647e82c706911a4e1292d74611b646c84bf0227784386c4ff0de0b68b008527e27ed2350a3e47e651c0c7d53caad98e3beb2d513a7270b0cb5c14de1184ca25606c16807312253e42647809f66362250096aa3ad04650c13bce6eac9f4357098873ed8aa2dbd2e70faf1e2fc4c3f07f6dd288a1137ba5c876a592ef86055b1237062315a27ba97c9990dfa9789d8bbd1054148ad2642b0346f8309e3034df8e225bde76558740f7b746a8f350441c7c21e0f3d93d7da3cf852b4579f435c20094a0ff58818e6a12023583daee9fcd9be4cfdb8140b2e784e794e8f97d9ef029062950b20d1c296e6c636e58772758c4858ce4d92bd75e2c29a5bacdcbf693ee0b6588fc80f83207775569820af8d045aaf0ec953c8513509088181a3f22c2eea418f0a473d81a232ecdea3233ac</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02-创建型-工厂&amp;建造者&amp;原型</title>
    <link href="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/"/>
    <url>/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/</url>
    
    <content type="html"><![CDATA[<h2 id="一、工厂模式【常用】"><a href="#一、工厂模式【常用】" class="headerlink" title="一、工厂模式【常用】"></a>一、工厂模式【常用】</h2><ol><li>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。</li><li>在这三种细分的工厂模式中，简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。所以，重点是前两种工厂模式。对于抽象工厂，稍微了解一下即可。</li></ol><h3 id="1、简单工厂"><a href="#1、简单工厂" class="headerlink" title="1、简单工厂"></a>1、简单工厂</h3><p>什么是简单工厂模式？</p><p>简单来说，就是定义一个工厂类，它可以根据不同的参数返回不同类的实例，被创建的实例通常都具有共同的父类。</p><p>通过一个例子来解释一下简单工厂。在下面这段代码中，我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>  <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<br>             <span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>    <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>    <span class="hljs-keyword">return</span> ruleConfig;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>    <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及 parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。重构之后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> createParser(ruleConfigFileExtension);<br>    <span class="hljs-keyword">if</span> (parser == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<br>              <span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>    <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>    <span class="hljs-keyword">return</span> ruleConfig;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>    <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">(String configFormat)</span> &#123;<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> parser;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了让类的职责更加单一(<strong>设计模式原则中的单一职责</strong>，)、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>  <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> RuleConfigParserFactory.createParser(ruleConfigFileExtension);<br>    <span class="hljs-keyword">if</span> (parser == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<br>              <span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>    <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>    <span class="hljs-keyword">return</span> ruleConfig;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>    <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigParserFactory</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">(String configFormat)</span> &#123;<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> parser;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。</li><li>实际上，如果 parser 可以复用，为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。在接下来的讲解中，我们把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作简单工厂模式的第二种实现方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigParserFactory</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">static</span> &#123;<br>    cachedParsers.put(<span class="hljs-string">&quot;json&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>());<br>    cachedParsers.put(<span class="hljs-string">&quot;xml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>());<br>    cachedParsers.put(<span class="hljs-string">&quot;yaml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>());<br>    cachedParsers.put(<span class="hljs-string">&quot;properties&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>());<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">(String configFormat)</span> &#123;<br>    <span class="hljs-keyword">if</span> (configFormat == <span class="hljs-literal">null</span> || configFormat.isEmpty()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//返回null还是IllegalArgumentException全凭你自己说了算</span><br>    &#125;<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> cachedParsers.get(configFormat.toLowerCase());<br>    <span class="hljs-keyword">return</span> parser;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>对于上面两种简单工厂模式的实现方法，如果我们要添加新的 parser，那势必要改动到 RuleConfigParserFactory 的代码，那这是不是违反开闭原则呢？实际上，如果不是需要频繁地添加新的 parser，只是偶尔修改一下 RuleConfigParserFactory 代码，稍微不符合开闭原则，也是完全可以接受的。</li><li>除此之外，在 RuleConfigParserFactory 的第一种代码实现中，有一组 if 分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？实际上，如果 if 分支并不是很多，代码中有 if 分支也是完全可以接受的。应用多态或设计模式来替代 if 分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合<strong>开闭原则</strong>，但也增加了类的个数，牺牲了代码的可读性。</li></ol><h3 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h3><p>看一个需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪pizza、 北京的胡椒pizza 或者是伦敦的奶酪pizza、伦敦的胡椒pizza。</p><p>如何实现？</p><p>思路一：使用简单工厂模式，创建不同的简单工厂类，比如BJPizzaSimpleFactory、 LDPizzaSimpleFactory 等等.从当前这个案例来说，也是可以的，但是考虑到项目的 规模，以及软件的可维护性、可扩展性并不是特别好</p><p>思路二：使用工厂模式</p><p>工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点 餐子类中具体实现。 </p><p>工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。</p><p>再接着上述简单工厂模式的例子，若是非要去掉if呢，怎么办？将代码重构后，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>  IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YamlRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PropertiesRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模式比起简单工厂模式更加符合开闭原则。</p><p>但是上述代码存在很大的问题。问题存在于这些工厂类的使用上。接下来，我们看一下，如何用这些工厂类来实现 RuleConfigSource 的 load() 函数。具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>  <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br><br>    <span class="hljs-type">IRuleConfigParserFactory</span> <span class="hljs-variable">parserFactory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parserFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParserFactory</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parserFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParserFactory</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parserFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParserFactory</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parserFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParserFactory</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);<br>    &#125;<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> parserFactory.createParser();<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>    <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>    <span class="hljs-keyword">return</span> ruleConfig;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>    <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 load() 函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。</li><li>我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。这段话听起来有点绕，代码实现出来，一看就能明白。其中，RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，getParserFactory() 返回的是缓存好的单例工厂对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>  <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br><br>    <span class="hljs-type">IRuleConfigParserFactory</span> <span class="hljs-variable">parserFactory</span> <span class="hljs-operator">=</span> RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);<br>    <span class="hljs-keyword">if</span> (parserFactory == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);<br>    &#125;<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> parserFactory.createParser();<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>    <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>    <span class="hljs-keyword">return</span> ruleConfig;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>    <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//因为工厂类只包含方法，不包含成员变量，完全可以复用，</span><br><span class="hljs-comment">//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigParserFactoryMap</span> &#123; <span class="hljs-comment">//工厂的工厂</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">static</span> &#123;<br>    cachedFactories.put(<span class="hljs-string">&quot;json&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParserFactory</span>());<br>    cachedFactories.put(<span class="hljs-string">&quot;xml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParserFactory</span>());<br>    cachedFactories.put(<span class="hljs-string">&quot;yaml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParserFactory</span>());<br>    cachedFactories.put(<span class="hljs-string">&quot;properties&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParserFactory</span>());<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IRuleConfigParserFactory <span class="hljs-title function_">getParserFactory</span><span class="hljs-params">(String type)</span> &#123;<br>    <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span> || type.isEmpty()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-type">IRuleConfigParserFactory</span> <span class="hljs-variable">parserFactory</span> <span class="hljs-operator">=</span> cachedFactories.get(type.toLowerCase());<br>    <span class="hljs-keyword">return</span> parserFactory;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则。</li><li>实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性，而且，每个 Factory 类只是做简单的 new 操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。</li></ol><p>问题来了：什么时候用简单工厂模式，什么时候用工厂模式？</p><ol><li>前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。</li><li>基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</li><li>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。</li></ol><h3 id="3、抽象工厂"><a href="#3、抽象工厂" class="headerlink" title="3、抽象工厂"></a>3、抽象工厂</h3><p>抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类 </p><p>抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。</p><p>从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。 </p><p>将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以 根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇， 更利于代码的维护和扩展。</p><p>抽象工厂没有前两者常用，简单了解即可。</p><p>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">针对规则配置的解析器：基于接口IRuleConfigParser<br>JsonRuleConfigParser<br>XmlRuleConfigParser<br>YamlRuleConfigParser<br>PropertiesRuleConfigParser<br><br>针对系统配置的解析器：基于接口ISystemConfigParser<br>JsonSystemConfigParser<br>XmlSystemConfigParser<br>YamlSystemConfigParser<br>PropertiesSystemConfigParser<br></code></pre></td></tr></table></figure><ol><li>针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编写一个工厂类，也就是要编写 8 个工厂类。如果我们未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。而我们知道，过多的类也会让系统难维护。这个问题该怎么解决呢？</li><li>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IConfigParserFactory</span> &#123;<br>  IRuleConfigParser <span class="hljs-title function_">createRuleParser</span><span class="hljs-params">()</span>;<br>  ISystemConfigParser <span class="hljs-title function_">createSystemParser</span><span class="hljs-params">()</span>;<br>  <span class="hljs-comment">//此处可以扩展新的parser类型，比如IBizConfigParser</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IConfigParserFactory</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createRuleParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> ISystemConfigParser <span class="hljs-title function_">createSystemParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonSystemConfigParser</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IConfigParserFactory</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createRuleParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> ISystemConfigParser <span class="hljs-title function_">createSystemParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlSystemConfigParser</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span><br></code></pre></td></tr></table></figure><h3 id="4、DI容器"><a href="#4、DI容器" class="headerlink" title="4、DI容器"></a>4、DI容器</h3><p>当创建对象是一个“大工程”的时候，我们一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。那何为“大工程”呢？上面我们讲了两种情况，一种是创建过程涉及复杂的 if-else 分支判断，另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程。</p><p>今天，我们再来讲一个创建对象的“大工程”，依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称 DI 容器。</p><p>DI 容器跟我们讲的工厂模式又有何区别和联系？DI 容器的核心功能有哪些，以及如何实现一个简单的 DI 容器？</p><h4 id="1、工厂模式和DI容器有何区别"><a href="#1、工厂模式和DI容器有何区别" class="headerlink" title="1、工厂模式和DI容器有何区别"></a>1、工厂模式和DI容器有何区别</h4><ol><li>实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</li><li>DI 容器相对于我们上面讲的工厂模式的例子来说，它处理的是更大的对象创建工程。上面讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。</li><li>除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。接下来，我们就详细讲讲，一个简单的 DI 容器应该包含哪些核心功能。</li></ol><h4 id="2、DI容器的核心功能"><a href="#2、DI容器的核心功能" class="headerlink" title="2、DI容器的核心功能"></a>2、DI容器的核心功能</h4><p>一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。</p><blockquote><p>配置解析</p></blockquote><ol><li>在上面讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，我们需要通过一种形式，让应用告知 DI 容器要创建哪些对象。这种形式就是我们要讲的配置。</li><li>我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。</li><li>下面是一个典型的 Spring 容器的配置文件。Spring 容器读取这个配置文件，解析出要创建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：rateLimiter 依赖 redisCounter。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiter</span> &#123;<br>  <span class="hljs-keyword">private</span> RedisCounter redisCounter;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">RateLimiter</span><span class="hljs-params">(RedisCounter redisCounter)</span> &#123;<br>    <span class="hljs-built_in">this</span>.redisCounter = redisCounter;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisCounter</span> &#123;<br>  <span class="hljs-keyword">private</span> String ipAddress;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisCounter</span><span class="hljs-params">(String ipAddress, <span class="hljs-type">int</span> port)</span> &#123;<br>    <span class="hljs-built_in">this</span>.ipAddress = ipAddress;<br>    <span class="hljs-built_in">this</span>.port = port;<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br>配置文件beans.xml：<br>&lt;beans&gt;<br>   &lt;bean id=<span class="hljs-string">&quot;rateLimiter&quot;</span> class=<span class="hljs-string">&quot;com.zb.RateLimiter&quot;</span>&gt;<br>      &lt;constructor-arg ref=<span class="hljs-string">&quot;redisCounter&quot;</span>/&gt;<br>   &lt;/bean&gt;<br> <br>   &lt;bean id=<span class="hljs-string">&quot;redisCounter&quot;</span> class=<span class="hljs-string">&quot;com.zb.redisCounter&quot;</span>&gt;<br>     &lt;constructor-arg type=<span class="hljs-string">&quot;String&quot;</span> value=<span class="hljs-string">&quot;127.0.0.1&quot;</span>&gt;<br>     &lt;constructor-arg type=<span class="hljs-string">&quot;int&quot;</span> value=<span class="hljs-number">1234</span>&gt;<br>   &lt;/bean&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><blockquote><p>对象创建</p></blockquote><ol><li>在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。</li><li>你可能会说，如果要创建的类对象非常多，BeansFactory 中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）呢？实际上并不会。待会讲到 DI 容器的具体实现的时候，我们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。</li></ol><blockquote><p>对象的声明周期管理</p></blockquote><ol><li>上面我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope=prototype 表示返回新创建的对象，scope=singleton 表示返回单例对象。</li><li>除此之外，我们还可以配置对象是否支持懒加载。如果 lazy-init=true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好。</li><li>不仅如此，我们还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。</li></ol><h3 id="5、实现简单的DI容器"><a href="#5、实现简单的DI容器" class="headerlink" title="5、实现简单的DI容器"></a>5、实现简单的DI容器</h3><p>用 Java 语言来实现一个简单的 DI 容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象。</p><h4 id="1、最小原型设计"><a href="#1、最小原型设计" class="headerlink" title="1、最小原型设计"></a>1、最小原型设计</h4><p>因为我们主要是讲解设计模式，所以，在今天的讲解中，我们只实现一个 DI 容器的最小原型。像 Spring 框架这样的 DI 容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">配置文件beans.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rateLimiter&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zb.RateLimiter&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;redisCounter&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;redisCounter&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zb.redisCounter&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span> <span class="hljs-attr">lazy-init</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;127.0.0.1&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">1234</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>&lt;/bean<br></code></pre></td></tr></table></figure><p>最小原型的使用方式跟 Spring 框架非常类似，示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<br>            <span class="hljs-string">&quot;beans.xml&quot;</span>);<br>    <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> (RateLimiter) applicationContext.getBean(<span class="hljs-string">&quot;rateLimiter&quot;</span>);<br>    rateLimiter.test();<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、提供执行入口"><a href="#2、提供执行入口" class="headerlink" title="2、提供执行入口"></a>2、提供执行入口</h4><p>面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类。通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext 和 ClassPathXmlApplicationContext。其中，ApplicationContext 是接口，ClassPathXmlApplicationContext 是接口的实现类。两个类具体实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApplicationContext</span> &#123;<br>  Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanId)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContext</span> &#123;<br>  <span class="hljs-keyword">private</span> BeansFactory beansFactory;<br>  <span class="hljs-keyword">private</span> BeanConfigParser beanConfigParser;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPathXmlApplicationContext</span><span class="hljs-params">(String configLocation)</span> &#123;<br>    <span class="hljs-built_in">this</span>.beansFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeansFactory</span>();<br>    <span class="hljs-built_in">this</span>.beanConfigParser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanConfigParser</span>();<br>    loadBeanDefinitions(configLocation);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(String configLocation)</span> &#123;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      in = <span class="hljs-built_in">this</span>.getClass().getResourceAsStream(<span class="hljs-string">&quot;/&quot;</span> + configLocation);<br>      <span class="hljs-keyword">if</span> (in == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Can not find config file: &quot;</span> + configLocation);<br>      &#125;<br>      List&lt;BeanDefinition&gt; beanDefinitions = beanConfigParser.parse(in);<br>      beansFactory.addBeanDefinitions(beanDefinitions);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">if</span> (in != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          in.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> log error</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanId)</span> &#123;<br>    <span class="hljs-keyword">return</span> beansFactory.getBean(beanId);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的代码中，我们可以看出，ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程：从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后，BeansFactory 根据 BeanDefinition 来创建对象。</p><h4 id="3、配置文件解析"><a href="#3、配置文件解析" class="headerlink" title="3、配置文件解析"></a>3、配置文件解析</h4><p>配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。配置文件的解析比较繁琐，不涉及我们要讲的理论知识，不是我们讲解的重点，所以这里我只给出两个类的大致设计思路，并未给出具体的实现代码。具体的代码框架如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanConfigParser</span> &#123;<br>  List&lt;BeanDefinition&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(InputStream inputStream)</span>;<br>  List&lt;BeanDefinition&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(String configContent)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlBeanConfigParser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanConfigParser</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> List&lt;BeanDefinition&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(InputStream inputStream)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>...</span><br>    <span class="hljs-keyword">return</span> parse(content);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> List&lt;BeanDefinition&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(String configContent)</span> &#123;<br>    List&lt;BeanDefinition&gt; beanDefinitions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>...</span><br>    <span class="hljs-keyword">return</span> beanDefinitions;<br>  &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanDefinition</span> &#123;<br>  <span class="hljs-keyword">private</span> String id;<br>  <span class="hljs-keyword">private</span> String className;<br>  <span class="hljs-keyword">private</span> List&lt;ConstructorArg&gt; constructorArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">Scope</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> Scope.SINGLETON;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">lazyInit</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// 省略必要的getter/setter/constructors</span><br> <br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> scope.equals(Scope.SINGLETON);<br>  &#125;<br><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Scope</span> &#123;<br>    SINGLETON,<br>    PROTOTYPE<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstructorArg</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isRef;<br>    <span class="hljs-keyword">private</span> Class type;<br>    <span class="hljs-keyword">private</span> Object arg;<br>    <span class="hljs-comment">// 省略必要的getter/setter/constructors</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、核心工厂类设计"><a href="#4、核心工厂类设计" class="headerlink" title="4、核心工厂类设计"></a>4、核心工厂类设计</h4><ol><li>最后，我们来看，BeansFactory 是如何设计和实现的。这也是我们这个 DI 容器最核心的一个类了。它负责根据从配置文件解析得到的 BeanDefinition 来创建对象。</li><li>如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中，下次再请求此对象的时候，直接从 map 中取出返回，不需要重新创建。如果对象的 scope 属性是 prototype，那每次请求对象，BeansFactory 都会创建一个新的对象返回。</li><li>实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的==反射==语法：<code>一种动态加载类和创建对象的机制</code>。我们知道，JVM 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 帮我们自动完成了，我们需要利用 Java 提供的反射语法自己去编写代码。</li><li>搞清楚了反射的原理，BeansFactory 的代码就不难看懂了。具体代码实现如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeansFactory</span> &#123;<br>  <span class="hljs-keyword">private</span> ConcurrentHashMap&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBeanDefinitions</span><span class="hljs-params">(List&lt;BeanDefinition&gt; beanDefinitionList)</span> &#123;<br>    <span class="hljs-keyword">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;<br>      <span class="hljs-built_in">this</span>.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;<br>      <span class="hljs-keyword">if</span> (beanDefinition.isLazyInit() == <span class="hljs-literal">false</span> &amp;&amp; beanDefinition.isSingleton()) &#123;<br>        createBean(beanDefinition);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanId)</span> &#123;<br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> beanDefinitions.get(beanId);<br>    <span class="hljs-keyword">if</span> (beanDefinition == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchBeanDefinitionException</span>(<span class="hljs-string">&quot;Bean is not defined: &quot;</span> + beanId);<br>    &#125;<br>    <span class="hljs-keyword">return</span> createBean(beanDefinition);<br>  &#125;<br><br>  <span class="hljs-meta">@VisibleForTesting</span><br>  <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(BeanDefinition beanDefinition)</span> &#123;<br>    <span class="hljs-keyword">if</span> (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;<br>      <span class="hljs-keyword">return</span> singletonObjects.get(beanDefinition.getId());<br>    &#125;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">Class</span> <span class="hljs-variable">beanClass</span> <span class="hljs-operator">=</span> Class.forName(beanDefinition.getClassName());<br>      List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs();<br>      <span class="hljs-keyword">if</span> (args.isEmpty()) &#123;<br>        bean = beanClass.newInstance();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        Class[] argClasses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[args.size()];<br>        Object[] argObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[args.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.size(); ++i) &#123;<br>          BeanDefinition.<span class="hljs-type">ConstructorArg</span> <span class="hljs-variable">arg</span> <span class="hljs-operator">=</span> args.get(i);<br>          <span class="hljs-keyword">if</span> (!arg.getIsRef()) &#123;<br>            argClasses[i] = arg.getType();<br>            argObjects[i] = arg.getArg();<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">refBeanDefinition</span> <span class="hljs-operator">=</span> beanDefinitions.get(arg.getArg());<br>            <span class="hljs-keyword">if</span> (refBeanDefinition == <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchBeanDefinitionException</span>(<span class="hljs-string">&quot;Bean is not defined: &quot;</span> + arg.getArg());<br>            &#125;<br>            argClasses[i] = Class.forName(refBeanDefinition.getClassName());<br>            argObjects[i] = createBean(refBeanDefinition);<br>          &#125;<br>        &#125;<br>        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | IllegalAccessException<br>            | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationFailureException</span>(<span class="hljs-string">&quot;&quot;</span>, e);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span> &amp;&amp; beanDefinition.isSingleton()) &#123;<br>      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);<br>      <span class="hljs-keyword">return</span> singletonObjects.get(beanDefinition.getId());<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>执行入口那里调用<code>addBeanDefinitions</code></li><li>然后<code>addBeanDefinitions</code>再调用createBean利用反射创建对象，如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中</li><li>最后最小原型设计那里再调用getBean从singletonObjects 获取对象。</li></ol><h2 id="二、建造者模式【常用】"><a href="#二、建造者模式【常用】" class="headerlink" title="二、建造者模式【常用】"></a>二、建造者模式【常用】</h2><p>建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。比如，有没有考虑过这样几个问题：直接使用构造函数或者配合 set 方法就能创建对象，为什么还需要建造者模式来创建呢？建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？</p><p>基本介绍： 建造者模式（Builder Pattern） 又叫生成器模式，是一种对象构建模式。它可以 将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方 法可以构造出不同表现（属性）的对象。建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象 的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p><h3 id="1、为何需要建造者模式？"><a href="#1、为何需要建造者模式？" class="headerlink" title="1、为何需要建造者模式？"></a>1、为何需要建造者模式？</h3><ol><li>在平时的开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。但是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？</li><li>假设有这样一道设计面试题：我们需要定义一个资源池配置类 ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个 ResourcePoolConfig 类。</li></ol><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923155455175.png"></p><p>只要稍微有点开发经验，那实现这样一个类并不是件难事。最常见、最容易想到的实现思路如下代码所示。因为 maxTotal、maxIdle、minIdle 不是必填变量，所以在创建 ResourcePoolConfig 对象的时候，我们通过往构造函数中，给这几个参数传递 null 值，来表示使用默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourcePoolConfig</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_TOTAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MIN_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxTotal</span> <span class="hljs-operator">=</span> DEFAULT_MAX_TOTAL;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxIdle</span> <span class="hljs-operator">=</span> DEFAULT_MAX_IDLE;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">minIdle</span> <span class="hljs-operator">=</span> DEFAULT_MIN_IDLE;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourcePoolConfig</span><span class="hljs-params">(String name, Integer maxTotal, Integer maxIdle, Integer minIdle)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;name should not be empty.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.name = name;<br><br>    <span class="hljs-keyword">if</span> (maxTotal != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (maxTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxTotal should be positive.&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.maxTotal = maxTotal;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (maxIdle != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (maxIdle &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxIdle should not be negative.&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.maxIdle = maxIdle;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (minIdle != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (minIdle &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;minIdle should not be negative.&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.minIdle = minIdle;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//...省略getter方法...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在，ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 bug。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 参数太多，导致可读性差、参数可能传递错误</span><br><span class="hljs-type">ResourcePoolConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcePoolConfig</span>(<span class="hljs-string">&quot;dbconnectionpool&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">8</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span> , <span class="hljs-literal">true</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>，<span class="hljs-literal">false</span>， <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>解决这个问题的办法应该也已经想到了，那就是用 set() 函数来给成员变量赋值，以替代冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项 name 是必填的，所以我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 maxTotal、maxIdle、minIdle 都不是必填的，所以我们通过 set() 函数来设置，让使用者自主选择填写或者不填写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourcePoolConfig</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_TOTAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MIN_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxTotal</span> <span class="hljs-operator">=</span> DEFAULT_MAX_TOTAL;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxIdle</span> <span class="hljs-operator">=</span> DEFAULT_MAX_IDLE;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">minIdle</span> <span class="hljs-operator">=</span> DEFAULT_MIN_IDLE;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourcePoolConfig</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;name should not be empty.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMaxTotal</span><span class="hljs-params">(<span class="hljs-type">int</span> maxTotal)</span> &#123;<br>    <span class="hljs-keyword">if</span> (maxTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxTotal should be positive.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.maxTotal = maxTotal;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMaxIdle</span><span class="hljs-params">(<span class="hljs-type">int</span> maxIdle)</span> &#123;<br>    <span class="hljs-keyword">if</span> (maxIdle &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxIdle should not be negative.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.maxIdle = maxIdle;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMinIdle</span><span class="hljs-params">(<span class="hljs-type">int</span> minIdle)</span> &#123;<br>    <span class="hljs-keyword">if</span> (minIdle &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;minIdle should not be negative.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.minIdle = minIdle;<br>  &#125;<br>  <span class="hljs-comment">//...省略getter方法...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们来看新的 ResourcePoolConfig 类该如何使用。我写了一个示例代码，如下所示。没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ResourcePoolConfig使用举例</span><br><span class="hljs-type">ResourcePoolConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcePoolConfig</span>(<span class="hljs-string">&quot;dbconnectionpool&quot;</span>);<br>config.setMaxTotal(<span class="hljs-number">16</span>);<br>config.setMaxIdle(<span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><p>至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过 set() 方法设置可选配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。</p><ul><li>我们刚刚讲到，name 是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。</li><li>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。</li><li>如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。</li></ul><p>为了解决这些问题，建造者模式就派上用场了。我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了。我们用建造者模式重新实现了上面的需求，具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourcePoolConfig</span> &#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxTotal;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxIdle;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> minIdle;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">ResourcePoolConfig</span><span class="hljs-params">(Builder builder)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = builder.name;<br>    <span class="hljs-built_in">this</span>.maxTotal = builder.maxTotal;<br>    <span class="hljs-built_in">this</span>.maxIdle = builder.maxIdle;<br>    <span class="hljs-built_in">this</span>.minIdle = builder.minIdle;<br>  &#125;<br>  <span class="hljs-comment">//...省略getter方法...</span><br><br>  <span class="hljs-comment">//我们将Builder类设计成了ResourcePoolConfig的内部类。</span><br>  <span class="hljs-comment">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_TOTAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MIN_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxTotal</span> <span class="hljs-operator">=</span> DEFAULT_MAX_TOTAL;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxIdle</span> <span class="hljs-operator">=</span> DEFAULT_MAX_IDLE;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">minIdle</span> <span class="hljs-operator">=</span> DEFAULT_MIN_IDLE;<br><br>    <span class="hljs-keyword">public</span> ResourcePoolConfig <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span><br>      <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (maxIdle &gt; maxTotal) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcePoolConfig</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>      <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.name = name;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setMaxTotal</span><span class="hljs-params">(<span class="hljs-type">int</span> maxTotal)</span> &#123;<br>      <span class="hljs-keyword">if</span> (maxTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.maxTotal = maxTotal;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setMaxIdle</span><span class="hljs-params">(<span class="hljs-type">int</span> maxIdle)</span> &#123;<br>      <span class="hljs-keyword">if</span> (maxIdle &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.maxIdle = maxIdle;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setMinIdle</span><span class="hljs-params">(<span class="hljs-type">int</span> minIdle)</span> &#123;<br>      <span class="hljs-keyword">if</span> (minIdle &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.minIdle = minIdle;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span><br><span class="hljs-type">ResourcePoolConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcePoolConfig</span>.Builder()<br>        .setName(<span class="hljs-string">&quot;dbconnectionpool&quot;</span>)<br>        .setMaxTotal(<span class="hljs-number">16</span>)<br>        .setMaxIdle(<span class="hljs-number">10</span>)<br>        .setMinIdle(<span class="hljs-number">12</span>)<br>        .build();<br></code></pre></td></tr></table></figure><p>实际上，使用建造者模式创建对象，还可以避免对象存在无效状态。无效状态是指对象没有实例化完全，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Rectangle</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectange</span>(); <span class="hljs-comment">// r is invalid</span><br>r.setWidth(<span class="hljs-number">2</span>); <span class="hljs-comment">// r is invalid</span><br>r.setHeight(<span class="hljs-number">3</span>); <span class="hljs-comment">// r is valid</span><br></code></pre></td></tr></table></figure><ol><li>为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。==(建造者主要解决参数过多、参数检验、控制对象创建后不可变的问题)==</li><li>实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露 set() 方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍。</li></ol><h3 id="2、与工厂模式有何区别？"><a href="#2、与工厂模式有何区别？" class="headerlink" title="2、与工厂模式有何区别？"></a>2、与工厂模式有何区别？</h3><ol><li>从上面的讲解中，我们可以看出，建造者模式是让建造者类来负责对象的创建工作。上面讲到的工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？</li><li>实际上，工厂模式是用来<code>创建不同但是相关类型的对象</code>（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建<code>一种类型的复杂对象</code>，通过设置不同的可选参数，“定制化”地创建不同的对象。</li></ol><p>网上有一个经典的例子很好地解释了两者的区别:</p><blockquote><p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p></blockquote><h2 id="三、原型模式【不常用】"><a href="#三、原型模式【不常用】" class="headerlink" title="三、原型模式【不常用】"></a>三、原型模式【不常用】</h2><p>现有如下需求：现在有一只羊tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和tom 羊 属性完全相同的10只羊。</p><p>思路：Java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以 将一个Java对象复制一份，但是需要实现clone的Java类必须要实现一个接口Cloneable， 该接口表示该类能够复制且具有复制的能力 =&gt; 原型模式</p><h3 id="1、原型模式原理与应用"><a href="#1、原型模式原理与应用" class="headerlink" title="1、原型模式原理与应用"></a>1、原型模式原理与应用</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。</p><ol><li>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。</li><li>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</li></ol><blockquote><p>举个例子</p></blockquote><ol><li>假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建立一个散列表索引。</li><li>如果你熟悉的是 Java 语言，可以直接使用语言中提供的 HashMap 容器来实现。其中，HashMap 的 key 为搜索关键词，value 为关键词详细信息（比如搜索次数）。我们只需要将数据从数据库中读取出来，放入 HashMap 就可以了。</li><li>不过，我们还有另外一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对 v2 版本的数据进行更新，得到 v3 版本的数据。这里我们假设只有更新和新添关键词，没有删除关键词的行为。</li></ol><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923164243728.png"></p><ol><li>为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统 A 需要定期根据数据库中的数据，更新内存中的索引和数据。</li><li>我们该如何实现这个需求呢？实际上，也不难。我们只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta，从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是找出 Va 版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散列表中。</li><li>按照这个设计思路，我给出的示例代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">private</span> ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastUpdateTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到currentKeywords中</span><br>    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">maxNewUpdatedTime</span> <span class="hljs-operator">=</span> lastUpdateTime;<br>    <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>      <span class="hljs-keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;<br>        maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>      &#125;<br>      <span class="hljs-keyword">if</span> (currentKeywords.containsKey(searchWord.getKeyword())) &#123;<br>        currentKeywords.replace(searchWord.getKeyword(), searchWord);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        currentKeywords.put(searchWord.getKeyword(), searchWord);<br>      &#125;<br>    &#125;<br><br>    lastUpdateTime = maxNewUpdatedTime;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">(<span class="hljs-type">long</span> lastUpdateTime)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，现在，我们有一个特殊的要求：任何时刻，系统 A 中的所有数据都必须是同一个版本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。那刚刚的更新方式就不能满足这个要求了（因为数据很多，一个一个的for循环肯定会出现不同数据版本的问题）。除此之外，我们还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据。</p><ol><li>那我们该如何实现现在这个需求呢？</li><li>实际上，也不难。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在。</li><li>按照这个设计思路，示例代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>    HashMap&lt;String, SearchWord&gt; newKeywords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 从数据库中取出所有的数据，放入到newKeywords中</span><br>    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords();<br>    <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>      newKeywords.put(searchWord.getKeyword(), searchWord);<br>    &#125;<br><br>    currentKeywords = newKeywords;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出所有的数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>不过，在上面的代码实现中，newKeywords 构建的成本比较高。我们需要将这 10 万条数据从数据库中读出，然后计算哈希值，构建 newKeywords。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了。</li><li>我们拷贝 currentKeywords 数据到 newKeywords 中，然后从数据库中只捞出新增或者有更新的关键词，更新到 newKeywords 中。而相对于 10 万条数据来说，每次新增或者更新的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。</li><li>按照这个设计思路，我给出的示例代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastUpdateTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 原型模式就这么简单，拷贝已有对象的数据，更新少量差值</span><br>    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();<br><br>    <span class="hljs-comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br>    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">maxNewUpdatedTime</span> <span class="hljs-operator">=</span> lastUpdateTime;<br>    <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>      <span class="hljs-keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;<br>        maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>      &#125;<br>      <span class="hljs-keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;<br>        <span class="hljs-type">SearchWord</span> <span class="hljs-variable">oldSearchWord</span> <span class="hljs-operator">=</span> newKeywords.get(searchWord.getKeyword());<br>        oldSearchWord.setCount(searchWord.getCount());<br>        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        newKeywords.put(searchWord.getKeyword(), searchWord);<br>      &#125;<br>    &#125;<br><br>    lastUpdateTime = maxNewUpdatedTime;<br>    currentKeywords = newKeywords;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">(<span class="hljs-type">long</span> lastUpdateTime)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>这里利用了 Java 中的 clone() 语法来复制一个对象。如果你熟悉的语言没有这个语法，那把数据从 currentKeywords 中一个个取出来，然后再重新计算哈希值，放入到 newKeywords 中也是可以接受的。毕竟，最耗时的还是从数据库中取数据的操作。相对于数据库的 IO 操作来说，内存操作和 CPU 计算的耗时都是可以忽略的。</li><li>不过，不知道你有没有发现，实际上，刚刚的代码实现是有问题的。要弄明白到底有什么问题，我们需要先了解另外两个概念：深拷贝（Deep Copy）和浅拷贝（Shallow Copy）。</li></ol><h3 id="2、原型模式的实现方式：深拷贝与浅拷贝"><a href="#2、原型模式的实现方式：深拷贝与浅拷贝" class="headerlink" title="2、原型模式的实现方式：深拷贝与浅拷贝"></a>2、原型模式的实现方式：深拷贝与浅拷贝</h3><blockquote><p>拷贝的引入</p></blockquote><p>1、引用拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;Taylor&quot;</span>,<span class="hljs-number">26</span>);<br><span class="hljs-type">Teacher</span> <span class="hljs-variable">otherteacher</span> <span class="hljs-operator">=</span> teacher;<br>System.out.println(teacher);<br>System.out.println(otherteacher);<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">blog.Teacher@355da254<br>blog.Teacher@355da254<br></code></pre></td></tr></table></figure><p>由输出结果可以看出，二者的地址值是相同的，那么肯定就是同一个对象，teacher和otherteacher只是不同的引用而已。</p><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923165539504.png" alt="引用拷贝"></p><p>2、对象拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;Swift&quot;</span>,<span class="hljs-number">26</span>);<br><span class="hljs-type">Teacher</span> <span class="hljs-variable">otherteacher</span> <span class="hljs-operator">=</span> (Teacher)teacher.clone();<br>System.out.println(teacher);<br>System.out.println(otherteacher);<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">blog.Teacher@355da254<br>blog.Teacher@4dc63996<br></code></pre></td></tr></table></figure><p>由结果可以看出，地址值不同，也就是说二者是不同的对象，而不是把原对象的地址赋给了一个新的引用变量,这就叫做对象拷贝。</p><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923165730368.png" alt="对象拷贝"></p><p>==注：深拷贝和浅拷贝都是对象拷贝==</p><blockquote><p>浅拷贝</p></blockquote><ul><li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值拷贝，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据</li><li>对于数据类型是引用数据类型的成员变量(也就是子对象，或者数组啥的)，也就是只是将该成员变量的引用值（引用拷贝【并发引用传递，Java本质还是值传递】）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</li></ul><blockquote><p>深拷贝</p></blockquote><ul><li>对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li><li>也就是说浅拷贝对于子对象只是拷贝了引用值，并没有真正的拷贝整个对象。</li></ul><p>在内存中，用散列表组织的搜索关键词信息是如何存储的。从下图中我们可以发现，散列表索引中，每个结点存储的 key 是搜索关键词，value 是 SearchWord 对象的内存地址。SearchWord 对象本身存储在散列表之外的内存空间中。</p><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923171124069.png"></p><p>浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：</p><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923171203280.png" alt="浅拷贝"></p><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923171227022.png" alt="深拷贝"></p><ol><li>在 Java 语言中，Object 类的 clone() 方法执行的就是浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。</li><li>在上面的代码中，我们通过调用 HashMap 上的 clone() 浅拷贝方法来实现原型模式。当我们通过 newKeywords 更新 SearchWord 对象的时候（比如，更新“设计模式”这个搜索关键词的访问次数），newKeywords 和 currentKeywords 因为指向相同的一组 SearchWord 对象，就会导致 currentKeywords 中指向的 SearchWord，有的是老版本的，有的是新版本的，就没法满足我们之前的需求：currentKeywords 中的数据在任何时刻都是同一个版本的，不存在介于老版本与新版本之间的中间状态。</li></ol><p>我们可以将浅拷贝替换为深拷贝。newKeywords 不仅仅复制 currentKeywords 的索引，还把 SearchWord 对象也复制一份出来，这样 newKeywords 和 currentKeywords 就指向不同的 SearchWord 对象，也就不存在更新 newKeywords 的数据会导致 currentKeywords 的数据也被更新的问题了。</p><p>如何实现深拷贝，有如下两种方法：</p><p>第一种方法：<code>递归拷贝对象、对象的引用对象以及引用对象的引用对象</code>……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。重构之后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastUpdateTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Deep copy</span><br>    HashMap&lt;String, SearchWord&gt; newKeywords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;<br>      <span class="hljs-type">SearchWord</span> <span class="hljs-variable">searchWord</span> <span class="hljs-operator">=</span> e.getValue();<br>      <span class="hljs-type">SearchWord</span> <span class="hljs-variable">newSearchWord</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchWord</span>(<br>              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());<br>      newKeywords.put(e.getKey(), newSearchWord);<br>    &#125;<br><br>    <span class="hljs-comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br>    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">maxNewUpdatedTime</span> <span class="hljs-operator">=</span> lastUpdateTime;<br>    <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>      <span class="hljs-keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;<br>        maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>      &#125;<br>      <span class="hljs-keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;<br>        <span class="hljs-type">SearchWord</span> <span class="hljs-variable">oldSearchWord</span> <span class="hljs-operator">=</span> newKeywords.get(searchWord.getKeyword());<br>        oldSearchWord.setCount(searchWord.getCount());<br>        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        newKeywords.put(searchWord.getKeyword(), searchWord);<br>      &#125;<br>    &#125;<br><br>    lastUpdateTime = maxNewUpdatedTime;<br>    currentKeywords = newKeywords;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">(<span class="hljs-type">long</span> lastUpdateTime)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>第二种方法：<code>先将对象序列化，然后再反序列化成新的对象</code>。具体的示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deepCopy</span><span class="hljs-params">(Object object)</span> &#123;<br>  <span class="hljs-comment">// 序列化</span><br>  <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>  <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bo);<br>  oo.writeObject(object);<br>  <br>  <span class="hljs-comment">// 反序列化</span><br>  <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bo.toByteArray());<br>  <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">oi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bi);<br>  <br>  <span class="hljs-keyword">return</span> oi.readObject();<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对这个应用场景，有没有更快、更省内存的实现方式呢？</li><li>可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题中讲到的，在这个应用场景下，最快速 clone 散列表的方式。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastUpdateTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Shallow copy</span><br>    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();<br><br>    <span class="hljs-comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br>    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">maxNewUpdatedTime</span> <span class="hljs-operator">=</span> lastUpdateTime;<br>    <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>      <span class="hljs-keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;<br>        maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>      &#125;<br>      <span class="hljs-keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;<br>        newKeywords.remove(searchWord.getKeyword());<br>      &#125;<br>      newKeywords.put(searchWord.getKeyword(), searchWord);<br>    &#125;<br><br>    lastUpdateTime = maxNewUpdatedTime;<br>    currentKeywords = newKeywords;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">(<span class="hljs-type">long</span> lastUpdateTime)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>尊重原创，原著文章链接： <a href="https://imlql.cn/post/ba432704.html">https://imlql.cn/post/ba432704.html</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式概述</title>
    <link href="/2022/09/21/she-ji-mo-shi-gai-shu/"/>
    <url>/2022/09/21/she-ji-mo-shi-gai-shu/</url>
    
    <content type="html"><![CDATA[<h2 id="一、设计模式定义"><a href="#一、设计模式定义" class="headerlink" title="一、设计模式定义"></a>一、设计模式定义</h2><p>设计模式是在特定环境下为解决某一通用软件设计问题提供的一套定制的解决方案，该方案描述了对象和类之间的相互作用。</p><p>设计模式一般包含模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式，关键元素为：模式名称、问题、解决方案、效果。</p><h2 id="二、设计模式的分类"><a href="#二、设计模式的分类" class="headerlink" title="二、设计模式的分类"></a>二、设计模式的分类</h2><p>根据目的分类，可分为：</p><ol><li>创建型</li><li>结构型</li><li>行为型</li></ol><p>根据范围分类，可分为：</p><ol><li>类模式</li><li>对象模式</li></ol><h2 id="三、GoF设计模式简介"><a href="#三、GoF设计模式简介" class="headerlink" title="三、GoF设计模式简介"></a>三、GoF设计模式简介</h2><p>在GoF的经典著作中一共描述了23种设计模式。</p><p>按目的分类：</p><blockquote><p>创建型模式</p></blockquote><p>1、工厂模式</p><p>工厂模式（Factory Pattern）是Java中最常用的设计模式之一。</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p>2、抽象工厂模式</p><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p>3、单例模式</p><p>单例模式（Singleton Pattern）是Java中最简单的设计模式之一。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>4、建造者（构建者）模式</p><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。</p><p>一个Builder类会一步一步构造最终的对象。该Builder类是独立于其他对象的。</p><p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p>5、原型模式</p><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。</p><p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><blockquote><p>结构型模式</p></blockquote><p>6、适配器模式</p><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。</p><p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。</p><p>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p>7、装饰器模式</p><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><p>8、代理模式</p><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。</p><p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p><p>为其他对象提供一种代理以控制对这个对象的访问。</p><p>9、外观模式</p><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。</p><p>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p><p>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p>10、桥接模式</p><p>桥接模式（Bridge Pattern）是用于把抽象化与实现化解耦，使得二者可以独立变化。它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p><p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p><p>将抽象部分与实现部分分离，使它们都可以独立的变化。</p><p>又称为柄体（Handle and Body）模式或接口（Interface）模式。</p><p>11、组合模式</p><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了<strong>对象组的树形结构</strong>。</p><p>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p><p>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><p>12、享元模式</p><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p><p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。</p><p>运用共享技术有效地支持大量细粒度的对象。</p><blockquote><p>行为型模式</p></blockquote><p>13、策略模式</p><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的context对象。策略对象改变context对象的执行算法。</p><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。</p><p>14、模板模式</p><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>15、观察者模式</p><p>当对象间存在一对多关系时，则使用观察者模式（ObserverPattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。</p><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>16、迭代器模式</p><p>迭代器模式（Iterator Pattern）是Java和.Net编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p><p>迭代器模式属于行为型模式。</p><p>提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。</p><p>17、责任链模式</p><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。</p><p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p><p>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><p>18、命令模式</p><p>命令模式（Command Pattern）是一种数据驱动的设计模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p><p>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p><p>19、备忘录模式</p><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。</p><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p><p>20、状态模式</p><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。</p><p>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的context对象。</p><p>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p><p>21、访问者模式</p><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p><p>主要将数据结构与数据操作分离。</p><p>主要解决：稳定的数据结构和易变的操作耦合问题。</p><p>22、中介者模式</p><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。</p><p>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>23、解释器模式</p><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在SQL解析、符号处理引擎等。</p><p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p><h2 id="四、面向对象设计原则"><a href="#四、面向对象设计原则" class="headerlink" title="四、面向对象设计原则"></a>四、面向对象设计原则</h2><h3 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h3><p>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。</p><h3 id="2、里氏替换原则"><a href="#2、里氏替换原则" class="headerlink" title="2、里氏替换原则"></a>2、里氏替换原则</h3><p>所有引用基类的地方必须能透明地使用其子类的对象。</p><h3 id="3、依赖倒置原则"><a href="#3、依赖倒置原则" class="headerlink" title="3、依赖倒置原则"></a>3、依赖倒置原则</h3><ol><li>上层模块不应该依赖底层模块，它们都应该依赖于抽象。</li><li>抽象不应该依赖于细节，细节应该依赖于抽象。</li></ol><h3 id="4、接口隔离原则"><a href="#4、接口隔离原则" class="headerlink" title="4、接口隔离原则"></a>4、接口隔离原则</h3><p>每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</p><h3 id="5、迪米特法则（最少知道原则）"><a href="#5、迪米特法则（最少知道原则）" class="headerlink" title="5、迪米特法则（最少知道原则）"></a>5、迪米特法则（最少知道原则）</h3><p>一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p><h3 id="6、合成复用原则"><a href="#6、合成复用原则" class="headerlink" title="6、合成复用原则"></a>6、合成复用原则</h3><p>尽量使用对象组合/聚合，而不是继承关系达到软件复用的目的。</p><h3 id="7、开闭原则"><a href="#7、开闭原则" class="headerlink" title="7、开闭原则"></a>7、开闭原则</h3><p>软件实体应该对扩展开放，对修改关闭</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2022/09/21/lian-biao/"/>
    <url>/2022/09/21/lian-biao/</url>
    
    <content type="html"><![CDATA[<h1>一、理论</h1><h2 id="1、链表类型">1、链表类型</h2><h3 id="1、单链表">1、单链表</h3><p><img src="/2022/09/21/lian-biao/image-20221011101058417.png" alt></p><h3 id="2、双链表">2、双链表</h3><p><img src="/2022/09/21/lian-biao/image-20221011101124093.png" alt></p><h3 id="3、循环链表">3、循环链表</h3><p>循环链表可以用来解决<code>约瑟夫环</code>问题</p><p><img src="/2022/09/21/lian-biao/image-20221011101149273.png" alt></p><h2 id="2、链表存储方式">2、链表存储方式</h2><p>数组在内存中是连续分布的，但链表在内存中不是连续分布的。</p><p>链表是通过指针域的指针来连接各个节点。所以链表的分配机制取决于操作系统的内存管理。</p><h2 id="3、链表的定义">3、链表的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-comment">// 结点的值</span><br>    <span class="hljs-type">int</span> val;<br><br>    <span class="hljs-comment">// 下一个结点</span><br>    ListNode next;<br><br>    <span class="hljs-comment">// 节点的构造函数(无参)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 节点的构造函数(有一个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br><br>    <span class="hljs-comment">// 节点的构造函数(有两个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val, ListNode next)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、链表的基本操作">4、链表的基本操作</h2><h3 id="1、删除节点">1、删除节点</h3><p><img src="/2022/09/21/lian-biao/image-20221011101632656.png" alt></p><p>删除D节点，直接将C节点的next节点指向E即可。java有自己的内存回收机制，不用自己手动释放。</p><h3 id="2、添加节点">2、添加节点</h3><p><img src="/2022/09/21/lian-biao/image-20221011101738080.png" alt></p><p>增加F节点，先将F节点的next指向D，再将C节点的next指向F。</p><p>但是有一点需要注意，在C后增加节点，首先得找到C节点，找节点的复杂度是O(n)</p><h2 id="5、链表与数组的性能对比">5、链表与数组的性能对比</h2><p><img src="/2022/09/21/lian-biao/image-20221011102001636.png" alt></p><h1>二、翻转链表</h1><h2 id="1、翻转整个链表">1、翻转整个链表</h2><p>先上<code>本次</code>的链表定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">public</span> Node next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、双指针法</p><p>只需要改变链表的next指向即可</p><p><img src="/2022/09/21/lian-biao/image-20220921114419429.png" alt></p><p>首先定义cur节点，指向head；再定义pre指向null。</p><p>pre节点是cur节点的前序节点</p><p>先将cur.next节点保存在temp里，再进行翻转。保存在temp是为了防止下一个节点丢失。</p><p>到最后cur为null时，pre为最后一个节点，此时返回pre即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reverse</span><span class="hljs-params">(Node head)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;   <span class="hljs-comment">// 以下注释以1 2为例</span><br>        temp = cur.next;   <span class="hljs-comment">// temp指向2</span><br>        cur.next = pre;    <span class="hljs-comment">// 1 和 2 之间已经断链， 1 已经指向了pre，也就是空</span><br><br>        pre = cur;     <span class="hljs-comment">//  同时向后移</span><br>        cur = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、递归法</p><p>递归法其实跟双指针法类似，每一步翻转都有三个过程：</p><ol><li>记录下一个节点</li><li>翻转</li><li>同时往后移</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//  其他代码</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> reverse(<span class="hljs-literal">null</span>, node1);    <span class="hljs-comment">// node1 为已定义好的链表的头结点</span><br>    <span class="hljs-keyword">while</span> (res != <span class="hljs-literal">null</span>) &#123;<br>        System.out.print(res.value + <span class="hljs-string">&quot; &quot;</span>);<br>        res = res.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reverse</span><span class="hljs-params">(Node pre, Node cur)</span> &#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.next;  <span class="hljs-comment">//记录下一个节点</span><br>    cur.next = pre;     <span class="hljs-comment">// 翻转</span><br><br>    <span class="hljs-keyword">return</span> reverse(cur, temp);   <span class="hljs-comment">//向后移</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、翻转部分链表">2、翻转部分链表</h2><p>给定一个链表的头结点，给定m和n，要求翻转m到n之间的链表</p><p>思路：使用头插法</p><ol><li>首先找到m节点的前一个节点，定义为pre，这个pre就相当于头插法的头结点的前序节点</li><li>用一个for循环，遍历从m到n，进行链表的头插</li><li>最后返回头结点即可</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseBetween</span> <span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        res.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            pre = cur;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m; i &lt; n; i++) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = temp.next;<br><br>            temp.next = pre.next;<br>            pre.next = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.next;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>之所以定义res节点，是为了方便操作头结点，即当m为1时不用对头结点进行特殊处理</p></blockquote><h1>三、环形链表</h1><p>环形链表一共有两个问题，第一个问题是验证一个链表是否有环，第二个问题是找到环形链表的入口。</p><p>先来看第一个问题</p><h2 id="1、验证链表是否有环">1、验证链表是否有环</h2><p>判断链表是否有环，可以使用快慢指针法，定义一个fast，以及一个slow，slow每走一步，fast就走两步，若是有环的话，那么最终一定会相遇。</p><p>为什么？</p><p>首先肯定是fast先进环，当slow进环时，slow走一步fast走两步，整体来看就是fast在追赶slow一步，那么只要有环，最终fast就一定会追上slow。</p><h2 id="2、若有环，如何找到入口？">2、若有环，如何找到入口？</h2><p>用公式来表示一下。</p><p>假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：</p><p><img src="/2022/09/21/lian-biao/image-20221013094802419.png" alt></p><p>那么在相遇时，slow走了（x + y），fast走了(x + y + n * (y + z))。fast有可能在环内走了n圈。根据步长，可以看出fast走的距离是slow的二倍，即：</p><p>2 * (x + y) = x + y + n * (y + z)</p><p>两边消去一个 x + y：</p><p>x + y = n * (y + z)</p><p>要找到入口，那就是要求x的距离，将x放在一边：</p><p>x = n * (y + z) - y</p><p>整理之后就是：</p><p>x = (n - 1) * (y + z) + z</p><p>假设n = 1时，n = 1意味着fast在环内走了一圈就碰见slow了，这时候计算入口时(x = z)，<code>只需要在他们相遇的节点处定义一个index1，在头结点处定义一个index2，令他们每次走一步，相遇即为入口节点</code>。</p><p>若是n &gt; 1时，fast指针在环形转n圈之后才遇到 slow指针。该问题也可简化为n = 1，其实本质上都一样，只不过index1在环内多转了几圈，然后碰到index2。</p><blockquote><p>有个疑问：那为什么在环中相遇时，slow走过的距离一定是x + y，而不是 x + 若干环的距离 + y 呢？</p></blockquote><p>因为当slow进环时，fast一定在环内，而fast和slow每走一次就相当于fast在靠近slow一步，所以当slow还没进入到下一次循环的时候，就会被fast追上。</p><h1>四、经典题目</h1><h2 id="1、合并k个已排序的链表">1、合并k个已排序的链表</h2><p>原题链接：<a href="https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6?tpId=295&amp;tqId=724&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj">BM5 合并k个已排序的链表</a></p><p>三种方法</p><h3 id="1、方法一：借用辅助空间">1、方法一：借用辅助空间</h3><p>思路：既然要合并k个链表，那么先定义一个list，将这些链表的值都存入进list，最后对list进行排序，然后一一取出并将其组成链表即可</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ArrayList&lt;ListNode&gt; lists)</span> &#123;<br>    <span class="hljs-comment">// 定义虚拟头结点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        ArrayList&lt;Integer&gt; array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> lists.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> lists.get(i);<br>            <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>                array.add(node.val);<br>                node = node.next;<br>            &#125;<br>        &#125;<br>        Collections.sort(array);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.size(); i++) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">ccc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(array.get(i));<br>            cur.next = ccc;<br>            cur = cur.next;<br>        &#125;<br>    <span class="hljs-comment">// 最后返回虚拟头结点的下一个节点</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br></code></pre></td></tr></table></figure><p>当然时间复杂度是比较高的，排序就需要O(n * log2n)</p><h3 id="2、方法二：优先队列">2、方法二：优先队列</h3><p>优先队列方法类似于双指针，都是从几个中选出最小的。优先队列是一种内置的基于堆排序的容器，分为大顶堆和小顶堆，小顶堆就是堆顶为最小的元素。本题采用小顶堆。</p><p>使用优先队列时，必须要手动<code>重载比较方法</code>。因为容器内部的次序基于堆排序，因此每次插入元素时间复杂度都是O(log2n)，而每次取出堆顶元素都是直接取出。</p><p>思路：</p><ol><li>遍历k个链表头，将不是空节点的节点放进优先队列</li><li>优先队列弹出最小值，并且若弹出的节点的下一个节点不为空，就将下一个节点放进优先队列</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ArrayList&lt;ListNode&gt; lists)</span> &#123;<br>        <span class="hljs-comment">//小顶堆</span><br>        Queue&lt;ListNode&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((v1, v2) -&gt; v1.val - v2.val);<br>        <span class="hljs-comment">//遍历所有链表第一个元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lists.size(); i++)&#123;<br>            <span class="hljs-comment">//不为空则加入小顶堆</span><br>            <span class="hljs-keyword">if</span>(lists.get(i) != <span class="hljs-literal">null</span>)<br>                pq.add(lists.get(i));<br>        &#125;<br>        <span class="hljs-comment">//加一个表头</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-comment">//直到小顶堆为空</span><br>        <span class="hljs-keyword">while</span>(!pq.isEmpty())&#123;<br>            <span class="hljs-comment">//取出最小的元素</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> pq.poll();<br>            <span class="hljs-comment">//连接</span><br>            head.next = temp;<br>            head = head.next;<br>            <span class="hljs-comment">//每次取出链表的后一个元素加入小顶堆</span><br>            <span class="hljs-keyword">if</span>(temp.next != <span class="hljs-literal">null</span>)<br>                pq.add(temp.next);<br>        &#125;<br>        <span class="hljs-comment">//去掉表头</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n * log 2 * k)，每次加入优先队列排序需要O(log2k)</p><h3 id="3、方法三：归并排序思想【推荐】">3、方法三：归并排序思想【推荐】</h3><p>首先需要明确两个概念。</p><p>1、双指针</p><p>双指针指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个指针（特殊情况甚至可以多个），两个指针或是同方向访问两个链表、或是同方向访问一个链表（快慢指针）、或是相反方向扫描（对撞指针），从而达到我们需要的目的。</p><p>2、分治</p><p>分治分治，分而治之。“分”指的是将一个大而复杂的问题划分成多个性质相同但是规模更小的子问题，子问题继续按照这样划分，直到问题可以被轻易解决；“治”指的是将子问题单独进行处理。经过分治后的子问题，需要将解进行合并才能得到原问题的解，因此整个分治过程经常用递归来实现。</p><p>其实这道题也可以两两比较，只要遍历链表数组，取出开头的两个链表，按照上述思路合并，然后新链表再与后一个继续合并，如此循环，知道全部合并完成。但是，太浪费时间。</p><p>可不可以直接归并的分治来做，而不是顺序遍历合并链表呢？可以！</p><p>归并排序简单来说就是将一个数组每次划分成等长的两部分，对两部分进行排序即是子问题。对子问题继续划分，直到子问题只有1个元素。还原的时候呢，将每个子问题和它相邻的另一个子问题利用上述双指针的方式，1个与1个合并成2个，2个与2个合并成4个，因为这每个单独的子问题合并好的都是有序的，直到合并成原本长度的数组。</p><p>对于这k个链表，就相当于上述合并阶段的k个子问题，需要划分为链表数量更少的子问题，直到每一组合并时是两两合并，然后继续往上合并，这个过程基于递归：</p><ul><li><strong>终止条件：</strong> 划分的时候直到左右区间相等或左边大于右边。</li><li><strong>返回值：</strong> 每级返回已经合并好的子问题链表。</li><li><strong>本级任务：</strong> 对半划分，将划分后的子问题合并成新的链表。</li></ul><p>简单画个图来帮助理解一下：</p><p><img src="/2022/09/21/lian-biao/image-20221027112036683.png" alt></p><p>若是有五个链表需要合并，分治就是右边的情况</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//两个链表合并函数</span><br>   <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">Merge</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>       <span class="hljs-comment">//一个已经为空了，直接返回另一个</span><br>       <span class="hljs-keyword">if</span>(list1 == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">return</span> list2;<br>       <span class="hljs-keyword">if</span>(list2 == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">return</span> list1;<br>       <span class="hljs-comment">//加一个表头</span><br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>       <span class="hljs-comment">//两个链表都要不为空</span><br>       <span class="hljs-keyword">while</span>(list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-comment">//取较小值的节点</span><br>           <span class="hljs-keyword">if</span>(list1.val &lt;= list2.val)&#123;<br>               cur.next = list1;<br>               <span class="hljs-comment">//只移动取值的指针</span><br>               list1 = list1.next;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               cur.next = list2;<br>               <span class="hljs-comment">//只移动取值的指针</span><br>               list2 = list2.next;<br>           &#125;<br>           <span class="hljs-comment">//指针后移</span><br>           cur = cur.next;<br>       &#125;<br>       <span class="hljs-comment">//哪个链表还有剩，直接连在后面</span><br>       <span class="hljs-keyword">if</span>(list1 != <span class="hljs-literal">null</span>)<br>           cur.next = list1;<br>       <span class="hljs-keyword">else</span><br>           cur.next = list2;<br>       <span class="hljs-comment">//返回值去掉表头</span><br>       <span class="hljs-keyword">return</span> dummy.next;<br>   &#125;<br>    <br>   <span class="hljs-comment">//划分合并区间函数</span><br>   ListNode <span class="hljs-title function_">divideMerge</span><span class="hljs-params">(ArrayList&lt;ListNode&gt; lists, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>       <span class="hljs-keyword">if</span>(left &gt; right)<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-comment">//中间一个的情况</span><br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == right)<br>           <span class="hljs-keyword">return</span> lists.get(left);<br>       <span class="hljs-comment">//从中间分成两段，再将合并好的两段合并</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>       <span class="hljs-keyword">return</span> Merge(divideMerge(lists, left, mid), divideMerge(lists, mid + <span class="hljs-number">1</span>, right));<br>   &#125;<br>    <br>   <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ArrayList&lt;ListNode&gt; lists)</span> &#123;<br>       <span class="hljs-comment">//k个链表归并排序</span><br>       <span class="hljs-keyword">return</span> divideMerge(lists, <span class="hljs-number">0</span>, lists.size() - <span class="hljs-number">1</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlog2k)</li><li>空间复杂度：O(log2k)</li></ul><p>上述代码中的Merge()方法，可以直接用来对两个有序链表进行合并。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见架构模式</title>
    <link href="/2022/09/20/chang-jian-jia-gou-mo-shi/"/>
    <url>/2022/09/20/chang-jian-jia-gou-mo-shi/</url>
    
    <content type="html"><![CDATA[<p>扫盲！</p><p>几种常见的架构模式：<strong>Client-Server、Peer to Peer、MVC、Layered、Distribute-Cluster、Micro-Service、Even-Source、Hexagonal</strong></p><p>几种架构模式：</p><h3 id="1、Client-Server"><a href="#1、Client-Server" class="headerlink" title="1、Client-Server"></a>1、Client-Server</h3><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20220920190951638.png" alt="cs"></p><p>client-server 模式以请求-响应方式工作，客户端发送请求信息，服务端接受请求，作出相应处理，然后发回响应信息。所有我们访问的互联网网站都是这种架构。在桌面程序流行的时代，互联网还没有当前这么发达的时代。Client-Server 还只代表 Desktop Client-Server 模式，使用浏览器的方式称之为 B-S 模式，即 Browser-Server 模式。如今 Browser、Desktop Application、Mobile Application、Mobile Web 等统称为 Client。</p><h3 id="2、Peer-to-Peer"><a href="#2、Peer-to-Peer" class="headerlink" title="2、Peer to Peer"></a>2、Peer to Peer</h3><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20220920191053669.png" alt="p2p"></p><p>端对端服务模式（Peer to Peer，简称 P2P），亦称为“点对点模式”，是指通过互联网将个人与个人连接起来，绕开中心平台而直接提供服务、完成交易的模式。P2P 的早期含意是计算机通信领域中的“对等网络协议”，它打破了传统的 Client/Server(C/S)模式，使得成千上万台彼此连接的计算机都处于对等地位，网络的参与者直接共享他们所拥有的一部分硬件资源（包括处理能力、存储能力、网络连接能力、打印机等），这些共享资源通过互联网，能被其它对等节点(Peer)直接访问而无需经过统一的中间体。</p><p>P2P 模式流行于文件分享与下载、计算与存储、即时通信和协同共享等领域。</p><h3 id="3、MVC"><a href="#3、MVC" class="headerlink" title="3、MVC"></a>3、MVC</h3><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20220920191214418.png" alt="mvc"></p><p>Model-View-Controller，MVC 架构是面向对象编程的一大进步。服务将逻辑划分为三个不同的组建：Model——模型，即数据，通常存储在数据库中，在内存中进行逻辑操作。View——用户可见的组建，用于用户交互和数据展示，如 Web GUI。Controller——逻辑操作，连接 Model 和 View 的组件，操作 Model 逻辑和 View 交互展示逻辑。</p><h3 id="4、Layered"><a href="#4、Layered" class="headerlink" title="4、Layered"></a>4、Layered</h3><p>说起分层架构，最让人熟知的就是经典的三层架构。经典三层架构自顶向下由用户界面层（User Interface Layer）、业务逻辑层（Business Logic Layer）与数据访问层（Data Access Layer）组成。三层架构是简单 Client-Server 架构的升级。</p><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20220920191630251.png" alt="there layer"></p><h3 id="5、Distribute-Cluster"><a href="#5、Distribute-Cluster" class="headerlink" title="5、Distribute-Cluster"></a>5、Distribute-Cluster</h3><p>之上所提的架构都是在单体架构之下。单体架构和多服务架构是从服务的部署模式、运行模式来考虑。</p><p>单体架构有如下优势：</p><ul><li>易于开发：借助于开发框架，单体应用的开发及其简单，开发人员也很少需要考虑系统、部署、网络等层次的问题。</li><li>易于测试：单体应用部署在一个进程中，环境简单。只要服务启动就可以测试所有的功能。</li><li>易于部署：往往只需要将应用打包成一个简单的包就可。</li><li>易于水平扩展：只需要将程序包部署多个服务即可。</li></ul><p>单体应用的劣势：</p><ul><li>维护成本增加：随着需求的增多，单体系统将越来越臃肿，维护的复杂性也将越来越大。</li><li>持续交互周期长：一方面维护困难，另一方面单体应用在并行开发，并行测试上将十分困难，单体应用十分不适合快速迭代的敏捷开发。</li><li>扩展性差：由于臃肿的系统，将导致系统扩展性变难。系统的升级也需要十分谨慎。</li><li>对新人不友好。</li></ul><p>分布式系统拆分：</p><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20220920191745648.png" alt="service scale"></p><h3 id="6、Micro-Service"><a href="#6、Micro-Service" class="headerlink" title="6、Micro-Service"></a>6、Micro-Service</h3><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调、相互配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常基于 HTTP 的 RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境。</p><p>Spring Cloud 技术栈:</p><ul><li>SpringBoot：单体服务，快速创建项目，快速集成各种框架，易于测试，易于部署。</li><li>Feign：微服务独立部署，通过相关协议通信。Feign 就是一个简单的申明式通信框架，基于 HTTP restful。</li><li>Eureka：独立服务越来越多，服务实例也越来越多。服务治理便是必须的，Eureka 提供高可用的服务注册和服务发现功能。</li><li>Ribbon：Feign 只负责通信，Ribbon 提供客户端负载均衡，是系统优化的部分。</li><li>Hystrix：微服务将带来服务间复杂的依赖关系，分布式和集群的复杂度也将带来许多难以预料的问题。为防止复杂网络和复杂系统某一点的问题导致整个系统的雪崩状态，便有了 Hystrix，Hystrix 是 Spring Cloud 体系中优秀的断路器，可以在系统发生问题时进行服务降级，防止整体系统崩溃。</li><li>Zuul：统一网关，统一网关是以 Facade 模式，对外提供友好的接口，微服务化之后，服务将越来越多，越来越复杂，为了降低外部系统调用的复杂度，统一网关就是常用解决方案。</li><li>Config：服务划分越多，配置将越多，Spring cloud config 提供统一的配置管理。</li><li>Sleuth：服务监控和治理。监控是复杂系统必需的基础设施。系统感知、问题发现、性能定位都需要监控的加持。</li></ul><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20220920191927004.png" alt="micro service"></p><h3 id="7、Even-Source"><a href="#7、Even-Source" class="headerlink" title="7、Even-Source"></a>7、Even-Source</h3><p>事件溯源是最新流行一种应用程序体系结构模式。事件源将应用程序进行的状态更改建模为事件的不可变序列或“日志”。事件源不是在现场修改应用程序的状态，而是将触发状态更改的事件存储在不可变的日志中，并将状态更改建模为对日志中事件的响应。</p><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20221021153056824.png"></p><p>CQRS 模式通常基事件溯源模式。在传统的体系结构中，使用同一数据模型查询和更新数据库。这十分简单，非常适用于基本的 CRUD 操作。但是，在更复杂的应用程序中，此方法会变得难以操作。例如，在读取方面，应用程序可能执行大量不同的查询，返回具有不同形状的数据传输对象 (DTO)。对象映射可能会变得复杂。在写入方面，模型可能实施复杂验证和业务逻辑。结果，模型执行太多操作，过度复杂。</p><p>CQRS（命令查询的责任分离 Command Query Responsibility Segregation ）将读取和写入操作分成不同的模型，使用 <strong>命令</strong> 更新数据，并使用 <strong>查询</strong> 来读取数据。</p><h3 id="8、Hexagonal"><a href="#8、Hexagonal" class="headerlink" title="8、Hexagonal"></a>8、Hexagonal</h3><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20221021153305168.png"></p><p>六边形架构又称“端口和适配器模式”，是 Alistair Cockburn 提出的一种具有对称性特征的架构风格。在这种架构中，系统通过适配器的方式与外部交互，将应用服务与领域服务封装在系统内部。</p><p>六边形架构由以下三个组件组成：</p><ul><li>Ports：又可以分为输入端和输出端，是系统与其他系统交互的接口。</li><li>Adapters：与其他系统的适配层，一方面防止核心系统和领域被外部影响，即防腐;另一方面方便 api 使用。</li><li>Domain：应用和模型是程序的核心。</li></ul><p>六边形架构的核心理念是：应用通过”端口”跟外部进行交互。在传统的分层架构中很容易跨越层间的边界，把业务逻辑渗透到其它层中去。六边形架构重要的就是“边界”和“领域”。六边形架构的初衷是为了解决技术与业务系统的解耦合问题，以及技术与技术间的解耦合问题，这一架构从设计模式中来，从业务的实体服务出发，将面向接口的设计具体化的端口协议和适配器实现，服务自身实现独立性和完备性。</p><p>参考：<a href="https://mp.weixin.qq.com/s/NJFJ5UrzGk0cMGL1oZe0Bg">扫个盲先？吹一吹企业常用的软件架构！</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>架构</tag>
      
      <tag>分布式/微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Second Test</title>
    <link href="/2022/09/20/second-test/"/>
    <url>/2022/09/20/second-test/</url>
    
    <content type="html"><![CDATA[<p>第二次测试</p><p>托拉拽：</p><p><img src="/2022/09/20/second-test/image-20220920171706059.png" alt="不愧是我"></p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Test</title>
    <link href="/2022/09/20/test/"/>
    <url>/2022/09/20/test/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/09/20/test/%E5%90%89%E4%BB%964.jpg" alt="图片测试"></p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习笔记</title>
    <link href="/2022/09/19/docker-xue-xi/"/>
    <url>/2022/09/19/docker-xue-xi/</url>
    
    <content type="html"><![CDATA[<h2 id="一、为何要用Docker"><a href="#一、为何要用Docker" class="headerlink" title="一、为何要用Docker?"></a>一、为何要用Docker?</h2><h3 id="1、什么是Docker"><a href="#1、什么是Docker" class="headerlink" title="1、什么是Docker?"></a>1、什么是Docker?</h3><p>Docker 使用 Google 公司推出的 Go 语言  进行开发实现，基于 Linux 内核 的cgroup，namespace，以及 AUFS 类的 UnionFS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。 由于隔离的进程独立于宿主和其它的隔离的进 程，因此也称其为容器。Docker 最初实现是基于 LXC.</p><p>Docker 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上，构建杰出的软件。</p><p>用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><h3 id="2、Docker的优点："><a href="#2、Docker的优点：" class="headerlink" title="2、Docker的优点："></a>2、Docker的优点：</h3><ul><li><p>环境隔离(‘<strong>隔离，安全</strong>‘)</p><p>Docker 实现了资源隔离，一台机器运行多个容器互无影响。</p></li><li><p>更高效的资源利用(<strong>节约成本</strong>)</p><p>Docker 容器的运行不需要额外的虚拟化管理程序的支持，它是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。</p></li><li><p>更快速的交付部署(<strong>敏捷</strong>)</p><p>使用 Docker，开发人员可以利用镜像快速构建一套标准的研发环境，开发完成后，测试和运维人员可以直接通过使用相同的环境来部署代码。</p></li><li><p>更易迁移扩展(<strong>可移植性</strong>)</p><p>Docker 容器几乎可以在任意的平台上运行，包括虚拟机、公有云、私有云、个人电脑、服务器等，这种兼容性让用户可以在不同平台之间轻松的迁移应用。</p></li><li><p>更简单的更新管理(<strong>高效</strong>)</p><p>使用 Dockerfile，只需要很少的配置修改，就可以替代以往大量的更新工作。并且所有修改都是以增量的方式进行分发和更新，从而实现自动化和高效的容器管理。</p></li></ul><h3 id="3、Docker-的基本组成架构"><a href="#3、Docker-的基本组成架构" class="headerlink" title="3、Docker 的基本组成架构"></a>3、Docker 的基本组成架构</h3><p>具体参考<a href="https://juejin.cn/post/6844904035053486087#heading-2">Docker搭建你的第一个 Node 项目到服务器(完整版)</a></p><h4 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h4><p>镜像仓库，存储大量镜像，可以从镜像仓库拉取和推送镜像。</p><h4 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h4><p>类似虚拟机快照，从仓库拉取，或者在现有工具镜像上创建新镜像。通过镜像可以启动容器。</p><h4 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h4><p>从镜像中创建应用环境，以单进程的方式运行。对外公开服务。是一种短暂的和一次性的环境。</p><h4 id="Docker-数据卷"><a href="#Docker-数据卷" class="headerlink" title="Docker 数据卷"></a>Docker 数据卷</h4><p>数据卷可以完成数据持久化，数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>卷会一直存在，直到没有容器使用</li></ul><h4 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h4><p>Docker 容器之间的网络交互，可以使用<code>端口映射</code>的方式，其他容器可以直接通过端口实现。除该方式外还有一个<code>容器连接（linking）系统</code>也可以达到容器交互。（本文中 node 连接 mongodb 使用的是端口映射的方式）</p><p>关于Docker 网络模块，容器连接详情推荐这篇文章: <a href="https://juejin.cn/post/6844903756920782855">Docker的网络模式详解</a></p><h3 id="4、Docker的常用命令（常用）"><a href="#4、Docker的常用命令（常用）" class="headerlink" title="4、Docker的常用命令（常用）"></a>4、Docker的常用命令（常用）</h3><h4 id="镜像常用命令"><a href="#镜像常用命令" class="headerlink" title="镜像常用命令"></a>镜像常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull [镜像名称:版本] 拉取镜像<br>docker images  镜像列表<br>docker rmi [镜像名称:版本] 删除镜像<br>docker <span class="hljs-built_in">history</span> [镜像名称] 镜像操作记录<br>docker tag [镜像名称:版本][新镜像名称:新版本]<br>docker inspect [镜像名称:版本] 查看镜像详细<br>docker search [关键字] 搜索镜像<br>docker login 镜像登陆<br></code></pre></td></tr></table></figure><h4 id="容器常用命令"><a href="#容器常用命令" class="headerlink" title="容器常用命令"></a>容器常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps -a 容器列表(所有容器)<br>docker ps  查看所有(运行的)容器<br>docker <span class="hljs-built_in">exec</span> -ti &lt;<span class="hljs-built_in">id</span>&gt; bash  以 bash 命令进入容器内<br>docker run -ti --name [容器名称][镜像名称:版本] bash 启动容器并进入<br>docker logs 查看容器日志<br>docker top &lt;container_id&gt; 查看容器最近的一个进程<br>docker run -ti --name [容器名称] -p 8080:80 [镜像名称:版本] bash  端口映射<br>docker <span class="hljs-built_in">rm</span> &lt;container_id&gt; 删除容器<br>docker stop &lt;container_id&gt; 停止容器<br>docker start &lt;container_id&gt; 开启容器<br>docker restart &lt;container_id&gt; 重启容器<br>docker inspect &lt;container_id&gt; 查看容器详情<br>docker commit [容器名称] my_image:v1.0  容器提交为新的镜像<br></code></pre></td></tr></table></figure><h4 id="DockerFile常用命令"><a href="#DockerFile常用命令" class="headerlink" title="DockerFile常用命令"></a>DockerFile常用命令</h4><p>见第六节</p><h2 id="二、CentOs-7-上Docker安装部署"><a href="#二、CentOs-7-上Docker安装部署" class="headerlink" title="二、CentOs 7 上Docker安装部署"></a>二、CentOs 7 上Docker安装部署</h2><h3 id="1、若是以前安装过docker，先执行以下步骤"><a href="#1、若是以前安装过docker，先执行以下步骤" class="headerlink" title="1、若是以前安装过docker，先执行以下步骤"></a>1、若是以前安装过docker，先执行以下步骤</h3><ol><li><p>更新yum包（生产环境中慎重）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y update<br></code></pre></td></tr></table></figure><p>此命令不是必须，有服务器重启一下服务器</p></li><li><p>卸载旧版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum remove docker  docker-common docker-selinux docker-engine<br></code></pre></td></tr></table></figure></li></ol><h3 id="2、安装docker的详细步骤"><a href="#2、安装docker的详细步骤" class="headerlink" title="2、安装docker的详细步骤"></a>2、安装docker的详细步骤</h3><ol><li><p>首先安装需要的软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y yum-utils device-mapper-persistent-data lvm2<br></code></pre></td></tr></table></figure></li><li><p>设置yum源，我使用的是阿里仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure></li><li><p>选择docker版本并安装<br>查看可用的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum list docker-ce --showduplicates | <span class="hljs-built_in">sort</span> -r                 <br></code></pre></td></tr></table></figure><p>选择一个版本并安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install docker-ce-版本号<br></code></pre></td></tr></table></figure><p>我安装的是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y install docker-ce-18.03.1.ce<br></code></pre></td></tr></table></figure></li><li><p>启动docker并设置开机自启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start docker<br>systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure></li></ol><h2 id="三、image文件"><a href="#三、image文件" class="headerlink" title="三、image文件"></a>三、image文件</h2><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出本机的所有 image 文件。</span><br>docker image <span class="hljs-built_in">ls</span><br><br><span class="hljs-comment"># 删除 image 文件</span><br>docker image <span class="hljs-built_in">rm</span> [imageName]<br></code></pre></td></tr></table></figure></blockquote><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/">Docker Hub</a> 是最重要、最常用的 image 仓库。</p><h2 id="四、实例：“Hello-world”"><a href="#四、实例：“Hello-world”" class="headerlink" title="四、实例：“Hello world”"></a>四、实例：“Hello world”</h2><p>通过最简单的“Hello world”实例感受一下image文件</p><p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image pull library/hello-world<br></code></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p><p>由于 Docker 官方提供的 image 文件，都放在<a href="https://hub.docker.com/r/library/"><code>library</code></a>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image pull hello-world<br></code></pre></td></tr></table></figure></blockquote><p>抓取成功以后，就可以在本机看到这个 image 文件了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure></blockquote><p>现在，运行这个 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run hello-world<br></code></pre></td></tr></table></figure></blockquote><p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p><p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p><p>如果运行成功，你会在屏幕上读到下面的输出。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run hello-world<br><br>Hello from Docker!<br>This message shows that your installation appears to be working correctly.<br><br>... ...<br></code></pre></td></tr></table></figure></blockquote><p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p><p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run -it ubuntu bash<br></code></pre></td></tr></table></figure></blockquote><p>对于那些不会自动终止的容器，必须使用<a href="https://docs.docker.com/engine/reference/commandline/container_kill/"><code>docker container kill</code></a> 命令手动终止。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">kill</span> [containID]<br></code></pre></td></tr></table></figure></blockquote><h2 id="五、容器文件"><a href="#五、容器文件" class="headerlink" title="五、容器文件"></a>五、容器文件</h2><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出本机正在运行的容器</span><br>$ docker container <span class="hljs-built_in">ls</span><br><br><span class="hljs-comment"># 列出本机所有容器，包括终止运行的容器</span><br>$ docker container <span class="hljs-built_in">ls</span> --all<br></code></pre></td></tr></table></figure></blockquote><p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p><p>终止运行的容器文件，依然会占据硬盘空间，可以使用<a href="https://docs.docker.com/engine/reference/commandline/container_rm/"><code>docker container rm</code></a>命令删除。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">rm</span> [containerID]<br></code></pre></td></tr></table></figure></blockquote><p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p><h2 id="六、Dockerfile部署Spring-Boot-项目"><a href="#六、Dockerfile部署Spring-Boot-项目" class="headerlink" title="六、Dockerfile部署Spring Boot 项目"></a>六、Dockerfile部署Spring Boot 项目</h2><h3 id="1、将已有的spring-boot-项目打包"><a href="#1、将已有的spring-boot-项目打包" class="headerlink" title="1、将已有的spring boot 项目打包"></a>1、将已有的spring boot 项目打包</h3><h3 id="2、在linux中创建一个文件夹，例如我创建为-root-docker-test-jar01"><a href="#2、在linux中创建一个文件夹，例如我创建为-root-docker-test-jar01" class="headerlink" title="2、在linux中创建一个文件夹，例如我创建为 /root/docker_test/jar01"></a>2、在linux中创建一个文件夹，例如我创建为 /root/docker_test/jar01</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /root/docker_test/jar01<br></code></pre></td></tr></table></figure><h3 id="3、将jar包上传到linux文件夹中"><a href="#3、将jar包上传到linux文件夹中" class="headerlink" title="3、将jar包上传到linux文件夹中"></a>3、将jar包上传到linux文件夹中</h3><p>利用MobaxTerm将jar包上传到jar01中</p><h3 id="4、编写DockerFile文件"><a href="#4、编写DockerFile文件" class="headerlink" title="4、编写DockerFile文件"></a>4、编写DockerFile文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 基于java镜像创建新镜像</span><br>FROM openjdk:11<br><span class="hljs-comment"># 作者</span><br>MAINTAINER zbiao<br><span class="hljs-comment"># 将jar包添加到容器中并更名为app.jar</span><br>ADD  demo-helloworld.jar app.jar<br><span class="hljs-comment"># 运行jar包</span><br>ENTRYPOINT [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;app.jar&quot;</span>]<br></code></pre></td></tr></table></figure><p>ADD 后面是源文件，再后面才是目标文件</p><blockquote><p>注意：ADD、COPY 指令用法一样，唯一不同的是 ADD 支持将归档文件（tar, gzip, bzip2, etc）做提取和解压操作。还有需要注意的是，COPY 指令需要复制的目录一定要放在 Dockerfile 文件的同级目录下。</p></blockquote><p>参考：<a href="http://lpxz.work/2022/07/04/Docker%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6-%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2-updating%E2%80%A6">LPxz的个人博客</a></p><h3 id="5、制作镜像"><a href="#5、制作镜像" class="headerlink" title="5、制作镜像"></a>5、制作镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t zbdemo .<br></code></pre></td></tr></table></figure><p>注意是在jar01目录下</p><h3 id="6、启动容器"><a href="#6、启动容器" class="headerlink" title="6、启动容器"></a>6、启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 8080:8080 --name zbdemo03 zbdemo:latest<br></code></pre></td></tr></table></figure><p>命令参数：</p><ul><li>-d：后台运行</li><li>-p：公开指定端口号</li><li>-name：容器命名</li></ul><p>启动后可通过 <code>docker ps</code> 查看正在运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-10-centos jar01]<span class="hljs-comment"># docker ps</span><br>CONTAINER ID        IMAGE               COMMAND               CREATED             STATUS              PORTS                    NAMES<br>618cf8b1a0a8        zbdemo:latest       <span class="hljs-string">&quot;java -jar app.jar&quot;</span>   14 minutes ago      Up 13 minutes       0.0.0.0:8080-&gt;8080/tcp   zbdemo04<br>45d6deb5444a        zbdemo:latest       <span class="hljs-string">&quot;java -jar app.jar&quot;</span>   16 minutes ago      Up 16 minutes       0.0.0.0:8082-&gt;8082/tcp   zbdemo03<br></code></pre></td></tr></table></figure><h3 id="7、查看启动日志"><a href="#7、查看启动日志" class="headerlink" title="7、查看启动日志"></a>7、查看启动日志</h3><p>我们可以通过 <code>docker logs name</code> 查看指定容器的日志，后面name为容器名，如zbdemo03</p><h3 id="8、DockerFile配置参数"><a href="#8、DockerFile配置参数" class="headerlink" title="8、DockerFile配置参数"></a>8、DockerFile配置参数</h3><p>FROM：FROM 是构建镜像的基础源镜像，该 Image 文件继承官方的 node image。</p><p>详细说明：Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令！ 它引入一个镜像作为我们要构建镜像的基础层，就好像我们首先要安装好操作系统，才可以在操作系统上面安装软件一样。</p><p>RUN：后面跟的是在容器中要执行的命令。</p><p>详细说明：每一个 <code>RUN</code> 指令都会新建立一层，在其上执行这些命令，我们频繁使用 <code>RUN</code> 指令会创建大量镜像层，然而 <code>Union FS</code> 是有最大层数限制的，不能超过 <code>127</code> 层，而且我们应该把每一层中我用文件清除，比如一些没用的依赖，来防止镜像臃肿。</p><p>WORKDIR：容器的工作目录</p><p>COPY：拷贝文件至容器的工作目录下，.dockerignore 指定的文件不会拷贝</p><p>EXPOSE：将容器内的某个端口导出供外部访问</p><p>CMD：Dockerfile 执行写一个 CMD 否则后面的会被覆盖，CMD 后面的命令是容器每次启动执行的命令，多个命令之间可以使用 &amp;&amp; 链接，例如 CMD git pull &amp;&amp; npm start</p><p>详细说明:<code>CMD</code> 指令用来在启动容器的时候，指定默认的容器主进程的启动命令和参数。 </p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>image</tag>
      
      <tag>dockerfile</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法</title>
    <link href="/2022/09/16/tan-xin-suan-fa/"/>
    <url>/2022/09/16/tan-xin-suan-fa/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="贪心算法基础知识"><a href="#贪心算法基础知识" class="headerlink" title="贪心算法基础知识"></a>贪心算法基础知识</h2><p>无套路</p><p>大体思路： 求局部最优，进而求全局最优</p><p>贪心算法一般分为如下四步：</p><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><p>个人思路：将两个数组排序，然后饼干那个一一对应孩子的胃口，若是饼干小了，直接饼干后移，若是孩子小了，仍然直接给出，count+1</p><hr><p>但还有种反向操作，先给大的，后给小的；尽可能多的满足孩子的胃口。</p><p>奥，卡哥跟我想的一样，都是用一个index来避免二次遍历，这道题先满足胃口小的和先满足胃口大的都一样</p><h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p>序列还可以删除，一定要注意这一点</p><p>摆动序列可以转化为求峰值和谷底，求出一个峰值或谷底结果就加一</p><p>result初始化为1，是因为如果初始化0的话，就没有考虑到边界，初始化为1就体现了已经处理左边界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((curDiff &gt; <span class="hljs-number">0</span> &amp;&amp; preDiff &lt;= <span class="hljs-number">0</span>) || (curDiff &lt; <span class="hljs-number">0</span> &amp;&amp; preDiff &gt;= <span class="hljs-number">0</span>)) &#123;<br>count++;<br>preDiff = curDiff;<br>&#125;<br></code></pre></td></tr></table></figure><p>pre处写&lt;=   、 &gt;=  是因为要考虑初始化情况，因为pre初始化为0，所以不管当前大于还是小于，都符合</p><p>同时序列还可以删除，这一点体现在pre = cur的放置位置，放在if里面，意思是只找峰值或谷底，而不去管边界；若是放到if外面，意思是每次都要进行处理，很明显，本题我们要选择放在if里面</p><p>另一种解法是DP,以后再说</p><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p>若全是负数？</p><p>想法：跟上题类似，定义pre和cur，再定义一个最大值，最大值一定是从正数开始，但是若全是负数？？</p><p>行不通，否</p><ol><li>思路一：暴力法，两层for循环，外层遍历，内层从外层开始，找出最大连续和；这样就把每个连续和求出来了，直接返回最大</li><li>思路二：贪心法，重点在于想局部最优，局部最优是：一旦加到了负数，则直接从下一个开始；同时用result记录最大值，由此来确定终止区间。</li><li>思路三：动态规划，目前不涉及</li></ol><p>思路二贪心的实现，有一个问题，若是全是负数呢？又回到了我最初的想法，若全是负数的话，那就应该把result初始化为Integer的最小值，然后先加到sum里，再判断result和sum大小，最后再判断sum是否大于0，这样就完美解决了全是负数的问题。</p><p>我最初是先判断sum是否大于0，若不是则直接continue，这样导致出现全是负数的时候就无法解决。</p><p>卡哥厉害！</p><h2 id="买股票的最佳时机II"><a href="#买股票的最佳时机II" class="headerlink" title="买股票的最佳时机II"></a>买股票的最佳时机II</h2><p>真蠢啊！</p><p>我在想：是否可以像以前那样，定义一个cur，一个pre；找谷峰和谷底，但这样极难实现，或者说就不可以实现</p><p>卡哥是通过计算两天之间的差值，只记录正值即可，并相加；</p><p>还有一种的DP,暂时不考虑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prices.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (prices[i + <span class="hljs-number">1</span>] - prices[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                sum += prices[i + <span class="hljs-number">1</span>] - prices[i];<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>我被秀一脸</p><h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p>回溯？</p><p>看起来像是回溯</p><p>本人想法：局部最优：跳到一个方块，然后找这个方块能跳到的范围内的数值最大的，并且如果最大范围超过了数组，则证明可以跳到，反之不行</p><hr><p>我的想法是不正确的，卡哥的思路：局部最优：找最大覆盖范围，每个都得遍历，若是找到了某个元素覆盖范围覆盖了数组的长度，则可以，反之若是遍历完还是没有返回true，那说明不行了。</p><blockquote><p>也可以这样遍历数组：</p></blockquote><p>​    遍历的是coverMax，而不是整个数组，数组的遍历在for循环里面，看似没遍历数组，实则是对数组的每一个元素都遍历了。</p><h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="==跳跃游戏II=="></a>==跳跃游戏II==</h2><p>这下该找最大了吧</p><p>还是不能找最大，但是讲道理，可行，但是就是跑不通</p><p>卡哥思路：依然是找最大覆盖范围，定义当前最大范围和全体最大范围，当走到当前最大范围时，判断全体最大范围是否大于数组长度，若大于的话，直接+1并且break;若是不大于，就更新当前最大范围到全体最大范围</p><blockquote><p>新思路：最大范围</p></blockquote><h2 id="K次取反后最大化的数组和"><a href="#K次取反后最大化的数组和" class="headerlink" title="K次取反后最大化的数组和"></a>K次取反后最大化的数组和</h2><p>想法：其实只分奇数次和偶数次。需要判断负数的数量，若是负数总数小于k，则先将负数全部转正，然后再减二，直到k为0或1，是0的话不用说了，是1的话将最小的翻转；若负数总数大于k，那么更好办了，直接翻转。</p><p>当然排序会更容易处理一些。</p><p>Yes，跟卡哥想的一样，不过排序是按绝对值大小进行排序，但是我觉得也可以直接排序</p><p>最重要的是，按贪心的思路来想，局部最优，全局最优。</p><p>局部最优是：每次翻转最小的整数</p><p>全局最优是：整个数值达到最大</p><p>确实要按绝对值排序！而且是绝对值从大到小！到最后翻转最后一个数即可；反之绝对值从小到大亦可。</p><h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p>无从下手</p><p>贪心法一：</p><p>进行全局贪心</p><ul><li>情况一：如果gas的总和小于cost总和，那么无论从哪里出发，一定是跑不了一圈的</li><li>情况二：rest[i] = gas[i]-cost[i]为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。</li><li>情况三：如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能这个负数填平，能把这个负数填平的节点就是出发节点。</li></ul><p>贪心法二：</p><p>每个加油站的剩余量rest[i]为gas[i] - cost[i]。</p><p>i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。</p><p><strong>局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置</strong>。</p><p>水</p><h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p>求峰值，或者说是附近位置最大值这种，一般都需要从左到右再从右到左两次遍历确定</p><p>第一次从左到右，判断右边比左边大，则右边+1；</p><p>第二次从右到左，判断左边比右边大，则取原来的和右边+1二者最大值</p><p>注意：原数组进行比较，而不是candy数组进行比较；在这纠结了起码十五分钟！</p><h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h2><p>初步思路：维持一个数组，只保存5和10的个数，还可以求一个sum；局部最优：每次先挑最大的数，也即10，再挑5,；全局最优：所有人都可以找零</p><p>Yes。思路一样，只不过卡哥实现是用两个int型，我用数组，其实用int更好一点。卡哥是遇到直接减，不管是否大于零还是小于零，到最后判断这两个是否都大于等于零即可；我是若是减了大于0，则减。</p><p>卡哥代码更易实现</p><h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h2><p>初步思路：先找ki == 0 的人，然后从小打到再排列，先放小的；然后再找ki == 1的，再从小开始放；然后找ki == 2的，以此类推。</p><p>实现：有一种想法是建两个数组，一个存hi，一个存ki，定义一个函数，功能是交换数组某两个位置的元素。</p><p>思路不可行。我的思路相当于按k排序，但是这种会出现一个问题，[5,2],[7,1]到底谁先呢？出现不确定性。</p><p>卡哥：这种两种维度的题一定要先确定一个维度，若是两个维度都想兼顾到的话就会顾此失彼。</p><p>实现：看了卡哥的，真是厉害！使用自定义函数Arrays.sort()进行排序，之后使用list来遍历</p><blockquote><p>注意：从小到大：o1 - o2;从大到小：o2 - o1</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(people, (a, b) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])<br>                <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];   <span class="hljs-comment">//从小到大</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>];   <span class="hljs-comment">//从大到小</span><br>        &#125;);<br></code></pre></td></tr></table></figure><p>==插入操作==</p><p>使用LinkedList.add(index, value)方法进行插入，第一个参数是插入位置</p><p>最后使用toArray方法进行数组转换。</p><p>卡哥方法使用到位！厉害</p><h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h2><p>数组第一个数组进行排序，从小到大；从结尾出判断，若下面有有数组在这个区间，则将这个区间一同删去（或者说往后遍历）</p><p>思路跟卡哥一样，只是实现是个问题</p><p>首先是排序，二维数组经典排序（从小到大）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(points, (o1, o2) -&gt; Integer.compare(o1[<span class="hljs-number">0</span>], o2[<span class="hljs-number">0</span>]));<br></code></pre></td></tr></table></figure><p>实现：从1处开始遍历，判断上一个的结尾和下一个的开头是否有交集，若无交集，直接count++;若有交集，则更新下一个的右边界，更新为上一个和下一个的最小值，最后返回。</p><h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><p>初步思路：仍然是排序，从小到大排序，若是开端相同，则默认删掉结尾长的那个数组；留下来是下一个的开端大于等于上一个的结尾；若是下一个开端小于上一个结尾，说明有重叠，则直接更新下一个结尾。</p><p>试了一下，果然成功了。</p><p>卡哥思路更简单，也更加全面。分按左区间排序和右区间排序；我上面的思路就是按左区间进行排序的，卡哥用了一个int pre来记录上一次结尾的最小值，每次都更新pre</p><h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h2><p>自己没有思路。。</p><p>卡哥思路：总共26个字母，先把这些字母最后出现字母写进数组，然后再遍历一次字符串，每次更新最大右边界，若当前位置等于当前出现最大值，说明已经到了该划分的时候</p><p>贪心，并没有体现，至少我想象不出。</p><p>开拓视野吧。但是很精彩</p><h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p>貌似不难</p><p>初步思路：对左边界进行排序，只需要判断右边界是否大于左边界即可</p><p>==重要：==</p><p>定义二维数组：</p><p>List&lt;int[]&gt; res = new ArrayList&lt;&gt;();</p><p>list添加二维数组：</p><p>res.add(new int[]{start, intervals[i - 1] [1]});</p><p>list转二维数组：</p><p>res.toArray(new int[res.size()] []);</p><blockquote><p>注意</p></blockquote><p>处理的永远是上一层的末尾，所以最后要单独处理一下最后一层</p><h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h2><p>暴力解法：写一个判断是否单调递增的函数，从这个数开始往下遍历，找到一个符合的立刻返回</p><p>结果自然是超时。哈哈哈哈</p><p>贪心解法：局部最优：首先若是str[i - 1] &gt;  str[i]的话，证明前一位数大，则将str[i-1]–,并让str[i] = 9，这样就可保证局部最大；全局最优：遍历，即可达到全局最优。</p><p>问题在于，是从前往后遍历还是从后往前遍历。当然是从后往前遍历，因为从前往后遍历的时候，比如332，  332 -&gt; 329，Out。从后往前遍历，332 -&gt; 329 -&gt; 299</p><p>本题用到的java方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 整形转string</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.valueOf(n);<br><span class="hljs-comment">// 字符串转字符数组</span><br><span class="hljs-type">char</span>[] chars = s.toCharArray();<br><span class="hljs-comment">// 先转字符串再转整形</span><br>Integer.parseInt(String.valueOf(chars));<br></code></pre></td></tr></table></figure><p>以下都可转string</p><p><img src="/2022/09/16/tan-xin-suan-fa/Typora文件\Typora图片\image-20220621143453592.png" alt="image-20220621143453592"></p><h2 id="买卖股票的最佳时机（含手续费）"><a href="#买卖股票的最佳时机（含手续费）" class="headerlink" title="买卖股票的最佳时机（含手续费）"></a>买卖股票的最佳时机（含手续费）</h2><p>初步思路：遇到极小值的就买入，遇到极大值就卖出</p><p>当然也可能有问题</p><p>卡哥思路：不需要计算具体时间，只需要计算连续收获利润即可</p><p>计算收获利润时：</p><ol><li>收获利润这一天并不是最终收获利润的那一天</li><li>前一天是最终收获利润那一天，今天重新计算</li><li>不作操作，不买不卖</li></ol><p>很巧妙</p><p>每次执行操作时都加上fee，初始化一个buy，遍历数组，若是遇到p + fee &lt; buy的，另buy重置为p + fee，说明需要买入；若是遇到p &gt; buy的，说明有利润，直接加到sum里，并重置buy = p；其他的情况可以不管。</p><p>但其实本题用动态规划更好一点</p><h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><p>个人想法：可以发现，每三层必有一个监控，在第二层设置监控即可。另外再设置一个数组，用来标记是否已经监控，连续两层必有监控。</p><p>细节：但是设置标记数组的话，需要知道树的全部子节点，不易实现。</p><p>卡哥思路：从下到上，从最下面的叶子结点开始，对叶子结点的父节点设置监控。局部最优：从叶节点的父节点开始设置监控；全局最优：使用的摄像头最少</p><p>难点：</p><p>如何遍历树</p><p>如何隔两个节点放置监控</p><ol><li><p>如何遍历树<br>使用后序遍历</p></li><li><p>如何隔两个节点放置监控<br>每个节点三个状态：</p><ul><li>0   无覆盖</li><li>1   有摄像头</li><li>2   有覆盖</li></ul><p>单层处理逻辑四种情况：</p><ul><li>左右孩子都有覆盖<br>则中间节点肯定无覆盖</li><li>左右孩子至少有一个无覆盖<br>中间节点应放置摄像头</li><li>左右节点至少有一个摄像头</li><li>处理头结点</li></ul></li></ol><p>总的来说，一共就那几种情况。</p><p>先判断左右孩子是否至少有一个无覆盖，有则直接放置一个摄像头；再判断左右孩子是否都是有覆盖，若全都有覆盖，则中间节点必定是无覆盖；剩下情况直接返回有覆盖。</p><p>这是一道Hard题，==仔细揣摩==。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法</title>
    <link href="/2022/09/16/hui-su-suan-fa/"/>
    <url>/2022/09/16/hui-su-suan-fa/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯通常隐藏在递归函数的下面</p><p>==for循环横向遍历，递归纵向遍历==</p><p>回溯法是一个纯暴力搜索，并不是高效的算法</p><p>适用于：</p><ol><li>组合问题</li><li>切割问题</li><li>子集问题</li><li>排列问题</li><li>棋盘问题</li></ol><p>回溯法可以抽象为一个树形结构（n叉树）</p><h2 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="回溯法模板"></a>回溯法模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(参数)</span> &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素(树中结点孩子的数量就是集合的大小)) &#123;<br>        处理结点;<br>        backtracking(路径， 选择列表);   <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>        <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p><img src="/2022/09/16/hui-su-suan-fa/Typora文件\Typora图片\image-20220607093535686.png" alt="image-20220607093535686"></p><h2 id="组合总数III"><a href="#组合总数III" class="headerlink" title="组合总数III"></a>组合总数III</h2><ol><li>两个全局变量<br>List&lt;&gt; path;    List&lt;List&lt;&gt;&gt; res;<br>四个参数<br>n, k, index, sum</li><li>终止条件<br>值总和相等</li><li>单层处理逻辑<br>回溯</li></ol><p>剪枝操作：</p><ol><li>已经选择的元素个数：path.size();</li><li>还需要的元素个数为: k - path.size();</li><li>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li></ol><h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p>本题的难点在于：如何将数字与字母相对应？</p><p>可以用一个二维数组，将数字与字母位置写死，需要时可直接取出来；</p><p>还是递归老三部：</p><ol><li>确定递归参数</li><li>确定终止条件</li><li>确定单层处理逻辑</li></ol><p>本题貌似无法剪枝。</p><p>要进行字符串的增加或者删除时，可以使用StringBuilder，其中增加用append，删除用deleteCharAt()，最后转为String 可以用sb.toString()。</p><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p>依然是递归三部曲</p><p>只是这道题与之前的几道题的区别在于，这道题可以重复使用数字，并且没有限定有几个数；</p><p>首先对数组元素进行排序；解决重复使用数字，使用一个index，index用来定位，以前的不可重复递归的时候是index+1，可重复的话就是index；解决没有限定几个数，可以用sum是否大于target来判断</p><h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h2><p>难点在于，每个数字在组合中只能使用一次，==但是==，会出现重复的。</p><p>比如[1,1,2],target = 3,       处理不好的话[1,2],[1,2]会出现两次，就需要去重。回溯去重有两种去重，一种是树枝去重，另一种是树层去重。</p><p>对于本题来说，树枝是可以重复的，因为人家本来就有重复的元素；树层是不可以重复的。</p><p>有如下==两种办法去重==：</p><ol><li><p>使用数组标记<br>先判断，若i &gt; 0并且本次遍历元素与上一个元素相同，同时标记数组为false，则表明为树层重复，应该去掉，直接continue；<br>解释一下标记数组，若已经使用过，则将标记数组置为1，status[i - 1] == 0代表i-1个元素没有使用过<br>那么肯定，若i-1没有使用过，则本次重复为树层重复；若i-1已使用过，则代表已经使用过，为树枝重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; status[i - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)       <br><span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure></li><li><p>不使用数组标记<br>很简单，若是本次与上一个相等，则就是树层重复</p></li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ( i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] ) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><ul><li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个…..。</li><li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…..。</li></ul><p>亦可以抽象为一颗树形结构</p><p><img src="/2022/09/16/hui-su-suan-fa/Typora文件\Typora图片\image-20220610103125075.png" alt="image-20220610103125075"></p><p>难点：</p><ul><li>切割问题可以抽象为组合问题</li><li>如何模拟那些切割线<br>用index来定位</li><li>切割问题中递归如何终止<br>若index大于s.length()，则加入结果并返回</li><li>在递归循环中如何截取子串<br>用s.substring()</li><li>如何判断回文<br>回文好解决，用双指针解决</li></ul><h2 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h2><p>substring() 前闭后开</p><p>==做这类型题，一定注意区间是开还是闭！！！==</p><p>思路一：</p><p>本题可直接对原字符串s进行操作，因为后续会有回溯操作</p><p>需要写一个判断是否有效的函数，思路为：定义一个sum,令sum = sum * 10 + s.charAt(i) - ‘0’;即可求出数值，然后判断是否大于255即可</p><p>还有一个坑：因为要输出ip的时候ip地址中间有’.’，所以进行递归的时候直接i + 2,例如：backtracking(s, i + 2, pointsum);</p><p>同时，本题与其他的回溯不同的是，本题处理单层逻辑时，若是发现数字不是有效数字，则直接跳出，而不是continue；</p><p>思路二:</p><p>剪枝操作，回溯函数参数附带一个index，以及一个number，代表当前的ip段，一共有四段</p><p>终止条件：如果index == 字符串长度， 并且number == 4， 则是正确的，添加进res并返回，否则直接返回</p><p>单层操作：重点在for循环的第二个条件，在第二个条件里就判断是否有效，而不像思路一那样另写一个方法</p><p>==Integer.parseInt(s.substring(start, i + 1)) &gt;= 0 &amp;&amp; Integer.parseInt(s.substring(start, i + 1)) &lt;= 255；==</p><p>（若是面试华为鸿蒙的时候知道这个，说不定写出来了呢？）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length() &amp;&amp; i - start &lt; <span class="hljs-number">3</span> &amp;&amp; Integer.parseInt(s.substring(start, i + <span class="hljs-number">1</span>)) &gt;= <span class="hljs-number">0</span><br>&amp;&amp; Integer.parseInt(s.substring(start, i + <span class="hljs-number">1</span>)) &lt;= <span class="hljs-number">255</span>; i++) &#123;<br><span class="hljs-comment">// 如果ip段的长度大于1，并且第一位为0的话，continue</span><br>    <span class="hljs-comment">// 也就是说，0在第二位或者第三位，反正不在第一位，则令i++</span><br><span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> - start &gt; <span class="hljs-number">1</span> &amp;&amp; s.charAt(start) - <span class="hljs-string">&#x27;0&#x27;</span> == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>stringBuilder.append(s.substring(start, i + <span class="hljs-number">1</span>));<br><span class="hljs-comment">// 当stringBuilder里的网段数量小于3时，才会加点；如果等于3，说明已经有3段了，最后一段不需要再加点</span><br><span class="hljs-keyword">if</span> (number &lt; <span class="hljs-number">3</span>) &#123;<br>stringBuilder.append(<span class="hljs-string">&quot;.&quot;</span>);<br>&#125;<br>number++;<br>restoreIpAddressesHandler(s, i + <span class="hljs-number">1</span>, number);<br>number--;<br><span class="hljs-comment">// 删除当前stringBuilder最后一个网段，注意考虑点的数量的问题</span><br>stringBuilder.delete(start + number, i + number + <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p>难点在于：树枝上的子节点随时可以停下</p><p>个人思路：遍历一个，就把这个加入进去，碰到最大数即返回；所以可能要排序？</p><p>？？？竟然通过了，神奇！细节我还没有扣</p><hr><p>正确解法：</p><p><img src="/2022/09/16/hui-su-suan-fa/Typora文件\Typora图片\image-20220610151529520.png" alt="image-20220610151529520"></p><p>牛！</p><p>本题的res.add()位置就相当有讲究了</p><p>应该放在回溯的开头，为何？因为放在开头会有[]空这个子集，否则就少了一个子集</p><p>但是为什么不需要排序？是因为nums[i]就已经确定相对位置了，for循环从0开始，而num[]不变，就相当于一直往后遍历。这块有点绕，但精彩</p><h2 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h2><p>这个总要排序了吧？</p><p>这个要不排序的话，那么重复元素怎么解决。</p><p><em>倒是有一种解决办法，若这个元素与上个元素相等，则continue；</em>      ==解决不了==    必须要排序，要么排序，要么新建一个used数组</p><p>看了一眼，果然，是树层去重</p><p>Yes!!!!!!!                                   厉害厉害</p><h2 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h2><p>本题去重</p><p><img src="/2022/09/16/hui-su-suan-fa/Typora文件\Typora图片\image-20220613104412019.png" alt="image-20220613104412019"></p><p>昏过了 头，执行代码一直显示超出时间限制，原因是因为粗心大意而写了个死循环</p><p>map.getOrDefault(nums[i], 0)    厉害（我只会说厉害吗?）</p><p>词穷</p><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>排列问题与组合问题不同，组合问题需要一个index来确定遍历的位置，而排列不同，因为[2,1]和[1,2]是不同的，无法使用index，但是要使用一个used数组，或者其他的map等，用来记录是否已使用过</p><p>还是递归三部曲</p><p>参数不同，不需要index，同时可以定义一个全局变量，这样就不需要传参了。</p><h2 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h2><p>去重的时候，或者剪枝的时候</p><p>非常重要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// used[i - 1] == true，说明同一树枝nums[i - 1]使用过</span><br><span class="hljs-comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span><br></code></pre></td></tr></table></figure><p>树枝去重和树层去重；为什么不判断user[i]而要判断user[i - 1]呢，因为已经到了i这一层，那么i-1就一定已经处理过了</p><p>其余还是递归三部曲</p><h2 id="重新安排行程（重要）"><a href="#重新安排行程（重要）" class="headerlink" title="重新安排行程（重要）"></a>重新安排行程（重要）</h2><p>思路：</p><p>递归三部曲</p><p>可以发现，最终行程数 = 机场数 + 1，由此确定终止条件</p><p>回溯方法只考虑逻辑处理，而不考虑数据的输入，数据的输入在主函数完成</p><p>最重要的是各种集合的使用：</p><ul><li><p>集合的遍历：</p><ul><li><p>使用entry遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br> <br><span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;<br> <br>    System.out.println(<span class="hljs-string">&quot;Key = &quot;</span> + entry.getKey() + <span class="hljs-string">&quot;, Value = &quot;</span> + entry.getValue());<br> <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>遍历key或value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br> <br><span class="hljs-comment">//遍历map中的键</span><br> <br><span class="hljs-keyword">for</span> (Integer key : map.keySet()) &#123;<br> <br>    System.out.println(<span class="hljs-string">&quot;Key = &quot;</span> + key);<br> <br>&#125;<br> <br><span class="hljs-comment">//遍历map中的值</span><br> <br><span class="hljs-keyword">for</span> (Integer value : map.values()) &#123;<br> <br>    System.out.println(<span class="hljs-string">&quot;Value = &quot;</span> + value);<br> <br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>TreeMap的使用<br>会对key进行排序</p></li></ul><p>使用TreeMap，就很好的解决了题目要求的按字母大小排序的要求</p><blockquote><p>在进行插入的时候，逻辑是：1、判断是否存在这个key，如果存在，那么先取出原来的值，再赋值最新的值；若不存在，则建立一个TreeMap，再赋值最新的值。</p></blockquote><p>==遍历的时候总是多进一层==</p><blockquote><p>本题还有另外一个注意事项，就是本题的回溯方法返回值是boolean，为什么呢？</p></blockquote><p>因为我们只需要找出一个行程即可，若是找到行程，一路返回true；同时找行程的过程中使用TreeMap，就可以保证返回的行程是按字母表顺序来的</p><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>回溯法的经典题目</p><p>可以写个函数，来判断该位置是否能放皇后，      ==错误==：<em>斜对角的位置判断：数加起来等于一个定值，就说明该斜对角线已经有皇后了，如res[1] [2] 和res[0] [3],就属于同一条斜线</em></p><p>依然是递归三部曲</p><p>参数可以加一个row，用来遍历当前是第几层，同时若是到了最底层，则就返回；这是终止条件</p><p>┗|｀O′|┛ 嗷~~，知道了，判断是否有效不能简单的那么判断，因为上述没有考虑到另一条斜对角线，所以判断是否有效要分列，45°，135°三种情况</p><blockquote><p>不熟悉的方法：</p><ol><li>Arrays.fill（ a1, value ）;    其中a1是数组，后面value是值，数组赋值</li><li>String.copyValueOf(c)；    其中c是一个一维数组，char[] c， 表示将c转化为一个String类型<br>String.copyValueOf(char[] data, int offset, int count);  第二个参数表示子数组的初始偏移量；count表示子数组的长度</li></ol></blockquote><blockquote><p>新思路（新操作）：</p><ul><li>将数组全部置为’.’，满足要求再将数组置为’Q’</li><li>有些时候回溯算法处理单层逻辑时只考虑成功的情况，如   if () {} </li></ul></blockquote><h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h2><p>本题与以上的回溯法不同之处在于，本题是二重循环来进行遍历</p><p>总觉得时间复杂度会极高</p><p>同样，本题也需要单独写一个判断有效函数，有效函数行和列好判断，问题在于九宫格的判断；可以发现，本题数组下标是从0开始的，也就是说 012     345  678，由此可以想到，val除以3，得到start，然后再*三，就得到九宫格</p><blockquote><p>返回值</p></blockquote><p>回溯函数返回值是boolean，目的是找到一个正确的解，一旦找到正确的解就返回；在两层for循环之后，若是还找不到正确的解，就返回false，所以不需要终止条件！</p><blockquote><p>原创数字</p></blockquote><p>如果不注意，就会把人家的原创数字毁掉，这时就需要用continue来跳过原创数字</p><blockquote><p>单层处理逻辑</p></blockquote><p>在进行单层处理时，可以做如下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">board[i][j] = m;<br><span class="hljs-keyword">if</span> (tracking(board))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br></code></pre></td></tr></table></figure><p>2-3行为什么要用if呢，必须的！若是找到了解，则直接返回true；</p><blockquote><p>递归体现在哪里？</p></blockquote><p>上述有个continue操作，遇到数字就跳过，因为上一层中已经新设定了数字，所以这一层就不会动上一层的数字，从而达到回溯效果</p><h2 id="回溯法总结"><a href="#回溯法总结" class="headerlink" title="回溯法总结"></a>回溯法总结</h2><p>可以解决如下问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>子集问题分析：</p><ul><li>时间复杂度：O(2^n)，因为每一个元素的状态无外乎取与不取，所以时间复杂度为O(2^n)</li><li>空间复杂度：O(n)，递归深度为n，所以系统栈所用空间为O(n)，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为O(n)</li></ul><p>排列问题分析：</p><ul><li>时间复杂度：O(n!)，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ….. 1 = n!。</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>组合问题分析：</p><ul><li>时间复杂度：O(2^n)，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>N皇后问题分析：</p><ul><li>时间复杂度：O(n!) ，其实如果看树形图的话，直觉上是O(n^n)，但皇后之间不能见面所以在搜索的过程中是有剪枝的，最差也就是O（n!），n!表示n * (n-1) * …. * 1。</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>解数独问题分析：</p><ul><li>时间复杂度：O(9^m) , m是’.’的数目。</li><li>空间复杂度：O(n^2)，递归的深度是n^2</li></ul><p><strong>一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括吧！</strong></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2022/09/16/er-cha-shu/"/>
    <url>/2022/09/16/er-cha-shu/</url>
    
    <content type="html"><![CDATA[<h1>二叉树</h1><h2 id="二叉树最近公共祖先">二叉树最近公共祖先</h2><p>思路：</p><p>找p,q;必须要遍历整棵树，自底向上遍历，采用后序遍历</p><p>找到p或q就返回q或q的结点，找不到则返回空；若是发现左子树和右子树都不为空，那就说明，当前结点root就是最近的公共祖先；若是发现左子树为空，右子树不为空，则说明是通过右子树返回的，返回右子树即可</p><p>所以逻辑就很清楚了：</p><ol><li>先判断root是否为p q null 这几种情况</li><li>left = 递归方法；</li><li>right = 递归方法；</li><li>再判断左右子树是否为空的情况，据此来返回二叉树最近公共祖先</li></ol><h2 id="二叉树搜索最近公共祖先">二叉树搜索最近公共祖先</h2><p>一种思路是上述的二叉树最近公共祖先</p><p>另一种思路就是利用二叉搜索树的性质</p><p>思路：</p><p>如果当前结点同时大于p、q，那么就说明应该在左子树找；反之，在右子树找；如果发现一边大一边小，那么直接返回当前结点，当前结点就是最近公共祖先</p><p>第三种思路，迭代法</p><p>迭代法：</p><p>用一个while循环，若当前结点同时大于p、q，往左子树走；反之，往右子树走；否则，直接返回</p><p><strong>秒！！！</strong></p><h2 id="二叉搜索树的插入操作">二叉搜索树的插入操作</h2><p>我的想法是，首先备份root结点（通过创建一个新节点），然后while写一个死循环，若找到插入位置，则break，最后返回即可。</p><p>上述为迭代法</p><p>下面是递归法：</p><p>若root为空，则创建一个新结点，说明找到位置了</p><p>若root大于当前结点，则递归左子树调用方法</p><p>若root小于当前结点，则递归右子树调用方法</p><h2 id="删除二叉搜索树中的结点">删除二叉搜索树中的结点</h2><p>递归三部曲</p><ul><li>确定递归函数以及返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ul><p>思路：</p><p>一共有五种情况：</p><ol><li>根节点为空，则返回root，说明递归结束（没找到）；</li><li>根节点左右子树都为空，则返回null，说明是叶子结点，直接删掉；</li><li>根节点左子树为空右子树不为空，返回右子树；</li><li>根节点左子树不为空右子树为空，返回左子树；</li><li>根节点左右子树都不为空，则将左子树放到右子树的最左子树处，返回右子树。</li></ol><h2 id="修剪二叉搜索树">修剪二叉搜索树</h2><p>剪枝操作</p><p>给定范围(low, high)</p><p>若根节点小于low，直接去操作右子树，左子树已然全部挂</p><p>同理，若根节点大于high，直接去操作左子树</p><p>若root在合理范围内，则递归操作左右子树</p><h2 id="将有序数组转为二叉搜索树">将有序数组转为二叉搜索树</h2><p>注意数组越界，在二分法时要注意： int mid = left + ((right - left) / 2);</p><p>思路:</p><p>因为是有序，所以直接按区间划分，每次将中间结点赋值给root结点，然后递归的划分区间</p><h2 id="把二叉搜索树转化为累加树">把二叉搜索树转化为累加树</h2><p>因为是二叉搜索树，所以中序遍历就是升序。</p><p>因为本题要累加，如果从最小的开始加的话，无法知道后续大于最小的数的累加；所以只能从最大的开始，从最大的开始的话，那直接对中序遍历做一个右中左的处理，即可达到逆序输出；</p><p>处理结点是先创建一个pre，来保存先前的数，而后一直加下去</p><h2 id="重建二叉树">重建二叉树</h2><p>给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。</p><blockquote><p>方法一：递归</p></blockquote><p><strong>具体做法：</strong></p><ul><li>step 1：先根据前序遍历第一个点建立根节点。</li><li>step 2：然后遍历中序遍历找到根节点在数组中的位置。</li><li>step 3：再按照子树的节点数将两个遍历的序列分割成子数组，将子数组送入函数建立子树。</li><li>step 4：直到子树的序列长度为0，结束递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">reConstructBinaryTree</span><span class="hljs-params">(<span class="hljs-type">int</span> [] pre, <span class="hljs-type">int</span> [] vin)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> pre.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> vin.length;<br>        <span class="hljs-comment">//每个遍历都不能为0</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || m == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//构建根节点</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(pre[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vin.length; i++) &#123;<br>            <span class="hljs-comment">//找到中序遍历中的前序第一个元素</span><br>            <span class="hljs-keyword">if</span> (pre[<span class="hljs-number">0</span>] == vin[i]) &#123;<br>                <span class="hljs-comment">//构建左子树</span><br>                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>),<br>                                                  Arrays.copyOfRange(vin, <span class="hljs-number">0</span>, i));<br>                <span class="hljs-comment">//构建右子树</span><br>                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + <span class="hljs-number">1</span>, pre.length),<br>                                                   Arrays.copyOfRange(vin, i + <span class="hljs-number">1</span>, vin.length));<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树总结">二叉树总结</h2><h3 id="1、二叉树的理论基础">1、二叉树的理论基础</h3><ul><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于二叉树，你该了解这些！ (opens new window)</a>：二叉树的种类、存储方式、遍历方式、定义方式</li></ul><h3 id="2、二叉树的遍历方式">2、二叉树的遍历方式</h3><ul><li>深度优先遍历<ul><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">二叉树：前中后序递归法 (opens new window)</a>：递归三部曲初次亮相</li><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">二叉树：前中后序迭代法（一） (opens new window)</a>：通过栈模拟递归</li><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html">二叉树：前中后序迭代法（二）统一风格(opens new window)</a></li></ul></li><li>广度优先遍历<ul><li><a href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">二叉树的层序遍历 (opens new window)</a>：通过队列模拟</li></ul></li></ul><h3 id="3、求二叉树的属性">3、求二叉树的属性</h3><ul><li>二叉树：是否对称(opens new window)<ul><li>递归：后序，比较的是根节点的左子树与右子树是不是相互翻转</li><li>迭代：使用队列/栈将两个节点顺序放入容器中进行比较</li></ul></li><li>二叉树：求最大深度(opens new window)<ul><li>递归：后序，求根节点最大高度就是最大深度，通过递归函数的返回值做计算树的高度</li><li>迭代：层序遍历</li></ul></li><li>二叉树：求最小深度(opens new window)<ul><li>递归：后序，求根节点最小高度就是最小深度，注意最小深度的定义</li><li>迭代：层序遍历</li></ul></li><li>二叉树：求有多少个节点(opens new window)<ul><li>递归：后序，通过递归函数的返回值计算节点数量</li><li>迭代：层序遍历</li></ul></li><li>二叉树：是否平衡(opens new window)<ul><li>递归：后序，注意后序求高度和前序求深度，递归过程判断高度差</li><li>迭代：效率很低，不推荐</li></ul></li><li>二叉树：找所有路径(opens new window)<ul><li>递归：前序，方便让父节点指向子节点，涉及回溯处理根节点到叶子的所有路径</li><li>迭代：一个栈模拟递归，一个栈来存放对应的遍历路径</li></ul></li><li>二叉树：递归中如何隐藏着回溯(opens new window)<ul><li>详解<a href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html">二叉树：找所有路径 (opens new window)</a>中递归如何隐藏着回溯</li></ul></li><li>二叉树：求左叶子之和(opens new window)<ul><li>递归：后序，必须三层约束条件，才能判断是否是左叶子。</li><li>迭代：直接模拟后序遍历</li></ul></li><li>二叉树：求左下角的值(opens new window)<ul><li>递归：顺序无所谓，优先左孩子搜索，同时找深度最大的叶子节点。</li><li>迭代：层序遍历找最后一行最左边</li></ul></li><li>二叉树：求路径总和(opens new window)<ul><li>递归：顺序无所谓，递归函数返回值为bool类型是为了搜索一条边，没有返回值是搜索整棵树。</li><li>迭代：栈里元素不仅要记录节点指针，还要记录从头结点到该节点的路径数值总和</li></ul></li></ul><h3 id="4、二叉树的修改与构造">4、二叉树的修改与构造</h3><ul><li>翻转二叉树(opens new window)<ul><li>递归：前序，交换左右孩子</li><li>迭代：直接模拟前序遍历</li></ul></li><li>构造二叉树(opens new window)<ul><li>递归：前序，重点在于找分割点，分左右区间构造</li><li>迭代：比较复杂，意义不大</li></ul></li><li>构造最大的二叉树(opens new window)<ul><li>递归：前序，分割点为数组最大值，分左右区间构造</li><li>迭代：比较复杂，意义不大</li></ul></li><li>合并两个二叉树(opens new window)<ul><li>递归：前序，同时操作两个树的节点，注意合并的规则</li><li>迭代：使用队列，类似层序遍历</li></ul></li></ul><h3 id="5、求二叉搜索树的属性">5、求二叉搜索树的属性</h3><ul><li><a href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html">二叉搜索树中的搜索(opens new window)</a><ul><li>递归：二叉搜索树的递归是有方向的</li><li>迭代：因为有方向，所以迭代法很简单</li></ul></li><li><a href="https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">是不是二叉搜索树(opens new window)</a><ul><li>递归：中序，相当于变成了判断一个序列是不是递增的</li><li>迭代：模拟中序，逻辑相同</li></ul></li><li><a href="https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html">求二叉搜索树的最小绝对差(opens new window)</a><ul><li>递归：中序，双指针操作</li><li>迭代：模拟中序，逻辑相同</li></ul></li><li><a href="https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html">求二叉搜索树的众数(opens new window)</a><ul><li>递归：中序，清空结果集的技巧，遍历一遍便可求众数集合</li><li><a href="https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html">二叉搜索树转成累加树(opens new window)</a></li><li>递归：中序，双指针操作累加</li><li>迭代：模拟中序，逻辑相同</li></ul></li></ul><h3 id="6、二叉树公共祖先问题">6、二叉树公共祖先问题</h3><ul><li>二叉树的公共祖先问题(opens new window)<ul><li>递归：后序，回溯，找到左子树出现目标值，右子树节点目标值的节点。</li><li>迭代：不适合模拟回溯</li></ul></li><li>二叉搜索树的公共祖先问题(opens new window)<ul><li>递归：顺序无所谓，如果节点的数值在目标区间就是最近公共祖先</li><li>迭代：按序遍历</li></ul></li></ul><h3 id="7、二叉搜索树的修改与构造">7、二叉搜索树的修改与构造</h3><ul><li>二叉搜索树中的插入操作(opens new window)<ul><li>递归：顺序无所谓，通过递归函数返回值添加节点</li><li>迭代：按序遍历，需要记录插入父节点，这样才能做插入操作</li></ul></li><li>二叉搜索树中的删除操作(opens new window)<ul><li>递归：前序，想清楚删除非叶子节点的情况</li><li>迭代：有序遍历，较复杂</li></ul></li><li>修剪二叉搜索树(opens new window)<ul><li>递归：前序，通过递归函数返回值删除节点</li><li>迭代：有序遍历，较复杂</li></ul></li><li>构造二叉搜索树(opens new window)<ul><li>递归：前序，数组中间节点分割</li><li>迭代：较复杂，通过三个队列来模拟</li></ul></li></ul><h3 id="8、阶段总结">8、阶段总结</h3><p>大家以上题目都做过了，也一定要看如下阶段小结。</p><p><strong>每周小结都会对大家的疑问做统一解答，并且对每周的内容进行拓展和补充，所以一定要看，将细碎知识点一网打尽！</strong></p><ul><li><a href="https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20200927%E4%BA%8C%E5%8F%89%E6%A0%91%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html">本周小结！（二叉树系列一）(opens new window)</a></li><li><a href="https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201003%E4%BA%8C%E5%8F%89%E6%A0%91%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html">本周小结！（二叉树系列二）(opens new window)</a></li><li><a href="https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201010%E4%BA%8C%E5%8F%89%E6%A0%91%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html">本周小结！（二叉树系列三）(opens new window)</a></li><li><a href="https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201017%E4%BA%8C%E5%8F%89%E6%A0%91%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html">本周小结！（二叉树系列四）(opens new window)</a></li></ul><h3 id="9、最后总结">9、最后总结</h3><p><strong>在二叉树题目选择什么遍历顺序是不少同学头疼的事情，我们做了这么多二叉树的题目了，Carl给大家大体分分类</strong>。</p><ul><li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li><li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li><li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li></ul><p>注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序，<a href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html">二叉树：找所有路径 (opens new window)</a>也用了前序，这是为了方便让父节点指向子节点。</p><p>所以求普通二叉树的属性还是要具体问题具体分析。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2022/09/16/dan-diao-zhan/"/>
    <url>/2022/09/16/dan-diao-zhan/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>在使用单调栈的时候首先要明确如下几点：</p><ol><li>单调栈里存放的元素是什么？</li></ol><p>单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。</p><ol><li>单调栈里元素是递增呢？ 还是递减呢？</li></ol><p><strong>注意一下顺序为 从栈头到栈底的顺序</strong>，因为单纯的说从左到右或者从前到后，不说栈头朝哪个方向的话，大家一定会越看越懵。</p><h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h2><p>思路一：暴力，两层for循环就可以解决问题</p><p>思路二：单调栈</p><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。</p><p>单调栈时间复杂度为O(n)</p><p>本题使用栈头到栈尾递增，注意单调栈里面放的是元素的下标i</p><p>若是栈尾元素大于等于当前元素，直接进栈；否则栈尾元素小于当前元素的话，先弹出比当前元素小的栈尾（用while判断），再入栈</p><h2 id="下一个更大元素I"><a href="#下一个更大元素I" class="headerlink" title="下一个更大元素I"></a>下一个更大元素I</h2><p>首先想到暴力解法，外层遍历nums1，内层遍历nums2，当然可以，时间复杂度是O(n*2)</p><p>也可使用单调栈</p><p>我是这么想的，先用“每日温度”的思路，把nums2寻找右侧第一个比自己大的元素的位置找到，然后再遍历num1。可以一试；NO，到最后给res赋值的时候，找不到nums2的具体位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(nums2[i] &lt;= nums2[stack.peek()])    <span class="hljs-comment">//  小于等于，继续往里放</span><br>     stack.push(i);<br><span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()]) &#123;<br>           <span class="hljs-keyword">if</span> (hashMap.containsKey(nums2[stack.peek()])) &#123;<br>                  <span class="hljs-type">Integer</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> hashMap.get(nums2[stack.peek()]); <span class="hljs-comment">//先取出nums2的下标，再赋值给nums1</span><br>                  res[index] = nums2[i];<br>           &#125;<br>           stack.pop();<br>     &#125;<br>     stack.push(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>重点是第6、7行的代码</p><p>目的是nums1要从nums2中取出数；比如下面的nums[1],   nums[1] = 1,计算nums2中1的右边第一个大的元素，返回的是nums2[1]而不是下标1</p><p><img src="/2022/09/16/dan-diao-zhan/Typora文件\Typora图片\image-20220915111659905.png" alt="image-20220915111659905"></p><h2 id="下一个更大元素II"><a href="#下一个更大元素II" class="headerlink" title="下一个更大元素II"></a>下一个更大元素II</h2><p>本题加了个循环，个人想法是两遍，数组遍历两遍，当成一个数组来做</p><p>确实可以，但是做了无用功，例如扩充数组，扩充数组就不说了，最后还需要将res数组又缩小</p><p>卡哥思路：跟上题大体上类似，只不过本题是遍历了2倍的数组，然后循环的时候计算用i%size来计算</p><p>这种单调栈，我觉得最重要的是赋值的处理，循环内的关键代码的书写</p><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>三种思路：</p><p>一、双指针法</p><p>要求雨水，按列来求，雨水的高度等于该列左侧最高高度和右侧最高高度中低的那个，只需要将左右侧低的那个柱子的高度减去当前列柱子的高度，就可求出该列的雨水，然后从0循环，求总和</p><p>二、动态规划法</p><p>牛蛙牛蛙</p><p>动态规划思路和双指针法其实差不多，只不过由于双指针法存在着大量重复的操作，动态规划优化了一下而已</p><p>动态规划要求将左侧最高高度和右侧最高高度都保存在对应的一个数组里，如maxleft[], maxright[]</p><p>递推公式：左边的最高高度为上一个的最高高度和当前的高度取最大值，右侧同理</p><p>从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);</p><p>从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);</p><p>最后求和</p><p>本题动态规划最简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] maxleft = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[height.length];<br><span class="hljs-type">int</span>[] maxright = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[height.length];<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>maxleft[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>maxright[height.length - <span class="hljs-number">1</span>] = height[height.length - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; height.length; i++) &#123;<br>     maxleft[i] = Math.max(maxleft[i - <span class="hljs-number">1</span>], height[i]);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> height.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>     maxright[i] = Math.max(maxright[i + <span class="hljs-number">1</span>], height[i]);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; height.length; i++) &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> Math.min(maxleft[i], maxright[i]) - height[i];<br>     <span class="hljs-keyword">if</span> (area &gt; <span class="hljs-number">0</span>)<br>          sum += area;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br></code></pre></td></tr></table></figure><p>三、单调栈法</p><p>单调栈法比较难理解，单调栈法是维持栈内从栈头到栈尾从小到大的顺序排列，一旦发现新入栈的元素值大于栈顶元素，就弹出栈顶元素，此时栈顶元素就是底部，再弹出栈顶元素，栈顶元素就是左侧柱子，新入栈的元素就是右侧柱子；</p><p>思路有了，其中还有一些小细节。</p><p>求雨水的高度就是长乘宽，长是高度，宽是右侧与左侧柱子之间的距离，相加。</p><blockquote><p>关键代码：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stacktop]) &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">bottom</span> <span class="hljs-operator">=</span> stack.pop();    <span class="hljs-comment">//先把底柱的编号取出</span><br>     <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;   <span class="hljs-comment">//若是栈不为空的话，进行操作</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(height[i], height[stack.peek()]);    <span class="hljs-comment">//取出左边和右边的最小值，注意左柱为弹出</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> (min - height[bottom]) * (i - stack.peek() - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 求面积</span><br>          <span class="hljs-keyword">if</span> (area &gt; <span class="hljs-number">0</span>)<br>                sum += area;<br>          stacktop = stack.peek();   <span class="hljs-comment">//注意：左柱并没有弹出，而是更新栈顶元素，接着判断，因为是while</span><br>     &#125;<br>&#125;<br>stack.push(i);   <span class="hljs-comment">//最后再将当前元素进栈，进行下一次循环</span><br></code></pre></td></tr></table></figure><h2 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h2><p>感觉这类题动态规划可能好一点？</p><p>本题跟接雨水那道题类似，只不过本题换成了求当前柱子左右两边第一个小于该柱子的柱子</p><p>还有一个区别，是本题要记录下标，而不是高度</p><blockquote><p>思路一：动态规划</p></blockquote><p>动态规划主要体现在求两侧第一个小于该柱子的柱子上</p><ul><li>求左侧：<br>从0开始遍历，使用一个变量t来记录，碰到大的，再往左走；碰到小的直接赋值</li><li>求右侧：<br>从length-2开始遍历，跟求左侧一样</li></ul><p>最后求和，求最大</p><blockquote><p>思路二：单调栈</p></blockquote><p>也能成功AC，但是很明显，单调栈的用时更长</p><p>维持一个栈头到栈尾由大到小的栈，若是遇到当前元素大于栈头元素的，直接进栈；等于也是直接进栈；当前元素小于栈头元素的，那么当前栈顶元素就是底柱，栈顶弹出后，当前元素的栈顶是左柱，i是右柱；即可求出面积，并同求最大值。</p><p>但是需要数组扩容，两边同时扩一下；可能是为了防止i = 1的时候前面没有元素可弹出现栈溢出的错误吧。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2022/09/16/dong-tai-gui-hua/"/>
    <url>/2022/09/16/dong-tai-gui-hua/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划通俗来讲就是由上一个状态推导出来的</p><p>状态转移公式</p><p>一般解题步骤有以下五步：</p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p>动态规划Debug</p><p>先确定状态转移公式，做到心中有数；若没通过，打印出来，看看与自己心中所想是否一样；若是一样的，那就是递推公式、初始化或者遍历顺序有问题了。</p><p>==问题要问的专业==</p><h2 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h2><p>DP五部曲：</p><ol><li><p>确定dp数组以及下标含义：dp[i]的定义：第i个数的斐波那契数值是dp[i]</p></li><li><p>确定递推公式：题目已经给了，<strong>状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p></li><li><p>如何初始化：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">dp[0] = 0;<br>dp[1] = 1;<br></code></pre></td></tr></table></figure></li><li><p>确定遍历顺序：从前往后遍历</p></li><li><p>举例推导dp数组：按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p><p>0 1 1 2 3 5 8 13 21 34 55</p></li></ol><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p>dp[i]的定义：  第i个阶梯有多少种爬楼梯的方式</p><p>递推公式：  </p><p>Out！</p><p>卡哥思路：</p><ol><li>dp[i]的定义：  第i个阶梯有多少种爬楼梯的方式</li><li>递推公式：<br>先想dp[i - 1]，dp[i - 1] 再爬上一阶就是dp[i];再想dp[i - 2]，dp[i - 2]再爬上两阶就是dp[i]；<br>所以dp[i] = dp[i - 1] + dp[i - 2];</li><li>初始化就有争议了：但是注意看题目的范围，题目说的是n为整数，那么自然从1开始喽，初始化1、2，然后从3开始遍历</li><li>确定遍历顺序：从前往后遍历</li><li>举例推导dp数组：<br><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220624112625495.png" alt="image-20220624112625495"></li></ol><p>递推公式这样想： i层 = i - 1 层 + i- 2 层的</p><p>有多少种方法达到i-1层，先记为n1,；有多少种方法达到i-2层，再记为n2；让这俩相加即可</p><h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h2><p>但是这道题好像也可以用贪心？</p><ol><li>dp[i]表示前i阶楼梯所用的花费</li><li>递推公式：<br>不会了</li></ol><p>不能用贪心</p><p>接着来</p><ol><li>dp[i]表示前i阶楼梯所用的花费</li><li>递推公式：<br>从i-1和i-2处下手，dp[i] = min(dp[i-1], dp[i - 2]) + cost[i];<br>不会递推公式了就从i-1和i-2下手</li><li>初始化：只需初始化dp[0]和dp[1]即可</li><li>确定遍历顺序，本体显然是从前到后</li><li>举例推导</li></ol><p>个人觉得dp完了之后还要验算一下结尾情况</p><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义，dp[i] [j]表示到达这一步有多少种走法，最后返回dp[m] [n]即可</li><li>递推公式：<br>dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1];</li><li>初始化：<br>dp[0] [0] = 1；dp[0] [1] = 1；dp[1] [0] = 1；</li><li>二维数组进行遍历，双重循环</li><li>举例推导</li></ol><p>上述五部曲中，有问题的是第三点和第四点。首先第三点初始化，初始化只初始化了  0 1   和 1 0，但是要是碰到0 2 和2 0 呢？会报错，所以边界都要考虑到位，至于说是具体是几种走法，当然是一种啦，因为边界，只有从边界这一侧走过来；第四点遍历顺序，不够细致，是从左到右为主呢还是从上到下为主，其实我觉得都可以，但是要写出来，从左到右顺理成章。</p><p>成功AC</p><p>还有一种思路：</p><p>数论方法：</p><p>组合数学中学到的蚂蚁上树问题，厉害厉害！</p><p>组合问题，从（0，0）到（m, n），共需要 m + n - 2步，需要m - 1步的向右，所以就是</p><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220627101912530.png" alt="image-20220627101912530"></p><p>Yse, AC !</p><p>long 转int:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回int型</span><br><span class="hljs-type">long</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">300</span>;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)a;<br></code></pre></td></tr></table></figure><h2 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h2><p>中间有障碍物了；</p><p>个人思路：与上一题dp一样，只不过多了一个障碍物判断</p><ol><li>确定dp数组的含义，dp[i] [j]表示到达这一步有多少种走法，最后返回dp[m] [n]即可</li><li>递推公式：<br>dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1];中间加一个判断是否为障碍物</li><li>初始化：<br>所有边界都初始化为1</li><li>一层一层的来，从左到右，从上到下</li><li>举例推导</li></ol><p>Yes   成功AC，改了半天bug，问题在于初始化，若是碰到在边界的障碍物，该怎么初始化？应该将其以及其后面的边界全置位0</p><p>看了卡哥的代码，感觉自己好蠢啊，其实可以不用分的这么细，只考虑需要的情况即可，例如进行初始化时我是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; obstacleGrid.length; i++) &#123;<br>          <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)<br>              flag = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>)<br>              dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">else</span><br>              dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>      &#125;<br>      flag = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; obstacleGrid[<span class="hljs-number">0</span>].length; j++) &#123;<br>          <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>)<br>              flag = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>)<br>              dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">else</span><br>              dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>      &#125;<br></code></pre></td></tr></table></figure><p>卡哥是这样的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>   <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//一旦遇到障碍，后续都到不了</span><br>   dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>   <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">////一旦遇到障碍，后续都到不了</span><br>   dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      &#125;<br></code></pre></td></tr></table></figure><p>遍历优化,我的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obstacleGrid[i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span> &amp;&amp; obstacleGrid[i][j - <span class="hljs-number">1</span>] != <span class="hljs-number">1</span>)<br>dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obstacleGrid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> &amp;&amp; obstacleGrid[i - <span class="hljs-number">1</span>][j] != <span class="hljs-number">1</span>)<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br><span class="hljs-keyword">else</span><br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>但其实，这三种可以合为一种，因为碰到一种情况时，另一个dp就为0，所以加上也无所谓</p><p>可以直接合为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><p>动态规划五部曲：</p><ol><li>确定dp[i]的意思：dp[i]表示 i可以拆分成的最大乘积。下面想不通了可以回来想想dp[i]的含义；</li><li>确定递推公式：递归公式若是不好想的话，可以往回想想，想想i - 1或者是dp[i]是怎么得来的。可以分为两部分：  j *(i - j)或者 j *dp[i - j]，二者取最大值。这为什么可以呢，第一个是把 i直接分为两个数的乘积，第二个是把i分为两个以上的乘积，j从1开始遍历，一直去最大值即可；</li><li>初始化：dp[1] = 1;dp[2] = 1; dp[3] = 2;</li><li>遍历顺序从前到后，两层遍历；外层是i: 3到i，内层是j: 1到i</li><li>举例推导</li></ol><p>这道题遍历的时候，卡哥内层是从1遍历到i - j，卡哥说是后面重复了，但是由于我还没有相同，所以直接用的 1到i</p><h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h2><p>动态规划五部曲：</p><ol><li>确定dp[i]的意思：dp[i]的意思是i个节点的二叉搜索树共有dp[i]种</li><li>确定递推公式：往回想，如果求dp[3]的时候，先想dp[2],然后再怎么演化为dp[3]，但是演化，我想到的是：分为大于部分和小于部分，但是中间部分呢？<br>dp[i] = 2 * dp[i - 1] + 1？</li><li>初始化：</li></ol><p>卒！</p><p>第二步就错了。</p><p>卡哥思路：画图，先画出一个节点的数量，再画出两个节点的数量；然后画第三个节点的时候，分为几种情况，1为节点头，2为节点头，3为节点头。</p><p>1为节点头时，数量就是dp[2]；2为节点头时，数量就是d[1]*d[1];3为节点头时，数量就是dp[2]。</p><p>所以接着上述：</p><ol><li></li><li>递推公式：dp[i]  += dp[j - 1] * dp[i - j];  j从1开始</li><li>初始化：只需初始化dp[0] = 1即可</li><li>遍历顺序当然是从前往后遍历</li><li>举例推导 </li></ol><p>成功AC！但是递推公式到底怎么想出来的。</p><p>当i = 3时，   0 2；  1 1； 2 0  </p><p>j从0开始，到i - 1。</p><p>递推公式依然是从前面几个入手，从而推出i是怎么来到 。</p><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220628110720342.png" alt="image-20220628110720342"></p><h3 id="01背包问题（二维数组）"><a href="#01背包问题（二维数组）" class="headerlink" title="01背包问题（二维数组）"></a>01背包问题（二维数组）</h3><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>动态规划五部曲：</p><ol><li><p>确定dp数组以及含义：对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p></li><li><p>那么可以有两个方向推出来dp[i] [j]，</p><ul><li><strong>不放物品i</strong>：由dp[i - 1] [j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1] [j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</li><li><strong>放物品i</strong>：由dp[i - 1] [j - weight[i]]推出，dp[i - 1] [j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1] [j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li></ul><p>递归公式： dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);</p></li><li><p>初始化：首先从dp[i] [j]的定义出发，如果背包容量j为0的话，即dp[i] [0]，无论是选取哪些物品，背包价值总和一定为0。</p><p>状态转移方程 dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p><p>dp[0] [j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p><p>那么很明显当 j &lt; weight[0]的时候，dp[0] [j] 应该是 0，因为背包容量比编号0的物品重量还小。</p><p>当j &gt;= weight[0]时，dp[0] [j] 应该是value[0]，因为背包容量放足够放编号0物品。</p><p>代码初始化如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; j &lt; weight[<span class="hljs-number">0</span>]; j++) &#123;  <span class="hljs-comment">// 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。</span><br>    dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 正序遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>其他的下标可以初始化为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化 dp</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(weight.size()</span>, vector&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220628112932740.png" alt="image-20220628112932740"></p></li><li><p>确定遍历顺序，先遍历物品后遍历背包重量和先遍历背包重量后遍历物品都可以，只是先遍历物品更容易理解。<br>先遍历物品：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]; <br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先遍历背包重量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>举例推导</p></li></ol><p>Java完整01背包代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>        <span class="hljs-type">int</span>[] value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bagsize</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>        testweightbagproblem(weight, value, bagsize);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testweightbagproblem</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weight, <span class="hljs-type">int</span>[] value, <span class="hljs-type">int</span> bagsize)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">wlen</span> <span class="hljs-operator">=</span> weight.length, value0 = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//定义dp数组：dp[i][j]表示背包容量为j时，前i个物品能获得的最大价值</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[wlen + <span class="hljs-number">1</span>][bagsize + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//初始化：背包容量为0时，能获得的价值都为0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= wlen; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = value0;<br>        &#125;<br>        <span class="hljs-comment">//遍历顺序：先遍历物品，再遍历背包容量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= wlen; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= bagsize; j++)&#123;<br>                <span class="hljs-keyword">if</span> (j &lt; weight[i - <span class="hljs-number">1</span>])&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i - <span class="hljs-number">1</span>]] + value[i - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//打印dp数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= wlen; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagsize; j++)&#123;<br>                System.out.print(dp[i][j] + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.print(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="01背包问题（滚动数组）"><a href="#01背包问题（滚动数组）" class="headerlink" title="01背包问题（滚动数组）"></a>01背包问题（滚动数组）</h3><p>滚动数组其实就是一维数组</p><p>动态规划五部曲：</p><ol><li><p>确定dp数组的定义<br>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p></li><li><p>一维dp数组的递推公式</p><p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p><p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p><p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1] [j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，所以递归公式为：   dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p></li><li><p>初始化数组，初始化一定要和定义联系在一起<br>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。<br>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p></li><li><p>遍历顺序：遍历顺序一定是先遍历物品，再遍历背包容量。并且遍历背包容量的时候，滚动数组一定是从大到小的遍历。为什么呢？因为滚动数组遍历的时候需要前面的值，但是前面的值一直变化，而从后往前的 话，前面的值就一直为0。</p></li><li><p>举例推导</p><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220629111108557.png" alt="image-20220629111108557"></p></li></ol><p>滚动数组遍历全代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-type">int</span>[] weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>       <span class="hljs-type">int</span>[] value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">bagWight</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>       testWeightBagProblem(weight, value, bagWight);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWeightBagProblem</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weight, <span class="hljs-type">int</span>[] value, <span class="hljs-type">int</span> bagWeight)</span>&#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">wLen</span> <span class="hljs-operator">=</span> weight.length;<br>       <span class="hljs-comment">//定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值</span><br>       <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bagWeight + <span class="hljs-number">1</span>];<br>       <span class="hljs-comment">//遍历顺序：先遍历物品，再遍历背包容量</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; wLen; i++)&#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bagWeight; j &gt;= weight[i]; j--)&#123;<br>               dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">//打印dp数组</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagWeight; j++)&#123;<br>           System.out.print(dp[j] + <span class="hljs-string">&quot; &quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>其实我还没完全理解明白！</p><h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2><p>这完全看不出来是要用动态规划啊。个人思路：先进行排序，然后从中间分成两个数组，每次判断是否相等，若是不相等，则从大的那边匀一个给小的，以此类推；最后要是发现大的那边最终小于小的那边了，则证明没有，返回false。</p><blockquote><p>回溯法：</p><ul><li>698.划分为k个相等的子集</li><li>473.火柴拼正方形</li></ul></blockquote><p>以上我的思路是也称为回溯暴力法，但是超时。直接上01背包</p><p>重点是要理解为何能嵌套01背包，以及重量以及容量都对应着什么。</p><p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p><ul><li>背包的体积为sum / 2</li><li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li><li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。</li><li>背包中每一个元素是不可重复放入。</li></ul><p>动态规划五部曲：</p><ol><li><p>确定dp数组含义：<br>**dp[j]表示 背包总容量是j，最大可以凑成j的子集总和为dp[j]**。</p></li><li><p>确定递推公式：<br>本题相当于背包里放数值，那么重量也就是nums[i]，其价值也是nums[i]<br>dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</p></li><li><p>如何初始化，跟滚动数组初始化一样，0初始化为0，其余整数初始化为0，负数初始化为负无穷</p></li><li><p>遍历顺序，同滚动数组，先遍历物品，放到这道题也就是nums[i]；嵌套遍历价值</p></li><li><p>举例推导</p><p>dp[j]的数值一定是小于等于j的。</p><p><strong>如果dp[j] == j 说明，集合中的子集总和正好可以凑成总和j，理解这一点很重要。</strong></p></li></ol><p>好好想想！！！</p><p>一层遍历最后的结果，也是一层一层，还是相当于两层遍历的结果，只不过最后保存的是i = nums.length 的值</p><h2 id="最后一块石头的重量II"><a href="#最后一块石头的重量II" class="headerlink" title="最后一块石头的重量II"></a>最后一块石头的重量II</h2><p>与昨天的分割等子集和类似，都是分割成两块重量相差最小的块，然后相减即可。<em>不过这道题与上题不同的是，其中一块的具体重量无法确定</em></p><p>本题物品重量store[], 价值也为store[]；对应01背包问题的物品重量和价值</p><ol><li>确定dp数组的含义：dp[j]表示j块石头相加得出来的总重量</li><li>确定递归函数：可以分为两步考虑，一个是不放第j块，另一个是放第j块；不放就是dp[j ], 放就是dp[j - store[j] ] + store[j]<br>所以：dp[j] = max(dp[j], dp[j - store[j] ] + store[j]  )</li><li>初始化：先全部初始化为0，之后肯定会一层一层的遍历；至于dp数组开到多大，一种做法是所有数相加再除以二；还有一种是看题目给的范围，直接范围除以二</li><li>遍历顺序：外层从前往后，内层从后往前</li><li>举例推导</li></ol><p>最后判断的时候，dp[j]表示可以装多大的重量，那么另一边就是sum - dp[j],那么相差最小就是 sum - dp[j] - dp[j]</p><p>上面斜体字写得 那一段，真是愚蠢！</p><p>dp不管如何分，只管target的大小，也就是总和 / 2；</p><p>其实动态规划二维数组和一维数组，本质上还是二维数组，只不过每次二维数组一次遍历，而一维数组进行多次遍历，最后只保留最后一次遍历的那次结果。</p><h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h2><p>瞟了一眼卡哥的思路，我只能说牛</p><p>首先给出了一个target，那么一定会有left 和right；   同时left + right = sum; 但是 target = left - (sum - left); 所以left = (target + sum) / 2,本题也就转换为求数组中有多少个和是left的组合</p><p>同样，动态规划五部曲：</p><ol><li><p>确定dp[]数组的含义：dp[j]数组表示和为j的有多少种方法</p></li><li><p>确定递归函数</p><p>确定递归函数的时候，考虑一下来源；来源有哪些呢？不考虑nums[i]的情况下，填满容量为j - nums[i]的背包，有dp[j - nums[i]]种方法。<br>考虑nums[i]的情况下，凑成dp[j]就有dp[j - nums[i]]种方法。</p><p>例如：dp[j]，j 为5，</p><ul><li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 dp[5]。</li><li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 dp[5]。</li><li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 dp[5]</li><li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 dp[5]</li><li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 dp[5]</li></ul><p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来</p><p>组合问题的公式：dp[j] += dp[j - nums[i]]</p></li><li><p>初始化：全初始化为0</p></li><li><p>遍历顺序：外层从前往后，内层从后往前</p></li><li><p>举例推导</p></li></ol><p>可以记住：在求装满背包有几种方法的时候，递推公式一般为：dp[j] += dp[j - nums[i]];</p><p>到最后动态规划总结的 时候，==一定要多总结各种dp公式==！！</p><h2 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h2><p>动态规划？</p><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]数组表示</li></ol><p>破功</p><p>动规五部曲：</p><ol><li><p>确定dp数组的含义：**dp[i] [j]：最多有i个0和j个1的strs的最大子集的大小为dp[i] [j]**。</p></li><li><p>确定递推公式</p><p>dp[i] [j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。</p><p>dp[i] [j] 就可以是 dp[i - zeroNum] [j - oneNum] + 1。</p><p>然后我们在遍历的过程中，取dp[i] [j]的最大值。</p><p>所以递推公式：dp[i] [j] = max(dp[i][j], dp[i - zeroNum] [j - oneNum] + 1);</p></li><li><p>dp数组如何初始化，初始化为0即可，因为物品重量不可能为0，所以只需初始化为0；</p></li><li><p>确定遍历顺序<br>外层for循环遍历物品，内层for循环遍历背包容量且从后向前遍历！</p></li><li><p>举例推导</p></li></ol><h2 id="零钱兑换II"><a href="#零钱兑换II" class="headerlink" title="零钱兑换II"></a>零钱兑换II</h2><p>一看到题目中的是钱币不限，就知道要用完全背包</p><ol><li>确定dp数组含义：dp[j]表示总金额为j的货币组合数为dp[j]</li><li>确定递推公式：dp[j]就是dp[j - coins[i]]（不考虑coins[i]）相加。<br>所以：dp[j] += dp[j - coins[i]]</li><li>如何初始化：dp[0] = 1,这是开始，其余初始化为0；</li><li>确定遍历顺序<br>到底是先遍历背包再遍历重量还是先遍历重量再遍历背包；先试想一下，若是先遍历背包再遍历重量，那么重量就会遍历好几次，可能就是排列；而先遍历重量再遍历背包的话，就是组合。若是是在无法确定，自己手动演示一遍</li><li>举例推导</li></ol><p>要想清楚，背包和物品套在本题是对应哪一部分</p><blockquote><p>再来理解一下递推公式：     dp[j] += dp[j - coins[i]]   ；代表遍历每个 coins，那么dp[j]就等于 前一个的相加，而前一个就用coins[i]来表示；所以会有   += 的出现。</p></blockquote><p><strong>注意：求装满背包有几种方法类似的题目，递推公式基本都是这样的</strong>。</p><h2 id="组合总和IV"><a href="#组合总和IV" class="headerlink" title="组合总和IV"></a>组合总和IV</h2><p>不对，自己哪里出了问题</p><ol><li>确定dp数组含义：dp[j]表示总和为j的组合数为dp[j]</li><li>确定递推公式：dp[j]就是dp[j - nums[i]]（不考虑nums[i]）相加。<br>所以：dp[j] += dp[j - nums[i]]</li><li>如何初始化：dp[0] = 1,这是开始，其余初始化为0；</li><li>确定遍历顺序<br>到底是先遍历背包再遍历重量还是先遍历重量再遍历背包；先试想一下，若是先遍历背包再遍历重量，那么重量就会遍历好几次，可能就是排列；而先遍历重量再遍历背包的话，就是组合。若是是在无法确定，自己手动演示一遍<br>那么本题，要求的是排列数，那就先遍历背包再遍历重量;</li><li>举例推导</li></ol><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><h2 id="爬楼梯-进阶版"><a href="#爬楼梯-进阶版" class="headerlink" title="爬楼梯(进阶版)"></a>爬楼梯(进阶版)</h2><ol><li>确定dp数组以及下标的含义<br><strong>dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法</strong>。</li><li>确定递推公式：<br>dp[i]有几种来源，dp[i-1],dp[i-2],dp[i-3]等等。dp[i] += dp[i - j]</li><li>dp如何初始化<br>dp[0] = 1,其余都初始化为0</li><li>确定遍历顺序<br>首先明确要求排列还是求组合，这是求排列问题；那么先遍历背包，再遍历重量</li><li>举例推导</li></ol><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>总金额为背包，coins为物品重量；要求件数最少</p><p>动态规划五部曲：</p><ol><li>确定dp数组含义：<br>dp[i]表示总金额为i的最少的硬币个数</li><li>确定递推公式：<br>先考虑dp[i]怎么来的，dp[i]由 dp[i - coins[j]]，然后一直遍历；那么就是dp[i] += dp[i - coins[j]]</li><li>初始化<br>dp[0] = 1,其余都为0</li><li>遍历顺序<br>组合还是排列？组合，那就先物品重量，再背包</li><li>举例推导</li></ol><p>错！</p><ol><li><p>确定dp数组含义：<br>dp[i]表示总金额为i的最少的硬币个数</p></li><li><p>确定递推公式：<br>先考虑dp[j]怎么来的，dp[j]由 dp[j - coins[i]]，</p><p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）</p><p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p><p>递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);</p></li><li><p>初始化<br>dp[0] = 0,其他的初始化的时候，要考虑要求最大值还是求最小值，题目是要求最小值，那么就赋值最大值，否则就会被dp[0]一直覆盖</p></li><li><p>遍历顺序<br>本题组合和排列均可，那就先背包还是先物品都可以</p></li><li><p>举例推导</p></li></ol><p>动态规划就算知道了五部曲，到现在还有两个难点：</p><ul><li>遍历时i 和 j的初始值赋值问题，尤其是内层循环，是从 0开始还是从coins[i]开始</li><li>写递推公式的判定问题，是直接写还是要满足什么条件再写</li></ul><h2 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h2><p>告诉你用动态规划，要怎么套</p><p>背包是整数n，重量是每个完全平方数，完全平方数可以重复使用，相当于完全背包问题；<strong>但是重量需要判断</strong></p><ol><li>确定dp数组的含义：dp[j]表示和为j的完全平方数的最少数量</li><li>确定递推公式：<br>dp[j]可以由dp[j - i *i] 得来，所以dp[j] = min(dp[j], dp[j - i * i] + 1);</li><li>初始化：因为要求最小值，所以初始化为最大值；dp[0] = 0;</li><li>确定遍历顺序：遍历顺序都可，就先遍历背包，再遍历重量吧</li><li>举例推导</li></ol><blockquote><p>突然发现一个特点，那就是遍历的时候，dp[j]还是dp[i]，是谁不知道，但是一定要满足的是，要从头开始遍历，不能断断续续，这也能确定一部分是i还是j</p></blockquote><p>==举例推导也很重要==</p><p>但是本题重要不需要判断，那么题目中要求的完全平方数体现在哪里呢？体现在递推公式上，递推公式是dp[j - i * i]，后面i * i就已经把那些不是完全平方数的排除了，不手动进行筛选，只在for循环里面进行筛选；也是一种思路</p><p>奥！我突然知道了，最内层循环的关键代码，dp[i]还是dp[j]要取决于代表的意义，==若i代表的是背包，则是dp[i]；反之==</p><h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h2><p>套动态规划、</p><p>字符串s相当于背包总重量，wordDict数组相当于物品重量；要求的是排列，组合肯定不行；</p><ol><li>确定dp数组的含义：dp[i]表示第i个位置可以匹配到</li><li></li></ol><p>OUT</p><p>思路不对。我的思路是求排列，但是若是遇到重复的 ？所以只需要组合</p><ol><li>确定dp数组的含义：dp[i]表示第i个位置可以匹配到</li><li>确定递推公式：<br>首先若是dp[j]为true的时候，说明  0-j 都可以遍历成功；那么若是存在   i - j 的字符串，则dp[i ]设置为true；if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true。</li><li>初始化：dp[0] = true；0是一定要初始化的，因为所有的判断都是以前面的为基础</li><li>遍历顺序：先遍历背包和先遍历物品都可以；但是推荐先遍历背包，若是先遍历物品的话，那就需要提前先把所有物品放进容器里</li><li>举例推导</li></ol><p>好难！ </p><h2 id="背包问题总结"><a href="#背包问题总结" class="headerlink" title="==背包问题总结=="></a>==背包问题总结==</h2><p>背包递推公式：</p><ul><li>问能否装满背包：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</li><li>问装满背包有几种方法：dp[j] += dp[j - nums[i]] ；</li><li>问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); </li><li>问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); </li></ul><p>遍历顺序：</p><ol><li><p>01背包<br>二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。</p></li><li><p>完全背包</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。<br>如果求最小数，那么两层for循环的先后顺序就无所谓了。</p></li></ol><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]表示前i个元素可以偷取的最大金额</li><li>确定递推公式：<br>我感觉要建立一个数组，确定是否已经选取；先假定选取第一个，然后不选第二个，再选第三个的时候判断第一个大还是第二个大；<br>dp[j]  += max(dp[j - 1], dp[j] )</li></ol><p>但是判定数组如何使用？</p><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]表示前i个元素可以偷取的最大金额</li><li>确定递推公式：<br>决定dp[i]的因素就是第i房间偷还是不偷。如果偷，那么就dp[i] = dp[i - 2] + nums[i]；若是不偷，则dp[i] = dp[i - 1]。但是这里要判断一下，这俩个那两个大，那么就是：dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])</li><li>初始化：直接初始化dp[0] = nums[0]，dp[1] = max(nums[0], nums[1])</li><li>确定遍历顺序：一层循环？从前往后遍历</li><li>举例推导</li></ol><p>动态规划并不是非要套什么01背包问题，像本题就不用，且单层循环</p><p>还要注意要判空处理，比如数组只有一个数或者是数组为空的情况</p><h2 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a>打家劫舍II</h2><p>本题相比上题，多了一个循环，也就是收尾是相连的；换句话说，就是选首不能选尾，选尾不能选首。可以把第一个数加到最后一个数后面这样处理吗？</p><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]表示前i个元素可以偷取的最大金额</li><li>确定递推公式：<br>决定dp[i]的因素就是第i房间偷还是不偷。如果偷，那么就dp[i] = dp[i - 2] + nums[i]；若是不偷，则dp[i] = dp[i - 1]。但是这里要判断一下，这俩个那两个大，那么就是：dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])</li><li>初始化：直接初始化dp[0] = nums[0]，dp[1] = max(nums[0], nums[1])</li><li>确定遍历顺序：一层循环？从前往后遍历</li><li>举例推导</li></ol><p>卡哥厉害！</p><p>分析如下：</p><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220708113513360.png" alt="image-20220708113513360"></p><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220708113521374.png" alt="image-20220708113521374"></p><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220708113529354.png" alt="image-20220708113529354"></p><p>既然首尾不能同时存在，那么我手动切去首或者尾不就行了。</p><p>情况二三可以包含情况一，所以代码总体逻辑还是跟上题类似，只不过本题需要比较情况二和情况三谁大谁小</p><blockquote><p>两个问题（已理顺）</p></blockquote><ol><li>主函数边界问题<br>主函数边界问题要深入到动态规划函数里面，发现里面的前闭后开的，解决。</li><li>不用数组进行动态规划遍历问题<br>首先要清楚，遍历要用到i-1和i-2的，那么就要定义三个变量，一个是i-2，一个是i-1，一个是i；分别用x,y,z来表示。由于初始化全为0，所以先赋值i - 1；再赋值当前的i，也就是动态规划递推公式，最后更新i -2,也就是x</li></ol><h2 id="打家劫舍III"><a href="#打家劫舍III" class="headerlink" title="打家劫舍III"></a>打家劫舍III</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[j]表示到第j层可以偷到的最大金额</li><li>确定递推公式：  考虑dp[j]，dp[j]要么是j-2个加上j的，要么是j-1的；具体是哪个取决于哪个比较大。<br>所以递推公式：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j])</li><li>初始化：第一层初始化为root，第二层初始化为第一层和第二层的最大值；</li><li>遍历顺序：使用层序遍历，一层一层</li><li>举例推导</li></ol><p>卡哥思路：</p><p>树形动态规划又是另外一种情况：</p><ol><li><p>确定递归函数的参数和返回值<br>返回的就是dp数组</p></li><li><p>确定终止条件<br>在遍历的过程中，若遇到空节点，无论是偷或者不偷，都初始化为0；注意，是数组</p></li><li><p>确定遍历顺序：<br>使用后序遍历；通过递归左节点，得到左节点偷与不偷的金钱；通过递归右节点，得到左节点偷与不偷的金钱</p></li><li><p>确定单层递归的逻辑</p><p>首先明确一点，res[0, 1];res[0]代表不偷当前节点，res[1]代表偷当前节点<br>分两种情况，若是偷当前节点，则左右节点不能偷，val1 = cur-&gt;val + left[0] + right[0];若是不偷当前节点，那么就要偷左右节点，既然是偷左右节点，那当然是要找左右节点的最大值，val2 = max(left[0], left[1]) + max(right[0], right[1])</p></li><li><p>举例推导</p></li></ol><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>贪心：</p><p>牛！计算最左最小值，最优最大值，计算差值即可</p><p>动态规划五部曲：</p><ol><li>确定dp数组含义：dp[i] [0]表示今天持有股票所得的价值；dp[i] [1]表示今天不持有股票所得的价值</li><li>确定动态规划递推公式：首先要明确，持有并不代表今天买入，同样，不持有并不代表是今天卖出的；<br>那么问题明朗了，持有分两种情况，一种是今天买入，一种是今天不买入；所以dp[i] [0] = max(- prices[i], dp[i - 1] [0]);<br>不持有分两种情况，一种是今天卖出，一种是今天不卖出；所以dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</li><li>初始化：从递推公式上可以看出，都是基于前一个来进行递推，所以初始化dp[0] [0] = -prices[0], dp[0] [1] = 0;</li><li>遍历顺序：从前往后遍历</li><li>举例推导</li></ol><blockquote><p>注意，确定动态规划递推公式的时候，注意正负号；</p></blockquote><p>动态规划确定dp数组的时候，思路要打开，有可能二维数组是因为有两个不同的维度，比如物品重量和物品价值；但也有可能是做一个标记，0 和 1；</p><h2 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h2><p>动态规划五部曲：</p><ol><li>确定dp数组含义：dp[i] [0]表示今天持有股票所得的价值；dp[i] [1]表示今天不持有股票所得的价值</li><li>确定动态规划递推公式：首先要明确，持有并不代表今天买入，同样，不持有并不代表是今天卖出的；<br>那么问题明朗了，持有分两种情况，一种是今天买入，一种是今天不买入；今天买入的情况，要用昨天未买入的价值减去prices[i]，<strong>这一点也是与前一道题有所不同</strong>， 所以dp[i] [0] = max(dp[i - 1] [1] - prices[i], dp[i - 1] [0]);<br>不持有分两种情况，一种是今天卖出，一种是今天不卖出；所以dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</li><li>初始化：从递推公式上可以看出，都是基于前一个来进行递推，所以初始化dp[0] [0] = -proces[0], dp[0] [1] = 0;</li><li>遍历顺序：从前往后遍历</li><li>举例推导</li></ol><h2 id="买卖股票的最佳时机III"><a href="#买卖股票的最佳时机III" class="headerlink" title="买卖股票的最佳时机III"></a>买卖股票的最佳时机III</h2><p>动态规划五部曲：</p><ol><li><p>确定dp数组的含义：dp[i] [j], j 从 0 到4 ，分别代表着不操作，第一次买卖股票，第二次买卖股票</p></li><li><p>确定动态规划递推公式：<br>不操作就不用说了，达到dp[i] [1]有两种途径：</p><ul><li>今天购买，dp[i] [1] = dp[i - 1] [0] - prices[i]</li><li>今天沿用昨天的状态，dp[i] [1] = dp[i - 1] [1]</li></ul><p>取最大值：  dp[i] [1] = max(dp[i - 1] [0] - prices[i], dp[i - 1] [1])<br>同样 dp[i] [2] = max(dp[i - 1] [1] + prices[i], dp[i - 1] [2])</p><p>同理 dp[i] [3] = max(dp[i - 1] [2] - prices[i], dp[i - 1] [3])</p><p>​         dp[i] [4] = max(dp[i - 1] [3] + prices[i], dp[i - 1] [4])</p></li><li><p>如何初始化：<br>dp[0] [0] = 0;  dp[0] [1] = -prices[0];  dp[0] [2] = 0; dp[0] [3] = -prices[0];  dp[0] [4] = 0; </p></li><li><p>确定遍历顺序：从前往后遍历</p></li><li><p>举例推导</p></li></ol><h2 id="买卖股票的最佳时机IV-再考虑考虑"><a href="#买卖股票的最佳时机IV-再考虑考虑" class="headerlink" title="买卖股票的最佳时机IV(再考虑考虑)"></a>买卖股票的最佳时机IV(再考虑考虑)</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j],代表第i天的状态为j所剩下的最大现金<ul><li>j的状态表示为：<br>0代表什么都不干，；<br>1代表第一次买入<br>2代表第一次卖出<br>3代表第二次买入<br>4代表第二次卖出    那么j的范围就可以定义为2*k + 1</li></ul></li><li>确定动态规划递推公式：<br>要想达到dp[i] [1]有两种：今天买，或者今天沿用昨天的状态；  dp[i] [1] = dp[i - 1] [0] - prices[i]  ； dp[i] [1] = dp[i - 1] [1]   ，选最大的<br>同样，达到dp[i] [2]也有两种：今天卖，今天沿用昨天的状态；  dp[i] [2] = max(dp[i - 1] [1] + prices[i], dp[i - 1] [2])<br>遍历j，从0到2*k + 1即可</li><li>初始化：<br>dp[0] [0] = 0;   第一次买入的话，dp[0] [1] = -prices[i]  ;第一次卖出的话，dp[0] [2] = 0;同理，之后只要是买入，不管第几次，都是-prices[i]</li><li>确定遍历顺序：从前往后</li><li>举例推导</li></ol><h2 id="最佳买卖股票时机含冷冻期-再考虑考虑"><a href="#最佳买卖股票时机含冷冻期-再考虑考虑" class="headerlink" title="最佳买卖股票时机含冷冻期(再考虑考虑)"></a>最佳买卖股票时机含冷冻期(再考虑考虑)</h2><p>动态规划五部曲：</p><ol><li><p>确定dp数组的含义：dp[i] [j],代表第i天的状态为j所剩下的最大现金</p><ul><li>j的第一个状态：0，表示今天买入</li><li>j的第一个状态：1，表示今天保持卖出状态，且度过冷冻期</li><li>j的第一个状态：2，表示今天卖出</li><li>j的第一个状态：3，表示今天为冷冻期</li></ul></li><li><p>确定递推公式：<br>==!==想想dp[i] [0] 如何来的，也就是今天买入，一种是今天买入，另一种是今天保持买入状态。二者取最大：max(dp[i - 1] [0] + prices[i] , dp[i - 1] [0]);;<br>以上错误，没有考虑到冷冻期的存在</p><p>达到买入股票状态（状态一）即：dp[i] [0]，有两个具体操作：</p><ul><li>操作一：前一天就是持有股票状态（状态一），dp[i] [0] = dp[i - 1] [0]</li><li>操作二：今天买入了，有两种情况<ul><li>前一天是冷冻期（状态四），dp[i - 1] [3] - prices[i]</li><li>前一天是保持卖出股票状态（状态二），dp[i - 1] [1] - prices[i]</li></ul></li></ul><p>所以操作二取最大值，即：max(dp[i - 1] [3], dp[i - 1] [1]) - prices[i]</p><p>那么dp[i] [0] = max(dp[i - 1] [0], max(dp[i - 1] [3], dp[i - 1] [1]) - prices[i]);</p><p>达到保持卖出股票状态（状态二）即：dp[i] [1]，有两个具体操作：</p><ul><li>操作一：前一天就是状态二</li><li>操作二：前一天是冷冻期（状态四）</li></ul><p>dp[i] [1] = max(dp[i - 1] [1], dp[i - 1] [3]);</p><p>达到今天就卖出股票状态（状态三），即：dp[i] [2] ，只有一个操作：</p><ul><li>操作一：昨天一定是买入股票状态（状态一），今天卖出</li></ul><p>即：dp[i] [2] = dp[i - 1] [0] + prices[i];</p><p>达到冷冻期状态（状态四），即：dp[i] [3]，只有一个操作：</p><ul><li>操作一：昨天卖出了股票（状态三）</li></ul><p>dp[i] [3] = dp[i - 1] [2];<br>==注意：讨论的是买卖股票的状态，并不是今天一定要买卖==</p></li><li><p>初始化<br>主要考虑第0天如何初始化即可。<br>dp[0] [0] = -prices[0]<br>dp[0] [1] = 0 ,第0天没有卖出，初始化为0即可<br>dp[0] [2] = 0, dp[0] [3] = 0</p></li><li><p>遍历顺序，从前往后</p></li><li><p>举例推导</p></li></ol><p>本题官方给的答案也很清晰</p><h2 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a>买卖股票的最佳时机含手续费</h2><ol><li><p>确定dp数组的含义：dp[i] [0],  dp[i] [1]，分别代表着持有股票所得的最大收入和不持有股票所得的最大收入</p></li><li><p>确定动态规划递推公式：<br>达到dp[i] [0]有两种途径：</p><ul><li>昨天已购买，dp[i] [0] = dp[i - 1] [0]</li><li>今天购买，dp[i] [0] = dp[i - 1] [1] -  prices[i]</li></ul><p>达到dp[i] [1] 有两种途径</p><ul><li>昨天已卖出，dp[i] [1] = dp[i - 1] [1]</li><li>今天卖出，要加上手续费，dp[i] [1] = dp[i - 1] [0] + prices[i] -fee</li></ul></li><li><p>如何初始化：<br>dp[0] [1] = 0;  dp[0] [0] = -prices[0]; </p></li><li><p>确定遍历顺序：从前往后遍历</p></li><li><p>举例推导</p></li></ol><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]表示i之前包括i的最长递增子序列的个数</li><li>确定递推公式：<br>个人想法是从当前位置向前找第一个小于i的那个，然后+1<br>其实道理都一样，卡哥是用dp[i]和dp[j]+1中取最大值，j的范围是0 到 i - 1</li><li>初始化：先全部初始化为1；   遍历为二次循环，而不是一次循环</li><li>遍历顺序：从前往后    i外层，j内层</li><li>举例推导 </li></ol><h2 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]表示i之前包括i的最长连续递增子序列的个数</li><li>确定递推公式：<br>只需要判断nums[i] 和nums[i-1]谁大谁小，若i大，则dp[i] = dp[i - 1] + 1，否则令dp[i] = 1</li><li>初始化：先全部初始化为1； </li><li>遍历顺序：从前往后   </li><li>举例推导</li></ol><p>So Easy！</p><h2 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j] 表示以下标i-1结尾的a和以下标j-1结尾的b的最长重复子数组</li><li>确定递推公式：<br>通过以前的状态来判断，若是A和B数组相等，那么就令dp[i] [j] = dp[i - 1] [j - 1] + 1;</li><li>初始化：首先dp[0] [0]是无意义的，但为了方便后续，将dp[0] [0]  dp[0] [j] dp[i] [0]全部初始化为0；其实初不初始化的无所谓</li><li>遍历顺序，两层遍历</li><li>举例推导</li></ol><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j]表示从0到i-1的字符串1和从0到j-1的字符串2的最长公共子序列</li><li>确定递推公式：<br>两种结果：相等、不等；相等的情况：dp[i] [j] = dp[i - 1] [j - 1] + 1;不等的情况：取dp[i - 1] [j - 2]和dp[i - 2] [j - 1]的最大值</li><li>初始化：将带0的初始化为0，带0的毫无意义</li><li>遍历顺序：从递推公式可以看出，一定是从前到后，从上到下</li><li>举例推导</li></ol><h2 id="不相交的线"><a href="#不相交的线" class="headerlink" title="不相交的线"></a>不相交的线</h2><p>与上述最长公共子序列代码95%一致</p><h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]表示前i个数的最大子序和</li><li>确定递推公式：<br>这么想，第i个数有两种情况，一种是直接加入dp[i]，另一种是从头算起，二者取最大</li><li>初始化：dp[0] = nums[0]</li><li>遍历顺序：从前到后</li><li>举例推导</li></ol><h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j]表示前i-1和前j - 1的字符串为子序列的个数</li><li>确定递推公式：<br>考虑两种情况：1、  i - 1 == j - 1，则dp[i] [j] = dp[i - 1] [ j - 1] + 1;2、i - 1 ！= j - 1，若不相等，那么T就要“删除”掉j - 1了，那么从数值上来看就相当于dp[i] [ j] = dp[i] [j - 1]</li><li>初始化：将带0的全部初始化为0</li><li>遍历顺序，两层循环，外层是i，遍历s；</li><li>举例推导</li></ol><p>==注意边界，每次都是边界出错；最后判断的是dp[s.length()] [t.length()]而不是dp[s.length()+1] [t.length()+1]==</p><blockquote><p>因为s.length()本身就不包括最后一个元素，属于是前闭后开</p></blockquote><h2 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j]表示前i-1和前j - 1的字符串为不同子序列的个数</li><li>确定递推公式：<br>两大块：1、相等  2、不等<br>1、相等： 可以用dp[i - 1] [j - 1]，也可以不用，为什么不用呢，是因为不同的子序列，可能得到的结果不同，所以就是dp[i - 2] [j - 1];二者相加，也即dp[i] [j] = dp[i - 1] [j - 1] + dp[i - 1] [j];<br>2、不等： 不等直接就是dp[i - 1] [j]，即dp[i] [j] = dp[i - 1] [j];</li><li>初始化：首先带0的肯定是要初始化的，至于怎么初始化，看dp[i] [0]，代表的含义以i-1为结尾的s可以随便删除元素，出现空字符串的个数；那么s删除所以元素才能 出现空字符串，也就是只有一种情况，所以就是dp[i] [0] = 1; dp[0] [j] 代表的含义是以j-1为结尾的t可以随便删除元素，出现空字符串的个数，那么肯定就是0，因为s为空，是无论如何都不可能变为j的；最后看dp[0] [0]，初始化为1</li><li>遍历顺序：从左到右，从上到下</li><li>举例推导</li></ol><blockquote><p>又是那个问题，边界没有注意到</p></blockquote><h2 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h2><p>两种动态规划的思路：</p><p>思路一：与上述的最长公共子序列相同，只不过多了一步用两个字符串的总长度减去最长公共子序列的长度</p><p>思路二：</p><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</li><li>确定递推公式：<br>word[i] 和word[j]相等：相等好说，直接dp[i] [j] = dp[i - 1] [j - 1]<br>word[i] 和word[j]不等：不等又有三种情况可以操作，删掉i+1，删掉j+1，同时删掉i和j+2；取最小值</li><li>初始化：dp[i] [0] 和dp[j] [0] 和dp[0] [0]是必须要初始化的；dp[i] [0]初始化为i，dp[0] [j]初始化为j，dp[0] [0]初始化为0</li><li>遍历顺序：两层循环，外层i</li><li>举例推导</li></ol><blockquote><p>1、Math.min() 该方法只能比较两个数的大小，碰到三个的就用两次该方法吧</p><p>2、要求最小值，那么每一次操作的+1必不可少</p></blockquote><h2 id="编辑距离-（经典）"><a href="#编辑距离-（经典）" class="headerlink" title="==编辑距离==（经典）"></a>==编辑距离==（经典）</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要操作元素的最少次数。</li><li>确定递推公式：<br>分两种情况：要么相等、要么不等<br>相等的情况：直接dp[i] [j] = dp[i - 1] [j - 1]<br>不等的情况：又分三种情况，需要word1增、删、改<pre><code class="hljs">                   增：word1增也即word2删，即dp[i] [j] = dp[i] [j - 1] + 1                   删：dp[i] [j] = dp[i - 1] [j] + 1                   改：改意思是word1 和 word2 相等，即dp[i] [j] = dp[i - 1] [j - 1] + 1</code></pre>取最小值</li><li>初始化：从递推公式可以看出，带0的必须初始化，dp[i] [0]初始化为i，dp[0] [j] 初始化为j</li><li>遍历顺序：两层循环，外层i</li><li>举例推导</li></ol><p>我愿称之为经典</p><h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j] 表示i到j的回文数</li><li>确定递推公式：<br>同样，s[i] 和s[j] 分相等和不等<br>不等：dp[i] [j] = false<br>相等：i和j相等或相差1，如a,   aa;   i 和j相差大于1，大于1，说明两个边已经是回文了，那么就判断里面是否也是回文，也即判断i+1 和 j - 1；</li><li>初始化：dp[i] [j]初始化为false</li><li>遍历顺序：dp[i] [j] 用到了 dp[i+1] [j-1]。意思是要用到左下角的数据，所以是从下到上，从左到右</li><li>举例推导</li></ol><blockquote><p>if (dp[i] [j])  和 if (dp[i] [j] == true)是判断是否为true<br>if (dp[i] [j] = true) 是赋值</p></blockquote><p>还有一种思路：</p><p>中心扩散法。  遍历每个回文中心，若相等同时向两边扩散，同时总数+1</p><h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j] 表示i到j的回文数</li><li>确定递推公式：<br>两种情况，s[i] 和 s[j] 相等，不等<br>相等：  那么向里边扩散，即dp[i] [j] = dp[i + 1] [ j -1] + 2<br>不等： 判断向左大还是向右，即dp[i] [j] = max(dp[i + 1] [j], dp[i] [ j - 1], dp[i] [j])</li><li>初始化：dp[i] [i] 初始化为1，其余初始化为0</li><li>遍历顺序：遍历顺序从递推公式开始，可以看出，这一行用到的数据需要用到下一行的数据，那也就是从下到上，从左到右</li><li>举例推导</li></ol><hr><h4 id="1235-规划兼职工作"><a href="#1235-规划兼职工作" class="headerlink" title="1235. 规划兼职工作"></a><a href="https://leetcode.cn/problems/maximum-profit-in-job-scheduling/">1235. 规划兼职工作</a></h4>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2022/09/15/wo-de-di-yi-pian-bo-ke-wen-zhang/"/>
    <url>/2022/09/15/wo-de-di-yi-pian-bo-ke-wen-zhang/</url>
    
    <content type="html"><![CDATA[<p>第一章</p><p>第二章</p><p>内容</p><p>参考文献</p><p>域名</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/15/hello-world/"/>
    <url>/2022/09/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
