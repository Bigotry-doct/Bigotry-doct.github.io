<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Z-《流行的云》</title>
    <link href="/2022/10/20/z-liu-xing-de-yun/"/>
    <url>/2022/10/20/z-liu-xing-de-yun/</url>
    
    <content type="html"><![CDATA[<p>特殊调弦</p><p><img src="/2022/10/20/z-liu-xing-de-yun/image-20221020103152306.png"></p><p><img src="/2022/10/20/z-liu-xing-de-yun/image-20221020103212498.png"></p><blockquote><p>曲谱来源 元子弹吉他</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>吉他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>吉他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令</title>
    <link href="/2022/10/19/git-chang-yong-ming-ling/"/>
    <url>/2022/10/19/git-chang-yong-ming-ling/</url>
    
    <content type="html"><![CDATA[<h2 id="1、创建版本库"><a href="#1、创建版本库" class="headerlink" title="1、创建版本库"></a>1、创建版本库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> &lt;url&gt; <span class="hljs-comment">#克隆远程版本</span><br><br>$ git init <span class="hljs-comment">#初始化本地版本库</span><br><br>$ git config --global user.name 用户名 <span class="hljs-comment">#设置用户名</span><br><br>$ git config --global user.email 邮箱 <span class="hljs-comment">#设置邮箱</span><br></code></pre></td></tr></table></figure><h2 id="2、修改和提交代码"><a href="#2、修改和提交代码" class="headerlink" title="2、修改和提交代码"></a>2、修改和提交代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status <span class="hljs-comment">#查看状态</span><br><br>$ git diff <span class="hljs-comment">#查看便变更内容</span><br><br>$ git add . <span class="hljs-comment">#跟踪所有改动的文件</span><br><br>$ git add &lt;file&gt; <span class="hljs-comment">#跟踪指定的文件</span><br><br>$ git <span class="hljs-built_in">mv</span> &lt;old&gt; &lt;new&gt; <span class="hljs-comment">#文件改名</span><br><br>$ git <span class="hljs-built_in">rm</span> &lt;file&gt; <span class="hljs-comment">#删除文件</span><br><br>$ git <span class="hljs-built_in">rm</span> --cached file <span class="hljs-comment">#停止跟踪文件但不删除</span><br><br>$ git commit -m <span class="hljs-string">&quot;commit message&quot;</span> <span class="hljs-comment">#提交所有更新过的文件</span><br><br>$ git commit -- amend <span class="hljs-comment">#修改最后一次提交</span><br></code></pre></td></tr></table></figure><h2 id="3、查看历史提交"><a href="#3、查看历史提交" class="headerlink" title="3、查看历史提交"></a>3、查看历史提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git long <span class="hljs-comment">#查看提交历史</span><br><br>$ git <span class="hljs-built_in">log</span> -p &lt;file&gt; <span class="hljs-comment">#查看指定文件的提交历史</span><br><br>$ git blame &lt;file&gt; <span class="hljs-comment">#以列表方式查看指定文件的提交历史</span><br></code></pre></td></tr></table></figure><h2 id="4、撤销"><a href="#4、撤销" class="headerlink" title="4、撤销"></a>4、撤销</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reset --hard HEAD <span class="hljs-comment">#撤销工作目录中所有未提交文件的修改内容</span><br><br>$ git checkout  HEAD file <span class="hljs-comment">#撤销指定的未提交文件的修改内容</span><br><br>$ git revert &lt;commit&gt; <span class="hljs-comment">#撤销指定的提交</span><br></code></pre></td></tr></table></figure><h2 id="5、分支、标签"><a href="#5、分支、标签" class="headerlink" title="5、分支、标签"></a>5、分支、标签</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch <span class="hljs-comment">#显示所有本地分支</span><br><br>$ git checkout &lt;branch/tag&gt; <span class="hljs-comment">#切换到指定分支或标签</span><br><br>$ git branch &lt;new-branch&gt; <span class="hljs-comment">#创建新的分支</span><br><br>$ git branch -d &lt;branch&gt; <span class="hljs-comment"># 删除本地分支</span><br><br>$ git tag <span class="hljs-comment">#列出所有本地标签</span><br><br>$ git tag &lt;tagname&gt; <span class="hljs-comment">#基于最新提交创建标签</span><br><br>$ git tag -d &lt;tagname&gt; <span class="hljs-comment">#删除标签</span><br></code></pre></td></tr></table></figure><h2 id="6、合并与衍合"><a href="#6、合并与衍合" class="headerlink" title="6、合并与衍合"></a>6、合并与衍合</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git merge &lt;branch&gt; <span class="hljs-comment">#合并指定分支到当前分支</span><br><br>$ git rebase &lt;branch&gt; <span class="hljs-comment">#衍合指定分支到当前分支</span><br></code></pre></td></tr></table></figure><h2 id="7、远程操作"><a href="#7、远程操作" class="headerlink" title="7、远程操作"></a>7、远程操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote -v <span class="hljs-comment">#查看远程版本信息</span><br><br>$ git remote show &lt;remote&gt; <span class="hljs-comment"># 查看指定远程版本库的信息</span><br><br>$ git remote add &lt;remote&gt; url <span class="hljs-comment">#添加远程版本库</span><br><br>$ git fetch &lt;remote&gt; <span class="hljs-comment">#从远程获取代码</span><br><br>$ git pull &lt;remote&gt; &lt;branch&gt; <span class="hljs-comment">#下载代码及快速合并</span><br><br>$ git push &lt;remote&gt; &lt;branch&gt; <span class="hljs-comment">#上传代码及快速合并</span><br><br>$ git push &lt;remote&gt; :&lt;branch/tag-name&gt; <span class="hljs-comment">#删除远程分支或标签</span><br><br>$ git push --tags <span class="hljs-comment">#上传所有标签</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10-行为型-备忘录-访问者</title>
    <link href="/2022/10/19/10-xing-wei-xing-bei-wang-lu-fang-wen-zhe/"/>
    <url>/2022/10/19/10-xing-wei-xing-bei-wang-lu-fang-wen-zhe/</url>
    
    <content type="html"><![CDATA[<h1 id="一、备忘录模式"><a href="#一、备忘录模式" class="headerlink" title="一、备忘录模式"></a>一、备忘录模式</h1><p>备忘录模式定义：备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。当你需要让对象返回之前的状态时,就使用备忘录模式。备忘录模式有两个目标:储存系统关键对象的重要状态；维护关键对象的封装。</p><h2 id="1、结构与实现"><a href="#1、结构与实现" class="headerlink" title="1、结构与实现"></a>1、结构与实现</h2><h3 id="1、备忘录模式结构"><a href="#1、备忘录模式结构" class="headerlink" title="1、备忘录模式结构"></a>1、备忘录模式结构</h3><p>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</p><p>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</p><p>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</p><p>备忘录有两个等效的接口：</p><ul><li><strong>窄接口</strong>：管理者(Caretaker)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(narror Interface)，这个窄接口只允许他把备忘录对象传给其他的对象。</li><li><strong>宽接口</strong>：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wide Interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。</li></ul><h3 id="2、备忘录模式代码实现"><a href="#2、备忘录模式代码实现" class="headerlink" title="2、备忘录模式代码实现"></a>2、备忘录模式代码实现</h3><p>Demo案例-打Boss</p><p>游戏中的某个场景，一游戏角色有生命力、攻击力、防御力等数据，在打Boss前和后一定会不一样的，我们允许玩家如果感觉与Boss决斗的效果不理想可以让游戏恢复到决斗之前的状态。</p><p>要实现上述案例，有两种方式：</p><ul><li>“白箱”备忘录模式</li><li>“黑箱”备忘录模式</li></ul><h4 id="1、白箱备忘录模式"><a href="#1、白箱备忘录模式" class="headerlink" title="1、白箱备忘录模式"></a>1、白箱备忘录模式</h4><p>备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开</p><p>关系类图：</p><p><img src="/2022/10/19/10-xing-wei-xing-bei-wang-lu-fang-wen-zhe/image-20221020110410991.png"></p><h5 id="1、GameRole"><a href="#1、GameRole" class="headerlink" title="1、GameRole"></a>1、GameRole</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GameRole</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> vit;<span class="hljs-comment">//生命力</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> atk;<span class="hljs-comment">//攻击力</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> def;<span class="hljs-comment">//防御力</span><br><br>    <span class="hljs-comment">//初始化状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.vit = <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">this</span>.atk = <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">this</span>.def = <span class="hljs-number">100</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//战斗</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fight</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.vit = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.atk = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.def = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//保存角色状态</span><br>    <span class="hljs-keyword">public</span> RoleStateMemento <span class="hljs-title function_">saveState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoleStateMemento</span>(vit, atk, def);<br>    &#125;<br><br>    <span class="hljs-comment">//恢复角色状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverState</span><span class="hljs-params">(RoleStateMemento roleStateMemento)</span> &#123;<br>        <span class="hljs-built_in">this</span>.vit = roleStateMemento.getVit();<br>        <span class="hljs-built_in">this</span>.atk = roleStateMemento.getAtk();<br>        <span class="hljs-built_in">this</span>.def = roleStateMemento.getDef();<br>    &#125;<br><br>    <span class="hljs-comment">//展示状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stateDisplay</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;角色生命力&quot;</span> + vit);<br>        System.out.println(<span class="hljs-string">&quot;角色攻击力&quot;</span> + atk);<br>        System.out.println(<span class="hljs-string">&quot;角色防御力&quot;</span> + def);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getVit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> vit;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVit</span><span class="hljs-params">(<span class="hljs-type">int</span> vit)</span> &#123;<br>        <span class="hljs-built_in">this</span>.vit = vit;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAtk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> atk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAtk</span><span class="hljs-params">(<span class="hljs-type">int</span> atk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.atk = atk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDef</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> def;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDef</span><span class="hljs-params">(<span class="hljs-type">int</span> def)</span> &#123;<br>        <span class="hljs-built_in">this</span>.def = def;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、RoleStateMemento"><a href="#2、RoleStateMemento" class="headerlink" title="2、RoleStateMemento"></a>2、RoleStateMemento</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleStateMemento</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> vit;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> atk;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> def;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RoleStateMemento</span><span class="hljs-params">(<span class="hljs-type">int</span> vit, <span class="hljs-type">int</span> atk, <span class="hljs-type">int</span> def)</span> &#123;<br>        <span class="hljs-built_in">this</span>.vit = vit;<br>        <span class="hljs-built_in">this</span>.atk = atk;<br>        <span class="hljs-built_in">this</span>.def = def;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getVit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> vit;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVit</span><span class="hljs-params">(<span class="hljs-type">int</span> vit)</span> &#123;<br>        <span class="hljs-built_in">this</span>.vit = vit;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAtk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> atk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAtk</span><span class="hljs-params">(<span class="hljs-type">int</span> atk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.atk = atk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDef</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> def;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDef</span><span class="hljs-params">(<span class="hljs-type">int</span> def)</span> &#123;<br>        <span class="hljs-built_in">this</span>.def = def;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、RoleStateCaretaker"><a href="#3、RoleStateCaretaker" class="headerlink" title="3、RoleStateCaretaker"></a>3、RoleStateCaretaker</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleStateCaretaker</span> &#123;<br>    <span class="hljs-keyword">private</span> RoleStateMemento roleStateMemento;<br><br>    <span class="hljs-keyword">public</span> RoleStateMemento <span class="hljs-title function_">getRoleStateMemento</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> roleStateMemento;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRoleStateMemento</span><span class="hljs-params">(RoleStateMemento roleStateMemento)</span> &#123;<br>        <span class="hljs-built_in">this</span>.roleStateMemento = roleStateMemento;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4、Client"><a href="#4、Client" class="headerlink" title="4、Client"></a>4、Client</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;--------------大战Boss前------------------------&quot;</span>);<br>        <span class="hljs-comment">//大战Boss前</span><br>        <span class="hljs-type">GameRole</span> <span class="hljs-variable">gameRole</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GameRole</span>();<br>        gameRole.initState();<br>        gameRole.stateDisplay();<br><br>        <span class="hljs-comment">//保存进度</span><br>        <span class="hljs-type">RoleStateCaretaker</span> <span class="hljs-variable">roleStateCaretaker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoleStateCaretaker</span>();<br>        roleStateCaretaker.setRoleStateMemento(gameRole.saveState());<br><br>        System.out.println(<span class="hljs-string">&quot;--------------大战Boss后------------------------&quot;</span>);<br>        <span class="hljs-comment">//大战Boss 损耗严重</span><br>        gameRole.fight();<br>        gameRole.stateDisplay();<br><br>        System.out.println(<span class="hljs-string">&quot;--------------满血复活------------------------&quot;</span>);<br>        gameRole.recoverState(roleStateCaretaker.getRoleStateMemento());<br>        gameRole.stateDisplay();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5、结果"><a href="#5、结果" class="headerlink" title="5、结果"></a>5、结果</h5><p><img src="/2022/10/19/10-xing-wei-xing-bei-wang-lu-fang-wen-zhe/image-20221020105645535.png"></p><h4 id="2、黑箱备忘录模式"><a href="#2、黑箱备忘录模式" class="headerlink" title="2、黑箱备忘录模式"></a>2、黑箱备忘录模式</h4><p>将 <code>RoleStateMemento</code> 设为 <code>GameRole</code> 的内部类，从而将 <code>RoleStateMemento</code> 对象封装在 <code>GameRole</code> 里面；在外面提供一个标识接口 <code>Memento</code> 给 <code>RoleStateCaretaker</code> 及其他对象使用。这样 <code>GameRole</code> 类看到的是 <code>RoleStateMemento</code> 所有的接口，而<code>RoleStateCaretaker</code> 及其他对象看到的仅仅是标识接口 <code>Memento</code> 所暴露出来的接口，从而维护了封装型。类图如下：</p><p><img src="/2022/10/19/10-xing-wei-xing-bei-wang-lu-fang-wen-zhe/image-20221020111221487.png"></p><h5 id="1、GameRole-1"><a href="#1、GameRole-1" class="headerlink" title="1、GameRole"></a>1、GameRole</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GameRole</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> vit;<span class="hljs-comment">//生命力</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> atk;<span class="hljs-comment">//攻击力</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> def;<span class="hljs-comment">//防御力</span><br><br>    <span class="hljs-comment">//初始化状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.vit = <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">this</span>.atk = <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">this</span>.def = <span class="hljs-number">100</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//战斗</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fight</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.vit = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.atk = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.def = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//保存角色状态</span><br>    <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">saveState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoleStateMemento</span>(vit, atk, def);<br>    &#125;<br><br>    <span class="hljs-comment">//恢复角色状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverState</span><span class="hljs-params">(Memento memento)</span> &#123;<br>        <span class="hljs-type">RoleStateMemento</span> <span class="hljs-variable">roleStateMemento</span> <span class="hljs-operator">=</span> (RoleStateMemento) memento;<br>        <span class="hljs-built_in">this</span>.vit = roleStateMemento.getVit();<br>        <span class="hljs-built_in">this</span>.atk = roleStateMemento.getAtk();<br>        <span class="hljs-built_in">this</span>.def = roleStateMemento.getDef();<br>    &#125;<br><br>    <span class="hljs-comment">//展示状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stateDisplay</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;角色生命力&quot;</span> + vit);<br>        System.out.println(<span class="hljs-string">&quot;角色攻击力&quot;</span> + atk);<br>        System.out.println(<span class="hljs-string">&quot;角色防御力&quot;</span> + def);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getVit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> vit;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVit</span><span class="hljs-params">(<span class="hljs-type">int</span> vit)</span> &#123;<br>        <span class="hljs-built_in">this</span>.vit = vit;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAtk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> atk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAtk</span><span class="hljs-params">(<span class="hljs-type">int</span> atk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.atk = atk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDef</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> def;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDef</span><span class="hljs-params">(<span class="hljs-type">int</span> def)</span> &#123;<br>        <span class="hljs-built_in">this</span>.def = def;<br>    &#125;<br><br>    <span class="hljs-comment">//在内部定义备忘录内部类 RoleStateMemento（该内部类设置为私有的）</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleStateMemento</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Memento</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> vit;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> atk;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> def;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">RoleStateMemento</span><span class="hljs-params">(<span class="hljs-type">int</span> vit, <span class="hljs-type">int</span> atk, <span class="hljs-type">int</span> def)</span> &#123;<br>            <span class="hljs-built_in">this</span>.vit = vit;<br>            <span class="hljs-built_in">this</span>.atk = atk;<br>            <span class="hljs-built_in">this</span>.def = def;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getVit</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> vit;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVit</span><span class="hljs-params">(<span class="hljs-type">int</span> vit)</span> &#123;<br>            <span class="hljs-built_in">this</span>.vit = vit;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAtk</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> atk;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAtk</span><span class="hljs-params">(<span class="hljs-type">int</span> atk)</span> &#123;<br>            <span class="hljs-built_in">this</span>.atk = atk;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDef</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> def;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDef</span><span class="hljs-params">(<span class="hljs-type">int</span> def)</span> &#123;<br>            <span class="hljs-built_in">this</span>.def = def;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、Memento"><a href="#2、Memento" class="headerlink" title="2、Memento"></a>2、Memento</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Memento</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、RoleStateCaretaker-1"><a href="#3、RoleStateCaretaker-1" class="headerlink" title="3、RoleStateCaretaker"></a>3、RoleStateCaretaker</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleStateCaretaker</span> &#123;<br>    <span class="hljs-keyword">private</span> Memento memento;<br><br>    <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">getMemento</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> memento;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMemento</span><span class="hljs-params">(Memento memento)</span> &#123;<br>        <span class="hljs-built_in">this</span>.memento = memento;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4、Client-1"><a href="#4、Client-1" class="headerlink" title="4、Client"></a>4、Client</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;--------------大战Boss前------------------------&quot;</span>);<br>        <span class="hljs-comment">//大战Boss前</span><br>        <span class="hljs-type">GameRole</span> <span class="hljs-variable">gameRole</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GameRole</span>();<br>        gameRole.initState();<br>        gameRole.stateDisplay();<br><br>        <span class="hljs-comment">//保存进度</span><br>        <span class="hljs-type">RoleStateCaretaker</span> <span class="hljs-variable">roleStateCaretaker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoleStateCaretaker</span>();<br>        roleStateCaretaker.setMemento(gameRole.saveState());<br><br>        System.out.println(<span class="hljs-string">&quot;--------------大战Boss后------------------------&quot;</span>);<br>        <span class="hljs-comment">//大战Boss 损耗严重</span><br>        gameRole.fight();<br>        gameRole.stateDisplay();<br><br>        System.out.println(<span class="hljs-string">&quot;--------------满血复活------------------------&quot;</span>);<br>        gameRole.recoverState(roleStateCaretaker.getMemento());<br>        gameRole.stateDisplay();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5、结果-1"><a href="#5、结果-1" class="headerlink" title="5、结果"></a>5、结果</h5><p><img src="/2022/10/19/10-xing-wei-xing-bei-wang-lu-fang-wen-zhe/image-20221020111438140.png"></p><h2 id="2、优缺点"><a href="#2、优缺点" class="headerlink" title="2、优缺点"></a>2、优缺点</h2><p><strong>优点：</strong></p><ul><li>它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。</li><li>备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。</li></ul><p><strong>缺点：</strong></p><ul><li>资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源。</li></ul><h2 id="3、应用场景"><a href="#3、应用场景" class="headerlink" title="3、应用场景"></a>3、应用场景</h2><ul><li>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</li><li>需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，idea等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</li></ul><p>参考：<a href="https://juejin.cn/post/6975288482927214605">设计模式学习21-备忘录模式</a></p><h1 id="二、访问者模式"><a href="#二、访问者模式" class="headerlink" title="二、访问者模式"></a>二、访问者模式</h1><p>定义：访问者（Visitor）模式的定义：<strong>将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。</strong>它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</p><h2 id="1、结构与实现-1"><a href="#1、结构与实现-1" class="headerlink" title="1、结构与实现"></a>1、结构与实现</h2><h3 id="1、访问者模式结构"><a href="#1、访问者模式结构" class="headerlink" title="1、访问者模式结构"></a>1、访问者模式结构</h3><p>抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。</p><p>具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</p><p>抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。</p><p>具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。</p><p>对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</p><h3 id="2、访问者模式代码实现"><a href="#2、访问者模式代码实现" class="headerlink" title="2、访问者模式代码实现"></a>2、访问者模式代码实现</h3><p>一个Demo案例-喂养宠物</p><p>现在养宠物的人特别多，就以这个为例，当然宠物还分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食。</p><p>以上五个结构分别对应如下:</p><ul><li>访问者角色：给宠物喂食的人</li><li>具体访问者角色：主人、其他人</li><li>抽象元素角色：动物抽象类</li><li>具体元素角色：宠物狗、宠物猫</li><li>结构对象角色：主人家</li></ul><h4 id="1、Person"><a href="#1、Person" class="headerlink" title="1、Person"></a>1、Person</h4><p><em>抽象访问者接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">//喂宠物狗</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">feed</span><span class="hljs-params">(Dog dog)</span>;<br><br>    <span class="hljs-comment">//喂宠物猫</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">feed</span><span class="hljs-params">(Cat cat)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、Owner"><a href="#2、Owner" class="headerlink" title="2、Owner"></a>2、Owner</h4><p><em>具体访问者角色 主人类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Owner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">feed</span><span class="hljs-params">(Dog dog)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;主人喂食宠物狗...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">feed</span><span class="hljs-params">(Cat cat)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;主人喂食宠物猫...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、Someone"><a href="#3、Someone" class="headerlink" title="3、Someone"></a>3、Someone</h4><p><em>具体访问者角色 其他人类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Someone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">feed</span><span class="hljs-params">(Dog dog)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;其他人喂食宠物狗...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">feed</span><span class="hljs-params">(Cat cat)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;其他人喂食宠物猫...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、Animal"><a href="#4、Animal" class="headerlink" title="4、Animal"></a>4、Animal</h4><p><em>定义动物接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Person person)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、Dog"><a href="#5、Dog" class="headerlink" title="5、Dog"></a>5、Dog</h4><p><em>实现Animal接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Person person)</span> &#123;<br>        person.feed(<span class="hljs-built_in">this</span>);<br>        System.out.println(<span class="hljs-string">&quot;真香~，汪汪汪！！！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、Cat"><a href="#6、Cat" class="headerlink" title="6、Cat"></a>6、Cat</h4><p><em>实现Animal接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Person person)</span> &#123;<br>        person.feed(<span class="hljs-built_in">this</span>);<br>        System.out.println(<span class="hljs-string">&quot;真香~，喵喵喵！！！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7、Home"><a href="#7、Home" class="headerlink" title="7、Home"></a>7、Home</h4><p><em>定义对象结构  主人的家</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Home</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Animal&gt; nodeList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Animal&gt;();<br><br>    <span class="hljs-comment">//添加方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Animal animal)</span> &#123;<br>        nodeList.add(animal);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aciton</span><span class="hljs-params">(Person person)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Animal node : nodeList) &#123;<br>            node.accept(person);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8、Client"><a href="#8、Client" class="headerlink" title="8、Client"></a>8、Client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Home</span> <span class="hljs-variable">home</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Home</span>();<br>        home.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br>        home.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>());<br><br>        <span class="hljs-type">Owner</span> <span class="hljs-variable">owner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Owner</span>();<br>        home.aciton(owner);<br>        System.out.println(<span class="hljs-string">&quot;===========================&quot;</span>);<br>        <span class="hljs-type">Someone</span> <span class="hljs-variable">someone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Someone</span>();<br>        home.aciton(someone);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9、结果"><a href="#9、结果" class="headerlink" title="9、结果"></a>9、结果</h4><p><img src="/2022/10/19/10-xing-wei-xing-bei-wang-lu-fang-wen-zhe/image-20221020113116173.png"></p><h2 id="2、优缺点-1"><a href="#2、优缺点-1" class="headerlink" title="2、优缺点"></a>2、优缺点</h2><p><strong>优点：</strong></p><ul><li>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li><li>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li><li>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li><li>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li></ul><p><strong>缺点：</strong></p><ul><li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</li><li>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</li><li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</li></ul><p>参考：<a href="https://juejin.cn/post/6974984329654960165">设计模式学习17-访问者模式</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>备忘录</tag>
      
      <tag>访问者</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>09-行为型-命令-解释器-中介</title>
    <link href="/2022/10/19/09-xing-wei-xing-ming-ling-jie-shi-qi-zhong-jie/"/>
    <url>/2022/10/19/09-xing-wei-xing-ming-ling-jie-shi-qi-zhong-jie/</url>
    
    <content type="html"><![CDATA[<h1 id="一、命令模式"><a href="#一、命令模式" class="headerlink" title="一、命令模式"></a>一、命令模式</h1><p>命令模式(Command Pattern)：将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。</p><p>命令模式通俗点来讲，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。</p><p>关系图如下：</p><p><img src="/2022/10/19/09-xing-wei-xing-ming-ling-jie-shi-qi-zhong-jie/image-20221019183821026.png"></p><ul><li><strong>Command</strong>  一个具体命令的抽象接口。</li><li><strong>ConcreteCommand</strong>  就是其具体的一个实现，你可以有多个<code>Command</code>接口的实现。具体命令本身并不实现具体的业务命令， 而是会将调用委派给一个业务逻辑对象去执行。</li><li><strong>Receiver</strong>  作为具体命令的最终接收者。几乎任何对象都可以作为接收者，命令的细节由<strong>Receiver</strong>来实现。</li><li><strong>Invoker</strong>  携带命令执行 <code>action</code>请求。它不负责创建命令对象，它通常会通过构造函数从客户端处获得预先生成的命令。</li><li><strong>Client</strong>  发起具体的命令交给<strong>Invoker</strong>去执行。</li></ul><p>看实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exe</span><span class="hljs-params">()</span>;  <br>&#125;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> Receiver receiver;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCommand</span><span class="hljs-params">(Receiver receiver)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.receiver = receiver;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exe</span><span class="hljs-params">()</span> &#123;  <br>        receiver.action();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">action</span><span class="hljs-params">()</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;command received!&quot;</span>);  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span> &#123;  <br>      <br>    <span class="hljs-keyword">private</span> Command command;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Invoker</span><span class="hljs-params">(Command command)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.command = command;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">action</span><span class="hljs-params">()</span>&#123;  <br>        command.exe();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Receiver</span> <span class="hljs-variable">receiver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Receiver</span>();  <br>        <span class="hljs-type">Command</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCommand</span>(receiver);  <br>        <span class="hljs-type">Invoker</span> <span class="hljs-variable">invoker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Invoker</span>(cmd);  <br>        invoker.action();  <br>    &#125;  <br>&#125;  <br><br></code></pre></td></tr></table></figure><p>命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开，熟悉Struts的同学应该知道，Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！</p><p>命令模式应用非常普遍，我们常见的断路器组件<strong>Hystrix</strong>，还有<strong>Java</strong>多线程中的线程池<code>ThreadPoolExecutor</code>都用到了命令模式。</p><p><strong>优点：</strong></p><ul><li>降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。</li><li>新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。</li><li>可以比较容易地设计一个命令队列或宏命令（组合命令）。</li><li>为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案。</li></ul><p><strong>缺点：</strong></p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。</li></ul><h1 id="二、解释器模式"><a href="#二、解释器模式" class="headerlink" title="二、解释器模式"></a>二、解释器模式</h1><p>解释器模式是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。</p><p>进行加减运算，怎么实现？第一想法是使用工具类，提供对应的加法和减法的工具方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用于两个整数相加</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">//用于两个整数相加</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b + c;<br>&#125;<br><br><span class="hljs-comment">//用于n个整数相加</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Integer ... arr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Integer i : arr) &#123;<br>        sum += i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的形式比较单一、有限，如果形式变化非常多，这就不符合要求，因为加法和减法运算，两个运算符与数值可以有无限种组合方式。比如 1+2+3+4+5、1+2+3-4等等。</p><p>现在需要一种翻译识别机器，能够解析由数字以及 + - 符号构成的合法的运算序列。如果把运算符和数字都看作节点的话，能够逐个节点的进行读取解析运算，这就是解释器模式的思维。</p><p>类图：</p><p><img src="/2022/10/19/09-xing-wei-xing-ming-ling-jie-shi-qi-zhong-jie/image-20221019184910429.png"></p><p>解释器的主要角色：</p><ul><li>抽象解释器(AbstractExpression/Expression)：声明一个所有具体表达式都要实现的抽象接口（或者抽象类），接口中主要是一个interpret()方法，称为解释操作。具体解释任务由它的各个实现类来完成，具体的解释器分别由终结符解释器TerminalExpression和非终结符解释器NonterminalExpression完成。</li><li>终结符表达式(TerminalExpression)：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。终结符一半是文法中的运算单元，比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。</li><li>非终结符表达式(NonterminalExpression)：文法中的每条规则对应于一个非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，+就是非终结符，解析+的解释器就是一个非终结符表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。</li><li>环境角色(Context)：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。</li></ul><h2 id="1、Demo案例-计算加减乘除算法"><a href="#1、Demo案例-计算加减乘除算法" class="headerlink" title="1、Demo案例-计算加减乘除算法"></a>1、Demo案例-计算加减乘除算法</h2><p>简单的一个解释器计算加减乘除算法</p><h3 id="1、AbstractExpression"><a href="#1、AbstractExpression" class="headerlink" title="1、AbstractExpression"></a>1、AbstractExpression</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象解释器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpreter</span><span class="hljs-params">(Context context)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、Add"><a href="#2、Add" class="headerlink" title="2、Add"></a>2、Add</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非终结表达式：加法</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Add</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractExpression left;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractExpression right;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpreter</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> left.interpreter(context) + right.interpreter(context);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、Subtract"><a href="#3、Subtract" class="headerlink" title="3、Subtract"></a>3、Subtract</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非终结表达式：减法</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subtract</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractExpression left;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractExpression right;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpreter</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> left.interpreter(context) - right.interpreter(context);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、Multiply"><a href="#4、Multiply" class="headerlink" title="4、Multiply"></a>4、Multiply</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非终结表达式：乘法</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Multiply</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractExpression left;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractExpression right;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpreter</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> left.interpreter(context) * right.interpreter(context);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、Division"><a href="#5、Division" class="headerlink" title="5、Division"></a>5、Division</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非终结表达式：除法</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Division</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractExpression left;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractExpression right;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpreter</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.right.interpreter(context);<br>        <span class="hljs-keyword">if</span> (right != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> left.interpreter(context) / right;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、Variable"><a href="#6、Variable" class="headerlink" title="6、Variable"></a>6、Variable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//终结表达式：变量</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Variable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String key;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpreter</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> context.getValue(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7、Context"><a href="#7、Context" class="headerlink" title="7、Context"></a>7、Context</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//环境上下文</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Integer&gt; valueMap = Maps.newHashMap();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addValue</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String key, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> value)</span> &#123;<br>        valueMap.put(key, Integer.valueOf(value));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String key)</span> &#123;<br>        <span class="hljs-keyword">return</span> valueMap.get(key).intValue();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8、Application"><a href="#8、Application" class="headerlink" title="8、Application"></a>8、Application</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>();<br>        context.addValue(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">6</span>);<br>        context.addValue(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">9</span>);<br>        context.addValue(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">Variable</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Variable</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">Variable</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Variable</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-type">Variable</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Variable</span>(<span class="hljs-string">&quot;c&quot;</span>);<br><br>        <span class="hljs-type">AbstractExpression</span> <span class="hljs-variable">multiplyValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Multiply</span>(a, b);<br>        <span class="hljs-type">AbstractExpression</span> <span class="hljs-variable">subtractValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subtract</span>(a, b);<br>        <span class="hljs-type">AbstractExpression</span> <span class="hljs-variable">addValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Add</span>(subtractValue, c);<br>        <span class="hljs-type">AbstractExpression</span> <span class="hljs-variable">divisionValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Division</span>(multiplyValue, addValue);<br><br>        log.info(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, context.getValueMap());<br>        log.info(<span class="hljs-string">&quot;(a*b)/(a-b+c) = &#123;&#125;&quot;</span>, divisionValue.interpreter(context));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9、结果"><a href="#9、结果" class="headerlink" title="9、结果"></a>9、结果</h3><p><img src="/2022/10/19/09-xing-wei-xing-ming-ling-jie-shi-qi-zhong-jie/image-20221019205702816.png"></p><h2 id="2、解释器模式使用场景"><a href="#2、解释器模式使用场景" class="headerlink" title="2、解释器模式使用场景"></a>2、解释器模式使用场景</h2><ul><li>当语言的文法较为简单，且执行效率不是关键问题时。</li><li>当问题重复出现，且可以用一种简单的语言来进行表达时。</li><li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候。</li></ul><h2 id="3、在jdk中的应用"><a href="#3、在jdk中的应用" class="headerlink" title="3、在jdk中的应用"></a>3、在jdk中的应用</h2><p>这个模式通常定义了一个语言的语法，然后解析相应语法的语句。</p><ol><li>java.util.Pattern</li><li>java.text.Normalizer</li><li>java.text.Format</li></ol><h1 id="三、中介模式"><a href="#三、中介模式" class="headerlink" title="三、中介模式"></a>三、中介模式</h1><p>中介者模式(Mediator Pattern)：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</p><p>下面的图可以更好的理解中介模式。</p><p><img src="/2022/10/19/09-xing-wei-xing-ming-ling-jie-shi-qi-zhong-jie/image-20221019212125724.png"></p><h2 id="1、Demo案例-租房问题"><a href="#1、Demo案例-租房问题" class="headerlink" title="1、Demo案例-租房问题"></a>1、Demo案例-租房问题</h2><p>现在租房基本都是通过房屋中介，房主将房屋托管给房屋中介，而租房者从房屋中介获取房屋信息。房屋中介充当租房者与房屋所有者之间的中介者</p><p>类图如下：</p><p><img src="/2022/10/19/09-xing-wei-xing-ming-ling-jie-shi-qi-zhong-jie/image-20221019213747108.png"></p><h3 id="1、Mediator"><a href="#1、Mediator" class="headerlink" title="1、Mediator"></a>1、Mediator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> &#123;<br>    <span class="hljs-comment">//声明一个联络方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">constact</span><span class="hljs-params">(String message, Person person)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、Person"><a href="#2、Person" class="headerlink" title="2、Person"></a>2、Person</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">protected</span> Mediator mediator;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, Mediator mediator)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.mediator = mediator;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、HouseOwner"><a href="#3、HouseOwner" class="headerlink" title="3、HouseOwner"></a>3、HouseOwner</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HouseOwner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HouseOwner</span><span class="hljs-params">(String name, Mediator mediator)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, mediator);<br>    &#125;<br><br>    <span class="hljs-comment">//与中介者联系</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">constact</span><span class="hljs-params">(String message)</span>&#123;<br>        mediator.constact(message,<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//获取信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getMessage</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;房主&quot;</span>+name+<span class="hljs-string">&quot;获取的信息:&quot;</span>+message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、Tenant"><a href="#4、Tenant" class="headerlink" title="4、Tenant"></a>4、Tenant</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tenant</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tenant</span><span class="hljs-params">(String name, Mediator mediator)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, mediator);<br>    &#125;<br><br>    <span class="hljs-comment">//与中介者联系</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">constact</span><span class="hljs-params">(String message)</span>&#123;<br>        mediator.constact(message,<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//获取信息</span><br>    <span class="hljs-comment">//获取信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getMessage</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;租房者&quot;</span>+name+<span class="hljs-string">&quot;获取的信息:&quot;</span>+message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、MediatorStructure"><a href="#5、MediatorStructure" class="headerlink" title="5、MediatorStructure"></a>5、MediatorStructure</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MediatorStructure</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mediator</span> &#123;<br><br>    <span class="hljs-comment">//中介结构必须知道所有房主和租房者的信息</span><br>    <span class="hljs-keyword">private</span> HouseOwner houseOwner;<br>    <span class="hljs-keyword">private</span> Tenant tenant;<br><br>    <span class="hljs-keyword">public</span> HouseOwner <span class="hljs-title function_">getHouseOwner</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> houseOwner;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHouseOwner</span><span class="hljs-params">(HouseOwner houseOwner)</span> &#123;<br>        <span class="hljs-built_in">this</span>.houseOwner = houseOwner;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Tenant <span class="hljs-title function_">getTenant</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> tenant;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTenant</span><span class="hljs-params">(Tenant tenant)</span> &#123;<br>        <span class="hljs-built_in">this</span>.tenant = tenant;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">constact</span><span class="hljs-params">(String message, Person person)</span> &#123;<br>        <span class="hljs-keyword">if</span> (person == houseOwner) &#123;<br>            <span class="hljs-comment">//如果是房主，则租房者获得信息</span><br>            tenant.getMessage(message);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//反之是房主获得信息</span><br>            houseOwner.getMessage(message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、Client"><a href="#6、Client" class="headerlink" title="6、Client"></a>6、Client</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//房主 租房者 中介机构</span><br>        <span class="hljs-type">MediatorStructure</span> <span class="hljs-variable">mediator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MediatorStructure</span>();<br><br>        <span class="hljs-comment">//房主和租房者只需要知道中介机构即可</span><br>        <span class="hljs-type">HouseOwner</span> <span class="hljs-variable">houseOwner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HouseOwner</span>(<span class="hljs-string">&quot;张三&quot;</span>, mediator);<br>        <span class="hljs-type">Tenant</span> <span class="hljs-variable">tenant</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tenant</span>(<span class="hljs-string">&quot;李四&quot;</span>, mediator);<br><br>        <span class="hljs-comment">//中介机构需要知道房主和租房者</span><br>        mediator.setHouseOwner(houseOwner);<br>        mediator.setTenant(tenant);<br><br>        tenant.constact(<span class="hljs-string">&quot;需要租一间房子&quot;</span>);<br>        houseOwner.constact(<span class="hljs-string">&quot;我有一间房子，你要租吗？？？&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7、结果"><a href="#7、结果" class="headerlink" title="7、结果"></a>7、结果</h3><p><img src="/2022/10/19/09-xing-wei-xing-ming-ling-jie-shi-qi-zhong-jie/image-20221019212554026.png"></p><h2 id="2、优缺点"><a href="#2、优缺点" class="headerlink" title="2、优缺点"></a>2、优缺点</h2><p><strong>优点：</strong></p><ul><li>中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星型结构。</li><li>中介者模式可将各同事对象解耦。中介者有利于各同事之间的松耦合，我们可以独立的改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则”。</li><li>可以减少子类生成，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使各个同事类可被重用，无须对同事类进行扩展。</li></ul><p><strong>缺点：</strong></p><ul><li>在具体中介者类中包含了大量同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li></ul><h2 id="3、应用场景"><a href="#3、应用场景" class="headerlink" title="3、应用场景"></a>3、应用场景</h2><ul><li>当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时。</li><li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li></ul><blockquote><p>参考：<a href="https://juejin.cn/post/6974984853402058760#heading-5">中介者模式</a>、<a href="https://juejin.cn/post/6844903795017646094#heading-38">学习并理解23种设计模式</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>命令</tag>
      
      <tag>解释器</tag>
      
      <tag>中介</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nohup什么东西？</title>
    <link href="/2022/10/18/nohup-shi-me-dong-xi/"/>
    <url>/2022/10/18/nohup-shi-me-dong-xi/</url>
    
    <content type="html"><![CDATA[<p>所以nohup是什么东西？</p><p><code>nohup</code>是英语 no hangup 的缩写，是不挂断的意思，也就是指程序不退出，用在系统后台不挂断地运行命令，退出终端不会影响程序的运行。</p><p>在工作中，我们可能经常要在服务器上跑程序，有可能要跑的程序耗时很长，需要运行一段时间，我们希望即使关闭终端，程序不受影响，继续运行。在Linux中的<code>nohup</code>命令可以达到这种效果。</p><h2 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> 命令 参数<br><span class="hljs-built_in">nohup</span> 选项<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">--<span class="hljs-built_in">help</span>     <span class="hljs-comment"># 显示此帮助信息并退出</span><br>--version  <span class="hljs-comment"># 显示版本信息并退出</span><br></code></pre></td></tr></table></figure><h2 id="Demo案例"><a href="#Demo案例" class="headerlink" title="Demo案例"></a>Demo案例</h2><p>准备一个test.py程序，功能是每隔2秒会输出”hello nohup!”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time <br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello nohup!&quot;</span>)<br>    time.sleep(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>然后使用<code>nohup python3 test.py</code>运行。</p><p>使用nohup命令时，程序的输出会默认重定向到一个nohup.out文件下。若是想要输出到指定的文件，则可以另外指定输出文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> python3 test.py &gt; out.txt<br></code></pre></td></tr></table></figure><p>但是现在还做不到让程序在后台运行，如果想要让程序在后台运行的话，可以加上 &amp; </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> python3 test.py &gt; out.txt &amp; <br></code></pre></td></tr></table></figure><p>此时关掉终端再重新打开，使用ps命令查看一下进程，发现程序还在运行。</p><p>这里如果想要把标准错误和标准输出都重定向到指定的out.txt文件中，可以使用<code>2&gt;&amp;1</code>符号，<code>2&gt;&amp;1</code>符号的意思是将将标准错误 2 重定向到标准输出 &amp;1。</p><ul><li>0 stdin (standard input，标准输入)</li><li>1 stdout (standard output，标准输出)</li><li>2 stderr (standard error，标准错误输出)</li></ul><p>具体详情见：<a href>2&gt;&amp;1到底是什么意思？</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> python3 test.py &gt; out.txt 2&gt;&amp;1 &amp; <br></code></pre></td></tr></table></figure><p><code>nohup</code>命令结合<code>&amp;</code>符号可以使进程在后台运行，即使关闭了终端依然不受影响。</p><p>那么如何结束进程呢？</p><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>执行一个<code>kill</code>命令时，实际上是发送了一个信号给系统，让它去结束掉一些不正常的应用进程。 可以使用<code>kill -l</code>命令看到所有信号的列表：</p><p><img src="/2022/10/18/nohup-shi-me-dong-xi/image-20221018215614795.png"></p><p>下面是一些常用信号的含义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">(1)SIGHUP 终端线路挂断，终止进程<br>(2)SIGINT 中断进程（同 Ctrl + C）<br>(3)SIGQUIT 退出进程（同 Ctrl + \）<br>(15)SIGTERM 终止进程<br>(9)SIGKILL 强制终止进程<br>(18)SIGCONT 继续（与SIGSTOP相反， <span class="hljs-built_in">fg</span>/bg命令）<br>(19)SIGSTOP 暂停（同 Ctrl + Z）<br></code></pre></td></tr></table></figure><p>常用到的有15 和 9</p><p>(15)SIGTERM：也就是执行<code>kill -15 pid</code>命令，这里”-15”即代表SIGTERM信号。<br> 注意：SIGTERM是默认选项，也就是说执行<code>kill pid</code>和<code>kill -15 pid</code>是等价的。<br> 执行此指令时操作系统会发送一个SIGTERM信号给对应的程序，当程序接收到该信号后，可以用一段时间来正常关闭，一般会先保存进度并释放资源，然后再停止，也就是不一定会立即停止进程，比如程序正在等待IO，可能就不会立马停止运行。也就是说，(15)SIGTERM信号不是强制停止，是可以被忽略的。</p><p>(9)SIGKILL：也就是执行<code>kill -9 pid</code>命令，这里”-9”即代表SIGKILL信号。<br> 是必杀信号，此信号强制进程立即停止运行。程序不能忽略此信号，而未保存的进度将会丢失，从而可能会影响服务的再次启动，此命令应该慎用。</p><p>kill语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> 信号或选项 pid<br></code></pre></td></tr></table></figure><p>默认信号（当没有指定的时候）是SIGTERM。当它不起作用时，可以使用<code>kill -9 pid</code>命令来强制kill掉一个进程。</p><p>应用的pid可以使用以下的命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef<br>ps -aux<br></code></pre></td></tr></table></figure><p>二者都可以查看到pid</p><p><img src="/2022/10/18/nohup-shi-me-dong-xi/image-20221018215918762.png"></p><p>比如想要kill掉PID为108的进程，只需要执行<code>kill -9 108</code>即可。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>nohup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-数据库</title>
    <link href="/2022/10/17/springboot-shu-ju-ku/"/>
    <url>/2022/10/17/springboot-shu-ju-ku/</url>
    
    <content type="html"><![CDATA[<h2 id="一、spring-boot-集成-Jdbc-Template"><a href="#一、spring-boot-集成-Jdbc-Template" class="headerlink" title="一、spring-boot 集成 Jdbc Template"></a>一、spring-boot 集成 Jdbc Template</h2><p>整体结构：</p><p><img src="/2022/10/17/springboot-shu-ju-ku/image-20221017184658161.png" alt="整体结构"></p><h3 id="1、导入依赖"><a href="#1、导入依赖" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、application-yml"><a href="#2、application-yml" class="headerlink" title="2、application.yml"></a>2、application.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/demo</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/spring-boot-demo?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;serverTimezone=GMT%2B8</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span><br>    <span class="hljs-attr">initialization-mode:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">continue-on-error:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">schema:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;classpath:db/schema.sql&quot;</span><br>    <span class="hljs-attr">data:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;classpath:db/data.sql&quot;</span><br>    <span class="hljs-attr">hikari:</span><br>      <span class="hljs-attr">minimum-idle:</span> <span class="hljs-number">5</span><br>      <span class="hljs-attr">connection-test-query:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">DUAL</span><br>      <span class="hljs-attr">maximum-pool-size:</span> <span class="hljs-number">20</span><br>      <span class="hljs-attr">auto-commit:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">idle-timeout:</span> <span class="hljs-number">30000</span><br>      <span class="hljs-attr">pool-name:</span> <span class="hljs-string">SpringBootDemoHikariCP</span><br>      <span class="hljs-attr">max-lifetime:</span> <span class="hljs-number">60000</span><br>      <span class="hljs-attr">connection-timeout:</span> <span class="hljs-number">30000</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.xkcoding:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h3 id="3、实体类User"><a href="#3、实体类User" class="headerlink" title="3、实体类User"></a>3、实体类User</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Table(name = &quot;orm_user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主键</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Pk</span><br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加密后的密码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加密使用的盐</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String salt;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 邮箱</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String email;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 手机号码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Column(name = &quot;phone_number&quot;)</span><br>    <span class="hljs-keyword">private</span> String phoneNumber;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 状态，-1：逻辑删除，0：禁用，1：启用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer status;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Column(name = &quot;create_time&quot;)</span><br>    <span class="hljs-keyword">private</span> Date createTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上次登录时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Column(name = &quot;last_login_time&quot;)</span><br>    <span class="hljs-keyword">private</span> Date lastLoginTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上次更新时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Column(name = &quot;last_update_time&quot;)</span><br>    <span class="hljs-keyword">private</span> Date lastUpdateTime;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、UserDao继承BaseDao"><a href="#4、UserDao继承BaseDao" class="headerlink" title="4、UserDao继承BaseDao"></a>4、UserDao继承BaseDao</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseDao</span>&lt;User, Long&gt; &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserDao</span><span class="hljs-params">(JdbcTemplate jdbcTemplate)</span> &#123;<br>        <span class="hljs-built_in">super</span>(jdbcTemplate);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 操作影响行数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">insert</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.insert(user, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据主键删除用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 操作影响行数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">delete</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.deleteById(id);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id   主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 操作影响行数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">update</span><span class="hljs-params">(User user, Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.updateById(user, id, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据主键获取用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> id对应的用户</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">selectById</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.findOneById(id);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据查询条件获取用户列表</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户查询条件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">selectUserList</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.findByExample(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、UserServiceImpl实现IUserService接口"><a href="#5、UserServiceImpl实现IUserService接口" class="headerlink" title="5、UserServiceImpl实现IUserService接口"></a>5、UserServiceImpl实现IUserService接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceImpl</span><span class="hljs-params">(UserDao userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户实体</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 保存成功 &#123;<span class="hljs-doctag">@code</span> true&#125; 保存失败 &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">save</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rawPass</span> <span class="hljs-operator">=</span> user.getPassword();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">salt</span> <span class="hljs-operator">=</span> IdUtil.simpleUUID();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> SecureUtil.md5(rawPass + Const.SALT_PREFIX + salt);<br>        user.setPassword(pass);<br>        user.setSalt(salt);<br>        <span class="hljs-keyword">return</span> userDao.insert(user) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 删除成功 &#123;<span class="hljs-doctag">@code</span> true&#125; 删除失败 &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">delete</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> userDao.delete(id) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户实体</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id   主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 更新成功 &#123;<span class="hljs-doctag">@code</span> true&#125; 更新失败 &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">update</span><span class="hljs-params">(User user, Long id)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">exist</span> <span class="hljs-operator">=</span> getUser(id);<br>        <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(user.getPassword())) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rawPass</span> <span class="hljs-operator">=</span> user.getPassword();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">salt</span> <span class="hljs-operator">=</span> IdUtil.simpleUUID();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> SecureUtil.md5(rawPass + Const.SALT_PREFIX + salt);<br>            user.setPassword(pass);<br>            user.setSalt(salt);<br>        &#125;<br>        BeanUtil.copyProperties(user, exist, CopyOptions.create().setIgnoreNullValue(<span class="hljs-literal">true</span>));<br>        exist.setLastUpdateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTime</span>());<br>        <span class="hljs-keyword">return</span> userDao.update(exist, id) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取单个用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 单个用户对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> userDao.findOneById(id);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取用户列表</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户实体</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUser</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> userDao.findByExample(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、结果"><a href="#6、结果" class="headerlink" title="6、结果"></a>6、结果</h3><p><img src="/2022/10/17/springboot-shu-ju-ku/image-20221017184607196.png"></p><h2 id="二、spring-boot-集成原生mybatis"><a href="#二、spring-boot-集成原生mybatis" class="headerlink" title="二、spring-boot 集成原生mybatis"></a>二、spring-boot 集成原生mybatis</h2><p>spring-boot 集成原生mybatis，使用 <a href="https://github.com/mybatis/spring-boot-starter">mybatis-spring-boot-starter</a> 集成</p><h3 id="1、导入依赖-1"><a href="#1、导入依赖-1" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、主启动类"><a href="#2、主启动类" class="headerlink" title="2、主启动类"></a>2、主启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(basePackages = &#123;&quot;com.xkcoding.orm.mybatis.mapper&quot;&#125;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootDemoOrmMybatisApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SpringBootDemoOrmMybatisApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>记得加 @MapperScan 注解</p><h3 id="3、application-yml"><a href="#3、application-yml" class="headerlink" title="3、application.yml"></a>3、application.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/spring-boot-demo?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;serverTimezone=GMT%2B8</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span><br>    <span class="hljs-attr">initialization-mode:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">continue-on-error:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">schema:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;classpath:db/schema.sql&quot;</span><br>    <span class="hljs-attr">data:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;classpath:db/data.sql&quot;</span><br>    <span class="hljs-attr">hikari:</span><br>      <span class="hljs-attr">minimum-idle:</span> <span class="hljs-number">5</span><br>      <span class="hljs-attr">connection-test-query:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">DUAL</span><br>      <span class="hljs-attr">maximum-pool-size:</span> <span class="hljs-number">20</span><br>      <span class="hljs-attr">auto-commit:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">idle-timeout:</span> <span class="hljs-number">30000</span><br>      <span class="hljs-attr">pool-name:</span> <span class="hljs-string">SpringBootDemoHikariCP</span><br>      <span class="hljs-attr">max-lifetime:</span> <span class="hljs-number">60000</span><br>      <span class="hljs-attr">connection-timeout:</span> <span class="hljs-number">30000</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.xkcoding:</span> <span class="hljs-string">debug</span><br>    <span class="hljs-attr">com.xkcoding.orm.mybatis.mapper:</span> <span class="hljs-string">trace</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-comment"># 下划线转驼峰</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mappers/*.xml</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.xkcoding.orm.mybatis.entity</span><br></code></pre></td></tr></table></figure><h3 id="4、UserMapper接口"><a href="#4、UserMapper接口" class="headerlink" title="4、UserMapper接口"></a>4、UserMapper接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询所有用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Select(&quot;SELECT * FROM orm_user&quot;)</span><br>    List&lt;User&gt; <span class="hljs-title function_">selectAllUser</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id查询用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 当前id的用户，不存在则是 &#123;<span class="hljs-doctag">@code</span> null&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Select(&quot;SELECT * FROM orm_user WHERE id = #&#123;id&#125;&quot;)</span><br>    User <span class="hljs-title function_">selectUserById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Long id)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功 - &#123;<span class="hljs-doctag">@code</span> 1&#125; 失败 - &#123;<span class="hljs-doctag">@code</span> 0&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;user&quot;)</span> User user)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功 - &#123;<span class="hljs-doctag">@code</span> 1&#125; 失败 - &#123;<span class="hljs-doctag">@code</span> 0&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Long id)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、UserMapper-xml"><a href="#5、UserMapper-xml" class="headerlink" title="5、UserMapper.xml"></a>5、UserMapper.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.xkcoding.orm.mybatis.mapper.UserMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;saveUser&quot;</span>&gt;</span><br>        INSERT INTO `orm_user` (`name`,<br>                                `password`,<br>                                `salt`,<br>                                `email`,<br>                                `phone_number`,<br>                                `status`,<br>                                `create_time`,<br>                                `last_login_time`,<br>                                `last_update_time`)<br>        VALUES (#&#123;user.name&#125;,<br>                #&#123;user.password&#125;,<br>                #&#123;user.salt&#125;,<br>                #&#123;user.email&#125;,<br>                #&#123;user.phoneNumber&#125;,<br>                #&#123;user.status&#125;,<br>                #&#123;user.createTime&#125;,<br>                #&#123;user.lastLoginTime&#125;,<br>                #&#123;user.lastUpdateTime&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span>&gt;</span><br>        DELETE<br>        FROM `orm_user`<br>        WHERE `id` = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserMapperTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SpringBootDemoOrmMybatisApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectAllUser</span><span class="hljs-params">()</span> &#123;<br>        List&lt;User&gt; userList = userMapper.selectAllUser();<br>        Assert.assertTrue(CollUtil.isNotEmpty(userList));<br>        log.debug(<span class="hljs-string">&quot;【userList】= &#123;&#125;&quot;</span>, userList);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectUserById</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.selectUserById(<span class="hljs-number">1L</span>);<br>        Assert.assertNotNull(user);<br>        log.debug(<span class="hljs-string">&quot;【user】= &#123;&#125;&quot;</span>, user);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">salt</span> <span class="hljs-operator">=</span> IdUtil.fastSimpleUUID();<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> User.builder().name(<span class="hljs-string">&quot;testSave3&quot;</span>).password(SecureUtil.md5(<span class="hljs-string">&quot;123456&quot;</span> + salt)).salt(salt).email(<span class="hljs-string">&quot;testSave3@xkcoding.com&quot;</span>).phoneNumber(<span class="hljs-string">&quot;17300000003&quot;</span>).status(<span class="hljs-number">1</span>).lastLoginTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTime</span>()).createTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTime</span>()).lastUpdateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTime</span>()).build();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> userMapper.saveUser(user);<br>        Assert.assertEquals(<span class="hljs-number">1</span>, i);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> userMapper.deleteById(<span class="hljs-number">1L</span>);<br>        Assert.assertEquals(<span class="hljs-number">1</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7、参考"><a href="#7、参考" class="headerlink" title="7、参考"></a>7、参考</h3><ul><li>Mybatis官方文档：<a href="http://www.mybatis.org/mybatis-3/zh/index.html">http://www.mybatis.org/mybatis-3/zh/index.html</a></li><li>Mybatis官方脚手架文档：<a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></li><li>Mybatis整合Spring Boot官方demo：<a href="https://github.com/mybatis/spring-boot-starter/tree/master/mybatis-spring-boot-samples">https://github.com/mybatis/spring-boot-starter/tree/master/mybatis-spring-boot-samples</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-配置文件以及日志</title>
    <link href="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/"/>
    <url>/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/</url>
    
    <content type="html"><![CDATA[<h2 id="一、多个配置文件的读取"><a href="#一、多个配置文件的读取" class="headerlink" title="一、多个配置文件的读取"></a>一、多个配置文件的读取</h2><p>现在有多个配置文件，运行时要读取其中一个配置文件，怎么选择？</p><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221014172131119.png"></p><p>多个配置文件的读取，在设置好property类后，可以在application中选择要读取的对象，如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/demo</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><p>当要读取 application-dev 时，只需将第七行代码改为dev，当要读取application-prod时，只需将第七行代码改为prod。</p><p>如下是设置为dev的运行结果：</p><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221014172456012.png"></p><h2 id="二、spring-boot-集成-spring-boot-starter-actuator"><a href="#二、spring-boot-集成-spring-boot-starter-actuator" class="headerlink" title="二、spring-boot 集成 spring-boot-starter-actuator"></a>二、spring-boot 集成 spring-boot-starter-actuator</h2><p>actuator用于监控 spring-boot 的启动和运行状态</p><h3 id="1、pom文件"><a href="#1、pom文件" class="headerlink" title="1、pom文件"></a>1、pom文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、application-yml"><a href="#2、application-yml" class="headerlink" title="2、application.yml"></a>2、application.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/demo</span><br><span class="hljs-comment"># 若要访问端点信息，需要配置用户名和密码</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">security:</span><br>    <span class="hljs-attr">user:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">zhaibiao</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>      <br><span class="hljs-attr">management:</span><br>  <span class="hljs-comment"># 端点信息接口使用的端口，为了和主系统接口使用的端口进行分离</span><br>  <span class="hljs-attr">server:</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8090</span><br>    <span class="hljs-attr">servlet:</span><br>      <span class="hljs-attr">context-path:</span> <span class="hljs-string">/sys</span><br>  <span class="hljs-comment"># 端点健康情况，默认值&quot;never&quot;，设置为&quot;always&quot;可以显示硬盘使用情况和线程情况</span><br>  <span class="hljs-attr">endpoint:</span><br>    <span class="hljs-attr">health:</span><br>      <span class="hljs-attr">show-details:</span> <span class="hljs-string">always</span><br>  <span class="hljs-comment"># 设置端点暴露的哪些内容，默认[&quot;health&quot;,&quot;info&quot;]，设置&quot;*&quot;代表暴露所有可访问的端点</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3、端点暴露地址"><a href="#3、端点暴露地址" class="headerlink" title="3、端点暴露地址"></a>3、端点暴露地址</h3><ol><li>打开浏览器，访问：<a href="http://localhost:8090/sys/actuator/mappings">http://localhost:8090/sys/actuator/mappings</a> ，输入用户名(zhaibiao)密码(123456)即可看到所有的mapping信息</li><li>访问：<a href="http://localhost:8090/sys/actuator/beans">http://localhost:8090/sys/actuator/beans</a> ，输入用户名(zhaibiao)密码(123456)即可看到所有 Spring 管理的Bean</li></ol><ul><li>actuator文档：<a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#production-ready">https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#production-ready</a></li></ul><h3 id="4、结果"><a href="#4、结果" class="headerlink" title="4、结果"></a>4、结果</h3><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221017161554284.png" alt="beans"></p><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221017161608902.png" alt="mappings"></p><h2 id="三、spring-boot集成admin"><a href="#三、spring-boot集成admin" class="headerlink" title="三、spring-boot集成admin"></a>三、spring-boot集成admin</h2><h3 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h3><h4 id="1、导入依赖"><a href="#1、导入依赖" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h4><p>服务端配置文件不需要太多配置，端口号即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8000</span><br></code></pre></td></tr></table></figure><h4 id="3、主启动类"><a href="#3、主启动类" class="headerlink" title="3、主启动类"></a>3、主启动类</h4><p>必须要在主启动类上加 <code>@EnableAdminServer</code> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAdminServer</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootDemoAdminServerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SpringBootDemoAdminServerApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h3><h4 id="1、导入依赖-1"><a href="#1、导入依赖-1" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2、配置文件-1"><a href="#2、配置文件-1" class="headerlink" title="2、配置文件"></a>2、配置文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/demo</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-comment"># Spring Boot Admin展示的客户端项目名，不设置，会使用自动生成的随机id</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">spring-boot-demo-admin-client</span><br>  <span class="hljs-attr">boot:</span><br>    <span class="hljs-attr">admin:</span><br>      <span class="hljs-attr">client:</span><br>        <span class="hljs-comment"># Spring Boot Admin 服务端地址</span><br>        <span class="hljs-attr">url:</span> <span class="hljs-string">&quot;http://localhost:8000/&quot;</span><br>        <span class="hljs-attr">instance:</span><br>          <span class="hljs-attr">metadata:</span><br>            <span class="hljs-comment"># 客户端端点信息的安全认证信息</span><br>            <span class="hljs-attr">user.name:</span> <span class="hljs-string">$&#123;spring.security.user.name&#125;</span><br>            <span class="hljs-attr">user.password:</span> <span class="hljs-string">$&#123;spring.security.user.password&#125;</span><br>  <span class="hljs-attr">security:</span><br>    <span class="hljs-attr">user:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">zhaibiao</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoint:</span><br>    <span class="hljs-attr">health:</span><br>      <span class="hljs-comment"># 端点健康情况，默认值&quot;never&quot;，设置为&quot;always&quot;可以显示硬盘使用情况和线程情况</span><br>      <span class="hljs-attr">show-details:</span> <span class="hljs-string">always</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-comment"># 设置端点暴露的哪些内容，默认[&quot;health&quot;,&quot;info&quot;]，设置&quot;*&quot;代表暴露所有可访问的端点</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span><br></code></pre></td></tr></table></figure><h4 id="3、控制类（用来测试）"><a href="#3、控制类（用来测试）" class="headerlink" title="3、控制类（用来测试）"></a>3、控制类（用来测试）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IndexController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(value = &#123;&quot;&quot;, &quot;/&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This is a Spring Boot Admin Client.&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、结果"><a href="#3、结果" class="headerlink" title="3、结果"></a>3、结果</h3><p>运行步骤：</p><ol><li>先启动server服务端，启动管控台服务端程序</li><li>再启动client客户端，注册到服务端</li><li>观察服务端里，客户端程序的运行状态等信息</li></ol><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221017163939849.png" alt="server"></p><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221017164045955.png" alt="client"></p><h2 id="四、spring-boot集成logback"><a href="#四、spring-boot集成logback" class="headerlink" title="四、spring-boot集成logback"></a>四、spring-boot集成logback</h2><p>演示如何使用 logback 记录程序运行过程中的日志，以及如何配置 logback，可以同时生成控制台日志和文件日志记录，文件日志以日期和大小进行拆分生成。</p><h3 id="1、导入依赖-2"><a href="#1、导入依赖-2" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>demo-logback<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、配置文件-2"><a href="#2、配置文件-2" class="headerlink" title="2、配置文件"></a>2、配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/demo</span><br></code></pre></td></tr></table></figure><p>配置端口</p><h3 id="3、logback-spring-xml"><a href="#3、logback-spring-xml" class="headerlink" title="3、logback-spring.xml"></a>3、logback-spring.xml</h3><p>在resources下建立logback-spring.xml用于配置logback</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_ERROR_PATTERN&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;FILE_LOG_PATTERN:-%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125; $&#123;LOG_LEVEL_PATTERN:-%5p&#125; $&#123;PID:- &#125; --- [%t] %-40.40logger&#123;39&#125; %file:%line: %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>INFO<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_INFO&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--如果只是想要 Info 级别的日志，只是过滤 info 还是会输出 Error 日志，因为 Error 的级别高， 所以我们使用下面的策略，可以避免输出 Error 的日志--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--过滤 Error--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>ERROR<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--匹配到就禁止--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--没有匹配到就允许--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。--&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;File&gt;logs/info.demo-logback.log&lt;/File&gt;--&gt;</span><br>  <span class="hljs-comment">&lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>logs/demo-logback/info.created_on_%d&#123;yyyy-MM-dd&#125;.part_%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--只保留最近90天的日志--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>90<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志--&gt;</span><br>   <span class="hljs-comment">&lt;!--&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- maxFileSize:这是活动文件的大小，默认值是10MB,本篇设置为1KB，只是为了演示 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>2MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;--&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;maxFileSize&gt;1KB&lt;/maxFileSize&gt;--&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;/triggeringPolicy&gt;--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处设置字符集 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_ERROR&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--如果只是想要 Error 级别的日志，那么需要过滤一下，默认是 info 级别的，ThresholdFilter--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>Error<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。--&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;File&gt;logs/error.demo-logback.log&lt;/File&gt;--&gt;</span><br>  <span class="hljs-comment">&lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>logs/demo-logback/error.created_on_%d&#123;yyyy-MM-dd&#125;.part_%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--只保留最近90天的日志--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>90<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- maxFileSize:这是活动文件的大小，默认值是10MB,本篇设置为1KB，只是为了演示 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>2MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_ERROR_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处设置字符集 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE_INFO&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE_ERROR&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4、主启动类进行测试"><a href="#4、主启动类进行测试" class="headerlink" title="4、主启动类进行测试"></a>4、主启动类进行测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootDemoLogbackApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(SpringBootDemoLogbackApplication.class, args);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> context.getBeanDefinitionNames().length;<br>        log.trace(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);<br>        log.debug(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);<br>        log.info(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);<br>        log.warn(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);<br>        log.error(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//int j = 1 / i;</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;【SpringBootDemoLogbackApplication】启动异常：&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、结果"><a href="#5、结果" class="headerlink" title="5、结果"></a>5、结果</h3><p>报错日志如下：</p><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221017170557025.png" alt="Error"></p><blockquote><p>TODO</p></blockquote><h2 id="五、spring-boot-使用-AOP-切面的方式记录-web-请求日志"><a href="#五、spring-boot-使用-AOP-切面的方式记录-web-请求日志" class="headerlink" title="五、spring-boot 使用 AOP 切面的方式记录 web 请求日志"></a>五、spring-boot 使用 AOP 切面的方式记录 web 请求日志</h2><h2 id="六、spring-boot-统一异常处理"><a href="#六、spring-boot-统一异常处理" class="headerlink" title="六、spring-boot 统一异常处理"></a>六、spring-boot 统一异常处理</h2>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>配置文件</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>v2-哈希表</title>
    <link href="/2022/10/13/v2-ha-xi-biao/"/>
    <url>/2022/10/13/v2-ha-xi-biao/</url>
    
    <content type="html"><![CDATA[<h1 id="一、理论基础"><a href="#一、理论基础" class="headerlink" title="一、理论基础"></a>一、理论基础</h1><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p><p>哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。</p><p>哈希表能解决什么问题呢？一般哈希表是用来判断一个元素是否出现在元素里。</p><p>例如要查询一个名字是否在这所学校里，要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。</p><h2 id="1、哈希函数"><a href="#1、哈希函数" class="headerlink" title="1、哈希函数"></a>1、哈希函数</h2><p>哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。</p><p>哈希函数通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p><p>但是若是哈希表不够大，而hashCode得到的数值又大于哈希表的长度呢？一般都是用取模来解决这个问题。</p><p>那么问题又来了，若是有很多同学通过hashCode得到的数值都相等呢？这个现象就叫哈希碰撞</p><h2 id="2、哈希碰撞"><a href="#2、哈希碰撞" class="headerlink" title="2、哈希碰撞"></a>2、哈希碰撞</h2><p>如下，小李和小王都映射到索引下标1的位置，产生哈希碰撞。</p><p><img src="/2022/10/13/v2-ha-xi-biao/image-20221013103434324.png"></p><p>解决办法有两个</p><h3 id="1、拉链法"><a href="#1、拉链法" class="headerlink" title="1、拉链法"></a>1、拉链法</h3><p>拉链法简而言之就是产生碰撞时，让发生冲突的元素都储存在链表中。</p><p><img src="/2022/10/13/v2-ha-xi-biao/image-20221013103638804.png"></p><h3 id="2、线性探测法"><a href="#2、线性探测法" class="headerlink" title="2、线性探测法"></a>2、线性探测法</h3><p>线性探测法是当产生冲突时，往下顺延至没有数据的那一位，如下图。</p><p><img src="/2022/10/13/v2-ha-xi-biao/image-20221013103733434.png"></p><p>所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。</p><h2 id="3、常见哈希结构"><a href="#3、常见哈希结构" class="headerlink" title="3、常见哈希结构"></a>3、常见哈希结构</h2><ul><li>数组</li><li>set</li><li>map</li></ul><h2 id="4、常用方法"><a href="#4、常用方法" class="headerlink" title="4、常用方法"></a>4、常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 是否包含关键字</span><br>map.containsKey(keys);<br><span class="hljs-comment">// 添加关键字和值</span><br>map.put(keys, value);<br><span class="hljs-comment">// 获取所有键的值</span><br>map.values();<br><br><span class="hljs-comment">// 字符串转字符数组</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;string&quot;</span>;<br><span class="hljs-type">char</span>[] ch = str.toCharArray();<br><span class="hljs-comment">// 字符数组转字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">keys</span> <span class="hljs-operator">=</span> String.valueOf(ch);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>08-行为型-状态-迭代器</title>
    <link href="/2022/10/12/08-xing-wei-xing-zhuang-tai-die-dai-qi/"/>
    <url>/2022/10/12/08-xing-wei-xing-zhuang-tai-die-dai-qi/</url>
    
    <content type="html"><![CDATA[<h1 id="一、状态模式"><a href="#一、状态模式" class="headerlink" title="一、状态模式"></a>一、状态模式</h1><p>状态模式（State Pattern）：它主要用来解决对象在多种状态转换时，需要对外 输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换。</p><p>当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了 其类。</p><h2 id="1、Demo案例-抽奖活动问题"><a href="#1、Demo案例-抽奖活动问题" class="headerlink" title="1、Demo案例-抽奖活动问题"></a>1、Demo案例-抽奖活动问题</h2><blockquote><p>需求</p></blockquote><ol><li>假如每参加一次这个活动要 扣除用户50积分，中奖概率 是10%  </li><li>奖品数量固定，抽完就不能 抽奖 </li><li>活动有四个状态: 可以抽奖、 不能抽奖、发放奖品和奖品 领完 </li><li>活动的四个状态转换关系图 </li></ol><p><img src="/2022/10/12/08-xing-wei-xing-zhuang-tai-die-dai-qi/image-20221012210047466.png"></p><p>状态模式解决该问题类图：</p><p><img src="/2022/10/12/08-xing-wei-xing-zhuang-tai-die-dai-qi/image-20221012211016481.png"></p><h3 id="1、State"><a href="#1、State" class="headerlink" title="1、State"></a>1、State</h3><p>状态抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span> &#123;<br>   <br>   <span class="hljs-comment">// 扣除积分 - 50</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductMoney</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 是否抽中奖品</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">raffle</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 发放奖品</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispensePrize</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、NoRaffleState"><a href="#2、NoRaffleState" class="headerlink" title="2、NoRaffleState"></a>2、NoRaffleState</h3><p>不能抽奖状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoRaffleState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">State</span> &#123;<br><br>    <span class="hljs-comment">// 初始化时传入活动引用，扣除积分后改变其状态</span><br>    RaffleActivity activity;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NoRaffleState</span><span class="hljs-params">(RaffleActivity activity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.activity = activity;<br>    &#125;<br><br>    <span class="hljs-comment">// 当前状态可以扣积分 , 扣除后，将状态设置成可以抽奖状态</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductMoney</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;扣除50积分成功，您可以抽奖了&quot;</span>);<br>        activity.setState(activity.getCanRaffleState());<br>    &#125;<br><br>    <span class="hljs-comment">// 当前状态不能抽奖</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">raffle</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;扣了积分才能抽奖喔！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 当前状态不能发奖品</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispensePrize</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;不能发放奖品&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、DispenseState"><a href="#3、DispenseState" class="headerlink" title="3、DispenseState"></a>3、DispenseState</h3><p>发放奖品的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DispenseState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">State</span> &#123;<br><br>    <span class="hljs-comment">// 初始化时传入活动引用，发放奖品后改变其状态</span><br>    RaffleActivity activity;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DispenseState</span><span class="hljs-params">(RaffleActivity activity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.activity = activity;<br>    &#125;<br>    <br>    <span class="hljs-comment">//</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductMoney</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;不能扣除积分&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">raffle</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;不能抽奖&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//发放奖品</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispensePrize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(activity.getCount() &gt; <span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;恭喜中奖了&quot;</span>);<br>            <span class="hljs-comment">// 改变状态为不能抽奖</span><br>            activity.setState(activity.getNoRafflleState());<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;很遗憾，奖品发送完了&quot;</span>);<br>            <span class="hljs-comment">// 改变状态为奖品发送完毕, 后面我们就不可以抽奖</span><br>            activity.setState(activity.getDispensOutState());<br>            <span class="hljs-comment">//System.out.println(&quot;抽奖活动结束&quot;);</span><br>            <span class="hljs-comment">//System.exit(0);</span><br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、DispenseOutState"><a href="#4、DispenseOutState" class="headerlink" title="4、DispenseOutState"></a>4、DispenseOutState</h3><p>奖品发放完毕状态</p><p>当我们activity 改变成 DispenseOutState， 抽奖活动结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DispenseOutState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">State</span> &#123;<br><br>   <span class="hljs-comment">// 初始化时传入活动引用</span><br>    RaffleActivity activity;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DispenseOutState</span><span class="hljs-params">(RaffleActivity activity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.activity = activity;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductMoney</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;奖品发送完了，请下次再参加&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">raffle</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;奖品发送完了，请下次再参加&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispensePrize</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;奖品发送完了，请下次再参加&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、CanRaffleState"><a href="#5、CanRaffleState" class="headerlink" title="5、CanRaffleState"></a>5、CanRaffleState</h3><p>可以抽奖的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CanRaffleState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">State</span> &#123;<br><br>    RaffleActivity activity;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CanRaffleState</span><span class="hljs-params">(RaffleActivity activity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.activity = activity;<br>    &#125;<br><br>    <span class="hljs-comment">//已经扣除了积分，不能再扣</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductMoney</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;已经扣取过了积分&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//可以抽奖, 抽完奖后，根据实际情况，改成新的状态</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">raffle</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;正在抽奖，请稍等！&quot;</span>);<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// 10%中奖机会</span><br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 改变活动状态为发放奖品 context</span><br>            activity.setState(activity.getDispenseState());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;很遗憾没有抽中奖品！&quot;</span>);<br>            <span class="hljs-comment">// 改变状态为不能抽奖</span><br>            activity.setState(activity.getNoRafflleState());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 不能发放奖品</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispensePrize</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;没中奖，不能发放奖品&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、RaffleActivity"><a href="#6、RaffleActivity" class="headerlink" title="6、RaffleActivity"></a>6、RaffleActivity</h3><p>抽奖活动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RaffleActivity</span> &#123;<br><br>   <span class="hljs-comment">// state 表示活动当前的状态，是变化</span><br>    <span class="hljs-type">State</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 奖品数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 四个属性，表示四种状态</span><br>    <span class="hljs-type">State</span> <span class="hljs-variable">noRafflleState</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoRaffleState</span>(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-type">State</span> <span class="hljs-variable">canRaffleState</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanRaffleState</span>(<span class="hljs-built_in">this</span>);<br>    <br>    <span class="hljs-type">State</span> <span class="hljs-variable">dispenseState</span> <span class="hljs-operator">=</span>   <span class="hljs-keyword">new</span> <span class="hljs-title class_">DispenseState</span>(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-type">State</span> <span class="hljs-variable">dispensOutState</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DispenseOutState</span>(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-comment">//构造器</span><br>    <span class="hljs-comment">//1. 初始化当前的状态为 noRafflleState（即不能抽奖的状态）</span><br>    <span class="hljs-comment">//2. 初始化奖品的数量 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RaffleActivity</span><span class="hljs-params">( <span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = getNoRafflleState();<br>        <span class="hljs-built_in">this</span>.count = count;<br>    &#125;<br><br>    <span class="hljs-comment">//扣分, 调用当前状态的 deductMoney</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debuctMoney</span><span class="hljs-params">()</span>&#123;<br>        state.deductMoney();<br>    &#125;<br><br>    <span class="hljs-comment">//抽奖 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">raffle</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-comment">// 如果当前的状态是抽奖成功</span><br>        <span class="hljs-keyword">if</span>(state.raffle())&#123;<br>           <span class="hljs-comment">//领取奖品</span><br>            state.dispensePrize();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(State state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = state;<br>    &#125;<br><br>    <span class="hljs-comment">//这里请大家注意，每领取一次奖品，count--</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">curCount</span> <span class="hljs-operator">=</span> count; <br>       count--;<br>        <span class="hljs-keyword">return</span> curCount;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCount</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-built_in">this</span>.count = count;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getNoRafflleState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> noRafflleState;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNoRafflleState</span><span class="hljs-params">(State noRafflleState)</span> &#123;<br>        <span class="hljs-built_in">this</span>.noRafflleState = noRafflleState;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getCanRaffleState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> canRaffleState;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCanRaffleState</span><span class="hljs-params">(State canRaffleState)</span> &#123;<br>        <span class="hljs-built_in">this</span>.canRaffleState = canRaffleState;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getDispenseState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> dispenseState;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDispenseState</span><span class="hljs-params">(State dispenseState)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dispenseState = dispenseState;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getDispensOutState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> dispensOutState;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDispensOutState</span><span class="hljs-params">(State dispensOutState)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dispensOutState = dispensOutState;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7、ClientTest"><a href="#7、ClientTest" class="headerlink" title="7、ClientTest"></a>7、ClientTest</h3><p>主函数测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientTest</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-comment">// 创建活动对象，奖品有1个奖品</span><br>        <span class="hljs-type">RaffleActivity</span> <span class="hljs-variable">activity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RaffleActivity</span>(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 我们连续抽30次奖</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;--------第&quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;次抽奖----------&quot;</span>);<br>            <span class="hljs-comment">// 参加抽奖，第一步点击扣除积分</span><br>            activity.debuctMoney();<br><br>            <span class="hljs-comment">// 第二步抽奖</span><br>            activity.raffle();<br>        &#125;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、状态模式原理"><a href="#2、状态模式原理" class="headerlink" title="2、状态模式原理"></a>2、状态模式原理</h2><p>类图如下：</p><p><img src="/2022/10/12/08-xing-wei-xing-zhuang-tai-die-dai-qi/image-20221012210214155.png"></p><blockquote><p>说明</p></blockquote><ol><li>Context 类为环境角色, 用于维护State实例,这个实例定义当前状态 </li><li>State 是抽象状态角色,定义一个接口封装与Context 的一个特点接口相关行为 </li><li>ConcreteState 具体的状态角色，每个子类实现一个与Context 的一个状态相关行为</li></ol><h2 id="3、状态模式应用"><a href="#3、状态模式应用" class="headerlink" title="3、状态模式应用"></a>3、状态模式应用</h2><p>状态模式在实际项目-借贷平台中的应用</p><ol><li>借贷平台的订单，有审核-发布-抢单 等等 步骤，随着操作的不同，会改变订单的 状态, 项目中的这个模块实现就会使用到状态模式 </li><li>通常通过if/else判断订单的状态，从而实现不同的逻辑，伪代码如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(审核)&#123;<br><span class="hljs-comment">//审核逻辑</span><br>&#125;elseif(发布)&#123;<br><span class="hljs-comment">//发布逻辑</span><br>&#125;elseif(接单)&#123;<br><span class="hljs-comment">//接单逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p>问题分析：</p><p>这类代码难以应对变化，在添加一种状态时，我们需要手动 添加if/else，在添加一种功能时，要对所有的状态进行判断。 因此代码会变得越来越臃肿，并且一旦没有处理某个状态， 便会发生极其严重的BUG，难以维护。此时就需要使用状态模式</p><h2 id="4、状态模式注意事项"><a href="#4、状态模式注意事项" class="headerlink" title="4、状态模式注意事项"></a>4、状态模式注意事项</h2><ol><li>代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中 </li><li>方便维护。将容易产生问题的if-else语句删除了，如果把每个状态的行为都放到一 个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多if-else语句， 而且容易出错 </li><li>符合“开闭原则”。容易增删状态 </li><li>会产生很多类。每个状态都要一个对应的类，当状态过多时会产生很多类，加大维 护难度 </li><li>应用场景：当一个事件或者对象有很多种状态，状态之间会相互转换，对不同的状 态要求有不同的行为的时候，可以考虑使用状态模式</li></ol><h1 id="二、迭代器模式"><a href="#二、迭代器模式" class="headerlink" title="二、迭代器模式"></a>二、迭代器模式</h1><h2 id="1、迭代器模式的原理和实现"><a href="#1、迭代器模式的原理和实现" class="headerlink" title="1、迭代器模式的原理和实现"></a>1、迭代器模式的原理和实现</h2><p>迭代器模式，也叫游标模式。迭代器模式用来遍历集合对象。这里说的“集合对象”也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。</p><p>迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及<strong>容器和容器迭代器</strong>部分两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。</p><p>通过一个例子来具体讲，如何实现一个迭代器。</p><p>大部分编程语言都提供了遍历容器的迭代器类，我们在平时开发中，直接拿来用即可，几乎不大可能从零编写一个迭代器。不过，这里为了讲解迭代器的实现原理，我们假设某个新的编程语言的基础类库中，还没有提供线性容器对应的迭代器，需要我们从零开始开发。</p><p>线性数据结构包括数组和链表，在大部分编程语言中都有对应的类来封装这两种数据结构，在开发中直接拿来用就可以了。假设在这种新的编程语言中，这两个数据结构分别对应 ArrayList 和 LinkedList 两个类。除此之外，我们从两个类中抽象出公共的接口，定义为 List 接口，以方便开发者基于接口而非实现编程，编写的代码能在两种数据存储结构之间灵活切换。</p><p>现在针对 ArrayList 和 LinkedList 两个线性容器，设计实现对应的迭代器。定义一个迭代器接口 Iterator，以及针对两种容器的具体的迭代器实现类 ArrayIterator 和 ListIterator。</p><p>先来看下 Iterator 接口的定义。具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 接口定义方式一</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>  E <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 接口定义方式二</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>  E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Iterator 接口有两种定义方式。在第一种定义中，next() 函数用来将游标后移一位元素，currentItem() 函数用来返回当前游标指向的元素。在第二种定义中，返回当前元素与后移一位这两个操作，要放到同一个函数 next() 中完成。第一种定义方式更加灵活一些，比如我们可以多次调用 currentItem() 查询当前元素，而不移动游标。所以，在接下来的实现中，我们选择第一种接口定义方式。</p><p>再来看下 ArrayIterator 的代码实现，具体如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayIterator</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor;<br>  <span class="hljs-keyword">private</span> ArrayList&lt;E&gt; arrayList;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayIterator</span><span class="hljs-params">(ArrayList&lt;E&gt; arrayList)</span> &#123;<br>    <span class="hljs-built_in">this</span>.cursor = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">this</span>.arrayList = arrayList;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> cursor != arrayList.size(); <span class="hljs-comment">// 注意这里，cursor在指向最后一个元素的时候，hasNext()仍旧返回true。</span><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    cursor++;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> E <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (cursor &gt;= arrayList.size()) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> arrayList.get(cursor);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    ArrayList&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    names.add(<span class="hljs-string">&quot;lql&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;dl&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;tql&quot;</span>);<br><br>    Iterator&lt;String&gt; iterator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIterator</span>(names);<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>      System.out.println(iterator.currentItem());<br>      iterator.next();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码实现中，需要将待遍历的容器对象，通过构造函数传递给迭代器类。实际上，为了封装迭代器的创建细节，我们可以在容器中定义一个 iterator() 方法，来创建对应的迭代器。为了能实现基于接口而非实现编程，我们还需要将这个方法定义在 List 接口中。具体的代码实现和使用示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>  Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>  <span class="hljs-comment">// ...省略其他接口函数...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIterator</span>(<span class="hljs-built_in">this</span>);<br>  &#125;<br>  <span class="hljs-comment">// ...省略其他代码</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    names.add(<span class="hljs-string">&quot;lql&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;dl&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;tql&quot;</span>);<br><br>    Iterator&lt;String&gt; iterator = names.iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>      System.out.println(iterator.currentItem());<br>      iterator.next();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 LinkedIterator，它的代码结构跟 ArrayIterator 完全相同。结合刚刚的例子，来总结一下迭代器的设计思路。总结下来就三句话：迭代器中需要定义 hasNext()、currentItem()、next() 三个最基本的方法。待遍历的容器对象通过依赖注入传递到迭代器类中。容器通过 iterator() 方法来创建迭代器。</p><h2 id="2、迭代器模式的优势"><a href="#2、迭代器模式的优势" class="headerlink" title="2、迭代器模式的优势"></a>2、迭代器模式的优势</h2><p>一般来讲，遍历集合数据有三种方法：for 循环、foreach 循环、iterator 迭代器。对于这三种方式，我拿 Java 语言来举例说明一下。具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    names.add(<span class="hljs-string">&quot;lql&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;dl&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;tql&quot;</span>);<br><br>    <span class="hljs-comment">// 第一种遍历方式：for循环</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; names.size(); i++) &#123;<br>      System.out.print(names.get(i) + <span class="hljs-string">&quot;,&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 第二种遍历方式：foreach循环</span><br>    <span class="hljs-keyword">for</span> (String name : names) &#123;<br>      System.out.print(name + <span class="hljs-string">&quot;,&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 第三种遍历方式：迭代器遍历</span><br>    Iterator&lt;String&gt; iterator = names.iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>      System.out.print(iterator.next() + <span class="hljs-string">&quot;,&quot;</span>); <span class="hljs-comment">// Java中的迭代器接口是第二种定义方式，next()既移动游标又返回数据</span><br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>实际上，foreach 循环只是一个语法糖而已，底层是基于迭代器来实现的。也就是说，上面代码中的第二种遍历方式（foreach 循环代码）的底层实现，就是第三种遍历方式（迭代器遍历代码）。这两种遍历方式可以看作同一种遍历方式，也就是迭代器遍历方式。</p><p>从上面的代码来看，for 循环遍历方式比起迭代器遍历方式，代码看起来更加简洁。那为什么还要用迭代器来遍历容器呢？为什么还要给容器设计对应的迭代器呢？原因有以下三个。</p><ol><li>首先，对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用 for 循环来遍历就足够了。但是，对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比如，树有前中后序、按层遍历，图有深度优先、广度优先遍历等等。如果由客户端代码来实现这些遍历算法，势必增加开发成本，而且容易写错。如果将这部分遍历的逻辑写到容器类中，也会导致容器类代码的复杂性。前面也多次提到，应对复杂性的方法就是拆分。我们可以将遍历操作拆分到迭代器类中。比如，针对图的遍历，我们就可以定义 DFSIterator、BFSIterator 两个迭代器类，让它们分别来实现深度优先遍历和广度优先遍历。</li><li>其次，将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这样，我们就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响。</li><li>最后，容器和迭代器都提供了抽象的接口，方便我们在开发的时候，基于接口而非具体的实现编程。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成从后往前遍历链表，客户端代码只需要将迭代器类从 LinkedIterator 切换为 ReversedLinkedIterator 即可，其他代码都不需要修改。除此之外，添加新的遍历算法，我们只需要扩展新的迭代器类，也更符合开闭原则。</li></ol><p>迭代器模式主要作用是解耦容器代码和遍历代码。</p><h2 id="3、在遍历的同时增删集合元素会发生什么？"><a href="#3、在遍历的同时增删集合元素会发生什么？" class="headerlink" title="3、在遍历的同时增删集合元素会发生什么？"></a>3、在遍历的同时增删集合元素会发生什么？</h2><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为<strong>结果不可预期行为</strong>或者<strong>未决行为</strong>，也就是说，运行结果到底是对还是错，要视情况而定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>  E <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayIterator</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor;<br>  <span class="hljs-keyword">private</span> ArrayList&lt;E&gt; arrayList;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayIterator</span><span class="hljs-params">(ArrayList&lt;E&gt; arrayList)</span> &#123;<br>    <span class="hljs-built_in">this</span>.cursor = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">this</span>.arrayList = arrayList;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> cursor &lt; arrayList.size();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    cursor++;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> E <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (cursor &gt;= arrayList.size()) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> arrayList.get(cursor);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>  Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIterator</span>(<span class="hljs-built_in">this</span>);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;c&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;d&quot;</span>);<br><br>    Iterator&lt;String&gt; iterator = names.iterator();<br>    iterator.next();<br>    names.remove(<span class="hljs-string">&quot;a&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>我们知道，ArrayList 底层对应的是数组这种数据结构，在执行完第 55 行代码的时候，数组中存储的是 a、b、c、d 四个元素，迭代器的游标 cursor 指向元素 a。当执行完第 58行代码的时候，游标指向元素 b，到这里都没有问题。</li><li>为了保持数组存储数据的连续性，数组的删除操作会涉及元素的搬移。当执行到第 59行代码的时候，我们从数组中将元素 a 删除掉，b、c、d 三个元素会依次往前搬移一位，这就会导致游标本来指向元素 b，现在变成了指向元素 c。原本在执行完第 58 行代码之后，我们还可以遍历到 b、c、d 三个元素，但在执行完第 59 行代码之后，我们只能遍历到 c、d 两个元素，b 遍历不到了。</li></ol><ol><li>不过，如果第 59 行代码删除的不是游标前面的元素（元素 a）以及游标所在位置的元素（元素 b），而是游标后面的元素（元素 c 和 d），这样就不会存在任何问题了，不会存在某个元素遍历不到的情况了。</li><li>所以，我们前面说，在遍历的过程中删除集合元素，结果是不可预期的，有时候没问题（删除元素 c 或 d），有时候就有问题（删除元素 a 或 b），这个要视情况而定（到底删除的是哪个位置的元素），就是这个意思。</li><li>在遍历的过程中删除集合元素，有可能会导致某个元素遍历不到，那在遍历的过程中添加集合元素，会发生什么情况呢？还是结合刚刚那个例子来讲解，我们将上面的代码稍微改造一下，把删除元素改为添加元素。具体的代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;c&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;d&quot;</span>);<br><br>    Iterator&lt;String&gt; iterator = names.iterator();<br>    iterator.next();<br>    names.add(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;x&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>在执行完第 10 行代码之后，数组中包含 a、b、c、d 四个元素，游标指向 b 这个元素，已经跳过了元素 a。在执行完第 11 行代码之后，我们将 x 插入到下标为 0 的位置，a、b、c、d 四个元素依次往后移动一位。这个时候，游标又重新指向了元素 a。元素 a 被游标重复指向两次，也就是说，元素 a 存在被重复遍历的情况。</li><li>跟删除情况类似，如果我们在游标的后面添加元素，就不会存在任何问题。所以，在遍历的同时添加集合元素也是一种不可预期行为。</li></ol><h2 id="4、如何应对遍历时改变集合导致的未决行为？"><a href="#4、如何应对遍历时改变集合导致的未决行为？" class="headerlink" title="4、如何应对遍历时改变集合导致的未决行为？"></a>4、如何应对遍历时改变集合导致的未决行为？</h2><ol><li>当通过迭代器来遍历集合的时候，增加、删除集合元素会导致不可预期的遍历结果。实际上，“不可预期”比直接出错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难 debug 的 bug 就是这么产生的。那如何才能避免出现这种不可预期的运行结果呢？</li><li>有两种比较干脆利索的解决方案：一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。</li><li>实际上，第一种解决方案比较难实现，我们要确定遍历开始和结束的时间点。遍历开始的时间节点我们很容易获得。我们可以把创建迭代器的时间点作为遍历开始的时间点。但是，遍历结束的时间点该如何来确定呢？</li><li>在实际的软件开发中，每次使用迭代器来遍历元素，并不一定非要把所有元素都遍历一遍。</li><li>我们可以在迭代器类中定义一个新的接口 finishIteration()，主动告知容器迭代器使用完了，你可以增删元素了，可行吗？但是，这就要求程序员在使用完迭代器之后要主动调用这个函数，也增加了开发成本，还很容易漏掉。</li></ol><ol><li>实际上，第二种解决方法更加合理。Java 语言就是采用的这种解决方案，增删元素之后，让遍历报错。</li><li>怎么确定在遍历时候，集合有没有增删元素呢？我们在 ArrayList 中定义一个成员变量 modCount，记录集合被修改的次数，集合每调用一次增加或删除元素的函数，就会给 modCount 加 1。当通过调用集合上的 iterator() 函数来创建迭代器的时候，我们把 modCount 值传递给迭代器的 expectedModCount 成员变量，之后每次调用迭代器上的 hasNext()、next()、currentItem() 函数，我们都会检查集合上的 modCount 是否等于 expectedModCount，也就是看，在创建完迭代器之后，modCount 是否改变过。</li><li>如果两个值不相同，那就说明集合存储的元素已经改变了，要么增加了元素，要么删除了元素，之前创建的迭代器已经不能正确运行了，再继续使用就会产生不可预期的结果，所以我们选择 fail-fast 解决方式，抛出运行时异常，结束掉程序，让程序员尽快修复这个因为不正确使用迭代器而产生的 bug。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor;<br>  <span class="hljs-keyword">private</span> ArrayList arrayList;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> expectedModCount;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayIterator</span><span class="hljs-params">(ArrayList arrayList)</span> &#123;<br>    <span class="hljs-built_in">this</span>.cursor = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">this</span>.arrayList = arrayList;<br>    <span class="hljs-built_in">this</span>.expectedModCount = arrayList.modCount;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>    checkForComodification();<br>    <span class="hljs-keyword">return</span> cursor &lt; arrayList.size();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    checkForComodification();<br>    cursor++;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span> &#123;<br>    checkForComodification();<br>    <span class="hljs-keyword">return</span> arrayList.get(cursor);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (arrayList.modCount != expectedModCount) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 代码示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;c&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;d&quot;</span>);<br><br>    Iterator&lt;String&gt; iterator = names.iterator();<br>    iterator.next();<br>    names.remove(<span class="hljs-string">&quot;a&quot;</span>);<br>    iterator.next(); <span class="hljs-comment">// 抛出ConcurrentModificationException异常</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、如何在遍历的同时安全的删除集合元素？"><a href="#5、如何在遍历的同时安全的删除集合元素？" class="headerlink" title="5、如何在遍历的同时安全的删除集合元素？"></a>5、如何在遍历的同时安全的删除集合元素？</h2><ol><li>像 Java 语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个 remove() 方法，能够在遍历集合的同时，安全地删除集合中的元素。不过，需要说明的是，它并没有提供添加元素的方法。毕竟迭代器的主要作用是遍历，添加元素放到迭代器里本身就不合适。</li><li>Java 迭代器中提供的 remove() 方法还是比较鸡肋的，作用有限。它只能删除游标指向的前一个元素，而且一个 next() 函数之后，只能跟着最多一个 remove() 操作，多次调用 remove() 操作会报错。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;c&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;d&quot;</span>);<br><br>    Iterator&lt;String&gt; iterator = names.iterator();<br>    iterator.next();<br>    iterator.remove();<br>    iterator.remove(); <span class="hljs-comment">// 报错，抛出IllegalStateException异常</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么通过迭代器就能安全的删除集合中的元素呢？来看下 remove() 函数是如何实现的，代码如下所示。在 Java 实现中，迭代器类是容器类的内部类，并且 next() 函数不仅将游标后移一位，还会返回当前的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; &#123;<br>  <span class="hljs-keyword">transient</span> Object[] elementData;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>  <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Itr</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-type">int</span> cursor; <span class="hljs-comment">// index of next element to return</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br><br>    Itr() &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> cursor != size;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>      checkForComodification();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>      <span class="hljs-keyword">if</span> (i &gt;= size) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>      Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>      <span class="hljs-keyword">if</span> (i &gt;= elementData.length) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>      cursor = i + <span class="hljs-number">1</span>;<br><br>      <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>      checkForComodification();<br><br>      <span class="hljs-keyword">try</span> &#123;<br>        ArrayList.<span class="hljs-built_in">this</span>.remove(lastRet);<br>        cursor = lastRet;<br>        lastRet = -<span class="hljs-number">1</span>;<br>        expectedModCount = modCount;<br>      &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码实现中，迭代器类新增了一个 lastRet 成员变量，用来记录游标指向的前一个元素。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的游标和 lastRet 值，来保证不会因为删除元素而导致某个元素遍历不到。如果通过容器来删除元素，并且希望更新迭代器中的游标值来保证遍历不出错，我们就要维护这个容器都创建了哪些迭代器，每个迭代器是否还在使用等信息，代码实现就变得比较复杂了。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>状态</tag>
      
      <tag>迭代器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07-行为型-策略-职责链</title>
    <link href="/2022/10/11/07-xing-wei-xing-ce-lue-zhi-ze-lian/"/>
    <url>/2022/10/11/07-xing-wei-xing-ce-lue-zhi-ze-lian/</url>
    
    <content type="html"><![CDATA[<h1 id="一、策略模式【常用】"><a href="#一、策略模式【常用】" class="headerlink" title="一、策略模式【常用】"></a>一、策略模式【常用】</h1><h2 id="1、Demo案例-鸭子问题"><a href="#1、Demo案例-鸭子问题" class="headerlink" title="1、Demo案例-鸭子问题"></a>1、Demo案例-鸭子问题</h2><p>编写鸭子项目，具体要求如下: </p><ol><li>有各种鸭子(比如 野鸭、北京鸭、水鸭等， 鸭子有各种行为，比如 叫、飞行等) </li><li>显示鸭子的信息</li></ol><h3 id="1、传统方式解决鸭子问题代码实现"><a href="#1、传统方式解决鸭子问题代码实现" class="headerlink" title="1、传统方式解决鸭子问题代码实现"></a>1、传统方式解决鸭子问题代码实现</h3><h4 id="1、Duck"><a href="#1、Duck" class="headerlink" title="1、Duck"></a>1、Duck</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Duck</span><span class="hljs-params">()</span> &#123;<br>   <br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span>;<span class="hljs-comment">//显示鸭子信息</span><br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;鸭子嘎嘎叫~~&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;鸭子会游泳~~&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;鸭子会飞翔~~~&quot;</span>);<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、PekingDuck"><a href="#2、PekingDuck" class="headerlink" title="2、PekingDuck"></a>2、PekingDuck</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PekingDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Duck</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot;~~北京鸭~~~&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-comment">//因为北京鸭不能飞翔，因此需要重写fly</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot;北京鸭不能飞翔&quot;</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、ToyDuck"><a href="#3、ToyDuck" class="headerlink" title="3、ToyDuck"></a>3、ToyDuck</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToyDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Duck</span>&#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot;玩具鸭&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-comment">//需要重写父类的所有方法</span><br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;玩具鸭不能叫~~&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;玩具鸭不会游泳~~&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;玩具鸭不会飞翔~~~&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、WildDuck"><a href="#4、WildDuck" class="headerlink" title="4、WildDuck"></a>4、WildDuck</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WildDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Duck</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; 这是野鸭 &quot;</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、问题"><a href="#5、问题" class="headerlink" title="5、问题"></a>5、问题</h4><p>那么问题来了</p><ol><li>其它鸭子，都继承了Duck类，所以fly让所有子类都会飞了，这是不正确的 </li><li>上面说的1 的问题，其实是继承带来的问题：对类的局部改动，尤其超类的局部改 动，会影响其他部分。会有溢出效应</li><li>为了改进1问题，我们可以通过覆盖fly 方法来解决 =&gt; 覆盖解决</li><li>问题又来了，如果我们有一个玩具鸭子ToyDuck, 这样就需要ToyDuck去覆盖Duck 的所有实现的方法</li></ol><p>解决思路 ==策略模式== </p><h3 id="2、策略模式解决鸭子问题代码实现"><a href="#2、策略模式解决鸭子问题代码实现" class="headerlink" title="2、策略模式解决鸭子问题代码实现"></a>2、策略模式解决鸭子问题代码实现</h3><p>思路分析：</p><p>分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体 设定行为对象。原则就是：分离变化部分，封装接口，基于接口编程各种功能。此模 式让行为的变化独立于算法的使用者</p><h4 id="1、FlyBehavior"><a href="#1、FlyBehavior" class="headerlink" title="1、FlyBehavior"></a>1、FlyBehavior</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FlyBehavior</span> &#123;<br>   <br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 子类具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、GoodFlyBehavior"><a href="#2、GoodFlyBehavior" class="headerlink" title="2、GoodFlyBehavior"></a>2、GoodFlyBehavior</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodFlyBehavior</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FlyBehavior</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; 飞翔技术高超 ~~~&quot;</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、BadFlyBehavior"><a href="#3、BadFlyBehavior" class="headerlink" title="3、BadFlyBehavior"></a>3、BadFlyBehavior</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BadFlyBehavior</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FlyBehavior</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; 飞翔技术一般 &quot;</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、NoFlyBehavior"><a href="#4、NoFlyBehavior" class="headerlink" title="4、NoFlyBehavior"></a>4、NoFlyBehavior</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoFlyBehavior</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FlyBehavior</span>&#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; 不会飞翔  &quot;</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、QuackBehavior"><a href="#5、QuackBehavior" class="headerlink" title="5、QuackBehavior"></a>5、QuackBehavior</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">QuackBehavior</span> &#123;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span>;<span class="hljs-comment">//子类实现</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、Duck"><a href="#6、Duck" class="headerlink" title="6、Duck"></a>6、Duck</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span> &#123;<br><br>   <span class="hljs-comment">//属性, 策略接口</span><br>   FlyBehavior flyBehavior;<br>   <span class="hljs-comment">//其它属性&lt;-&gt;策略接口</span><br>   QuackBehavior quackBehavior;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Duck</span><span class="hljs-params">()</span> &#123;<br>   <br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span>;<span class="hljs-comment">//显示鸭子信息</span><br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;鸭子嘎嘎叫~~&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;鸭子会游泳~~&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//改进</span><br>      <span class="hljs-keyword">if</span>(flyBehavior != <span class="hljs-literal">null</span>) &#123;<br>         flyBehavior.fly();<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFlyBehavior</span><span class="hljs-params">(FlyBehavior flyBehavior)</span> &#123;<br>      <span class="hljs-built_in">this</span>.flyBehavior = flyBehavior;<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setQuackBehavior</span><span class="hljs-params">(QuackBehavior quackBehavior)</span> &#123;<br>      <span class="hljs-built_in">this</span>.quackBehavior = quackBehavior;<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7、PekingDuck"><a href="#7、PekingDuck" class="headerlink" title="7、PekingDuck"></a>7、PekingDuck</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PekingDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Duck</span> &#123;<br><br>   <span class="hljs-comment">//假如北京鸭可以飞翔，但是飞翔技术一般</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">PekingDuck</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>      flyBehavior = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadFlyBehavior</span>();<br>      <br>   &#125;<br>   <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot;~~北京鸭~~~&quot;</span>);<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8、ToyDuck"><a href="#8、ToyDuck" class="headerlink" title="8、ToyDuck"></a>8、ToyDuck</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToyDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Duck</span>&#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ToyDuck</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>      flyBehavior = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoFlyBehavior</span>();<br>   &#125;<br>   <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot;玩具鸭&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-comment">//需要重写父类的所有方法</span><br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;玩具鸭不能叫~~&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;玩具鸭不会游泳~~&quot;</span>);<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9、WildDuck"><a href="#9、WildDuck" class="headerlink" title="9、WildDuck"></a>9、WildDuck</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WildDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Duck</span> &#123;<br>   <br>   <span class="hljs-comment">//构造器，传入FlyBehavor 的对象</span><br>   <span class="hljs-keyword">public</span>  <span class="hljs-title function_">WildDuck</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>      flyBehavior = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GoodFlyBehavior</span>();<br>   &#125;<br>   <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; 这是野鸭 &quot;</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10、Client"><a href="#10、Client" class="headerlink" title="10、Client"></a>10、Client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-type">WildDuck</span> <span class="hljs-variable">wildDuck</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WildDuck</span>();<br>      wildDuck.fly();<span class="hljs-comment">//</span><br>      <br>      <span class="hljs-type">ToyDuck</span> <span class="hljs-variable">toyDuck</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ToyDuck</span>();<br>      toyDuck.fly();<br>      <br>      <span class="hljs-type">PekingDuck</span> <span class="hljs-variable">pekingDuck</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PekingDuck</span>();<br>      pekingDuck.fly();<br>      <br>      <span class="hljs-comment">//动态改变某个对象的行为, 北京鸭 不能飞</span><br>      pekingDuck.setFlyBehavior(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NoFlyBehavior</span>());<br>      System.out.println(<span class="hljs-string">&quot;北京鸭的实际飞翔能力&quot;</span>);<br>      pekingDuck.fly();<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2022/10/11/07-xing-wei-xing-ce-lue-zhi-ze-lian/image-20221012163252938.png"></p><h2 id="2、策略模式工作原理"><a href="#2、策略模式工作原理" class="headerlink" title="2、策略模式工作原理"></a>2、策略模式工作原理</h2><ol><li>策略模式（Strategy Pattern）中，定义算法族，分别封装起来，让他们之间可以 互相替换，此模式让算法的变化独立于使用算法的客户 </li><li>这算法体现了几个设计原则，第一、把变化的代码从不变的代码中分离出来； 第二、针对接口编程而不是具体类（定义了策略接口）；第三、多用组合/聚合， 少用继承（客户通过组合方式使用策略）</li></ol><p>类图如下：</p><p><img src="/2022/10/11/07-xing-wei-xing-ce-lue-zhi-ze-lian/image-20221012162105114.png"></p><p>从上图可以看到，客户context 有成员变量strategy或者其他的策略接口 ,至于需要使用到哪个策略，我们可以在构造器中指定。</p><h2 id="3、策略模式在JDK-Arrays-应用"><a href="#3、策略模式在JDK-Arrays-应用" class="headerlink" title="3、策略模式在JDK-Arrays 应用"></a>3、策略模式在JDK-Arrays 应用</h2><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] data = &#123; <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span> &#125;;<br><br>        <span class="hljs-comment">// 说明</span><br>        <span class="hljs-comment">// 1. 实现了 Comparator 接口（策略接口） , 匿名类对象 new Comparator&lt;Integer&gt;()&#123;..&#125;</span><br>        <span class="hljs-comment">// 2. 对象 new Comparator&lt;Integer&gt;()&#123;..&#125; 就是实现了策略接口的对象</span><br>        <span class="hljs-comment">// 3. public int compare(Integer o1, Integer o2)&#123;&#125; 指定具体的处理方式</span><br>        Comparator&lt;Integer&gt; comparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>                <span class="hljs-keyword">if</span> (o1 &gt; o2) &#123;<br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;;<br>        &#125;;<br><br>        <span class="hljs-comment">// 说明</span><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">       * public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;</span><br><span class="hljs-comment">              if (c == null) &#123;</span><br><span class="hljs-comment">                  sort(a); //默认方法</span><br><span class="hljs-comment">              &#125; else &#123;</span><br><span class="hljs-comment">                  if (LegacyMergeSort.userRequested)</span><br><span class="hljs-comment">                      legacyMergeSort(a, c); //使用策略对象c</span><br><span class="hljs-comment">                  else</span><br><span class="hljs-comment">                     // 使用策略对象c</span><br><span class="hljs-comment">                      TimSort.sort(a, 0, a.length, c, null, 0, 0);</span><br><span class="hljs-comment">              &#125;</span><br><span class="hljs-comment">          &#125;</span><br><span class="hljs-comment">       */</span><br>        <span class="hljs-comment">// 方式1</span><br>        Arrays.sort(data, comparator);<br><br>        System.out.println(Arrays.toString(data)); <span class="hljs-comment">// ????????</span><br><br><br>        <span class="hljs-comment">//方式2- lambda 表达式</span><br>        Integer[] data2 = &#123; <span class="hljs-number">19</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">14</span>, <span class="hljs-number">13</span> &#125;;<br><br>        Arrays.sort(data2, (var1, var2) -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(var1.compareTo(var2) &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;);<br><br>        System.out.println(<span class="hljs-string">&quot;data2=&quot;</span> + Arrays.toString(data2));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>上述用两种方式实现策略模式，方式1是以Comparator为接口，实现compare方法来完成具体实现</li><li>方式2是直接在lambda处指定策略</li></ol><h2 id="4、注意事项"><a href="#4、注意事项" class="headerlink" title="4、注意事项"></a>4、注意事项</h2><ol><li>策略模式的关键是：分析项目中变化部分与不变部分 </li><li>策略模式的核心思想是：多用组合/聚合 少用继承；用行为类组合，而不是行为的 继承。更有弹性 </li><li>体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只 要添加一种策略（或者行为）即可，避免了使用多重转移语句（if..else if..else） </li><li>提供了可以替换继承关系的办法： 策略模式将算法封装在独立的Strategy类中使得 你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展 </li><li>需要注意的是：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大</li></ol><h1 id="二、职责链模式"><a href="#二、职责链模式" class="headerlink" title="二、职责链模式"></a>二、职责链模式</h1><p>模板模式、策略模式，职责链模式。这三种模式具有相同的作用：复用和扩展，在实际的项目开发中比较常用，特别是框架开发中，我们可以利用它们来提供框架的扩展点，能够让框架的使用者在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p><h2 id="1、Demo案例-学校采购"><a href="#1、Demo案例-学校采购" class="headerlink" title="1、Demo案例-学校采购"></a>1、Demo案例-学校采购</h2><blockquote><p>需求</p></blockquote><p>采购员采购教学器材</p><ol><li>如果金额小于等于 5000, 由教学主任审批 （0&lt;=x&lt;=5000）</li><li>如果金额小于等于 10000, 由院长审批 (5000&lt;x&lt;=10000)</li><li>如果金额小于等于 30000, 由副校长审批 (10000&lt;x&lt;=30000)</li><li>如果金额超过 30000 以上，有校长审批 ( 30000&lt;x)</li></ol><h3 id="1、传统方式解决方案"><a href="#1、传统方式解决方案" class="headerlink" title="1、传统方式解决方案"></a>1、传统方式解决方案</h3><ol><li>传统方式是：接收到一个采购请求后，根据采购金额来调用对应的 Approver (审批人)完成审批。</li><li>传统方式的问题分析 : 客户端这里会使用到 分支判断(比如 switch) 来对不同的采购请求处理， 这样就存在如下问题 (1) 如果各个级别的人员审批金额发生变化，在客户端的也需要变化 (2) 客户端必须明确的知道有多少个审批级别和访问</li><li>这样对一个采购请求进行处理 和 Approver (审批人) 就存在强耦合关系，不利于代码的扩展和维护</li></ol><h3 id="2、职责链模式方案代码"><a href="#2、职责链模式方案代码" class="headerlink" title="2、职责链模式方案代码"></a>2、职责链模式方案代码</h3><h4 id="1、Approver【抽象类】"><a href="#1、Approver【抽象类】" class="headerlink" title="1、Approver【抽象类】"></a>1、Approver【抽象类】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Approver</span> &#123;<br><br>  Approver approver; <span class="hljs-comment">// 下一个处理者</span><br>  String name; <span class="hljs-comment">// 名字</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Approver</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br><br>  <span class="hljs-comment">// 下一个处理者</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApprover</span><span class="hljs-params">(Approver approver)</span> &#123;<br>    <span class="hljs-built_in">this</span>.approver = approver;<br>  &#125;<br><br>  <span class="hljs-comment">// 处理审批请求的方法，得到一个请求, 处理是子类完成，因此该方法做成抽象</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest purchaseRequest)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、PurchaseRequest"><a href="#2、PurchaseRequest" class="headerlink" title="2、PurchaseRequest"></a>2、PurchaseRequest</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 请求类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseRequest</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 请求类型</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// 请求金额</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 构造器</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">PurchaseRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> type, <span class="hljs-type">float</span> price, <span class="hljs-type">int</span> id)</span> &#123;<br>    <span class="hljs-built_in">this</span>.type = type;<br>    <span class="hljs-built_in">this</span>.price = price;<br>    <span class="hljs-built_in">this</span>.id = id;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> type;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> price;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> id;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、DepartmentApprover"><a href="#3、DepartmentApprover" class="headerlink" title="3、DepartmentApprover"></a>3、DepartmentApprover</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 教学主任</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DepartmentApprover</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Approver</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DepartmentApprover</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>    <span class="hljs-built_in">super</span>(name);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest purchaseRequest)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-keyword">if</span> (purchaseRequest.getPrice() &lt;= <span class="hljs-number">5000</span>) &#123;<br>      System.out.println(<span class="hljs-string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="hljs-string">&quot; 被 &quot;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; 处理&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      approver.processRequest(purchaseRequest);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、CollegeApprover"><a href="#4、CollegeApprover" class="headerlink" title="4、CollegeApprover"></a>4、CollegeApprover</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 院长</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollegeApprover</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Approver</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">CollegeApprover</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>    <span class="hljs-built_in">super</span>(name);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest purchaseRequest)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-keyword">if</span> (purchaseRequest.getPrice() &gt; <span class="hljs-number">5000</span> &amp;&amp; purchaseRequest.getPrice() &lt;= <span class="hljs-number">10000</span>) &#123;<br>      System.out.println(<span class="hljs-string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="hljs-string">&quot; 被 &quot;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; 处理&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      approver.processRequest(purchaseRequest);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、ViceSchoolMasterApprover"><a href="#5、ViceSchoolMasterApprover" class="headerlink" title="5、ViceSchoolMasterApprover"></a>5、ViceSchoolMasterApprover</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 副校长</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViceSchoolMasterApprover</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Approver</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ViceSchoolMasterApprover</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>    <span class="hljs-built_in">super</span>(name);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest purchaseRequest)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-keyword">if</span> (purchaseRequest.getPrice() &gt; <span class="hljs-number">10000</span> &amp;&amp; purchaseRequest.getPrice() &lt;= <span class="hljs-number">30000</span>) &#123;<br>      System.out.println(<span class="hljs-string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="hljs-string">&quot; 被 &quot;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; 处理&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      approver.processRequest(purchaseRequest);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、SchoolMasterApprover"><a href="#6、SchoolMasterApprover" class="headerlink" title="6、SchoolMasterApprover"></a>6、SchoolMasterApprover</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 校长</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SchoolMasterApprover</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Approver</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">SchoolMasterApprover</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>    <span class="hljs-built_in">super</span>(name);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest purchaseRequest)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-keyword">if</span> (purchaseRequest.getPrice() &gt; <span class="hljs-number">30000</span>) &#123;<br>      System.out.println(<span class="hljs-string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="hljs-string">&quot; 被 &quot;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; 处理&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      approver.processRequest(purchaseRequest);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7、Client"><a href="#7、Client" class="headerlink" title="7、Client"></a>7、Client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-comment">// 创建一个请求</span><br>    <span class="hljs-type">PurchaseRequest</span> <span class="hljs-variable">purchaseRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PurchaseRequest</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4000</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 创建相关的审批人</span><br>    <span class="hljs-type">DepartmentApprover</span> <span class="hljs-variable">departmentApprover</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DepartmentApprover</span>(<span class="hljs-string">&quot;张主任&quot;</span>);<br>    <span class="hljs-type">CollegeApprover</span> <span class="hljs-variable">collegeApprover</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CollegeApprover</span>(<span class="hljs-string">&quot;李院长&quot;</span>);<br>    <span class="hljs-type">ViceSchoolMasterApprover</span> <span class="hljs-variable">viceSchoolMasterApprover</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViceSchoolMasterApprover</span>(<span class="hljs-string">&quot;王副校&quot;</span>);<br>    <span class="hljs-type">SchoolMasterApprover</span> <span class="hljs-variable">schoolMasterApprover</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SchoolMasterApprover</span>(<span class="hljs-string">&quot;B校长&quot;</span>);<br><br>    <span class="hljs-comment">// 需要将各个审批级别的下一个设置好 (处理人构成环形: )</span><br>    departmentApprover.setApprover(collegeApprover);<br>    collegeApprover.setApprover(viceSchoolMasterApprover);<br>    viceSchoolMasterApprover.setApprover(schoolMasterApprover);<br>    schoolMasterApprover.setApprover(departmentApprover);<br><br>    departmentApprover.processRequest(purchaseRequest);<br>    viceSchoolMasterApprover.processRequest(purchaseRequest);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、职责链模式工作原理"><a href="#2、职责链模式工作原理" class="headerlink" title="2、职责链模式工作原理"></a>2、职责链模式工作原理</h2><ol><li>职责链模式（Chain of Responsibility Pattern）,  又叫 责任链模式，为请求创建了一个接收者 对象的链(简单示意图)。这种模式对请求的 发送者和接收者进行解耦。 </li><li>职责链模式通常每个接收者都包含对另一个接 收者的引用。如果一个对象不能处理该请求， 那么它会把相同的请求传给下一个接收者，依 此类推。 </li></ol><p>职责链模式（Chain Of Responsibility）， 使多个对象都有机会处理请求，从而避 免请求的发送者和接收者之间的耦合关 系。将这个对象连成一条链，并沿着这 条链传递该请求，直到有一个对象处理 它为止。</p><p>通俗来讲，就是在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p><blockquote><p>职责链模式最常用来开发框架的过滤器和拦截器</p></blockquote><h2 id="3、Servlet-Filter"><a href="#3、Servlet-Filter" class="headerlink" title="3、Servlet Filter"></a>3、Servlet Filter</h2><p>Servlet Filter 是 Java Servlet 规范中定义的组件，翻译成中文就是过滤器，它可以实现对 HTTP 请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等。因为它是 Servlet 规范的一部分，所以，只要是支持 Servlet 的 Web 容器（比如，Tomcat、Jetty 等），都支持过滤器功能。</p><p><img src="/2022/10/11/07-xing-wei-xing-ce-lue-zhi-ze-lian/image-20221012180753720.png"></p><p>在实际项目中 Servlet Filter的使用 。一个简单的示例代码，如下所示。添加一个过滤器，只需要定义一个实现 javax.servlet.Filter 接口的过滤器类，并且将它配置在 web.xml 配置文件中。Web 容器启动的时候，会读取 web.xml 中的配置，创建过滤器对象。当有请求到来的时候，会先经过过滤器，然后才由 Servlet 来处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>    <span class="hljs-comment">// 在创建Filter时自动调用，</span><br>    <span class="hljs-comment">// 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）</span><br><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span><br>      <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    System.out.println(<span class="hljs-string">&quot;拦截客户端发送来的请求.&quot;</span>);<br>    chain.doFilter(request, response);<br>    System.out.println(<span class="hljs-string">&quot;拦截发送给客户端的响应.&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 在销毁Filter时自动调用</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">// 在web.xml配置文件中如下配置：<br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>logFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.zb.cd.LogFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>logFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>从刚刚的示例代码中可以发现，添加过滤器非常方便，不需要修改任何代码，定义一个实现 javax.servlet.Filter 的类，再改改配置就搞定了，完全符合开闭原则。那 Servlet Filter 是如何做到如此好的扩展性的呢？它利用的就是职责链模式。</li><li>职责链模式的实现包含处理器接口（IHandler）或抽象类（Handler），以及处理器链（HandlerChain）。对应到 Servlet Filter，javax.servlet.Filter 就是处理器接口，FilterChain 就是处理器链。接下来重点来看 FilterChain 是如何实现的。</li><li>不过，Servlet 只是一个规范，并不包含具体的实现，所以，Servlet 中的 FilterChain 只是一个接口定义。具体的实现类由遵从 Servlet 规范的 Web 容器来提供，比如，ApplicationFilterChain 类就是 Tomcat 提供的 FilterChain 的实现类，源码如下所示。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationFilterChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FilterChain</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前执行到了哪个filter</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n; <span class="hljs-comment">// filter的个数</span><br>  <span class="hljs-keyword">private</span> ApplicationFilterConfig[] filters;<br>  <span class="hljs-keyword">private</span> Servlet servlet;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> &#123;<br>    <span class="hljs-keyword">if</span> (pos &lt; n) &#123;<br>      <span class="hljs-type">ApplicationFilterConfig</span> <span class="hljs-variable">filterConfig</span> <span class="hljs-operator">=</span> filters[pos++];<br>      <span class="hljs-type">Filter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> filterConfig.getFilter();<br>      filter.doFilter(request, response, <span class="hljs-built_in">this</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// filter都处理完毕后，执行servlet</span><br>      servlet.service(request, response);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFilter</span><span class="hljs-params">(ApplicationFilterConfig filterConfig)</span> &#123;<br>    <span class="hljs-keyword">for</span> (ApplicationFilterConfig filter : filters) <span class="hljs-keyword">if</span> (filter == filterConfig) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (n == filters.length) &#123; <span class="hljs-comment">// 扩容</span><br>      ApplicationFilterConfig[] newFilters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationFilterConfig</span>[n + INCREMENT];<br>      System.arraycopy(filters, <span class="hljs-number">0</span>, newFilters, <span class="hljs-number">0</span>, n);<br>      filters = newFilters;<br>    &#125;<br>    filters[n++] = filterConfig;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ApplicationFilterChain 中的 doFilter() 函数的代码实现比较有技巧，实际上是一个递归调用。可以用每个 Filter（比如 LogFilter）的 doFilter() 的代码实现，直接替换 ApplicationFilterChain 的第 12 行代码，可以看出是递归调用。如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span>  &#123;<br>    <span class="hljs-keyword">if</span> (pos &lt; n) &#123;<br>        <span class="hljs-type">ApplicationFilterConfig</span> <span class="hljs-variable">filterConfig</span> <span class="hljs-operator">=</span> filters[pos++];<br>        <span class="hljs-type">Filter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> filterConfig.getFilter();<br>        <span class="hljs-comment">//filter.doFilter(request, response, this);</span><br>        <span class="hljs-comment">//把filter.doFilter的代码实现展开替换到这里</span><br>        System.out.println(<span class="hljs-string">&quot;拦截客户端发送来的请求.&quot;</span>);<br>        chain.doFilter(request, response); <span class="hljs-comment">// chain就是this</span><br>        System.out.println(<span class="hljs-string">&quot;拦截发送给客户端的响应.&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// filter都处理完毕后，执行servlet</span><br>        servlet.service(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样实现主要是为了在一个 doFilter() 方法中，支持双向拦截，既能拦截客户端发送来的请求，也能拦截发送给客户端的响应。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>策略</tag>
      
      <tag>职责链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C-《安河桥》</title>
    <link href="/2022/10/09/c-an-he-qiao/"/>
    <url>/2022/10/09/c-an-he-qiao/</url>
    
    <content type="html"><![CDATA[<center>《安河桥》</center><p>原调G | 选调G </p><p><img src="/2022/10/09/c-an-he-qiao/image-20221009170248015.png"></p><p><img src="/2022/10/09/c-an-he-qiao/image-20221009170322004.png"></p><p><img src="/2022/10/09/c-an-he-qiao/image-20221009170357665.png"></p><p><img src="/2022/10/09/c-an-he-qiao/image-20221009170417935.png"></p><p><img src="/2022/10/09/c-an-he-qiao/image-20221009170440876.png"></p><blockquote><p>曲谱来源大树音乐屋</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>吉他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>吉他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C-《成都》</title>
    <link href="/2022/10/09/c-cheng-du/"/>
    <url>/2022/10/09/c-cheng-du/</url>
    
    <content type="html"><![CDATA[<center>《成都》<center><p>原调D | 选调C | capo = 3   </p><p><img src="/2022/10/09/c-cheng-du/image-20221009165319957.png"></p><p><img src="/2022/10/09/c-cheng-du/image-20221009165406564.png"></p><blockquote><p>曲谱来源于趣谈音乐</p></blockquote></center></center>]]></content>
    
    
    <categories>
      
      <category>吉他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>吉他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>v2-数组</title>
    <link href="/2022/10/08/v2-shu-zu/"/>
    <url>/2022/10/08/v2-shu-zu/</url>
    
    <content type="html"><![CDATA[<h1 id="一、理论基础"><a href="#一、理论基础" class="headerlink" title="一、理论基础"></a>一、理论基础</h1><p>定义：<strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p><p>需要注意两点：</p><ul><li>数组下标从0开始</li><li>数组内存空间的地址是连续的</li></ul><p>针对二维数组在内存空间的地址是否连续，不同的编程语言的内存管理不同。在C++中二维数组是连续分布的。但在java中二维数组不是连续分布的。</p><p>java中的二维数组可能是如下排列方式：</p><p><img src="/2022/10/08/v2-shu-zu/image-20221008165054951.png"></p><p>基本方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;    <span class="hljs-comment">// 长度</span><br>nums[i];  <span class="hljs-comment">// 取值</span><br></code></pre></td></tr></table></figure><h1 id="二、经典题目（力扣"><a href="#二、经典题目（力扣" class="headerlink" title="二、经典题目（力扣"></a>二、经典题目（力扣</h1><h2 id="1、704-二分查找"><a href="#1、704-二分查找" class="headerlink" title="1、704.二分查找"></a>1、704.二分查找</h2><p>二分查找的前提条件是数组有序，同时还要保证数组无重复元素，因为若是有重复元素，二分查找返回来的索引可能不是唯一的。二分查找需要注意的地方是边界问题，一旦确定好边界，都要按这个规则来，一会是左闭右闭一会是左闭右开，当然绕！</p><p>所以若是看到数组有序且无重复，可以联想二分查找</p><p>二分查找两种写法：</p><ul><li>左闭右闭即[left, right]</li><li>左闭右开即[left, right)</li></ul><h3 id="1、左闭右闭"><a href="#1、左闭右闭" class="headerlink" title="1、左闭右闭"></a>1、左闭右闭</h3><p>定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right]</strong> 。</p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，同样if (nums[middle] &lt; target) left要赋值为 middle + 1。因为是左闭右闭，所以middle一定已经判断过了，直接跳过即可</li></ul><h3 id="2、左闭右开"><a href="#2、左闭右开" class="headerlink" title="2、左闭右开"></a>2、左闭右开</h3><p>定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right）</strong> 。</p><ul><li>while (left &lt;= right) 要使用 &lt; ，因为left == right是没有有意义的，所以不能使用&lt;=，要使用&lt;</li><li>if (nums[middle] &gt; target) right 要赋值为 middle， if (nums[middle] &lt; target) left要赋值为 middle + 1。</li></ul><p>二者选一个即可，我个人倾向于左闭右闭</p><h3 id="3、相关题目推荐"><a href="#3、相关题目推荐" class="headerlink" title="3、相关题目推荐"></a>3、相关题目推荐</h3><ul><li><a href="https://programmercarl.com/0035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html">35.搜索插入位置(opens new window)</a></li><li><a href="https://programmercarl.com/0034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.html">34.在排序数组中查找元素的第一个和最后一个位置(opens new window)</a></li><li>69.x 的平方根</li><li>367.有效的完全平方数</li></ul><h2 id="2、27-移除元素"><a href="#2、27-移除元素" class="headerlink" title="2、27.移除元素"></a>2、27.移除元素</h2><p>题目要求不能使用额外的数组空间，意味着只能原地操作</p><p>两种方法</p><h3 id="1、暴力法"><a href="#1、暴力法" class="headerlink" title="1、暴力法"></a>1、暴力法</h3><p>for循环两次，碰到目标值，就将后面的各个元素往前移动一位</p><p>当然时间复杂度比较高，O(n*2)</p><h3 id="2、双指针法"><a href="#2、双指针法" class="headerlink" title="2、双指针法"></a>2、双指针法</h3><p>维持两个指针，一个快一个慢，for循环一次，若不为目标值，将fast所在位置的元素赋值给slow所在位置的元素，同时往后进一位</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (fast = <span class="hljs-number">0</span>; fast &lt; nums.length; fast++) &#123;<br>   <span class="hljs-keyword">if</span>(nums[fast] != val) &#123;<br>       nums[slow++] = nums[fast];<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、相关题目推荐-1"><a href="#3、相关题目推荐-1" class="headerlink" title="3、相关题目推荐"></a>3、相关题目推荐</h3><ul><li>26.删除排序数组中的重复项</li><li>283.移动零</li><li>844.比较含退格的字符串</li><li>977.有序数组的平方</li></ul><h2 id="3、209-长度最小的子数组"><a href="#3、209-长度最小的子数组" class="headerlink" title="3、209.长度最小的子数组"></a>3、209.长度最小的子数组</h2><p>三种方法</p><h3 id="1、暴力法-1"><a href="#1、暴力法-1" class="headerlink" title="1、暴力法"></a>1、暴力法</h3><p>两层for循环，每遍历一个，就向后相加找到大于target的索引并记录，同时保留一个res来记录最小值</p><p>当然时间复杂度是比较高的，O(n*2)</p><h3 id="2、滑动窗口"><a href="#2、滑动窗口" class="headerlink" title="2、滑动窗口"></a>2、滑动窗口</h3><p>定义两个指针start和end，并记录sum，若是sum &lt; target，就将end往后++；若是sum &gt;= target，就将start++，并对sum和size做相应操作</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (end &lt; nums.length) &#123;<br>     sum += nums[end];<br>     <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>     min = Math.min(min, end - start + <span class="hljs-number">1</span>);<br>        sum -= nums[start];<br>        start++;<br>     &#125;<br>     end++;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、相关题目推荐-2"><a href="#3、相关题目推荐-2" class="headerlink" title="3、相关题目推荐"></a>3、相关题目推荐</h3><ul><li><a href="https://leetcode.cn/problems/fruit-into-baskets/">904.水果成篮(opens new window)</a></li><li>==<a href="https://leetcode.cn/problems/minimum-window-substring/">76.最小覆盖子串</a>==【经典】</li></ul><h3 id="4、滑动窗口总结"><a href="#4、滑动窗口总结" class="headerlink" title="4、滑动窗口总结"></a>4、滑动窗口总结</h3><p>滑动窗口有最小滑动窗口模板和最大滑动窗口模板，具体要求看题目要求</p><p>最小滑动窗口模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (j &lt; len)&#123;<br>    判断[i, j]是否满足条件<br>    <span class="hljs-keyword">while</span> (满足条件)&#123;<br>        不断更新结果(注意在<span class="hljs-keyword">while</span>内更新！)<br>        i += <span class="hljs-number">1</span> （最大程度的压缩i，使得滑窗尽可能的小）<br>    &#125;<br>    j += <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (end &lt; nums.length) &#123;<br>     sum += nums[end];<br>     <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>     min = Math.min(min, end - start + <span class="hljs-number">1</span>);<br>        sum -= nums[start];<br>        start++;<br>     &#125;<br>     end++;<br>&#125;<br></code></pre></td></tr></table></figure><p>代表题目为209</p><p>最大滑动窗口模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (j &lt; len)&#123;<br>    判断[i, j]是否满足条件<br>    <span class="hljs-keyword">while</span> (不满足条件)&#123;<br>        i += <span class="hljs-number">1</span> （最大程度的压缩i，使得滑窗尽可能的小）<br>    &#125;<br>    不断更新结果(注意在<span class="hljs-keyword">while</span>内更新！)<br>    j += <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (right &lt; fruits.length) &#123;<br>    map.put(fruits[right], map.getOrDefault(fruits[right], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (map.size() &gt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-comment">// count为水果最大数目，当map大小超过2时，滑窗需前移left;</span><br>       map.put(fruits[left], map.get(fruits[left]) - <span class="hljs-number">1</span>);<br>       <span class="hljs-keyword">if</span> (map.get(fruits[left]) == <span class="hljs-number">0</span>) &#123;<br>            map.remove(fruits[left]);<br>       &#125;<br>       left++;<br>    &#125;<br>    count = Math.max(count, right - left + <span class="hljs-number">1</span>);<br>    right++;<br>&#125;<br></code></pre></td></tr></table></figure><p>代表题目为904</p><h2 id="4、59-螺旋矩阵II"><a href="#4、59-螺旋矩阵II" class="headerlink" title="4、59.螺旋矩阵II"></a>4、59.螺旋矩阵II</h2><p>正确解决二分法是坚持循环不变量原则，这道题也是一样，要么一直左闭右开，要么一直左闭右闭。</p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由此可见，需要定义的变量有：</p><ol><li>返回的数组</li><li>循环次数，每一环为一次，定义这个的目的是控制边界，因为有的时候需要赋值n-1次，有的时候需要赋值n-2次，这个时候就要用到循环次数</li><li>定义起始变量start，每循环一圈就令start++</li><li>定义全局变量i, j</li></ol><h3 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h3><ul><li>54.螺旋矩阵</li><li>剑指Offer 29.顺时针打印矩阵</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书笔记</title>
    <link href="/2022/09/27/du-shu-bi-ji/"/>
    <url>/2022/09/27/du-shu-bi-ji/</url>
    
    <content type="html"><![CDATA[<h2 id="《也许你该找个人聊聊》"><a href="#《也许你该找个人聊聊》" class="headerlink" title="《也许你该找个人聊聊》"></a>《也许你该找个人聊聊》</h2><ul><li><p>梦境是忏悔的预演</p></li><li><p>我就像一个深藏不露的赌徒，每天西装革履地佯装去工作，早上出门前还要跟妻子和家人吻别，但一出家门便开车直奔赌场。</p></li><li><p>“所有洞察都只是心理治疗给你的安慰奖。”这是我最喜欢的一句格言，意思是：即使你拥有世上所有的真知灼见，但如果你在治疗之外的现实生活中不去作出改变，那再多的洞察，甚至治疗本身，都将毫无价值。</p></li><li><p>他是不是忘了取消订单，还是他在用食物和我沟通，凸显他的缺席？有时当来访者不出现的时候，他们会这样做来惩罚治疗师，并让治疗师知道“你让我失望了”。</p></li><li><p>让黑夜降临我们内心的，也会留下星星。     ——维克多·雨果</p></li><li><p>她讨厌自己像个小姑娘一样痴迷、愚蠢、无助、困惑，她讨厌自己为了见他而一件件地挑选衣服，脱下这件，换上那件，床上堆满的衣服就是她缺乏安全感又过度投入的证据。</p></li></ul><h2 id="《杀死一只知更鸟》"><a href="#《杀死一只知更鸟》" class="headerlink" title="《杀死一只知更鸟》"></a>《杀死一只知更鸟》</h2><ul><li>“总不能因为这过去一百年我们一败涂地，就放弃争取胜利吧”   –阿迪克斯</li><li>阿迪克斯怎么知道我在偷听？许多年过后我才恍然大悟：他其实想让我听见他说的每一个字。</li><li>“勇敢就是，在你还没开始的时候就知道自己注定会输，但依然义无反顾地去做，并且不管发生什么都坚持到底”  –阿迪克斯</li></ul><h2 id="《时间从来不悟，却回答了所有问题》"><a href="#《时间从来不悟，却回答了所有问题》" class="headerlink" title="《时间从来不悟，却回答了所有问题》"></a>《时间从来不悟，却回答了所有问题》</h2><ul><li>日记是当时的真实记录，不是我今天的回想：是代表我当时的感情，不是今天的感情。</li><li>戴着时间的枷锁跳舞反而更能增加一些意想不到的兴趣。</li></ul><h2 id="《堂吉诃德》"><a href="#《堂吉诃德》" class="headerlink" title="《堂吉诃德》"></a>《堂吉诃德》</h2><ul><li>他防再有这种危险，用几条铁皮衬着重新做了一个，自以为够结实了，不肯再检验，就当它是坚牢的、带面甲的头盔。<br>——实际上依旧脆弱无比，自欺欺人，典型的鸵鸟心态，我们有没有这种行为呢？</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06-行为型-观察者-模板</title>
    <link href="/2022/09/27/06-xing-wei-xing-guan-cha-zhe-mo-ban/"/>
    <url>/2022/09/27/06-xing-wei-xing-guan-cha-zhe-mo-ban/</url>
    
    <content type="html"><![CDATA[<h1 id="一、观察者模式【常用】"><a href="#一、观察者模式【常用】" class="headerlink" title="一、观察者模式【常用】"></a>一、观察者模式【常用】</h1><ol><li>23种设计模式分为创建型、结构型、行为型。创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合或组装”问题，那行为型设计模式主要解决的就是“类或对象之间的交互”问题。</li><li>行为型设计模式比较多，有 11 个，几乎占了 23 种经典设计模式的一半。它们分别是：观察者模式、模板模式、策略模式、职责链模式、状态模式、迭代器模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</li><li>根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</li></ol><h2 id="1、Demo案例-天气预报"><a href="#1、Demo案例-天气预报" class="headerlink" title="1、Demo案例-天气预报"></a>1、Demo案例-天气预报</h2><ol><li>气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去(比如发布到自己的网站或第三方)。</li><li>需要<strong>设计开放型</strong> <strong>API</strong>，便于<strong>其他第三方也能接入气象站获取数据</strong>。</li><li>提供温度、气压和湿度的接口</li><li>测量数据更新时，要能实时的通知给第三方</li></ol><h3 id="1、方案一"><a href="#1、方案一" class="headerlink" title="1、方案一"></a>1、方案一</h3><p><img src="/2022/09/27/06-xing-wei-xing-guan-cha-zhe-mo-ban/image-20220930151033041.png" alt="传统设计方案"></p><h4 id="1、WeatherData"><a href="#1、WeatherData" class="headerlink" title="1、WeatherData"></a>1、WeatherData</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 类是核心</span><br><span class="hljs-comment"> * 1. 包含最新的天气情况信息 </span><br><span class="hljs-comment"> * 2. 含有 CurrentConditions 对象</span><br><span class="hljs-comment"> * 3. 当数据有更新时，就主动的调用   CurrentConditions对象update方法(含 display), 这样他们（接入方）就看到最新的信息</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeatherData</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> temperatrue;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> pressure;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> humidity;<br>   <span class="hljs-keyword">private</span> CurrentConditions currentConditions;<br>   <span class="hljs-comment">//加入新的第三方</span><br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">WeatherData</span><span class="hljs-params">(CurrentConditions currentConditions)</span> &#123;<br>      <span class="hljs-built_in">this</span>.currentConditions = currentConditions;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getTemperature</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> temperatrue;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getPressure</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> pressure;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getHumidity</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> humidity;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dataChange</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//调用 接入方的 update</span><br>      currentConditions.update(getTemperature(), getPressure(), getHumidity());<br>   &#125;<br><br>   <span class="hljs-comment">//当数据有更新时，就调用 setData</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> pressure, <span class="hljs-type">float</span> humidity)</span> &#123;<br>      <span class="hljs-built_in">this</span>.temperatrue = temperature;<br>      <span class="hljs-built_in">this</span>.pressure = pressure;<br>      <span class="hljs-built_in">this</span>.humidity = humidity;<br>      <span class="hljs-comment">//调用dataChange， 将最新的信息 推送给 接入方 currentConditions</span><br>      dataChange();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、CurrentConditions"><a href="#2、CurrentConditions" class="headerlink" title="2、CurrentConditions"></a>2、CurrentConditions</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 显示当前天气情况（可以理解成是气象站自己的网站）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CurrentConditions</span> &#123;<br>   <span class="hljs-comment">// 温度，气压，湿度</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> temperature;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> pressure;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> humidity;<br><br>   <span class="hljs-comment">//更新 天气情况，是由 WeatherData 来调用，我使用推送模式</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> pressure, <span class="hljs-type">float</span> humidity)</span> &#123;<br>      <span class="hljs-built_in">this</span>.temperature = temperature;<br>      <span class="hljs-built_in">this</span>.pressure = pressure;<br>      <span class="hljs-built_in">this</span>.humidity = humidity;<br>      display();<br>   &#125;<br><br>   <span class="hljs-comment">//显示</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;***Today mTemperature: &quot;</span> + temperature + <span class="hljs-string">&quot;***&quot;</span>);<br>      System.out.println(<span class="hljs-string">&quot;***Today mPressure: &quot;</span> + pressure + <span class="hljs-string">&quot;***&quot;</span>);<br>      System.out.println(<span class="hljs-string">&quot;***Today mHumidity: &quot;</span> + humidity + <span class="hljs-string">&quot;***&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、Client"><a href="#3、Client" class="headerlink" title="3、Client"></a>3、Client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 创建接入方 currentConditions</span><br>    <span class="hljs-type">CurrentConditions</span> <span class="hljs-variable">currentConditions</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CurrentConditions</span>();<br>    <span class="hljs-comment">// 创建 WeatherData 并将 接入方 currentConditions 传递到 WeatherData中</span><br>    <span class="hljs-type">WeatherData</span> <span class="hljs-variable">weatherData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeatherData</span>(currentConditions);<br><br>    <span class="hljs-comment">// 更新天气情况</span><br>    weatherData.setData(<span class="hljs-number">30</span>, <span class="hljs-number">150</span>, <span class="hljs-number">40</span>);<br><br>    <span class="hljs-comment">// 天气情况变化</span><br>    System.out.println(<span class="hljs-string">&quot;============天气情况变化=============&quot;</span>);<br>    weatherData.setData(<span class="hljs-number">40</span>, <span class="hljs-number">160</span>, <span class="hljs-number">20</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、问题分析"><a href="#4、问题分析" class="headerlink" title="4、问题分析"></a>4、问题分析</h4><ol><li>其他第三方接入气象站获取数据的问题，无法在运行时动态的添加第三方 (新浪网站)</li><li>违反 ocp 原则，当加入第三方时，需要修改WeatherData代码，不利于维护。</li></ol><h3 id="2、观察者模式方案"><a href="#2、观察者模式方案" class="headerlink" title="2、观察者模式方案"></a>2、观察者模式方案</h3><h4 id="1、Subject【接口】"><a href="#1、Subject【接口】" class="headerlink" title="1、Subject【接口】"></a>1、Subject【接口】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口, 让WeatherData 来实现 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer o)</span>;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer o)</span>;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、Observer【接口】"><a href="#2、Observer【接口】" class="headerlink" title="2、Observer【接口】"></a>2、Observer【接口】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//观察者接口，有观察者来实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> pressure, <span class="hljs-type">float</span> humidity)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、WeatherData"><a href="#3、WeatherData" class="headerlink" title="3、WeatherData"></a>3、WeatherData</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeatherData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> temperatrue;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> pressure;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> humidity;<br>   <span class="hljs-comment">//观察者集合</span><br>   <span class="hljs-keyword">private</span> ArrayList&lt;Observer&gt; observers;<br>   <br>   <span class="hljs-comment">//加入新的第三方</span><br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">WeatherData</span><span class="hljs-params">()</span> &#123;<br>      observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Observer&gt;();<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getTemperature</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> temperatrue;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getPressure</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> pressure;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getHumidity</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> humidity;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dataChange</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//调用 接入方的 update</span><br>      <br>      notifyObservers();<br>   &#125;<br><br>   <span class="hljs-comment">//当数据有更新时，就调用 setData</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> pressure, <span class="hljs-type">float</span> humidity)</span> &#123;<br>      <span class="hljs-built_in">this</span>.temperatrue = temperature;<br>      <span class="hljs-built_in">this</span>.pressure = pressure;<br>      <span class="hljs-built_in">this</span>.humidity = humidity;<br>      <span class="hljs-comment">//调用dataChange， 将最新的信息 推送给 接入方 currentConditions</span><br>      dataChange();<br>   &#125;<br><br>   <span class="hljs-comment">//注册一个观察者</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer o)</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      observers.add(o);<br>   &#125;<br><br>   <span class="hljs-comment">//移除一个观察者</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer o)</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-keyword">if</span>(observers.contains(o)) &#123;<br>         observers.remove(o);<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-comment">//遍历所有的观察者，并通知</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; observers.size(); i++) &#123;<br>         observers.get(i).update(<span class="hljs-built_in">this</span>.temperatrue, <span class="hljs-built_in">this</span>.pressure, <span class="hljs-built_in">this</span>.humidity);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、CurrentConditions"><a href="#4、CurrentConditions" class="headerlink" title="4、CurrentConditions"></a>4、CurrentConditions</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CurrentConditions</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br><br>   <span class="hljs-comment">// 温度，气压，湿度</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> temperature;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> pressure;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> humidity;<br><br>   <span class="hljs-comment">// 更新 天气情况，是由 WeatherData 来调用，我使用推送模式</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> pressure, <span class="hljs-type">float</span> humidity)</span> &#123;<br>      <span class="hljs-built_in">this</span>.temperature = temperature;<br>      <span class="hljs-built_in">this</span>.pressure = pressure;<br>      <span class="hljs-built_in">this</span>.humidity = humidity;<br>      display();<br>   &#125;<br><br>   <span class="hljs-comment">// 显示</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;***Today mTemperature: &quot;</span> + temperature + <span class="hljs-string">&quot;***&quot;</span>);<br>      System.out.println(<span class="hljs-string">&quot;***Today mPressure: &quot;</span> + pressure + <span class="hljs-string">&quot;***&quot;</span>);<br>      System.out.println(<span class="hljs-string">&quot;***Today mHumidity: &quot;</span> + humidity + <span class="hljs-string">&quot;***&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、BaiduSite"><a href="#5、BaiduSite" class="headerlink" title="5、BaiduSite"></a>5、BaiduSite</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaiduSite</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br><br>  <span class="hljs-comment">// 温度，气压，湿度</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> temperature;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> pressure;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> humidity;<br><br>  <span class="hljs-comment">// 更新 天气情况，是由 WeatherData 来调用，我使用推送模式</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> pressure, <span class="hljs-type">float</span> humidity)</span> &#123;<br>    <span class="hljs-built_in">this</span>.temperature = temperature;<br>    <span class="hljs-built_in">this</span>.pressure = pressure;<br>    <span class="hljs-built_in">this</span>.humidity = humidity;<br>    display();<br>  &#125;<br><br>  <span class="hljs-comment">// 显示</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;===百度网站====&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;***百度网站 气温 : &quot;</span> + temperature + <span class="hljs-string">&quot;***&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;***百度网站 气压: &quot;</span> + pressure + <span class="hljs-string">&quot;***&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;***百度网站 湿度: &quot;</span> + humidity + <span class="hljs-string">&quot;***&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、Client"><a href="#6、Client" class="headerlink" title="6、Client"></a>6、Client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-comment">// 创建一个WeatherData</span><br>    <span class="hljs-type">WeatherData</span> <span class="hljs-variable">weatherData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeatherData</span>();<br><br>    <span class="hljs-comment">// 创建观察者</span><br>    <span class="hljs-type">CurrentConditions</span> <span class="hljs-variable">currentConditions</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CurrentConditions</span>();<br>    <span class="hljs-type">BaiduSite</span> <span class="hljs-variable">baiduSite</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaiduSite</span>();<br><br>    <span class="hljs-comment">// 注册到weatherData</span><br>    weatherData.registerObserver(currentConditions);<br>    weatherData.registerObserver(baiduSite);<br><br>    <span class="hljs-comment">// 测试</span><br>    System.out.println(<span class="hljs-string">&quot;通知各个注册的观察者, 看看信息&quot;</span>);<br>    weatherData.setData(<span class="hljs-number">10f</span>, <span class="hljs-number">100f</span>, <span class="hljs-number">30.3f</span>);<br><br>    weatherData.removeObserver(currentConditions);<br>    <span class="hljs-comment">// 测试</span><br>    System.out.println();<br>    System.out.println(<span class="hljs-string">&quot;通知各个注册的观察者, 看看信息&quot;</span>);<br>    weatherData.setData(<span class="hljs-number">10f</span>, <span class="hljs-number">100f</span>, <span class="hljs-number">30.3f</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、原理及应用场景剖析"><a href="#2、原理及应用场景剖析" class="headerlink" title="2、原理及应用场景剖析"></a>2、原理及应用场景剖析</h2><p><strong>观察者模式</strong>也被称为<strong>发布订阅模式</strong>。</p><p>在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p><ol><li>一般情况下，被依赖的对象叫作<strong>被观察者</strong>（Observable），依赖的对象叫作<strong>观察者</strong>（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。</li><li>实际上，观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式。现在先来看其中最经典的一种实现方式。这也是在讲到这种模式的时候，很多书籍或资料给出的最常见的实现方式。具体的代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer observer)</span>;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer observer)</span>;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">(Message message)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Message message)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>  <span class="hljs-keyword">private</span> List&lt;Observer&gt; observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Observer&gt;();<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer observer)</span> &#123;<br>    observers.add(observer);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer observer)</span> &#123;<br>    observers.remove(observer);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">(Message message)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Observer observer : observers) &#123;<br>      observer.update(message);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserverOne</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Message message)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span><br>    System.out.println(<span class="hljs-string">&quot;ConcreteObserverOne is notified.&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserverTwo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Message message)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span><br>    System.out.println(<span class="hljs-string">&quot;ConcreteObserverTwo is notified.&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ConcreteSubject</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteSubject</span>();<br>    subject.registerObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserverOne</span>());<br>    subject.registerObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserverTwo</span>());<br>    subject.notifyObservers(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原理和代码都比较容易理解，但是这种设计模式能解决什么问题？</p><p>假设我们在开发一个 P2P 投资理财系统，用户注册成功之后，我们会给用户发放投资体验金。代码实现大致是下面这个样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>  <span class="hljs-keyword">private</span> UserService userService; <span class="hljs-comment">// 依赖注入</span><br>  <span class="hljs-keyword">private</span> PromotionService promotionService; <span class="hljs-comment">// 依赖注入</span><br><br>  <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-comment">// 省略输入参数的校验代码</span><br>    <span class="hljs-comment">// 省略userService.register()异常的try-catch代码</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> userService.register(telephone, password);<br>    promotionService.issueNewUserExperienceCash(userId);<br>    <span class="hljs-keyword">return</span> userId;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>虽然注册接口做了两件事情，注册和发放体验金，违反单一职责原则，但是，如果没有扩展和修改的需求，现在的代码实现是可以接受的。如果非得用观察者模式，就需要引入更多的类和更加复杂的代码结构，反倒是一种过度设计。</li><li>相反，如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠券，并且还要给用户发送一封“欢迎注册成功”的站内信。这种情况下，我们就需要频繁地修改 register() 函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操作越来越多，那 register() 函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维护性。</li><li>这个时候，观察者模式就能派上用场了。利用观察者模式，对上面的代码进行了重构。重构之后的代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RegObserver</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRegSuccess</span><span class="hljs-params">(<span class="hljs-type">long</span> userId)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegPromotionObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RegObserver</span> &#123;<br>  <span class="hljs-keyword">private</span> PromotionService promotionService; <span class="hljs-comment">// 依赖注入</span><br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRegSuccess</span><span class="hljs-params">(<span class="hljs-type">long</span> userId)</span> &#123;<br>    promotionService.issueNewUserExperienceCash(userId);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegNotificationObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RegObserver</span> &#123;<br>  <span class="hljs-keyword">private</span> NotificationService notificationService;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRegSuccess</span><span class="hljs-params">(<span class="hljs-type">long</span> userId)</span> &#123;<br>    notificationService.sendInboxMessage(userId, <span class="hljs-string">&quot;Welcome...&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>  <span class="hljs-keyword">private</span> UserService userService; <span class="hljs-comment">// 依赖注入</span><br>  <span class="hljs-keyword">private</span> List&lt;RegObserver&gt; regObservers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  <span class="hljs-comment">// 一次性设置好，之后也不可能动态的修改</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRegObservers</span><span class="hljs-params">(List&lt;RegObserver&gt; observers)</span> &#123;<br>    regObservers.addAll(observers);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-comment">// 省略输入参数的校验代码</span><br>    <span class="hljs-comment">// 省略userService.register()异常的try-catch代码</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> userService.register(telephone, password);<br><br>    <span class="hljs-keyword">for</span> (RegObserver observer : regObservers) &#123;<br>      observer.handleRegSuccess(userId);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> userId;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>当我们需要添加新的观察者的时候，比如，用户注册成功之后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，UserController 类的 register() 函数完全不需要修改，只需要再添加一个实现了 RegObserver 接口的类，并且通过 setRegObservers() 函数将它注册到 UserController 类中即可。</li><li>前面我们已经学习了很多设计模式，不知道你有没有发现，实际上，<strong>设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。</strong>借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚松耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。</li></ol><h2 id="3、基于不同应用场景的不同实现方式"><a href="#3、基于不同应用场景的不同实现方式" class="headerlink" title="3、基于不同应用场景的不同实现方式"></a>3、基于不同应用场景的不同实现方式</h2><ol><li>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。</li><li>观察者模式有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</li><li>之前讲到的实现方式，从刚刚的分类方式上来看，它是一种同步阻塞的实现方式。观察者和被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码。对照上面讲到的用户注册的例子，register() 函数依次调用执行每个观察者的 handleRegSuccess() 函数，等到都执行完成之后，才会返回结果给客户端。</li><li>如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间尽可能短，那我们可以将同步阻塞的实现方式改为异步非阻塞的实现方式，以此来减少响应时间。具体来讲，当 userService.register() 函数执行完成之后，我们启动一个新的线程来执行观察者的 handleRegSuccess() 函数，这样 userController.register() 函数就不需要等到所有的 handleRegSuccess() 函数都执行完成之后才返回结果给客户端。userController.register() 函数从执行 3 个 SQL 语句才返回，减少到只需要执行 1 个 SQL 语句就返回，响应时间粗略来讲减少为原来的 1/3。</li><li>那如何实现一个异步非阻塞的观察者模式呢？简单一点的做法是，在每个 handleRegSuccess() 函数中，创建一个新的线程执行代码。不过，我们还有更加优雅的实现方式，那就是基于 EventBus 来实现。它可以复用在任何需要异步非阻塞观察者模式的应用场景中。</li><li>刚刚讲到的两个场景，不管是同步阻塞实现方式还是异步非阻塞实现方式，都是进程内的实现方式。如果用户注册成功之后，我们需要发送用户信息给大数据征信系统，而大数据征信系统是一个独立的系统，跟它之间的交互是跨不同进程的，那如何实现一个跨进程的观察者模式呢？</li><li>如果大数据征信系统提供了发送用户注册信息的 RPC 接口，我们仍然可以沿用之前的实现思路，在 handleRegSuccess() 函数中调用 RPC 接口来发送数据。但是，我们还有更加优雅、更加常用的一种实现方式，那就是基于消息队列（Message Queue，比如 ActiveMQ）来实现。</li><li>当然，这种实现方式也有弊端，那就是需要引入一个新的系统（消息队列），增加了维护成本。不过，它的好处也非常明显。在原来的实现方式中，观察者需要注册到被观察者中，被观察者需要依次遍历观察者来发送消息。而基于消息队列的实现方式，被观察者和观察者解耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。</li></ol><p>关于EventBus可以看这篇博客   </p><p><a href="https://imlql.cn/post/dd09051e.html">https://imlql.cn/post/dd09051e.html</a></p><h1 id="二、模板模式【常用】"><a href="#二、模板模式【常用】" class="headerlink" title="二、模板模式【常用】"></a>二、模板模式【常用】</h1><p>模板模式两大作用：复用和扩展</p><h2 id="1、Demo案例-豆浆制作"><a href="#1、Demo案例-豆浆制作" class="headerlink" title="1、Demo案例-豆浆制作"></a>1、Demo案例-豆浆制作</h2><p>编写制作豆浆的程序，说明如下: </p><ol><li>制作豆浆的流程 选材—&gt;添加配料—&gt;浸泡—&gt;放到豆浆机打碎 </li><li>通过添加不同的配料，可以制作出不同口味的豆浆 </li><li>选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的 </li><li>请使用 模板方法模式 完成 </li></ol><h3 id="1、SoyaMilk【抽象类】"><a href="#1、SoyaMilk【抽象类】" class="headerlink" title="1、SoyaMilk【抽象类】"></a>1、SoyaMilk【抽象类】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象类，表示豆浆</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SoyaMilk</span> &#123;<br><br>   <span class="hljs-comment">//模板方法, make , 模板方法可以做成final , 不让子类去覆盖.</span><br>   <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">make</span><span class="hljs-params">()</span> &#123;<br>      <br>      select(); <br>      <span class="hljs-keyword">if</span>(customerWantCondiments()) &#123;<br>         addCondiments();<br>      &#125;<br>      soak();<br>      beat();<br>      <br>   &#125;<br>   <br>   <span class="hljs-comment">//选材料</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;第一步：选择好的新鲜黄豆  &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-comment">//添加不同的配料， 抽象方法, 子类具体实现</span><br>   <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span>;<br>   <br>   <span class="hljs-comment">//浸泡</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">soak</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;第三步， 黄豆和配料开始浸泡， 需要3小时 &quot;</span>);<br>   &#125;<br>    <br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">beat</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;第四步：黄豆和配料放到豆浆机去打碎  &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-comment">//钩子方法，决定是否需要添加配料</span><br>   <span class="hljs-type">boolean</span> <span class="hljs-title function_">customerWantCondiments</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、RedBeanSoyaMilk"><a href="#2、RedBeanSoyaMilk" class="headerlink" title="2、RedBeanSoyaMilk"></a>2、RedBeanSoyaMilk</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedBeanSoyaMilk</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SoyaMilk</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    System.out.println(<span class="hljs-string">&quot; 加入上好的红豆 &quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、PureSoyaMilk"><a href="#3、PureSoyaMilk" class="headerlink" title="3、PureSoyaMilk"></a>3、PureSoyaMilk</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 纯豆浆</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PureSoyaMilk</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SoyaMilk</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-comment">// 空实现</span><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">customerWantCondiments</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、PeanutSoyaMilk"><a href="#4、PeanutSoyaMilk" class="headerlink" title="4、PeanutSoyaMilk"></a>4、PeanutSoyaMilk</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PeanutSoyaMilk</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SoyaMilk</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    System.out.println(<span class="hljs-string">&quot; 加入上好的花生 &quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、Client"><a href="#5、Client" class="headerlink" title="5、Client"></a>5、Client</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;----制作红豆豆浆----&quot;</span>);<br>    <span class="hljs-type">SoyaMilk</span> <span class="hljs-variable">redBeanSoyaMilk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedBeanSoyaMilk</span>();<br>    redBeanSoyaMilk.make();<br><br>    System.out.println(<span class="hljs-string">&quot;----制作花生豆浆----&quot;</span>);<br>    <span class="hljs-type">SoyaMilk</span> <span class="hljs-variable">peanutSoyaMilk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PeanutSoyaMilk</span>();<br>    peanutSoyaMilk.make();<br><br>    System.out.println(<span class="hljs-string">&quot;----制作纯豆浆----&quot;</span>);<br>    <span class="hljs-type">SoyaMilk</span> <span class="hljs-variable">pureSoyaMilk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PureSoyaMilk</span>();<br>    pureSoyaMilk.make();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、原理及应用"><a href="#2、原理及应用" class="headerlink" title="2、原理及应用"></a>2、原理及应用</h2><p>模板方法模式（Template Method Pattern），又叫模板模式(Template Pattern)，z 在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法 实现，但调用将以抽象类中定义的方式进行。</p><p>简单说，模板方法模式 定义一个操作中的算法的骨架，而将一些步骤延迟到子 类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定 步骤</p><p>原理很简单，代码实现就更加简单，我写了一个示例代码，如下所示。templateMethod() 函数定义为 final，是为了避免子类重写它。method1() 和 method2() 定义为 abstract，是为了强迫子类去实现。不过，这些都不是必须的，在实际的项目开发中，模板模式的代码实现比较灵活，待会儿讲到应用场景的时候，我们会有具体的体现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">templateMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...</span><br>        method1();<br>        <span class="hljs-comment">//...</span><br>        method2();<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">AbstractClass</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> ConcreteClass1();<br>demo.templateMethod();<br></code></pre></td></tr></table></figure><h2 id="3、模板作用一：复用"><a href="#3、模板作用一：复用" class="headerlink" title="3、模板作用一：复用"></a>3、模板作用一：复用</h2><p>模板模式把一个算法中不变的流程抽象到父类的模板方法 templateMethod() 中，将可变的部分 method1()、method2() 留给子类 ContreteClass1 和 ContreteClass2 来实现。所有的子类都可以复用父类中模板方法定义的流程代码。</p><h3 id="1、Java-InputStream"><a href="#1、Java-InputStream" class="headerlink" title="1、Java InputStream"></a>1、Java InputStream</h3><ol><li>Java IO 类库中，有很多类的设计用到了模板模式，比如 InputStream、OutputStream、Reader、Writer。拿 InputStream 来举例说明一下。</li><li> InputStream 部分相关代码如下。在代码中，read() 函数是一个模板方法，定义了读取数据的整个流程，并且暴露了一个可以由子类来定制的抽象方法。不过这个方法也被命名为了 read()，只是参数跟模板方法不同。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStream</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Closeable</span> &#123;<br>    <span class="hljs-comment">//...省略其他代码...</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (off &lt; <span class="hljs-number">0</span> || len &lt; <span class="hljs-number">0</span> || len &gt; b.length - off) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> read();<br>        <span class="hljs-keyword">if</span> (c == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        b[off] = (<span class="hljs-type">byte</span>) c;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (; i &lt; len; i++) &#123;<br>                c = read();<br>                <span class="hljs-keyword">if</span> (c == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                b[off + i] = (<span class="hljs-type">byte</span>) c;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ee) &#123;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteArrayInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-comment">//...省略其他代码...</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (pos &lt; count) ? (buf[pos++] &amp; <span class="hljs-number">0xff</span>) : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、Java-AbstractList"><a href="#2、Java-AbstractList" class="headerlink" title="2、Java AbstractList"></a>2、Java AbstractList</h3><p>在 Java AbstractList 类中，addAll() 函数可以看作模板方法，add() 是子类需要重写的方法，尽管没有声明为 abstract 的，但函数实现直接抛出了 UnsupportedOperationException 异常。前提是，如果子类不重写是不能使用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index,Collection&lt;?extends E&gt; c)</span>&#123;<br>        rangeCheckForAdd(index);<br>        <span class="hljs-type">boolean</span> modified=<span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span>(E e:c)&#123;<br>            add(index++,e);<br>            modified=<span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> modified;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index,E element)</span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、模板作用二：扩展"><a href="#4、模板作用二：扩展" class="headerlink" title="4、模板作用二：扩展"></a>4、模板作用二：扩展</h2><p>这里所说的扩展，并不是指代码的扩展性，而是指框架的扩展性，有点类似我们之前讲到的控制反转。基于这个作用，模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化框架的功能。我们通过 Junit TestCase、Java Servlet 两个例子来解释一下。</p><h3 id="1、Java-Servlet"><a href="#1、Java-Servlet" class="headerlink" title="1、Java Servlet"></a>1、Java Servlet</h3><p>对于 Java Web 项目开发来说，常用的开发框架是 SpringMVC。利用它，我们只需要关注业务代码的编写，底层的原理几乎不会涉及。但是，如果我们抛开这些高级框架来开发 Web 项目，必然会用到 Servlet。实际上，使用比较底层的 Servlet 来开发 Web 项目也不难。我们只需要定义一个继承 HttpServlet 的类，并且重写其中的 doGet() 或 doPost() 方法，来分别处理 get 和 post 请求。具体的代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">this</span>.doPost(req, resp);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp.getWriter().write(<span class="hljs-string">&quot;Hello World.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外，我们还需要在配置文件 web.xml 中做如下配置。Tomcat、Jetty 等 Servlet 容器在启动的时候，会自动加载这个配置文件中的 URL 和 Servlet 之间的映射关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.zb.cd.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当我们在浏览器中输入网址（比如，<a href="http://127.0.0.1:8080/hello">http://127.0.0.1:8080/hello</a> ）的时候，Servlet 容器会接收到相应的请求，并且根据 URL 和 Servlet 之间的映射关系，找到相应的 Servlet（HelloServlet），然后执行它的 service() 方法。service() 方法定义在父类 HttpServlet 中，它会调用 doGet() 或 doPost() 方法，然后输出数据（“Hello world”）到网页。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest req, ServletResponse res)</span><br>      <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    HttpServletRequest request;<br>    HttpServletResponse response;<br>    <span class="hljs-keyword">if</span> (!(req <span class="hljs-keyword">instanceof</span> HttpServletRequest &amp;&amp; res <span class="hljs-keyword">instanceof</span> HttpServletResponse)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletException</span>(<span class="hljs-string">&quot;non-HTTP request or response&quot;</span>);<br>    &#125;<br>    request = (HttpServletRequest) req;<br>    response = (HttpServletResponse) res;<br>    service(request, response);<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>      <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> req.getMethod();<br>    <span class="hljs-keyword">if</span> (method.equals(METHOD_GET)) &#123;<br>      <span class="hljs-type">long</span> <span class="hljs-variable">lastModified</span> <span class="hljs-operator">=</span> getLastModified(req);<br>      <span class="hljs-keyword">if</span> (lastModified == -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// servlet doesn&#x27;t support if-modified-since, no reason</span><br>        <span class="hljs-comment">// to go through further expensive logic</span><br>        doGet(req, resp);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ifModifiedSince</span> <span class="hljs-operator">=</span> req.getDateHeader(HEADER_IFMODSINCE);<br>        <span class="hljs-keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;<br>          <span class="hljs-comment">// If the servlet mod time is later, call doGet()</span><br>          <span class="hljs-comment">// Round down to the nearest second for a proper compare</span><br>          <span class="hljs-comment">// A ifModifiedSince of -1 will always be less</span><br>          maybeSetLastModified(resp, lastModified);<br>          doGet(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_HEAD)) &#123;<br>      <span class="hljs-type">long</span> <span class="hljs-variable">lastModified</span> <span class="hljs-operator">=</span> getLastModified(req);<br>      maybeSetLastModified(resp, lastModified);<br>      doHead(req, resp);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_POST)) &#123;<br>      doPost(req, resp);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_PUT)) &#123;<br>      doPut(req, resp);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_DELETE)) &#123;<br>      doDelete(req, resp);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;<br>      doOptions(req, resp);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_TRACE)) &#123;<br>      doTrace(req, resp);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">errMsg</span> <span class="hljs-operator">=</span> lStrings.getString(<span class="hljs-string">&quot;http.method_not_implemented&quot;</span>);<br>      Object[] errArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">1</span>];<br>      errArgs[<span class="hljs-number">0</span>] = method;<br>      errMsg = MessageFormat.format(errMsg, errArgs);<br>      resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>从上面的代码中我们可以看出，HttpServlet 的 service() 方法就是一个模板方法，它实现了整个 HTTP 请求的执行流程，doGet()、doPost() 是模板中可以由子类来定制的部分。实际上，这就相当于 Servlet 框架提供了一个扩展点（doGet()、doPost() 方法），让框架用户在不用修改 Servlet 框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。</p><h3 id="2、JUnit-TestCase"><a href="#2、JUnit-TestCase" class="headerlink" title="2、JUnit TestCase"></a>2、JUnit TestCase</h3><ol><li>跟 Java Servlet 类似，JUnit 框架也通过模板模式提供了一些功能扩展点（setUp()、tearDown() 等），让框架用户可以在这些扩展点上扩展功能。</li><li>在使用 JUnit 测试框架来编写单元测试的时候，我们编写的测试类都要继承框架提供的 TestCase 类。在 TestCase 类中，runBare() 函数是模板方法，它定义了执行测试用例的整体流程：先执行 setUp() 做些准备工作，然后执行 runTest() 运行真正的测试代码，最后执行 tearDown() 做扫尾工作。</li><li>TestCase 类的具体代码如下所示。尽管 setUp()、tearDown() 并不是抽象函数，还提供了默认的实现，不强制子类去重新实现，但这部分也是可以在子类中定制的，所以也符合模板模式的定义。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Assert</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Test</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runBare</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-type">Throwable</span> <span class="hljs-variable">exception</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    setUp();<br>    <span class="hljs-keyword">try</span> &#123;<br>      runTest();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable running) &#123;<br>      exception = running;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        tearDown();<br>      &#125; <span class="hljs-keyword">catch</span> (Throwable tearingDown) &#123;<br>        <span class="hljs-keyword">if</span> (exception == <span class="hljs-literal">null</span>) exception = tearingDown;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> exception;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * * Sets up the fixture, for example, open a network connection.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * &lt;p&gt;* This method is called before a test is executed.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;&#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * * Tears down the fixture, for example, close a network connection.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * &lt;p&gt;* This method is called after a test is executed.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【回调】</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>观察者</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05-结构型-门面-组合-享元</title>
    <link href="/2022/09/27/05-jie-gou-xing-men-mian-zu-he-xiang-yuan/"/>
    <url>/2022/09/27/05-jie-gou-xing-men-mian-zu-he-xiang-yuan/</url>
    
    <content type="html"><![CDATA[<h1 id="一、门面模式（外观模式）【不常用】"><a href="#一、门面模式（外观模式）【不常用】" class="headerlink" title="一、门面模式（外观模式）【不常用】"></a>一、门面模式（外观模式）【不常用】</h1><ol><li>门面模式原理和实现都特别简单，应用场景也比较明确，主要在接口设计方面使用。</li><li>为了保证接口的可复用性（或者叫通用性），我们需要将接口尽量设计得细粒度一点，职责单一一点。但是，如果接口的粒度过小，在接口的使用者开发一个业务功能时，就会导致需要调用 n 多细粒度的接口才能完成。调用者肯定会抱怨接口不好用。</li><li>相反，如果接口粒度设计得太大，一个接口返回 n 多数据，要做 n 多事情，就会导致接口不够通用、可复用性不好。接口不可复用，那针对不同的调用者的业务需求，我们就需要开发不同的接口来满足，这就会导致系统的接口无限膨胀。</li><li>那如何来解决接口的可复用性（通用性）和易用性之间的矛盾呢？</li></ol><h2 id="1、门面模式的原理与实现"><a href="#1、门面模式的原理与实现" class="headerlink" title="1、门面模式的原理与实现"></a>1、门面模式的原理与实现</h2><p>门面模式，也叫外观模式，英文全称是 Facade Design Pattern。在 GoF 的《设计模式》一书中，门面模式是这样定义的：</p><blockquote><p>Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use</p></blockquote><ol><li>翻译成中文就是：门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</li><li>假设有一个系统 A，提供了 a、b、c、d 四个接口。系统 B 完成某个业务功能，需要调用 A 系统的 a、b、d 接口。利用门面模式，我们提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用。</li><li>但是为什么不让系统 B 直接调用 a、b、d ，还要提供一个包裹 a、b、d 的接口 x 呢？</li><li>假设我们刚刚提到的系统 A 是一个后端服务器，系统 B 是 App 客户端。App 客户端通过后端服务器提供的接口来获取数据。我们知道，App 和服务器之间是通过移动网络通信的，网络通信耗时比较多，为了提高 App 的响应速度，我们要尽量减少 App 与服务器之间的网络通信次数。</li><li>假设，完成某个业务功能（比如显示某个页面信息）需要“依次”调用 a、b、d 三个接口，因自身业务的特点，不支持并发调用这三个接口。</li><li>如果我们现在发现 App 客户端的响应速度比较慢，排查之后发现，是因为过多的接口调用过多的网络通信。针对这种情况，我们就可以利用门面模式，让后端服务器提供一个包裹 a、b、d 三个接口调用的接口 x。App 客户端调用一次接口 x，来获取到所有想要的数据，将网络通信的次数从 3 次减少到 1 次，也就提高了 App 的响应速度。</li><li>这里举的例子只是应用门面模式的其中一个意图，也就是解决性能问题。实际上，不同的应用场景下，使用门面模式的意图也不同。</li></ol><h2 id="2、Demo案例-影院管理"><a href="#2、Demo案例-影院管理" class="headerlink" title="2、Demo案例-影院管理"></a>2、Demo案例-影院管理</h2><ul><li>组建一个家庭影院：</li><li>DVD 播放器、投影仪、自动屏幕、环绕立体声、爆米花机,要求完成使用家庭影院的功能，其过程为：</li><li>直接用遥控器：统筹各设备开关<ul><li>开爆米花机</li><li>放下屏幕</li><li>开投影仪</li><li>开音响</li><li>开 DVD，选 dvd</li><li>去拿爆米花</li><li>调暗灯光</li><li>播放</li><li>观影结束后，关闭各种设备</li></ul></li></ul><h3 id="1、传统方案"><a href="#1、传统方案" class="headerlink" title="1、传统方案"></a>1、传统方案</h3><p><img src="/2022/09/27/05-jie-gou-xing-men-mian-zu-he-xiang-yuan/image-20220927173050295.png"></p><ol><li>在 ClientTest 的 main 方法中，创建各个子系统的对象，并直接去调用子系统(对象)相关方法，会造成调用过程 混乱，没有清晰的过程 不利于在 ClientTest 中，去维护对子系统的操作</li><li>解决思路：<strong>定义一个高层接口</strong>，给<strong>子系统中的一组接口提供一个一致的界面</strong>(比如在高层接口提供四个方法 ready, play, pause, end )，用来访问子系统中的一群接口</li><li>也就是说 就是通过定义一个一致的接口(界面类)，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发 生调用，而无需关心这个子系统的内部细节 =&gt; <strong>外观模式</strong></li><li>外观类(Facade): 为调用端提供统一的调用接口, 外观类知道哪些子系统负责处理请求,从而将调用端的请求代 理给适当子系统对象</li><li>调用者(Client): 外观接口的调用者</li><li>子系统的集合：指模块或者子系统，处理 Facade 对象指派的任务，他是功能的实际提供者</li></ol><h3 id="2、门面模式代码"><a href="#2、门面模式代码" class="headerlink" title="2、门面模式代码"></a>2、门面模式代码</h3><h4 id="1、TheaterLight"><a href="#1、TheaterLight" class="headerlink" title="1、TheaterLight"></a>1、TheaterLight</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TheaterLight</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">TheaterLight</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TheaterLight</span>();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TheaterLight <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot; TheaterLight on &quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot; TheaterLight off &quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dim</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot; TheaterLight dim.. &quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bright</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot; TheaterLight bright.. &quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、Stereo"><a href="#2、Stereo" class="headerlink" title="2、Stereo"></a>2、Stereo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stereo</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Stereo</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stereo</span>();<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Stereo <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; Stereo on &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; Screen off &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">up</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; Screen up.. &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、Screen"><a href="#3、Screen" class="headerlink" title="3、Screen"></a>3、Screen</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Screen</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Screen</span>();<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Screen <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">up</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; Screen up &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; Screen down &quot;</span>);<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、Projector"><a href="#4、Projector" class="headerlink" title="4、Projector"></a>4、Projector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Projector</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Projector</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Projector</span>();<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Projector <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; Projector on &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; Projector ff &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">focus</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; Projector is Projector  &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、Popcorn"><a href="#5、Popcorn" class="headerlink" title="5、Popcorn"></a>5、Popcorn</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Popcorn</span> &#123;<br>   <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Popcorn</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Popcorn</span>();<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Popcorn <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; popcorn on &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; popcorn ff &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; popcorn is poping  &quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、DVDPlayer"><a href="#6、DVDPlayer" class="headerlink" title="6、DVDPlayer"></a>6、DVDPlayer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DVDPlayer</span> &#123;<br>   <br>   <span class="hljs-comment">//使用单例模式, 使用饿汉式</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">DVDPlayer</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DVDPlayer</span>();<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DVDPlayer <span class="hljs-title function_">getInstanc</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; dvd on &quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; dvd off &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; dvd is playing &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-comment">//....</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pause</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; dvd pause ..&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7、HomeTheaterFacade"><a href="#7、HomeTheaterFacade" class="headerlink" title="7、HomeTheaterFacade"></a>7、HomeTheaterFacade</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeTheaterFacade</span> &#123;<br><br>  <span class="hljs-comment">// 定义各个子系统对象</span><br>  <span class="hljs-keyword">private</span> TheaterLight theaterLight;<br>  <span class="hljs-keyword">private</span> Popcorn popcorn;<br>  <span class="hljs-keyword">private</span> Stereo stereo;<br>  <span class="hljs-keyword">private</span> Projector projector;<br>  <span class="hljs-keyword">private</span> Screen screen;<br>  <span class="hljs-keyword">private</span> DVDPlayer dVDPlayer;<br><br>  <span class="hljs-comment">// 构造器</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">HomeTheaterFacade</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-built_in">this</span>.theaterLight = TheaterLight.getInstance();<br>    <span class="hljs-built_in">this</span>.popcorn = Popcorn.getInstance();<br>    <span class="hljs-built_in">this</span>.stereo = Stereo.getInstance();<br>    <span class="hljs-built_in">this</span>.projector = Projector.getInstance();<br>    <span class="hljs-built_in">this</span>.screen = Screen.getInstance();<br>    <span class="hljs-built_in">this</span>.dVDPlayer = DVDPlayer.getInstanc();<br>  &#125;<br><br>  <span class="hljs-comment">// 操作分成 4 步</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ready</span><span class="hljs-params">()</span> &#123;<br>    popcorn.on();<br>    popcorn.pop();<br>    screen.down();<br>    projector.on();<br>    stereo.on();<br>    dVDPlayer.on();<br>    theaterLight.dim();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;<br>    dVDPlayer.play();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pause</span><span class="hljs-params">()</span> &#123;<br>    dVDPlayer.pause();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span> &#123;<br>    popcorn.off();<br>    theaterLight.bright();<br>    screen.up();<br>    projector.off();<br>    stereo.off();<br>    dVDPlayer.off();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、门面模式的应用场景举例"><a href="#3、门面模式的应用场景举例" class="headerlink" title="3、门面模式的应用场景举例"></a>3、门面模式的应用场景举例</h3><ol><li>在 GoF 给出的定义中提到，“门面模式让子系统更加易用”，实际上，它除了解决易用性问题之外，还能解决其他很多方面的问题。</li><li>除此之外，门面模式定义中的“子系统（subsystem）”也可以有多种理解方式。它既可以是一个完整的系统，也可以是更细粒度的类或者模块。</li></ol><h4 id="1、解决易用性问题"><a href="#1、解决易用性问题" class="headerlink" title="1、解决易用性问题"></a>1、解决易用性问题</h4><ol><li>门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如，Linux 系统调用函数就可以看作一种“门面”。它是 Linux 操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。再比如，Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。</li><li>设计原则、思想、模式很多都是相通的，是同一个道理不同角度的表述。实际上，从隐藏实现复杂性，提供更易用接口这个意图来看，门面模式有点类似之前讲到的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要的接口。除此之外，门面模式还有点类似之前提到封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节。</li></ol><h4 id="2、解决性能问题"><a href="#2、解决性能问题" class="headerlink" title="2、解决性能问题"></a>2、解决性能问题</h4><ol><li>关于利用门面模式解决性能问题这一点，刚刚已经讲过了。我们通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度。我们来讨论一下这样一个问题：从代码实现的角度来看，该如何组织门面接口和非门面接口？</li><li>如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普通接口来用即可。如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。</li></ol><h4 id="3、解决分布式事务问题"><a href="#3、解决分布式事务问题" class="headerlink" title="3、解决分布式事务问题"></a>3、解决分布式事务问题</h4><ol><li>关于利用门面模式来解决分布式事务问题，我们通过一个例子来解释一下。</li><li>在一个金融系统中，有两个业务领域模型，用户和钱包。这两个业务领域模型都对外暴露了一系列接口，比如用户的增删改查接口、钱包的增删改查接口。假设有这样一个业务场景：在用户注册的时候，我们不仅会创建用户（在数据库 User 表中），还会给用户创建一个钱包（在数据库的 Wallet 表中）。</li><li>对于这样一个简单的业务需求，我们可以通过依次调用用户的创建接口和钱包的创建接口来完成。但是，用户注册需要<code>支持事务</code>，也就是说，创建用户和钱包的两个操作，要么都成功，要么都失败，不能一个成功、一个失败。</li><li>要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。</li></ol><h1 id="二、组合模式【不常用】"><a href="#二、组合模式【不常用】" class="headerlink" title="二、组合模式【不常用】"></a>二、组合模式【不常用】</h1><ol><li>组合模式跟之前提到的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里的“组合模式”，主要是用来处理树形结构数据。这里的“数据”，可以简单理解为一组对象集合。</li><li>正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。</li></ol><h2 id="1、组合模式的原理与实现"><a href="#1、组合模式的原理与实现" class="headerlink" title="1、组合模式的原理与实现"></a>1、组合模式的原理与实现</h2><ol><li>在 GoF 的《设计模式》一书中，组合模式是这样定义的：</li></ol><blockquote><p>Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.</p></blockquote><ol><li><p>翻译成中文就是：将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。</p></li><li><p>假设有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：</p><ul><li><p>动态地添加、删除某个目录下的子目录或文件；</p></li><li><p>统计指定目录下的文件个数；</p></li><li><p>统计指定目录下的文件总大小。</p></li></ul></li><li><p>在下面的代码实现中，把文件和目录统一用 FileSystemNode 类来表示，并且通过 isFile 属性来区分。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br>  <span class="hljs-keyword">private</span> String path;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isFile;<br>  <span class="hljs-keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileSystemNode</span><span class="hljs-params">(String path, <span class="hljs-type">boolean</span> isFile)</span> &#123;<br>    <span class="hljs-built_in">this</span>.path = path;<br>    <span class="hljs-built_in">this</span>.isFile = isFile;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> path;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>    subNodes.add(fileOrDir);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> subNodes.size();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; i &lt; size; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (i &lt; size) &#123;<br>      subNodes.remove(i);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>想要补全其中的 countNumOfFiles() 和 countSizeOfFiles() 这两个函数，并不是件难事，实际上这就是树上的递归遍历算法。对于文件，我们直接返回文件的个数（返回 1）或大小。对于目录，我们遍历目录中每个子目录或者文件，递归计算它们的个数或大小，然后求和，就是这个目录下的文件个数和文件大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (isFile) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numOfFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>        numOfFiles += fileOrDir.countNumOfFiles();<br>    &#125;<br>    <span class="hljs-keyword">return</span> numOfFiles;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (isFile) &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path);<br>        <span class="hljs-keyword">if</span> (!file.exists()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> file.length();<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">sizeofFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>         sizeofFiles += fileOrDir.countSizeOfFiles();<br>    &#125;<br>    <span class="hljs-keyword">return</span> sizeofFiles;<br>&#125;<br></code></pre></td></tr></table></figure><p>单纯从功能实现角度来说，上面的代码没有问题，已经实现了我们想要的功能。但是，如果我们开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模（文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对业务的认知）的角度来说，最好对文件和目录进行区分设计，定义为 File 和 Directory 两个类。</p><p>按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br>  <span class="hljs-keyword">protected</span> String path;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileSystemNode</span><span class="hljs-params">(String path)</span> &#123;<br>    <span class="hljs-built_in">this</span>.path = path;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span>;<br>  <br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> path;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(String path)</span> &#123;<br>    <span class="hljs-built_in">super</span>(path);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span> &#123;<br>    java.io.<span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.File(path);<br>    <span class="hljs-keyword">if</span> (!file.exists()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> file.length();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Directory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br><br>  <span class="hljs-keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Directory</span><span class="hljs-params">(String path)</span> &#123;<br>    <span class="hljs-built_in">super</span>(path);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numOfFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>      numOfFiles += fileOrDir.countNumOfFiles();<br>    &#125;<br>    <span class="hljs-keyword">return</span> numOfFiles;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">sizeofFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>      sizeofFiles += fileOrDir.countSizeOfFiles();<br>    &#125;<br>    <span class="hljs-keyword">return</span> sizeofFiles;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>    subNodes.add(fileOrDir);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> subNodes.size();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; i &lt; size; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (i &lt; size) &#123;<br>      subNodes.remove(i);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>文件和目录类都设计好了，我们来看，如何用它们来表示一个文件系统中的目录树结构。具体的代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * /</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;/wz/</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;/wz/a.txt</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;/wz/b.txt</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;/wz/movies/</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;/wz/movies/c.avi</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;/xzg/</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;/xzg/docs/</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;/xzg/docs/d.txt</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">Directory</span> <span class="hljs-variable">fileSystemTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/&quot;</span>);<br>    <span class="hljs-type">Directory</span> <span class="hljs-variable">node_wz</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/wz/&quot;</span>);<br>    <span class="hljs-type">Directory</span> <span class="hljs-variable">node_xzg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/xzg/&quot;</span>);<br>    fileSystemTree.addSubNode(node_wz);<br>    fileSystemTree.addSubNode(node_xzg);<br><br>    <br>    <span class="hljs-type">File</span> <span class="hljs-variable">node_wz_a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/wz/a.txt&quot;</span>);<br>    <span class="hljs-type">File</span> <span class="hljs-variable">node_wz_b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/wz/b.txt&quot;</span>);<br>    <span class="hljs-type">Directory</span> <span class="hljs-variable">node_wz_movies</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/wz/movies/&quot;</span>);<br>    node_wz.addSubNode(node_wz_a);<br>    node_wz.addSubNode(node_wz_b);<br>    node_wz.addSubNode(node_wz_movies);<br><br>    <br>    <span class="hljs-type">File</span> <span class="hljs-variable">node_wz_movies_c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/wz/movies/c.avi&quot;</span>);<br>    node_wz_movies.addSubNode(node_wz_movies_c);<br><br>    <br>    <span class="hljs-type">Directory</span> <span class="hljs-variable">node_xzg_docs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/xzg/docs/&quot;</span>);<br>    node_xzg.addSubNode(node_xzg_docs);<br><br>    <br>    <span class="hljs-type">File</span> <span class="hljs-variable">node_xzg_docs_d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/xzg/docs/d.txt&quot;</span>);<br>    node_xzg_docs.addSubNode(node_xzg_docs_d);<br><br>    <br>    System.out.println(<span class="hljs-string">&quot;/ files num:&quot;</span> + fileSystemTree.countNumOfFiles());<br>    System.out.println(<span class="hljs-string">&quot;/wz/ files num:&quot;</span> + node_wz.countNumOfFiles());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>对照着这个例子，再重新看一下组合模式的定义：“将一组对象（文件和目录）组织成树形结构，以表示一种‘部分 - 整体’的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）。”</li><li>实际上，刚才的这种组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。</li></ol><h2 id="2、组合模式的应用场景举例"><a href="#2、组合模式的应用场景举例" class="headerlink" title="2、组合模式的应用场景举例"></a>2、组合模式的应用场景举例</h2><ol><li>刚刚提到了文件系统的例子，对于组合模式，再举一个例子。在实际的项目中，遇到类似的可以表示成树形结构的业务场景，只要“照葫芦画瓢”去设计就可以了。</li><li>假设我们在开发一个 OA 系统（办公自动化系统）。公司的组织结构包含部门和员工两种数据类型。其中，部门又可以包含子部门和员工。在数据库中的表结构如下所示：</li></ol><p><img src="/2022/09/27/05-jie-gou-xing-men-mian-zu-he-xiang-yuan/image-20220927191655637.png"></p><ol><li>我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。</li><li>部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这个应用场景可以使用组合模式来设计和实现。</li><li>这个例子的代码结构跟上一个例子的很相似，代码实现贴在下面。其中，HumanResource 是部门类（Department）和员工类（Employee）抽象出来的父类，为的是能统一薪资的处理逻辑。Demo 中的代码负责从数据库中读取数据并在内存中构建组织架构图。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">abstract</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">HumanResource</span>  &#123;<br>  <span class="hljs-keyword">protected</span>  <span class="hljs-type">long</span> id;<br>  <span class="hljs-keyword">protected</span>  <span class="hljs-type">double</span> salary;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-title function_">HumanResource</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span>  &#123;<br>    <span class="hljs-built_in">this</span>.id = id;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-type">long</span>  <span class="hljs-title function_">getId</span><span class="hljs-params">()</span>  &#123;<br>    <span class="hljs-keyword">return</span> id;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">abstract</span>  <span class="hljs-type">double</span>  <span class="hljs-title function_">calculateSalary</span><span class="hljs-params">()</span>;<br><br>&#125;<br><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Employee</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">HumanResource</span>  &#123;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-title function_">Employee</span><span class="hljs-params">(<span class="hljs-type">long</span> id, <span class="hljs-type">double</span> salary)</span>  &#123;<br>    <span class="hljs-built_in">super</span>(id);<br>    <span class="hljs-built_in">this</span>.salary = salary;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-type">double</span>  <span class="hljs-title function_">calculateSalary</span><span class="hljs-params">()</span>  &#123;<br>    <span class="hljs-keyword">return</span> salary;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Department</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">HumanResource</span>  &#123;<br>  <span class="hljs-keyword">private</span> List&lt;HumanResource&gt; subNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-title function_">Department</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span>  &#123;<br>    <span class="hljs-built_in">super</span>(id);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-type">double</span>  <span class="hljs-title function_">calculateSalary</span><span class="hljs-params">()</span>  &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">totalSalary</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (HumanResource hr : subNodes) &#123;<br>      totalSalary += hr.calculateSalary();<br>    &#125;<br>    <span class="hljs-built_in">this</span>.salary = totalSalary;<br>    <span class="hljs-keyword">return</span> totalSalary;<br><br>  &#125;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">addSubNode</span><span class="hljs-params">(HumanResource hr)</span>  &#123;<br>    subNodes.add(hr);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 构建组织架构的代码</span><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Demo</span>  &#123;<br>  <span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span>  <span class="hljs-type">long</span> ORGANIZATION\_ROOT\_ID = <span class="hljs-number">1001</span>;<br>  <span class="hljs-keyword">private</span> DepartmentRepo departmentRepo; <span class="hljs-comment">// 依赖注入</span><br>  <span class="hljs-keyword">private</span> EmployeeRepo employeeRepo; <span class="hljs-comment">// 依赖注入</span><br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">buildOrganization</span><span class="hljs-params">()</span>  &#123;<br>    <span class="hljs-type">Department</span> <span class="hljs-variable">rootDepartment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Department</span>(ORGANIZATION\_ROOT\_ID);<br>    buildOrganization(rootDepartment);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">buildOrganization</span><span class="hljs-params">(Department department)</span>  &#123;<br>    List&lt;Long&gt; subDepartmentIds = departmentRepo.getSubDepartmentIds(department.getId());<br>    <span class="hljs-keyword">for</span> (Long subDepartmentId : subDepartmentIds) &#123;<br>      <span class="hljs-type">Department</span> <span class="hljs-variable">subDepartment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Department</span>(subDepartmentId);<br>      department.addSubNode(subDepartment);<br>      buildOrganization(subDepartment);<br>    &#125;<br><br>    List&lt;Long&gt; employeeIds = employeeRepo.getDepartmentEmployeeIds(department.getId());<br>    <span class="hljs-keyword">for</span> (Long employeeId : employeeIds) &#123;<br>      <span class="hljs-type">double</span> <span class="hljs-variable">salary</span> <span class="hljs-operator">=</span> employeeRepo.getEmployeeSalary(employeeId);<br>      department.addSubNode(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(employeeId, salary));<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再拿组合模式的定义跟这个例子对照一下：“将一组对象（员工和部门）组织成树形结构，以表示一种‘部分 - 整体’的层次结构（部门与子部门的嵌套结构）。组合模式让客户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。”</p><h1 id="三、享元模式【不常用】"><a href="#三、享元模式【不常用】" class="headerlink" title="三、享元模式【不常用】"></a>三、享元模式【不常用】</h1><p>跟其他所有的设计模式类似，享元模式的原理和实现也非常简单。</p><h2 id="1、享元模式原理与实现"><a href="#1、享元模式原理与实现" class="headerlink" title="1、享元模式原理与实现"></a>1、享元模式原理与实现</h2><ol><li>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是<code>享元对象是不可变对象</code>。</li><li>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。</li><li>这里我稍微解释一下，定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象<code>不能暴露任何 set() 等修改内部状态的方法</code>。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。</li><li>接下来，通过一个简单的例子解释一下享元模式。</li><li>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。具体的代码如下所示。其中，ChessPiece 类表示棋子，ChessBoard 类表示一个棋局，里面保存了象棋中 30 个棋子的信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPiece</span> &#123; <span class="hljs-comment">// 棋子</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>  <span class="hljs-keyword">private</span> String text;<br>  <span class="hljs-keyword">private</span> Color color;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionX;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionY;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessPiece</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String text, Color color, <span class="hljs-type">int</span> positionX, <span class="hljs-type">int</span> positionY)</span> &#123;<br>    <span class="hljs-built_in">this</span>.id = id;<br>    <span class="hljs-built_in">this</span>.text = text;<br>    <span class="hljs-built_in">this</span>.color = color;<br>    <span class="hljs-built_in">this</span>.positionX = positionX;<br>    <span class="hljs-built_in">this</span>.positionY = positionX;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    RED,<br>    BLACK<br>  &#125;<br><br>  <span class="hljs-comment">// ...省略其他属性和getter/setter方法...</span><br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessBoard</span> &#123; <span class="hljs-comment">// 棋局</span><br>  <span class="hljs-keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessBoard</span><span class="hljs-params">()</span> &#123;<br>    init();<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    chessPieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPiece</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;車&quot;</span>, ChessPiece.Color.BLACK, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>    chessPieces.put(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPiece</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;馬&quot;</span>, ChessPiece.Color.BLACK, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>));<br>    <span class="hljs-comment">// ...省略摆放其他棋子的代码...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">int</span> chessPieceId, <span class="hljs-type">int</span> toPositionX, <span class="hljs-type">int</span> toPositionY)</span> &#123;<br>    <span class="hljs-comment">// ...省略...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个 ChessBoard 棋局对象。因为游戏大厅中有成千上万的房间（实际上，百万人同时在线的游戏大厅也有很多），那保存这么多棋局对象就会消耗大量的内存。有没有什么办法来节省内存呢？</p><p>这个时候，享元模式就可以派上用场了。像刚刚的实现方式，在内存中会有大量的相似对象。这些相似对象的 id、text、color 都是相同的，唯独 positionX、positionY 不同。实际上，我们可以将棋子的 id、text、color 属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 享元类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPieceUnit</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>  <span class="hljs-keyword">private</span> String text;<br>  <span class="hljs-keyword">private</span> Color color;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessPieceUnit</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String text, Color color)</span> &#123;<br>    <span class="hljs-built_in">this</span>.id = id;<br>    <span class="hljs-built_in">this</span>.text = text;<br>    <span class="hljs-built_in">this</span>.color = color;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    RED,<br>    BLACK<br>  &#125;<br>  <span class="hljs-comment">// ...省略其他属性和getter方法...</span><br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPieceUnitFactory</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Integer, ChessPieceUnit&gt; pieces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">static</span> &#123;<br>    pieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPieceUnit</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;車&quot;</span>, ChessPieceUnit.Color.BLACK));<br>    pieces.put(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPieceUnit</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;馬&quot;</span>, ChessPieceUnit.Color.BLACK));<br>    <span class="hljs-comment">// ...省略摆放其他棋子的代码...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ChessPieceUnit <span class="hljs-title function_">getChessPiece</span><span class="hljs-params">(<span class="hljs-type">int</span> chessPieceId)</span> &#123;<br>    <span class="hljs-keyword">return</span> pieces.get(chessPieceId);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPiece</span> &#123;<br>  <span class="hljs-keyword">private</span> ChessPieceUnit chessPieceUnit;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionX;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionY;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessPiece</span><span class="hljs-params">(ChessPieceUnit unit, <span class="hljs-type">int</span> positionX, <span class="hljs-type">int</span> positionY)</span> &#123;<br>    <span class="hljs-built_in">this</span>.chessPieceUnit = unit;<br>    <span class="hljs-built_in">this</span>.positionX = positionX;<br>    <span class="hljs-built_in">this</span>.positionY = positionY;<br>  &#125;<br><br>  <span class="hljs-comment">// 省略getter、setter方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessBoard</span> &#123;<br>  <span class="hljs-keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessBoard</span><span class="hljs-params">()</span> &#123;<br>    init();<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    chessPieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPiece</span>(ChessPieceUnitFactory.getChessPiece(<span class="hljs-number">1</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>    chessPieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPiece</span>(ChessPieceUnitFactory.getChessPiece(<span class="hljs-number">2</span>), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-comment">// ...省略摆放其他棋子的代码...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">int</span> chessPieceId, <span class="hljs-type">int</span> toPositionX, <span class="hljs-type">int</span> toPositionY)</span> &#123;<br>    <span class="hljs-comment">// ...省略...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>在上面的代码实现中，利用工厂类来缓存 ChessPieceUnit 信息（也就是 id、text、color）。通过工厂类获取到的 ChessPieceUnit 就是享元。所有的 ChessBoard 对象共享这 30 个 ChessPieceUnit 对象（因为象棋中只有 30 个棋子）。在使用享元模式之前，记录 1 万个棋局，我们要创建 30 万（30*1 万）个棋子的 ChessPieceUnit 对象。利用享元模式，我们只需要创建 30 个享元对象供所有棋局共享使用即可，大大节省了内存。</li><li>那享元模式的原理讲完了，我们来总结一下它的代码结构。实际上，它的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 来缓存已经创建过的享元对象，来达到复用的目的。</li></ol><h2 id="2、享元模式在文本编辑器中的应用"><a href="#2、享元模式在文本编辑器中的应用" class="headerlink" title="2、享元模式在文本编辑器中的应用"></a>2、享元模式在文本编辑器中的应用</h2><ol><li>弄懂了享元模式的原理和实现之后，再来看另外一个例子，如何利用享元模式来优化文本编辑器的内存占用？</li><li>可以把这里提到的文本编辑器想象成 Office 的 Word。不过，为了简化需求背景，我们假设这个文本编辑器只实现了文字编辑功能，不包含图片、表格等复杂的编辑功能。对于简化之后的文本编辑器，我们要在内存中表示一个文本文件，只需要记录文字和格式两部分信息就可以了，其中，格式又包括文字的字体、大小、颜色等信息。</li><li>尽管在实际的文档编写中，我们一般都是按照文本类型（标题、正文……）来设置文字的格式，标题是一种格式，正文是另一种格式等等。但是，从理论上讲，我们可以给文本文件中的每个文字都设置不同的格式。为了实现如此灵活的格式设置，并且代码实现又不过于太复杂，我们把每个文字都当作一个独立的对象来看待，并且在其中包含它的格式信息。具体的代码示例如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Character</span> &#123; <span class="hljs-comment">// 文字</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> c;<br><br>  <span class="hljs-keyword">private</span> Font font;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> colorRGB;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Character</span><span class="hljs-params">(<span class="hljs-type">char</span> c, Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>    <span class="hljs-built_in">this</span>.c = c;<br>    <span class="hljs-built_in">this</span>.font = font;<br>    <span class="hljs-built_in">this</span>.size = size;<br>    <span class="hljs-built_in">this</span>.colorRGB = colorRGB;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Editor</span> &#123;<br>  <span class="hljs-keyword">private</span> List&lt;Character&gt; chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendCharacter</span><span class="hljs-params">(<span class="hljs-type">char</span> c, Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>    <span class="hljs-type">Character</span> <span class="hljs-variable">character</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Character</span>(c, font, size, colorRGB);<br>    chars.add(character);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>在文本编辑器中，我们每敲一个文字，都会调用 Editor 类中的 appendCharacter() 方法，创建一个新的 Character 对象，保存到 chars 数组中。如果一个文本文件中，有上万、十几万、几十万的文字，那我们就要在内存中存储这么多 Character 对象。那有没有办法可以节省一点内存呢？</li><li>实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设置成不同的格式。所以，对于字体格式，我们可以将它设计成享元，让不同的文字共享使用。按照这个设计思路，我们对上面的代码进行重构。重构后的代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterStyle</span> &#123;<br>  <span class="hljs-keyword">private</span> Font font;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> colorRGB;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">CharacterStyle</span><span class="hljs-params">(Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>    <span class="hljs-built_in">this</span>.font = font;<br>    <span class="hljs-built_in">this</span>.size = size;<br>    <span class="hljs-built_in">this</span>.colorRGB = colorRGB;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-type">CharacterStyle</span> <span class="hljs-variable">otherStyle</span> <span class="hljs-operator">=</span> (CharacterStyle) o;<br>    <span class="hljs-keyword">return</span> font.equals(otherStyle.font)<br>        &amp;&amp; size == otherStyle.size<br>        &amp;&amp; colorRGB == otherStyle.colorRGB;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterStyleFactory</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;CharacterStyle&gt; styles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CharacterStyle <span class="hljs-title function_">getStyle</span><span class="hljs-params">(Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>    <span class="hljs-type">CharacterStyle</span> <span class="hljs-variable">newStyle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CharacterStyle</span>(font, size, colorRGB);<br>    <span class="hljs-keyword">for</span> (CharacterStyle style : styles) &#123;<br>      <span class="hljs-keyword">if</span> (style.equals(newStyle)) &#123;<br>        <span class="hljs-keyword">return</span> style;<br>      &#125;<br>    &#125;<br>    styles.add(newStyle);<br>    <span class="hljs-keyword">return</span> newStyle;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Character</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> c;<br>  <span class="hljs-keyword">private</span> CharacterStyle style;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Character</span><span class="hljs-params">(<span class="hljs-type">char</span> c, CharacterStyle style)</span> &#123;<br>    <span class="hljs-built_in">this</span>.c = c;<br>    <span class="hljs-built_in">this</span>.style = style;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Editor</span> &#123;<br>  <span class="hljs-keyword">private</span> List&lt;Character&gt; chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendCharacter</span><span class="hljs-params">(<span class="hljs-type">char</span> c, Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>    <span class="hljs-type">Character</span> <span class="hljs-variable">character</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Character</span>(c, CharacterStyleFactory.getStyle(font, size, colorRGB));<br>    chars.add(character);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、享元模式-vs-单例、缓存、对象池"><a href="#3、享元模式-vs-单例、缓存、对象池" class="headerlink" title="3、享元模式 vs 单例、缓存、对象池"></a>3、享元模式 vs 单例、缓存、对象池</h2><p>在上面的讲解中，多次提到“共享”“缓存”“复用”这些字眼，那它跟单例、缓存、对象池这些概念有什么区别呢？我们来简单对比一下。</p><h3 id="1、享元模式跟单例的区别"><a href="#1、享元模式跟单例的区别" class="headerlink" title="1、享元模式跟单例的区别"></a>1、享元模式跟单例的区别</h3><ol><li>在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例。</li><li>我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用享元模式是为了<code>对象复用，节省内存</code>，而应用多例模式是为了<code>限制对象的个数</code>。</li></ol><h3 id="2、享元模式跟缓存的区别"><a href="#2、享元模式跟缓存的区别" class="headerlink" title="2、享元模式跟缓存的区别"></a>2、享元模式跟缓存的区别</h3><p>在享元模式的实现中，我们通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际上是“存储”的意思，跟我们平时所说的“数据库缓存”“CPU 缓存”“MemCache 缓存”是两回事。我们平时所讲的缓存，主要是为了提高访问效率，而非复用。</p><h3 id="3、享元模式跟对象池的区别"><a href="#3、享元模式跟对象池的区别" class="headerlink" title="3、享元模式跟对象池的区别"></a>3、享元模式跟对象池的区别</h3><ol><li>对象池、连接池（比如数据库连接池）、线程池等也是为了复用，那它们跟享元模式有什么区别呢？</li><li>像 C++ 这样的编程语言，内存的管理是由程序员负责的。为了避免频繁地进行对象创建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉。</li><li>虽然对象池、连接池、线程池、享元模式都是为了复用，但是，如果我们再细致地抠一抠“复用”这个字眼的话，对象池、连接池、线程池等池化技术中的“复用”和享元模式中的“复用”实际上是不同的概念。</li><li>池化技术中的“复用”可以理解为“重复使用”，主要目的是<code>节省时间</code>（比如从数据库池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是<code>节省空间</code>。</li></ol><h2 id="4、享元模式在Java-Integer、String中的应用"><a href="#4、享元模式在Java-Integer、String中的应用" class="headerlink" title="4、享元模式在Java Integer、String中的应用"></a>4、享元模式在Java Integer、String中的应用</h2><p>先来看一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">56</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">56</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">129</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">129</span>;<br>System.out.println(i1 == i2);<br>System.out.println(i3 == i4);<br></code></pre></td></tr></table></figure><ol><li>Java提供了自动拆箱与装箱机制，比如int的装箱就是Integer.valueOf(); 拆箱就是i.intValue();</li><li>前 4 行赋值语句都会触发自动装箱操作，也就是会创建 Integer 对象并且赋值给 i1、i2、i3、i4 这四个变量。根据刚刚的讲解，i1、i2 尽管存储的数值相同，都是 56，但是指向不同的 Integer 对象，所以通过”==”来判定是否相同的时候，会返回 false。同理，i3 i4 判定语句也会返回 false。</li><li>不过，上面的分析还是不对，答案并非是两个 false，而是一个 true，一个 false。看到这里，可能会比较纳闷了。实际上，这正是因为 Integer 用到了享元模式来复用对象，才导致了这样的运行结果。当我们通过自动装箱，也就是调用 valueOf() 来创建 Integer 对象的时候，如果要创建的 Integer 对象的值在 -128 到 127 之间，会从 IntegerCache 类中直接返回，否则才调用 new 方法创建。看代码更加清晰一些，Integer 类的 valueOf() 函数的具体代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>       <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>           <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>   &#125;<br></code></pre></td></tr></table></figure><p>实际上，这里的 IntegerCache 相当于，我们上面讲的生成享元对象的工厂类，只不过名字不叫 xxxFactory 而已。我们来看它的具体代码实现。这个类是 Integer 的内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerCache</span> &#123;<br>       <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> -<span class="hljs-number">128</span>;<br>       <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> high;<br>       <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br><br>       <span class="hljs-keyword">static</span> &#123;<br>           <span class="hljs-comment">// high value may be configured by property</span><br>           <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">integerCacheHighPropValue</span> <span class="hljs-operator">=</span><br>               VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>           <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-keyword">try</span> &#123;<br>                   <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> parseInt(integerCacheHighPropValue);<br>                   i = Math.max(i, <span class="hljs-number">127</span>);<br>                   <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                   h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>               &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                   <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>               &#125;<br>           &#125;<br>           high = h;<br><br>           cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[(high - low) + <span class="hljs-number">1</span>];<br>           <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> low;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>               cache[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(j++);<br><br>           <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>           <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">private</span> <span class="hljs-title function_">IntegerCache</span><span class="hljs-params">()</span> &#123;&#125;<br>   &#125;<br></code></pre></td></tr></table></figure><ol><li>为什么 IntegerCache 只缓存 -128 到 127 之间的整型值呢？</li><li>在 IntegerCache 的代码实现中，当这个类被加载的时候，缓存的享元对象会被集中一次性创建好。毕竟整型值太多了，我们不可能在 IntegerCache 类中预先创建好所有的整型值，这样既占用太多内存，也使得加载 IntegerCache 类的时间过长。所以，我们只能选择缓存对于大部分应用来说最常用的整型值，也就是一个字节的大小（-128 到 127 之间的数据）。</li><li>实际上，JDK 也提供了方法来让我们可以自定义缓存的最大值，有下面两种方式。如果通过分析应用的 JVM 内存占用情况，发现 -128 到 255 之间的数据占用的内存比较多，就可以用如下方式，将缓存的最大值从 127 调整到 255。不过，这里注意一下，JDK 并没有提供设置最小值的方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一：</span><br>-Djava.lang.Integer.IntegerCache.high=<span class="hljs-number">255</span><br><span class="hljs-comment">//方法二：</span><br>-XX:AutoBoxCacheMax=<span class="hljs-number">255</span><br></code></pre></td></tr></table></figure><ol><li>现在，让我们再回到最开始的问题，因为 56 处于 -128 和 127 之间，i1 和 i2 会指向相同的享元对象，所以 i1 == i2 返回 true。而 129 大于 127，并不会被缓存，每次都会创建一个全新的对象，也就是说，i3 和 i4 指向不同的 Integer 对象，所以 i3 == i4 返回 false。</li></ol><p>实际上，除了 Integer 类型之外，其他包装器类型，比如 Long、Short、Byte 等，也都利用了享元模式来缓存 -128 到 127 之间的数据。</p><p>在我们平时的开发中，对于下面这样三种创建整型对象的方式，我们优先使用后两种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>);<br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>第一种创建方式并不会使用到 IntegerCache，而后面两种创建方法可以利用 IntegerCache 缓存，返回共享的对象，以达到节省内存的目的。举一个极端一点的例子，假设程序需要创建 1 万个 -128 到 127 之间的 Integer 对象。使用第一种创建方式，我们需要分配 1 万个 Integer 对象的内存空间；使用后两种创建方式，我们最多只需要分配 256 个 Integer 对象的内存空间。</p><h2 id="5、享元模式在-Java-String-中的应用"><a href="#5、享元模式在-Java-String-中的应用" class="headerlink" title="5、享元模式在 Java String 中的应用"></a>5、享元模式在 Java String 中的应用</h2><p>刚刚提到享元模式在 Java Integer 类中的应用，现在，我们再来看下，享元模式在 Java String 类中的应用。同样，我们还是先来看一段代码，你觉得这段代码输出的结果是什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;哈哈哈&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;哈哈哈&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span>  <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;哈哈哈&quot;</span>);<br><br>System.out.println(s1 == s2);<br>System.out.println(s1 == s3);<br></code></pre></td></tr></table></figure><ol><li>上面代码的运行结果是：一个 true，一个 false。跟 Integer 类的设计思路相似，String 类利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM 会专门开辟一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”。</li><li>不过，String 类的享元模式的设计，跟 Integer 类稍微有些不同。Integer 类中要共享的对象，是在类加载的时候，就集中一次性创建好的。但是，对于字符串来说，我们没法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>结构型</tag>
      
      <tag>门面</tag>
      
      <tag>组合</tag>
      
      <tag>享元</tag>
      
      <tag>外观</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04-结构型-装饰器-适配器</title>
    <link href="/2022/09/23/04-jie-gou-xing-zhuang-shi-qi-gua-pei-qi/"/>
    <url>/2022/09/23/04-jie-gou-xing-zhuang-shi-qi-gua-pei-qi/</url>
    
    <content type="html"><![CDATA[<h1 id="一、装饰器模式"><a href="#一、装饰器模式" class="headerlink" title="一、装饰器模式"></a>一、装饰器模式</h1><p>通过一个demo来理解装饰器模式。</p><h2 id="1、Demo案例-咖啡订单项目"><a href="#1、Demo案例-咖啡订单项目" class="headerlink" title="1、Demo案例-咖啡订单项目"></a>1、Demo案例-咖啡订单项目</h2><h3 id="1、星巴克订单需求"><a href="#1、星巴克订单需求" class="headerlink" title="1、星巴克订单需求"></a>1、星巴克订单需求</h3><ol><li>咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)</li><li>调料：Milk、Soy(豆浆)、Chocolate</li><li>要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便</li><li>使用 OO 的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡+调料组合。</li></ol><h3 id="2、方案一"><a href="#2、方案一" class="headerlink" title="2、方案一"></a>2、方案一</h3><p><img src="/2022/09/23/04-jie-gou-xing-zhuang-shi-qi-gua-pei-qi/image-20220926165413830.png" alt="方案1"></p><ol><li>Drink 是一个抽象类，表示饮料</li><li>des就是对咖啡的描述, 比如咖啡的名字 </li><li>cost() 方法就是计算费用，Drink 类中做成一个抽象方法</li><li>Decaf 就是单品咖啡， 继承Drink, 并实现cost</li><li>Espress &amp;&amp; Milk 就是单品咖啡+调料， 这个组合很多</li><li><code>问题</code>：这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料， 类的数量就会倍增，就会出现类爆炸</li></ol><h3 id="3、方案二"><a href="#3、方案二" class="headerlink" title="3、方案二"></a>3、方案二</h3><p>前面分析到方案 1 因为咖啡单品+调料组合会造成类的倍增，因此可以做改进，将调料内置到 Drink 类，这样就不会造成类数量过多。从而提高项目的维护性(如图)</p><p><img src="/2022/09/23/04-jie-gou-xing-zhuang-shi-qi-gua-pei-qi/image-20220926165735491.png" alt="方案2"></p><ol><li>方案 2 可以控制类的数量，不至于造成很多的类</li><li>在增加或者删除调料种类时，代码的维护量很大</li><li>考虑到用户可以添加多份调料时，可以将 hasMilk 返回一个对应 int</li><li>考虑使用 <strong>装饰者</strong> 模式</li></ol><blockquote><p>注意：装饰器模式是对功能的增强，而不是附加新的功能。代理模式才是附加新的功能。</p></blockquote><h3 id="4、装饰器模式代码"><a href="#4、装饰器模式代码" class="headerlink" title="4、装饰器模式代码"></a>4、装饰器模式代码</h3><p><img src="/2022/09/23/04-jie-gou-xing-zhuang-shi-qi-gua-pei-qi/image-20220926170746201.png" alt="装饰器模式"></p><h4 id="1、Drink【抽象类-主体Component】"><a href="#1、Drink【抽象类-主体Component】" class="headerlink" title="1、Drink【抽象类-主体Component】"></a>1、Drink【抽象类-主体Component】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Drink</span> &#123;<br><br>   <span class="hljs-keyword">public</span> String des; <span class="hljs-comment">// 描述</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0f</span>;<br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDes</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> des;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDes</span><span class="hljs-params">(String des)</span> &#123;<br>      <span class="hljs-built_in">this</span>.des = des;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> price;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrice</span><span class="hljs-params">(<span class="hljs-type">float</span> price)</span> &#123;<br>      <span class="hljs-built_in">this</span>.price = price;<br>   &#125;<br>   <br>   <span class="hljs-comment">//计算费用的抽象方法</span><br>   <span class="hljs-comment">//子类来实现</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">float</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span>;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、Decorator"><a href="#2、Decorator" class="headerlink" title="2、Decorator"></a>2、Decorator</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Drink</span> &#123;<br>   <span class="hljs-keyword">private</span> Drink obj;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Decorator</span><span class="hljs-params">(Drink obj)</span> &#123; <span class="hljs-comment">//组合</span><br>      <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>      <span class="hljs-built_in">this</span>.obj = obj;<br>   &#125;<br>   <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-comment">// getPrice 自己价格</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getPrice() + obj.cost();<br>   &#125;<br>   <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDes</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-comment">// obj.getDes() 输出被装饰者的信息</span><br>      <span class="hljs-keyword">return</span> des + <span class="hljs-string">&quot; &quot;</span> + getPrice() + <span class="hljs-string">&quot; &amp;&amp; &quot;</span> + obj.getDes();<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、Coffee"><a href="#3、Coffee" class="headerlink" title="3、Coffee"></a>3、Coffee</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Drink</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getPrice();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>单品类</p></blockquote><h4 id="4、ShortBlack"><a href="#4、ShortBlack" class="headerlink" title="4、ShortBlack"></a>4、ShortBlack</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShortBlack</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Coffee</span>&#123;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ShortBlack</span><span class="hljs-params">()</span> &#123;<br>      setDes(<span class="hljs-string">&quot; shortblack &quot;</span>);<br>      setPrice(<span class="hljs-number">4.0f</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、LongBlack"><a href="#5、LongBlack" class="headerlink" title="5、LongBlack"></a>5、LongBlack</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongBlack</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Coffee</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">LongBlack</span><span class="hljs-params">()</span> &#123;<br>      setDes(<span class="hljs-string">&quot; longblack &quot;</span>);<br>      setPrice(<span class="hljs-number">5.0f</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、DeCaf"><a href="#6、DeCaf" class="headerlink" title="6、DeCaf"></a>6、DeCaf</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeCaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Coffee</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">DeCaf</span><span class="hljs-params">()</span> &#123;<br>      setDes(<span class="hljs-string">&quot; 无因咖啡 &quot;</span>);<br>      setPrice(<span class="hljs-number">1.0f</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7、Espresso"><a href="#7、Espresso" class="headerlink" title="7、Espresso"></a>7、Espresso</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Espresso</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Coffee</span> &#123;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Espresso</span><span class="hljs-params">()</span> &#123;<br>      setDes(<span class="hljs-string">&quot; 意大利咖啡 &quot;</span>);<br>      setPrice(<span class="hljs-number">6.0f</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>调味品类</p></blockquote><h4 id="8、Chocolate"><a href="#8、Chocolate" class="headerlink" title="8、Chocolate"></a>8、Chocolate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//具体的Decorator， 这里就是调味品</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Chocolate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chocolate</span><span class="hljs-params">(Drink obj)</span> &#123;<br>      <span class="hljs-built_in">super</span>(obj);<br>      setDes(<span class="hljs-string">&quot; 巧克力 &quot;</span>);<br>      setPrice(<span class="hljs-number">3.0f</span>); <span class="hljs-comment">// 调味品 的价格</span><br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9、Milk"><a href="#9、Milk" class="headerlink" title="9、Milk"></a>9、Milk</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Milk</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Milk</span><span class="hljs-params">(Drink obj)</span> &#123;<br>      <span class="hljs-built_in">super</span>(obj);<br>      <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>      setDes(<span class="hljs-string">&quot; 牛奶 &quot;</span>);<br>      setPrice(<span class="hljs-number">2.0f</span>); <br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10、Soy"><a href="#10、Soy" class="headerlink" title="10、Soy"></a>10、Soy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Soy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span>&#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Soy</span><span class="hljs-params">(Drink obj)</span> &#123;<br>      <span class="hljs-built_in">super</span>(obj);<br>      <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>      setDes(<span class="hljs-string">&quot; 豆浆  &quot;</span>);<br>      setPrice(<span class="hljs-number">1.5f</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>主类调试</p></blockquote><h4 id="11、CoffeeBar"><a href="#11、CoffeeBar" class="headerlink" title="11、CoffeeBar"></a>11、CoffeeBar</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeBar</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-comment">// 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack</span><br><br>      <span class="hljs-comment">// 1. 点一份 LongBlack</span><br>      <span class="hljs-type">Drink</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongBlack</span>();<br>      System.out.println(<span class="hljs-string">&quot;费用1=&quot;</span> + order.cost());<br>      System.out.println(<span class="hljs-string">&quot;描述=&quot;</span> + order.getDes());<br><br>      <span class="hljs-comment">// 2. order 加入一份牛奶</span><br>      order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Milk</span>(order);<br><br>      System.out.println(<span class="hljs-string">&quot;order 加入一份牛奶 费用 =&quot;</span> + order.cost());<br>      System.out.println(<span class="hljs-string">&quot;order 加入一份牛奶 描述 = &quot;</span> + order.getDes());<br><br>      <span class="hljs-comment">// 3. order 加入一份巧克力</span><br><br>      order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chocolate</span>(order);<br><br>      System.out.println(<span class="hljs-string">&quot;order 加入一份牛奶 加入一份巧克力  费用 =&quot;</span> + order.cost());<br>      System.out.println(<span class="hljs-string">&quot;order 加入一份牛奶 加入一份巧克力 描述 = &quot;</span> + order.getDes());<br><br>      <span class="hljs-comment">// 3. order 加入一份巧克力</span><br><br>      order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chocolate</span>(order);<br><br>      System.out.println(<span class="hljs-string">&quot;order 加入一份牛奶 加入2份巧克力   费用 =&quot;</span> + order.cost());<br>      System.out.println(<span class="hljs-string">&quot;order 加入一份牛奶 加入2份巧克力 描述 = &quot;</span> + order.getDes());<br>   <br>      System.out.println(<span class="hljs-string">&quot;===========================&quot;</span>);<br>      <br>      <span class="hljs-type">Drink</span> <span class="hljs-variable">order2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeCaf</span>();<br>      <br>      System.out.println(<span class="hljs-string">&quot;order2 无因咖啡  费用 =&quot;</span> + order2.cost());<br>      System.out.println(<span class="hljs-string">&quot;order2 无因咖啡 描述 = &quot;</span> + order2.getDes());<br>      <br>      order2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Milk</span>(order2);<br>      <br>      System.out.println(<span class="hljs-string">&quot;order2 无因咖啡 加入一份牛奶  费用 =&quot;</span> + order2.cost());<br>      System.out.println(<span class="hljs-string">&quot;order2 无因咖啡 加入一份牛奶 描述 = &quot;</span> + order2.getDes());<br><br>   <br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、装饰者模式原理"><a href="#2、装饰者模式原理" class="headerlink" title="2、装饰者模式原理"></a>2、装饰者模式原理</h2><p>装饰者模式：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更 有弹性，装饰者模式也体现了开闭原则(ocp)</p><ol><li><p>装饰者模式就像打包一个快递</p><p>主体：比如：陶瓷、衣服 (Component) // 被装饰者</p><p>包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator)</p></li><li><p>Component 主体：比如类似前面的 Drink</p></li><li><p>ConcreteComponent 和 Decorator</p><p>ConcreteComponent：具体的主体， 比如前面的各个单品咖啡</p><p>Decorator: 装饰者，比如各调料</p></li><li><p>在Component 与 ConcreteComponent 之间，如果 ConcreteComponent 类很多,还可以设计一个缓冲层，将 共有的部分提取出来，抽象层一个类</p></li></ol><h2 id="3、Java-IO-类的用法"><a href="#3、Java-IO-类的用法" class="headerlink" title="3、Java IO 类的用法"></a>3、Java IO 类的用法</h2><p>Java IO 类库非常庞大和复杂，有几十个类，负责 IO 数据的读取和写入。如果对 Java IO 类做一下分类，我们可以从下面两个维度将它划分为四类。具体如下所示：</p><table><thead><tr><th></th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><p>针对不同的读取和写入场景，Java IO 又在这四个父类基础之上，扩展出了很多子类。具体如下所示：</p><p><img src="/2022/09/23/04-jie-gou-xing-zhuang-shi-qi-gua-pei-qi/image-20220926174459489.png"></p><p><img src="/2022/09/23/04-jie-gou-xing-zhuang-shi-qi-gua-pei-qi/image-20220926175005022.png"></p><blockquote><p>说明</p><ol><li>InputStream 是抽象类, 类似我们前面讲的 Drink</li><li>FileInputStream 是 InputStream 子类，类似我们前面的 DeCaf, LongBlack</li><li>FilterInputStream 是 InputStream 子类：类似我们前面 的 Decorator 修饰者</li><li>DataInputStream 是 FilterInputStream 子类，具体的修饰者，类似前面的 Milk, Soy 等</li><li>FilterInputStream 类 有 protected volatile InputStream in; 即含被装饰者</li><li>分析得出在jdk 的io体系中，就是使用装饰者模式</li></ol></blockquote><p>打开文件 test.txt，从中读取数据。其中，InputStream 是一个抽象类，FileInputStream 是专门用来读取文件流的子类。BufferedInputStream 是一个支持带缓存功能的数据读取类，可以提高数据读取的效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/user/test.txt&quot;</span>);<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(in);<br><span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">128</span>];<br><span class="hljs-keyword">while</span> (bin.read(data) != -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>初看上面的代码，会觉得 Java IO 的用法比较麻烦，需要先创建一个 FileInputStream 对象，然后再传递给 BufferedInputStream 对象来使用。我在想，Java IO 为什么不设计一个继承 FileInputStream 并且支持缓存的 BufferedFileInputStream 类呢？这样我们就可以像下面的代码中这样，直接创建一个 BufferedFileInputStream 类对象，打开文件读取数据，用起来岂不是更加简单？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedFileInputStream</span>(<span class="hljs-string">&quot;/user/test.txt&quot;</span>);<br><span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">128</span>];<br><span class="hljs-keyword">while</span> (bin.read(data) != -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、基于继承的设计方案"><a href="#4、基于继承的设计方案" class="headerlink" title="4、基于继承的设计方案"></a>4、基于继承的设计方案</h2><p>如果 InputStream 只有一个子类 FileInputStream 的话，那我们在 FileInputStream 基础之上，再设计一个孙子类 BufferedFileInputStream，也算是可以接受的，毕竟继承结构还算简单。但实际上，继承 InputStream 的子类有很多。我们需要给每一个 InputStream 的子类，再继续派生支持缓存读取的子类。</p><p>除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的 DataInputStream 类，支持按照基本数据类型（int、boolean、long 等）来读取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/user/test.txt&quot;</span>);<br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">din</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(in);<br><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> din.readInt();<br></code></pre></td></tr></table></figure><p>在这种情况下，如果我们继续按照继承的方式来实现的话，就需要再继续派生出 DataFileInputStream、DataPipedInputStream 等类。如果我们还需要既支持缓存、又支持按照基本类型读取数据的类，那就要再继续派生出 BufferedDataFileInputStream、BufferedDataPipedInputStream 等 n 多类。这还只是附加了两个增强功能，如果我们需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码既不好扩展，也不好维护。这也是我们不推荐使用继承的原因。</p><h2 id="5、基于装饰器模式的设计方案"><a href="#5、基于装饰器模式的设计方案" class="headerlink" title="5、基于装饰器模式的设计方案"></a>5、基于装饰器模式的设计方案</h2><p>前面提到“组合优于继承”，可以“使用组合来替代继承”。针对刚刚的继承结构过于复杂的问题，可以通过将继承关系改为组合关系来解决。下面的代码展示了 Java IO 的这种设计思路。以下是简化了的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStream</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[])</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">return</span> read(b, <span class="hljs-number">0</span>, b.length);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">skip</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">available</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span> readlimit)</span> &#123;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;mark/reset not supported&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">markSupported</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>    <span class="hljs-built_in">this</span>.in = in;<br>  &#125;<br><br>  <span class="hljs-comment">// ...实现基于缓存的读数据接口...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-title function_">DataInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>    <span class="hljs-built_in">this</span>.in = in;<br>  &#125;<br><br>  <span class="hljs-comment">// ...实现读取基本类型数据的接口</span><br>&#125;<br></code></pre></td></tr></table></figure><p>看了上面的代码，可能会问，那装饰器模式就是简单的“用组合替代继承”吗？当然不是。从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。</p><p><strong>第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</strong>比如，下面这样一段代码，我们对 FileInputStream 嵌套了两个装饰器类：BufferedInputStream 和 DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/user/test.txt&quot;</span>);<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(in);<br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">din</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(bin);<br><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> din.readInt();<br></code></pre></td></tr></table></figure><p><strong>第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。</strong>实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，代理模式中，<code>代理类附加的是跟原始类无关的功能</code>，而在装饰器模式中，<code>装饰器类附加的是跟原始类相关的增强功能</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 代理模式的代码结构(下面的接口也可以替换成抽象类)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> impelements IA &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-comment">//... </span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AProxy</span> impements IA &#123;<br>    <span class="hljs-keyword">private</span> IA a;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AProxy</span><span class="hljs-params">(IA a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 新添加的代理逻辑</span><br>        a.f();<br>        <span class="hljs-comment">// 新添加的代理逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 装饰器模式的代码结构(下面的接口也可以替换成抽象类)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> impelements IA &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-comment">//... </span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ADecorator</span> impements IA &#123;<br>    <span class="hljs-keyword">private</span> IA a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ADecorator</span><span class="hljs-params">(IA a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 功能增强代码</span><br>        a.f();<br>        <span class="hljs-comment">// 功能增强代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>实际上，如果去查看 JDK 的源码，会发现BufferedInputStream、DataInputStream 并非继承自 InputStream，而是另外一个叫 FilterInputStream 的类。那这又是出于什么样的设计意图，才引入这样一个类呢？</li><li>再重新来看一下 BufferedInputStream 类的代码。InputStream 是一个抽象类而非接口，而且它的大部分函数（比如 read()、available()）都有默认实现，按理来说，我们只需要在 BufferedInputStream 类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承 InputStream 的默认实现。但实际上，这样做是行不通的。</li><li>对于即便是不需要增加缓存功能的函数来说，BufferedInputStream 还是必须把它重新实现一遍，简单包裹对 InputStream 对象的函数调用。具体的代码示例如下所示。如果不重新实现，那 BufferedInputStream 类就无法将最终读取数据的任务，委托给传递进来的 InputStream 对象来完成。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>.in = in;<br>    &#125;<br><br><span class="hljs-comment">// f()函数不需要增强，只是重新调用一下InputStream in对象的f()</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123; <br>        in.f();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，DataInputStream 也存在跟 BufferedInputStream 同样的问题。为了避免代码重复，Java IO 抽象出了一个装饰器父类 FilterInputStream，代码实现如下所示。InputStream 的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">FilterInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>.in = in;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> in.read();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[])</span> <span class="hljs-keyword">throws</span> IOException &#123; <br>        <span class="hljs-keyword">return</span> read(b, <span class="hljs-number">0</span>, b.length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> in.read(b, off, len);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">skip</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> in.skip(n);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">available</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> in.available();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        in.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span> readlimit)</span> &#123;<br>        in.mark(readlimit);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        in.reset();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">markSupported</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> in.markSupported();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、适配器模式"><a href="#二、适配器模式" class="headerlink" title="二、适配器模式"></a>二、适配器模式</h1><p>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，<strong>主的目的是兼容性</strong>，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper) 。适配器模式属于结构型模式。主要分为三类：<strong>类适配器模式、对象适配器模式、接口适配器模式</strong></p><h2 id="1、Demo案例-充电器"><a href="#1、Demo案例-充电器" class="headerlink" title="1、Demo案例-充电器"></a>1、Demo案例-充电器</h2><p>基本介绍：Adapter 类，通过继承 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配。</p><ul><li>以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们 的目 dst(即 目标)是 5V 直流电</li></ul><h3 id="1、类适配器代码实现"><a href="#1、类适配器代码实现" class="headerlink" title="1、类适配器代码实现"></a>1、类适配器代码实现</h3><h4 id="1、Voltage220V"><a href="#1、Voltage220V" class="headerlink" title="1、Voltage220V"></a>1、Voltage220V</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//被适配的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Voltage220V</span> &#123;<br>   <span class="hljs-comment">//输出220V的电压</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">output220V</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> <span class="hljs-number">220</span>;<br>      System.out.println(<span class="hljs-string">&quot;电压=&quot;</span> + src + <span class="hljs-string">&quot;伏&quot;</span>);<br>      <span class="hljs-keyword">return</span> src;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、IVoltage5V"><a href="#2、IVoltage5V" class="headerlink" title="2、IVoltage5V"></a>2、IVoltage5V</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//适配接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IVoltage5V</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">output5V</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、Phone"><a href="#3、Phone" class="headerlink" title="3、Phone"></a>3、Phone</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;<br><br>   <span class="hljs-comment">//充电</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">charging</span><span class="hljs-params">(IVoltage5V iVoltage5V)</span> &#123;<br>      <span class="hljs-keyword">if</span>(iVoltage5V.output5V() == <span class="hljs-number">5</span>) &#123;<br>         System.out.println(<span class="hljs-string">&quot;电压为5V, 可以充电~~&quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (iVoltage5V.output5V() &gt; <span class="hljs-number">5</span>) &#123;<br>         System.out.println(<span class="hljs-string">&quot;电压大于5V, 不能充电~~&quot;</span>);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、VoltageAdapter"><a href="#4、VoltageAdapter" class="headerlink" title="4、VoltageAdapter"></a>4、VoltageAdapter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//适配器类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoltageAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Voltage220V</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVoltage5V</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">output5V</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-comment">//获取到220V电压</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">srcV</span> <span class="hljs-operator">=</span> output220V();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">dstV</span> <span class="hljs-operator">=</span> srcV / <span class="hljs-number">44</span> ; <span class="hljs-comment">//转成 5v</span><br>      <span class="hljs-keyword">return</span> dstV;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、Client"><a href="#5、Client" class="headerlink" title="5、Client"></a>5、Client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; === 类适配器模式 ====&quot;</span>);<br>      <span class="hljs-type">Phone</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br>      phone.charging(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VoltageAdapter</span>());<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、对象适配器实现"><a href="#2、对象适配器实现" class="headerlink" title="2、对象适配器实现"></a>2、对象适配器实现</h3><p>基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承 src 类，而是持有 src 类的实例，以解决 兼容性的问题。 即：持有 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配 ，在系统中尽量使用<strong>关联关系（聚合，组合）来替代继承</strong>关系。</p><p>上面的例子代码基本没用什么改变，改变的只有以下两个类</p><h4 id="1、VoltageAdapter"><a href="#1、VoltageAdapter" class="headerlink" title="1、VoltageAdapter"></a>1、VoltageAdapter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 适配器类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoltageAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVoltage5V</span> &#123;<br><br>  <span class="hljs-keyword">private</span> Voltage220V voltage220V; <span class="hljs-comment">// 关联关系-聚合</span><br><br>  <span class="hljs-comment">// 通过构造器，传入一个 Voltage220V 实例</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">VoltageAdapter</span><span class="hljs-params">(Voltage220V voltage220v)</span> &#123;<br><br>    <span class="hljs-built_in">this</span>.voltage220V = voltage220v;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">output5V</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dst</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != voltage220V) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> voltage220V.output220V(); <span class="hljs-comment">// 获取220V 电压</span><br>      System.out.println(<span class="hljs-string">&quot;使用对象适配器，进行适配~~&quot;</span>);<br>      dst = src / <span class="hljs-number">44</span>;<br>      System.out.println(<span class="hljs-string">&quot;适配完成，输出的电压为=&quot;</span> + dst);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dst;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、Client"><a href="#2、Client" class="headerlink" title="2、Client"></a>2、Client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    System.out.println(<span class="hljs-string">&quot; === 对象适配器模式 ====&quot;</span>);<br>    <span class="hljs-type">Phone</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br>    phone.charging(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VoltageAdapter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Voltage220V</span>()));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、适配器模式的原理与实现"><a href="#2、适配器模式的原理与实现" class="headerlink" title="2、适配器模式的原理与实现"></a>2、适配器模式的原理与实现</h2><p>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同 工作。其别名为包装器(Wrapper)</p><p>适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。具体的代码实现如下所示。其中，ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 类适配器: 基于继承</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-comment">//... </span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fb</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//... </span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//... </span><br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITarget</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.fa();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...重新实现f2()...</span><br>    &#125;<br><br><span class="hljs-comment">// 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span><br>&#125;<br><br><span class="hljs-comment">// 对象适配器：基于组合</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//... </span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fb</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//... </span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//... </span><br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-keyword">private</span> Adaptee adaptee;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Adaptor</span><span class="hljs-params">(Adaptee adaptee)</span> &#123;<br>        <span class="hljs-built_in">this</span>.adaptee = adaptee;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;<br>        adaptee.fa(); <span class="hljs-comment">//委托给Adaptee</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...重新实现f2()...</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span> &#123;<br>        adaptee.fc();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有两个，一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度。</p><ul><li>如果 Adaptee 接口并不多，那两种实现方式都可以。</li><li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。</li><li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。</li></ul><h2 id="3、适配器模式应用场景"><a href="#3、适配器模式应用场景" class="headerlink" title="3、适配器模式应用场景"></a>3、适配器模式应用场景</h2><p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p><h3 id="1、封装有缺陷的接口设计"><a href="#1、封装有缺陷的接口设计" class="headerlink" title="1、封装有缺陷的接口设计"></a>1、封装有缺陷的接口设计</h3><p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p><p>比如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CD</span> &#123; <span class="hljs-comment">//这个类来自外部sdk，我们无权修改它的代码</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticFunction1</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>        <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uglyNamingFunction2</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>        <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tooManyParamsFunction3</span><span class="hljs-params">(<span class="hljs-type">int</span> paramA, <span class="hljs-type">int</span> paramB, ...)</span> &#123; <span class="hljs-comment">//... &#125;</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lowPerformanceFunction4</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br><br>&#125;<br><br><span class="hljs-comment">// 使用适配器模式进行重构</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITarget</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">function1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">function2</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fucntion3</span><span class="hljs-params">(ParamsWrapperDefinition paramsWrapper)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">function4</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">// 注意：适配器类的命名不一定非得末尾带Adaptor</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CDAdaptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CD</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.staticFunction1();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.uglyNamingFucntion2();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function3</span><span class="hljs-params">(ParamsWrapperDefinition paramsWrapper)</span> &#123; <br>        <span class="hljs-built_in">super</span>.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function4</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...reimplement it...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、统一多个类的接口设计"><a href="#2、统一多个类的接口设计" class="headerlink" title="2、统一多个类的接口设计"></a>2、统一多个类的接口设计</h3><ol><li>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体还是举个例子来解释一下。</li><li>假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ASensitiveWordsFilter</span> &#123; <span class="hljs-comment">// A敏感词过滤系统提供的接口</span><br>  <span class="hljs-comment">// text是原始文本，函数输出用***替换敏感词之后的文本</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterSexyWords</span><span class="hljs-params">(String text)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterPoliticalWords</span><span class="hljs-params">(String text)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BSensitiveWordsFilter</span> &#123; <span class="hljs-comment">// B敏感词过滤系统提供的接口</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CSensitiveWordsFilter</span> &#123; <span class="hljs-comment">// C敏感词过滤系统提供的接口</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text, String mask)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RiskManagement</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">ASensitiveWordsFilter</span> <span class="hljs-variable">aFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ASensitiveWordsFilter</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">BSensitiveWordsFilter</span> <span class="hljs-variable">bFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BSensitiveWordsFilter</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">CSensitiveWordsFilter</span> <span class="hljs-variable">cFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CSensitiveWordsFilter</span>();<br><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterSensitiveWords</span><span class="hljs-params">(String text)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">maskedText</span> <span class="hljs-operator">=</span> aFilter.filterSexyWords(text);<br>    maskedText = aFilter.filterPoliticalWords(maskedText);<br>    maskedText = bFilter.filter(maskedText);<br>    maskedText = cFilter.filter(maskedText, <span class="hljs-string">&quot;***&quot;</span>);<br>    <span class="hljs-keyword">return</span> maskedText;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用适配器模式进行改造</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISensitiveWordsFilter</span> &#123; <span class="hljs-comment">// 统一接口定义</span><br>  String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ASensitiveWordsFilterAdaptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISensitiveWordsFilter</span> &#123;<br>  <span class="hljs-keyword">private</span> ASensitiveWordsFilter aFilter;<br><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">maskedText</span> <span class="hljs-operator">=</span> aFilter.filterSexyWords(text);<br>    maskedText = aFilter.filterPoliticalWords(maskedText);<br>    <span class="hljs-keyword">return</span> maskedText;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// ...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...</span><br><span class="hljs-comment">// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，</span><br><span class="hljs-comment">// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RiskManagement</span> &#123;<br>  <span class="hljs-keyword">private</span> List&lt;ISensitiveWordsFilter&gt; filters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSensitiveWordsFilter</span><span class="hljs-params">(ISensitiveWordsFilter filter)</span> &#123;<br>    filters.add(filter);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterSensitiveWords</span><span class="hljs-params">(String text)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">maskedText</span> <span class="hljs-operator">=</span> text;<br>    <span class="hljs-keyword">for</span> (ISensitiveWordsFilter filter : filters) &#123;<br>      maskedText = filter.filter(maskedText);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maskedText;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、替换依赖的外部系统"><a href="#3、替换依赖的外部系统" class="headerlink" title="3、替换依赖的外部系统"></a>3、替换依赖的外部系统</h3><p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。具体的代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 外部系统A</span><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">interface</span>  <span class="hljs-title class_">IA</span>  &#123;<br><span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">fa</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">A</span>  <span class="hljs-keyword">implements</span>  <span class="hljs-title class_">IA</span>  &#123;<br><span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">fa</span><span class="hljs-params">()</span>  &#123; <br>    <span class="hljs-comment">//... </span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 在我们的项目中，外部系统A的使用示例</span><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Demo</span>  &#123;<br>  <span class="hljs-keyword">private</span> IA a;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-title function_">Demo</span><span class="hljs-params">(IA a)</span>  &#123;<br>    <span class="hljs-built_in">this</span>.a = a;<br>  &#125;<br>  <span class="hljs-comment">//... </span><br><br>&#125;<br><br><span class="hljs-type">Demo</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>());<br><br><span class="hljs-comment">// 将外部系统A替换成外部系统B</span><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">BAdaptor</span>  implemnts  IA  &#123;<br>  <span class="hljs-keyword">private</span> B b;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-title function_">BAdaptor</span><span class="hljs-params">(B b)</span>  &#123;<br>    <span class="hljs-built_in">this</span>.b= b;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">fa</span><span class="hljs-params">()</span>  &#123;<br>  <span class="hljs-comment">//...</span><br>    b.fb();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，</span><br><span class="hljs-comment">// 只需要将BAdaptor如下注入到Demo即可。</span><br><span class="hljs-type">Demo</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BAdaptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>()));<br></code></pre></td></tr></table></figure><h3 id="4、兼容老版本接口"><a href="#4、兼容老版本接口" class="headerlink" title="4、兼容老版本接口"></a>4、兼容老版本接口</h3><ol><li>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。同样，还是通过一个例子，来进一步解释一下。</li><li>JDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它改名为 Iterator 类，并且对它的代码实现做了优化。但是考虑到如果将 Enumeration 直接从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过。为了避免这种情况的发生，我们必须把项目中所有使用到 Enumeration 的地方，都修改为使用 Iterator 才行。</li><li>单独一个项目做 Enumeration 到 Iterator 的替换，勉强还能接受。但是，使用 Java 开发的项目太多了，一次 JDK 的升级，导致所有的项目不做代码修改就会编译报错，这显然是不合理的。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本 JDK 的老代码，我们可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor。代码示例如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Collections</span>  &#123;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> Emueration <span class="hljs-title function_">emumeration</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Collection c)</span>  &#123;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enumeration</span>() &#123;<br>      <span class="hljs-type">Iterator</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> c.iterator();<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasMoreElments</span><span class="hljs-params">()</span>  &#123;<br>        <span class="hljs-keyword">return</span> i.hashNext();<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">nextElement</span><span class="hljs-params">()</span>  &#123;<br>        <span class="hljs-keyword">return</span> i.next():<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、适配不同格式的数据"><a href="#5、适配不同格式的数据" class="headerlink" title="5、适配不同格式的数据"></a>5、适配不同格式的数据</h3><p>前面我们讲到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; stooges = Arrays.asList(<span class="hljs-string">&quot;Larry&quot;</span>, <span class="hljs-string">&quot;Moe&quot;</span>, <span class="hljs-string">&quot;Curly&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="6、适配器模式在-Java-日志中的应用-Slf4j"><a href="#6、适配器模式在-Java-日志中的应用-Slf4j" class="headerlink" title="6、适配器模式在 Java 日志中的应用(Slf4j)"></a>6、适配器模式在 Java 日志中的应用(Slf4j)</h3><ol><li>Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等。</li><li>大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不像 JDBC 那样，一开始就制定了数据库操作的接口规范。</li><li>如果我们只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback 随便选一个就好。但是，如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。</li><li>比如，项目中用到的某个组件使用 log4j 来打印日志，而我们项目本身使用的是 logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比如，日志存储的文件地址、打印日志的格式）。如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要统一日志打印框架。</li><li>如果是做 Java 开发的，那 Slf4j 这个日志框架肯定不陌生，它相当于 JDBC 规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用。</li><li>不仅如此，Slf4j 的出现晚于 JUL、JCL、log4j 等日志框架，所以，这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合 Slf4j 接口规范。Slf4j 也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的 Slf4j 接口定义。具体的代码示例如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// slf4j统一的接口定义</span><br><span class="hljs-keyword">package</span> org.slf4j;<br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Logger</span> &#123;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTraceEnabled</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String msg)</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String format, Object arg)</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String format, Object arg1, Object arg2)</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String format, Object[] argArray)</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String msg, Throwable t)</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDebugEnabled</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg)</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg)</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg1, Object arg2)</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object[] argArray)</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg, Throwable t)</span>;<br><br><span class="hljs-comment">//...省略info、warn、error等一堆接口</span><br>&#125;<br><br><br><span class="hljs-comment">// log4j日志框架的适配器</span><br><span class="hljs-comment">// Log4jLoggerAdapter实现了LocationAwareLogger接口，</span><br><span class="hljs-comment">// 其中LocationAwareLogger继承自Logger接口，</span><br><span class="hljs-comment">// 也就相当于Log4jLoggerAdapter实现了Logger接口。</span><br><span class="hljs-keyword">package</span> org.slf4j.impl;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log4jLoggerAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MarkerIgnoringBase</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LocationAwareLogger</span>, Serializable &#123;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> org.apache.log4j.Logger logger; <span class="hljs-comment">// log4j</span><br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDebugEnabled</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> logger.isDebugEnabled();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg)</span> &#123;<br>    logger.log(FQCN, Level.DEBUG, msg, <span class="hljs-literal">null</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>      <span class="hljs-type">FormattingTuple</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> MessageFormatter.format(format, arg);<br>      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg1, Object arg2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>      <span class="hljs-type">FormattingTuple</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> MessageFormatter.format(format, arg1, arg2);<br>      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object\[\] argArray)</span> &#123;<br>    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>      <span class="hljs-type">FormattingTuple</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> MessageFormatter.arrayFormat(format, argArray);<br>      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg, Throwable t)</span> &#123;<br>    logger.log(FQCN, Level.DEBUG, msg, t);<br>  &#125;<br><br><span class="hljs-comment">//...省略一堆接口的实现...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以，在开发业务系统或者开发框架、组件的时候，我们统一使用 Slf4j 提供的接口来编写打印日志的代码，具体使用哪种日志框架实现（log4j、logback……），是可以动态地指定的（使用 Java 的 SPI 技术），只需要将相应的 SDK 导入到项目中即可。</p><h2 id="4、代理、桥接、装饰器、适配器-4-种设计模式的区别"><a href="#4、代理、桥接、装饰器、适配器-4-种设计模式的区别" class="headerlink" title="4、代理、桥接、装饰器、适配器 4 种设计模式的区别"></a>4、代理、桥接、装饰器、适配器 4 种设计模式的区别</h2><ol><li>代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。</li><li>尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。</li></ol><ul><li>代理模式：在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</li><li>桥接模式：目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</li><li>装饰者模式：在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</li><li>适配器模式：是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>结构型</tag>
      
      <tag>装饰器</tag>
      
      <tag>适配器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03-结构型-代理-桥接</title>
    <link href="/2022/09/23/03-jie-gou-xing-dai-li-qiao-jie/"/>
    <url>/2022/09/23/03-jie-gou-xing-dai-li-qiao-jie/</url>
    
    <content type="html"><![CDATA[<h2 id="一、代理模式【常用】"><a href="#一、代理模式【常用】" class="headerlink" title="一、代理模式【常用】"></a>一、代理模式【常用】</h2><ol><li>创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</li><li>其中，单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</li><li>另外一种类型的设计模式：结构型模式。结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。代理模式是在实际开发中经常被用到的一种设计模式。</li><li>代理模式有不同的形式, 主要有三种 <strong>静态代理</strong>、<strong>动态代理</strong> (JDK 代理、接口代理)和 <strong>Cglib</strong> <strong>代理</strong> (可以在内存 动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴) 。</li></ol><h3 id="1、静态代理"><a href="#1、静态代理" class="headerlink" title="1、静态代理"></a>1、静态代理</h3><p>实例具体要求</p><ol><li>定义一个接口:ITeacherDao</li><li>目标对象 TeacherDAO 实现接口 ITeacherDAO</li><li>使用静态代理方式,就需要在代理对象 TeacherDAOProxy 中也实现 ITeacherDAO</li><li>调用的时候通过调用代理对象的方法来调用目标对象</li><li>特别提醒：静态代理类与被代理类要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法</li></ol><blockquote><p><strong>ITeacherDao</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITeacherDao</span> &#123;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 授课的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>TeacherDao</strong> —&gt; 被代理类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TeacherDao</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITeacherDao</span> &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>System.out.println(<span class="hljs-string">&quot; 老师授课中  。。。。。&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>TeacherDaoProxy</strong> —&gt; 代理类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//代理对象,静态代理</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TeacherDaoProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITeacherDao</span>&#123;<br><br><span class="hljs-keyword">private</span> ITeacherDao target; <span class="hljs-comment">// 目标对象，通过接口来聚合</span><br><br><span class="hljs-comment">//构造器</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TeacherDaoProxy</span><span class="hljs-params">(ITeacherDao target)</span> &#123;<br><span class="hljs-built_in">this</span>.target = target;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>System.out.println(<span class="hljs-string">&quot;开始代理  完成某些操作。。。。。 &quot;</span>);<span class="hljs-comment">//方法</span><br>target.teach();<br>System.out.println(<span class="hljs-string">&quot;提交。。。。。&quot;</span>);<span class="hljs-comment">//方法</span><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Client</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-comment">//创建目标对象(被代理对象)</span><br><span class="hljs-type">TeacherDao</span> <span class="hljs-variable">teacherDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TeacherDao</span>();<br><br><span class="hljs-comment">//创建代理对象, 同时将被代理对象传递给代理对象</span><br><span class="hljs-type">TeacherDaoProxy</span> <span class="hljs-variable">teacherDaoProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TeacherDaoProxy</span>(teacherDao);<br><br><span class="hljs-comment">//通过代理对象，调用到被代理对象的方法</span><br><span class="hljs-comment">//即：执行的是代理对象的方法，代理对象再去调用目标对象的方法 </span><br>teacherDaoProxy.teach();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、动态代理"><a href="#2、动态代理" class="headerlink" title="2、动态代理"></a>2、动态代理</h3><ol><li>代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理</li><li>代理对象的生成，是利用 JDK 的 API，动态的在内存中构建代理对象</li><li>动态代理也叫做：<strong>JDK 代理</strong>、<strong>接口代理</strong></li><li>代理类所在包:java.lang.reflect.Proxy</li><li>JDK 实现代理只需要使用 <strong>newProxyInstance</strong> 方法,但是该方法需要接收三个参数,完整的写法是:</li></ol><p>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</p><blockquote><p>ITeacherDao</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITeacherDao</span> &#123;<br><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 授课方法</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>TeacherDao</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TeacherDao</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITeacherDao</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; 老师授课中.... &quot;</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot;hello &quot;</span> + name);<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ProxyFactory</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactory</span> &#123;<br><br>   <span class="hljs-comment">//维护一个目标对象 , Object</span><br>   <span class="hljs-keyword">private</span> Object target;<br><br>   <span class="hljs-comment">//构造器 ， 对target 进行初始化</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyFactory</span><span class="hljs-params">(Object target)</span> &#123;<br>      <br>      <span class="hljs-built_in">this</span>.target = target;<br>   &#125; <br>   <br>   <span class="hljs-comment">//给目标对象 生成一个代理对象</span><br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">()</span> &#123;<br>      <br>      <span class="hljs-comment">/* 说明</span><br><span class="hljs-comment">         public static Object newProxyInstance(ClassLoader loader,</span><br><span class="hljs-comment">                                          Class&lt;?&gt;[] interfaces,</span><br><span class="hljs-comment">                                          InvocationHandler h)</span><br><span class="hljs-comment">                                          </span><br><span class="hljs-comment">            1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span><br><span class="hljs-comment">            2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</span><br><span class="hljs-comment">            3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, </span><br><span class="hljs-comment">             会把当前执行的目标对象方法作为参数传入</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), <br>            target.getClass().getInterfaces(), <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>               <br>               <span class="hljs-meta">@Override</span><br>               <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                  <span class="hljs-comment">// TODO Auto-generated method stub</span><br>                  System.out.println(<span class="hljs-string">&quot;JDK代理开始~~&quot;</span>);<br>                  <span class="hljs-comment">//反射机制调用目标对象的方法</span><br>                  <span class="hljs-type">Object</span> <span class="hljs-variable">returnVal</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>                  System.out.println(<span class="hljs-string">&quot;JDK代理提交&quot;</span>);<br>                  <span class="hljs-keyword">return</span> returnVal;<br>               &#125;<br>            &#125;); <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Client</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-comment">//创建目标对象</span><br>      <span class="hljs-type">ITeacherDao</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TeacherDao</span>();<br>      <br>      <span class="hljs-comment">//给目标对象，创建代理对象, 可以转成 ITeacherDao</span><br>      <span class="hljs-type">ITeacherDao</span> <span class="hljs-variable">proxyInstance</span> <span class="hljs-operator">=</span> (ITeacherDao)<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>(target).getProxyInstance();<br>   <br>      <span class="hljs-comment">// proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象</span><br>      System.out.println(<span class="hljs-string">&quot;proxyInstance=&quot;</span> + proxyInstance.getClass());<br>      <br>      <span class="hljs-comment">//通过代理对象，调用目标对象的方法</span><br>      <span class="hljs-comment">//proxyInstance.teach();</span><br>      <br>      proxyInstance.sayHello(<span class="hljs-string">&quot; tom &quot;</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、Cglib代理"><a href="#3、Cglib代理" class="headerlink" title="3、Cglib代理"></a>3、Cglib代理</h3><ol><li><p>静态代理和 JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候可使用目标对象子类来实现代理-这就是Cglib代理</p></li><li><p>Cglib代理也叫作<strong>子类代理</strong>，它是在内存中构建一个子类对象从而实现对目标对象功能扩展, 有些书也将Cglib代理归属到动态代理。</p></li><li><p>Cglib 是一个强大的高性能的代码生成包,它可以在运行期扩展 java 类与实现 java 接口.它广泛的被许多 AOP 的 框架使用,例如 Spring AOP，实现方法拦截</p></li><li><p>在 AOP 编程中如何选择代理模式：</p><ul><li>目标对象需要实现接口，用 JDK 代理</li><li>目标对象不需要实现接口，用 Cglib 代理</li></ul></li><li><p>Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类</p></li><li><p>需要引入 cglib 的 jar 文件，在内存中动态构建子类，注意代理的类不能为 final，否则报错</p><p><code>java.lang.IllegalArgumentException</code>，目标对象的方法如果为 final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法。</p></li></ol><blockquote><p>TeacherDao</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TeacherDao</span> &#123;<br><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">teach</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; 老师授课中  ， 我是cglib代理，不需要实现接口 &quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ProxyFactory</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br><br>   <span class="hljs-comment">//维护一个目标对象</span><br>   <span class="hljs-keyword">private</span> Object target;<br>   <br>   <span class="hljs-comment">//构造器，传入一个被代理的对象</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyFactory</span><span class="hljs-params">(Object target)</span> &#123;<br>      <span class="hljs-built_in">this</span>.target = target;<br>   &#125;<br><br>   <span class="hljs-comment">//返回一个代理对象:  是 target 对象的代理对象</span><br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//1. 创建一个工具类</span><br>      <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>      <span class="hljs-comment">//2. 设置父类</span><br>      enhancer.setSuperclass(target.getClass());<br>      <span class="hljs-comment">//3. 设置回调函数</span><br>      enhancer.setCallback(<span class="hljs-built_in">this</span>);<br>      <span class="hljs-comment">//4. 创建子类对象，即代理对象</span><br>      <span class="hljs-keyword">return</span> enhancer.create();<br>      <br>   &#125;<br>   <br><br>   <span class="hljs-comment">//重写  intercept 方法，会调用目标对象的方法</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object arg0, Method method, Object[] args, MethodProxy arg3)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot;Cglib代理模式 ~~ 开始&quot;</span>);<br>      <span class="hljs-type">Object</span> <span class="hljs-variable">returnVal</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>      System.out.println(<span class="hljs-string">&quot;Cglib代理模式 ~~ 提交&quot;</span>);<br>      <span class="hljs-keyword">return</span> returnVal;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Client</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-comment">//创建目标对象</span><br>      <span class="hljs-type">TeacherDao</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TeacherDao</span>();<br>      <span class="hljs-comment">//获取到代理对象，并且将目标对象传递给代理对象</span><br>      <span class="hljs-type">TeacherDao</span> <span class="hljs-variable">proxyInstance</span> <span class="hljs-operator">=</span> (TeacherDao)<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>(target).getProxyInstance();<br><br>      <span class="hljs-comment">//执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> proxyInstance.teach();<br>      System.out.println(<span class="hljs-string">&quot;res=&quot;</span> + res);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、代理模式的原理解析"><a href="#4、代理模式的原理解析" class="headerlink" title="4、代理模式的原理解析"></a>4、代理模式的原理解析</h3><ol><li>代理模式（Proxy Design Pattern）的原理和代码实现都不难掌握。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能【<strong>装饰器是增强功能，代理是附加新的功能</strong>】。我们通过一个简单的例子来解释一下这段话。</li><li>我们开发了一个 MetricsCollector 类，用来收集接口请求的原始数据，比如访问时间、处理时长等。在业务系统中，我们采用如下方式来使用这个 MetricsCollector 类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>  <span class="hljs-comment">//...省略其他属性和方法...</span><br>  <span class="hljs-keyword">private</span> MetricsCollector metricsCollector; <span class="hljs-comment">// 依赖注入</span><br><br>  <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>    <span class="hljs-comment">// ... 省略login逻辑...</span><br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>    <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;login&quot;</span>, responseTime, startTimestamp);<br>    metricsCollector.recordRequest(requestInfo);<br><br>    <span class="hljs-comment">//...返回UserVo数据...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>    <span class="hljs-comment">// ... 省略register逻辑...</span><br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>    <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;register&quot;</span>, responseTime, startTimestamp);<br>    metricsCollector.recordRequest(requestInfo);<br><br>    <span class="hljs-comment">//...返回UserVo数据...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>很明显，上面的写法有两个问题。第一，性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。第二，收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理。</li><li>为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。具体的代码实现如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserController</span> &#123;<br>  UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span>;<br>  UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserController</span> &#123;<br>  <span class="hljs-comment">//...省略其他属性和方法...</span><br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-comment">//...省略login逻辑...</span><br>    <span class="hljs-comment">//...返回UserVo数据...</span><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-comment">//...省略register逻辑...</span><br>    <span class="hljs-comment">//...返回UserVo数据...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserControllerProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserController</span> &#123;<br>  <span class="hljs-keyword">private</span> MetricsCollector metricsCollector;<br>  <span class="hljs-keyword">private</span> UserController userController;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserControllerProxy</span><span class="hljs-params">(UserController userController)</span> &#123;<br>    <span class="hljs-built_in">this</span>.userController = userController;<br>    <span class="hljs-built_in">this</span>.metricsCollector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollector</span>();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>    <span class="hljs-comment">// 委托</span><br>    <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> userController.login(telephone, password);<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>    <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;login&quot;</span>, responseTime, startTimestamp);<br>    metricsCollector.recordRequest(requestInfo);<br><br>    <span class="hljs-keyword">return</span> userVo;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>    <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> userController.register(telephone, password);<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>    <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;register&quot;</span>, responseTime, startTimestamp);<br>    metricsCollector.recordRequest(requestInfo);<br><br>    <span class="hljs-keyword">return</span> userVo;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//UserControllerProxy使用举例</span><br><span class="hljs-comment">//因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span><br><span class="hljs-comment">//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span><br><span class="hljs-type">IUserController</span> <span class="hljs-variable">userController</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserControllerProxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserController</span>());<br></code></pre></td></tr></table></figure><ol><li>参照基于==接口==而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下，我们该如何实现代理模式呢？</li><li><code>对于这种外部类的扩展，我们一般都是采用继承的方式</code>。这里也不例外。我们让代理类继承原始类，然后扩展附加功能。原理很简单，直接看代码。具体代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserControllerProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UserController</span> &#123;<br>  <span class="hljs-keyword">private</span> MetricsCollector metricsCollector;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserControllerProxy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.metricsCollector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollector</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>    <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.login(telephone, password);<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>    <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;login&quot;</span>, responseTime, startTimestamp);<br>    metricsCollector.recordRequest(requestInfo);<br><br>    <span class="hljs-keyword">return</span> userVo;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>    <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.register(telephone, password);<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>    <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;register&quot;</span>, responseTime, startTimestamp);<br>    metricsCollector.recordRequest(requestInfo);<br><br>    <span class="hljs-keyword">return</span> userVo;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//UserControllerProxy使用举例</span><br><span class="hljs-type">UserController</span> <span class="hljs-variable">userController</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserControllerProxy</span>();<br></code></pre></td></tr></table></figure><h3 id="5、动态代理的原理解析"><a href="#5、动态代理的原理解析" class="headerlink" title="5、动态代理的原理解析"></a>5、动态代理的原理解析</h3><ol><li>不过，刚刚的代码实现还是有点问题。一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。</li><li>如果有 50 个要添加附加功能的原始类，那我们就要创建 50 个对应的代理类。这会导致项目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式的“重复”代码，也增加了不必要的开发成本。那这个问题怎么解决呢？</li><li>我们可以使用动态代理来解决这个问题。所谓动态代理（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。那如何实现动态代理呢？</li><li>如果你熟悉的是 Java 语言，实现动态代理就是件很简单的事情。因为 Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java 的反射语法）。我们来看一下，如何用 Java 的动态代理来实现刚刚的功能。具体的代码如下所示。其中，MetricsCollectorProxy 作为一个动态代理类，动态地给每个需要收集接口请求信息的类创建代理类。、</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MetricsCollectorProxy</span> &#123;<br>  <span class="hljs-keyword">private</span> MetricsCollector metricsCollector;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">MetricsCollectorProxy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.metricsCollector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollector</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">createProxy</span><span class="hljs-params">(Object proxiedObject)</span> &#123;<br>    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();<br>    <span class="hljs-type">DynamicProxyHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicProxyHandler</span>(proxiedObject);<br>    <span class="hljs-keyword">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicProxyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> Object proxiedObject;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DynamicProxyHandler</span><span class="hljs-params">(Object proxiedObject)</span> &#123;<br>      <span class="hljs-built_in">this</span>.proxiedObject = proxiedObject;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>      <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>      <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(proxiedObject, args);<br>      <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>      <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">apiName</span> <span class="hljs-operator">=</span> proxiedObject.getClass().getName() + <span class="hljs-string">&quot;:&quot;</span> + method.getName();<br>      <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(apiName, responseTime, startTimestamp);<br>      metricsCollector.recordRequest(requestInfo);<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//MetricsCollectorProxy使用举例</span><br><span class="hljs-type">MetricsCollectorProxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollectorProxy</span>();<br><span class="hljs-type">IUserController</span> <span class="hljs-variable">userController</span> <span class="hljs-operator">=</span> (IUserController) proxy.createProxy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserController</span>());<br></code></pre></td></tr></table></figure><p>实际上，Spring AOP 底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring 为这些类创建动态代理对象，并在 JVM 中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。</p><h3 id="6、代理模式的应用场景"><a href="#6、代理模式的应用场景" class="headerlink" title="6、代理模式的应用场景"></a>6、代理模式的应用场景</h3><h4 id="1、业务系统的非功能性需求开发"><a href="#1、业务系统的非功能性需求开发" class="headerlink" title="1、业务系统的非功能性需求开发"></a>1、业务系统的非功能性需求开发</h4><p>代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的例子，就是这个应用场景的一个典型例子。</p><p>如果你熟悉 Java 语言和 Spring 开发框架，这部分工作都是可以在 Spring AOP 切面中完成的。前面我们也提到，Spring AOP 底层的实现原理就是基于动态代理。</p><h4 id="2、代理模式在-RPC、缓存中的应用"><a href="#2、代理模式在-RPC、缓存中的应用" class="headerlink" title="2、代理模式在 RPC、缓存中的应用"></a>2、代理模式在 RPC、缓存中的应用</h4><p>实际上，RPC 框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。</p><h4 id="3、代理模式在缓存中的应用"><a href="#3、代理模式在缓存中的应用" class="headerlink" title="3、代理模式在缓存中的应用"></a>3、代理模式在缓存中的应用</h4><ol><li>假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。那如何来实现接口请求的缓存功能呢？</li><li>最简单的实现方法就是刚刚我们讲到的，给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存接口）、集中配置（比如配置每个接口缓存过期时间）。</li><li>针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于 Spring 框架来开发的话，那就可以在 AOP 切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如 http://…?..&amp;cached=true），我们便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回。</li></ol><h2 id="二、桥接模式【常用】"><a href="#二、桥接模式【常用】" class="headerlink" title="二、桥接模式【常用】"></a>二、桥接模式【常用】</h2><ol><li>已经了解了第一种结构型模式：代理模式。它在不改变原始类（或者叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。代理模式在平时的开发经常被用到，常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。</li><li>另一种结构型模式：桥接模式。桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相当于代理模式来说，桥接模式在实际的项目中并没有那么常用，见到能认识就可以。</li></ol><h3 id="1、Demo案例-手机操作问题"><a href="#1、Demo案例-手机操作问题" class="headerlink" title="1、Demo案例-手机操作问题"></a>1、Demo案例-手机操作问题</h3><h4 id="1、需求"><a href="#1、需求" class="headerlink" title="1、需求"></a>1、需求</h4><p>现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)，如图:</p><p><img src="/2022/09/23/03-jie-gou-xing-dai-li-qiao-jie/image-20220926161449612.png"></p><h4 id="2、传统方案解决手机操作问题分析"><a href="#2、传统方案解决手机操作问题分析" class="headerlink" title="2、传统方案解决手机操作问题分析"></a>2、传统方案解决手机操作问题分析</h4><p>传统方法对应的类图</p><p><img src="/2022/09/23/03-jie-gou-xing-dai-li-qiao-jie/image-20220926161534523.png" alt="类图"></p><ol><li>扩展性问题(<strong>类爆炸</strong>)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。</li><li>违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本.</li><li>解决方案-使用<strong>桥接模</strong>式</li><li>Bridge 模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把<code>抽象(Abstraction)与行为实现(Implementation)分离开来</code>，从而可以保持各部分的独立性以及应对他们的功能扩展</li></ol><h4 id="3、使用桥接模式的代码"><a href="#3、使用桥接模式的代码" class="headerlink" title="3、使用桥接模式的代码"></a>3、使用桥接模式的代码</h4><h5 id="1、brand接口"><a href="#1、brand接口" class="headerlink" title="1、brand接口"></a>1、brand接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Brand</span> &#123;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span>;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、Phone【抽象类】"><a href="#2、Phone【抽象类】" class="headerlink" title="2、Phone【抽象类】"></a>2、Phone【抽象类】</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;<br>   <br>   <span class="hljs-comment">//组合品牌</span><br>   <span class="hljs-keyword">private</span> Brand brand;<br><br>   <span class="hljs-comment">//构造器</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Phone</span><span class="hljs-params">(Brand brand)</span> &#123;<br>      <span class="hljs-built_in">super</span>();<br>      <span class="hljs-built_in">this</span>.brand = brand;<br>   &#125;<br>   <br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-built_in">this</span>.brand.open();<br>   &#125;<br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>      brand.close();<br>   &#125;<br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>      brand.call();<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、Vivo"><a href="#3、Vivo" class="headerlink" title="3、Vivo"></a>3、Vivo</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vivo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Brand</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; Vivo手机开机 &quot;</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; Vivo手机关机 &quot;</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; Vivo手机打电话 &quot;</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4、XiaoMi"><a href="#4、XiaoMi" class="headerlink" title="4、XiaoMi"></a>4、XiaoMi</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaoMi</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Brand</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; 小米手机开机 &quot;</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; 小米手机关机 &quot;</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; 小米手机打电话 &quot;</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5、FoldedPhone"><a href="#5、FoldedPhone" class="headerlink" title="5、FoldedPhone"></a>5、FoldedPhone</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//折叠式手机类，继承 抽象类 Phone</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FoldedPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Phone</span> &#123;<br><br>   <span class="hljs-comment">//构造器</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">FoldedPhone</span><span class="hljs-params">(Brand brand)</span> &#123;<br>      <span class="hljs-built_in">super</span>(brand);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-built_in">super</span>.open();<br>      System.out.println(<span class="hljs-string">&quot; 折叠样式手机 &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-built_in">super</span>.close();<br>      System.out.println(<span class="hljs-string">&quot; 折叠样式手机 &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-built_in">super</span>.call();<br>      System.out.println(<span class="hljs-string">&quot; 折叠样式手机 &quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6、UpRightPhone"><a href="#6、UpRightPhone" class="headerlink" title="6、UpRightPhone"></a>6、UpRightPhone</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpRightPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Phone</span> &#123;<br>   <br>      <span class="hljs-comment">//构造器</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">UpRightPhone</span><span class="hljs-params">(Brand brand)</span> &#123;<br>         <span class="hljs-built_in">super</span>(brand);<br>      &#125;<br>      <br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-built_in">super</span>.open();<br>         System.out.println(<span class="hljs-string">&quot; 直立样式手机 &quot;</span>);<br>      &#125;<br>      <br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-built_in">super</span>.close();<br>         System.out.println(<span class="hljs-string">&quot; 直立样式手机 &quot;</span>);<br>      &#125;<br>      <br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-built_in">super</span>.call();<br>         System.out.println(<span class="hljs-string">&quot; 直立样式手机 &quot;</span>);<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="7、Client"><a href="#7、Client" class="headerlink" title="7、Client"></a>7、Client</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <br>      <span class="hljs-comment">//获取折叠式手机 (样式 + 品牌 )</span><br>      <br>      <span class="hljs-type">Phone</span> <span class="hljs-variable">phone1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FoldedPhone</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">XiaoMi</span>());<br>      <br>      phone1.open();<br>      phone1.call();<br>      phone1.close();<br>      <br>      System.out.println(<span class="hljs-string">&quot;=======================&quot;</span>);<br>      <br>      <span class="hljs-type">Phone</span> <span class="hljs-variable">phone2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FoldedPhone</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vivo</span>());<br>      <br>      phone2.open();<br>      phone2.call();<br>      phone2.close();<br>      <br>      System.out.println(<span class="hljs-string">&quot;==============&quot;</span>);<br>      <br>      <span class="hljs-type">UpRightPhone</span> <span class="hljs-variable">phone3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpRightPhone</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">XiaoMi</span>());<br>      <br>      phone3.open();<br>      phone3.call();<br>      phone3.close();<br>      <br>      System.out.println(<span class="hljs-string">&quot;==============&quot;</span>);<br>      <br>      <span class="hljs-type">UpRightPhone</span> <span class="hljs-variable">phone4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpRightPhone</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vivo</span>());<br>      <br>      phone4.open();<br>      phone4.call();<br>      phone4.close();<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、桥接模式的原理解析"><a href="#2、桥接模式的原理解析" class="headerlink" title="2、桥接模式的原理解析"></a>2、桥接模式的原理解析</h3><ol><li>桥接模式，也叫作桥梁模式，英文是Bridge Design Pattern。</li><li>在 GoF 的《设计模式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。”</li><li>关于桥接模式，很多书籍、资料中，还有另外一种理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。</li><li>GoF 给出的定义非常的简短，单凭这一句话，估计没几个人能看懂是什么意思。所以，我们通过 JDBC 驱动的例子来解释一下。JDBC 驱动是桥接模式的经典应用。我们先来看一下，如何利用 JDBC 驱动来查询数据库。具体的代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>); <span class="hljs-comment">// 加载及注册JDBC驱动程序</span><br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_password&quot;</span>;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url);<br><span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> con.createStatement();<br><span class="hljs-type">String</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from test&quot;</span>;<br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery(query);<br><span class="hljs-keyword">while</span> (rs.next()) &#123;<br>  rs.getString(<span class="hljs-number">1</span>);<br>  rs.getInt(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>如果我们想要把 MySQL 数据库换成 Oracle 数据库，只需要把第一行代码中的 com.mysql.jdbc.Driver 换成 oracle.jdbc.driver.OracleDriver 就可以了。当然，也有更灵活的实现方式，我们可以把需要加载的 Driver 类写到配置文件中，当程序启动的时候，自动从配置文件中加载，这样在切换数据库的时候，我们都不需要修改代码，只需要修改配置文件就可以了。</li><li>不管是改代码还是改配置，在项目中，从一个数据库切换到另一种数据库，都只需要改动很少的代码，或者完全不需要改动代码，那如此优雅的数据库切换是如何实现的呢？</li><li>先从 com.mysql.jdbc.Driver 这个类的代码看起。部分相关代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mysql.jdbc;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NonRegisteringDriver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.sql.Driver &#123;<br>  <span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      java.sql.DriverManager.registerDriver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>());<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException E) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Construct a new driver and register it with DriverManager</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@throws</span> SQLException if a database error occurs.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Driver</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>  <span class="hljs-comment">// Required for Class.forName().newInstance()</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结合 com.mysql.jdbc.Driver 的代码实现，可以发现，当执行 Class.forName(“com.mysql.jdbc.Driver”) 这条语句的时候，实际上是做了两件事情。第一件事情是要求 JVM 查找并加载指定的 Driver 类，第二件事情是执行该类的静态代码，也就是将 MySQL Driver 注册到 DriverManager 类中。</p><p>现在，我们再来看一下，DriverManager 类是干什么用的。具体的代码如下所示。当我们把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后，后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DriverManager</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span>  CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers =  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>();<br><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">static</span> &#123;<br>    loadInitialDrivers();<br>    println(<span class="hljs-string">&quot;JDBC DriverManager initialized&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerDriver</span><span class="hljs-params">(java.sql.Driver driver)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-keyword">if</span> (driver != <span class="hljs-literal">null</span>) &#123;<br>      registeredDrivers.addIfAbsent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DriverInfo</span>(driver));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">(String url, String user, String password)</span><br>      <span class="hljs-keyword">throws</span> SQLException &#123;<br>    java.util.<span class="hljs-type">Properties</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Properties();<br>    <span class="hljs-keyword">if</span> (user != <span class="hljs-literal">null</span>) &#123;<br>      info.put(<span class="hljs-string">&quot;user&quot;</span>, user);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (password != <span class="hljs-literal">null</span>) &#123;<br>      info.put(<span class="hljs-string">&quot;password&quot;</span>, password);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。那弄懂定义中“抽象”和“实现”两个概念，就是理解桥接模式的关键。那在 JDBC 这个例子中，什么是“抽象”？什么是“实现”呢？</p><p>实际上，JDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。JDBC 和 Driver 独立开发，通过对象之间的组合关系，组装在一起。JDBC 的所有逻辑操作，最终都委托给 Driver 来执行。</p><h3 id="3、桥接模式的应用举例"><a href="#3、桥接模式的应用举例" class="headerlink" title="3、桥接模式的应用举例"></a>3、桥接模式的应用举例</h3><p>在前面，有一个 API 接口监控告警的例子：根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如，SERVE（严重）级别的消息会通过“自动语音电话”告知相关人员。</p><p>在当时的代码实现中，关于发送告警信息那部分代码，只给出了粗略的设计，现在一块实现一下。先来看最简单、最直接的一种实现方式。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">NotificationEmergencyLevel</span> &#123;<br>  SEVERE,<br>  URGENCY,<br>  NORMAL,<br>  TRIVIAL<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Notification</span> &#123;<br>  <span class="hljs-keyword">private</span> List&lt;String&gt; emailAddresses;<br>  <span class="hljs-keyword">private</span> List&lt;String&gt; telephones;<br>  <span class="hljs-keyword">private</span> List&lt;String&gt; wechatIds;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Notification</span><span class="hljs-params">()</span> &#123;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEmailAddress</span><span class="hljs-params">(List&lt;String&gt; emailAddress)</span> &#123;<br>    <span class="hljs-built_in">this</span>.emailAddresses = emailAddress;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTelephones</span><span class="hljs-params">(List&lt;String&gt; telephones)</span> &#123;<br>    <span class="hljs-built_in">this</span>.telephones = telephones;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWechatIds</span><span class="hljs-params">(List&lt;String&gt; wechatIds)</span> &#123;<br>    <span class="hljs-built_in">this</span>.wechatIds = wechatIds;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(NotificationEmergencyLevel level, String message)</span> &#123;<br>    <span class="hljs-keyword">if</span> (level.equals(NotificationEmergencyLevel.SEVERE)) &#123;<br>      <span class="hljs-comment">// ...自动语音电话</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level.equals(NotificationEmergencyLevel.URGENCY)) &#123;<br>      <span class="hljs-comment">// ...发微信</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level.equals(NotificationEmergencyLevel.NORMAL)) &#123;<br>      <span class="hljs-comment">// ...发邮件</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level.equals(NotificationEmergencyLevel.TRIVIAL)) &#123;<br>      <span class="hljs-comment">// ...发邮件</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 在API监控告警的例子中，我们如下方式来使用Notification类：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorAlertHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AlertHandler</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ErrorAlertHandler</span><span class="hljs-params">(AlertRule rule, Notification notification)</span> &#123;<br>    <span class="hljs-built_in">super</span>(rule, notification);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(ApiStatInfo apiStatInfo)</span> &#123;<br>    <span class="hljs-keyword">if</span> (apiStatInfo.getErrorCount()<br>        &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;<br>      notification.notify(NotificationEmergencyLevel.SEVERE, <span class="hljs-string">&quot;...&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>Notification 类的代码实现有一个最明显的问题，那就是有很多 if-else 分支逻辑。实际上，如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能（增加更多 if-else 分支判断），那这样的设计问题并不大，没必要非得一定要摒弃 if-else 分支逻辑。</li><li>不过，Notification 的代码显然不符合这个条件。因为每个 if-else 分支中的代码逻辑都比较复杂，发送通知的所有逻辑都扎堆在 Notification 类中。我们知道，类的代码越多，就越难读懂，越难修改，维护的成本也就越高。很多设计模式都是试图将庞大的类拆分成更细小的类，然后再通过某种更合理的结构组装在一起。</li><li>针对 Notification 的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender 相关类）。其中，Notification 类相当于抽象，MsgSender 类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以<code>动态</code>地去指定（比如，通过读取配置来获取对应关系）。</li></ol><p>按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MsgSender</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TelephoneMsgSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MsgSender</span> &#123;<br>  <span class="hljs-keyword">private</span> List&lt;String&gt; telephones;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">TelephoneMsgSender</span><span class="hljs-params">(List&lt;String&gt; telephones)</span> &#123;<br>    <span class="hljs-built_in">this</span>.telephones = telephones;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailMsgSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MsgSender</span> &#123;<br>  <span class="hljs-comment">// 与TelephoneMsgSender代码结构类似，所以省略...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WechatMsgSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MsgSender</span> &#123;<br>  <span class="hljs-comment">// 与TelephoneMsgSender代码结构类似，所以省略...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Notification</span> &#123;<br>  <span class="hljs-keyword">protected</span> MsgSender msgSender;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Notification</span><span class="hljs-params">(MsgSender msgSender)</span> &#123;<br>    <span class="hljs-built_in">this</span>.msgSender = msgSender;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SevereNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">SevereNotification</span><span class="hljs-params">(MsgSender msgSender)</span> &#123;<br>    <span class="hljs-built_in">super</span>(msgSender);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message)</span> &#123;<br>    msgSender.send(message);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UrgencyNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br>  <span class="hljs-comment">// 与SevereNotification代码结构类似，所以省略...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br>  <span class="hljs-comment">// 与SevereNotification代码结构类似，所以省略...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrivialNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br>  <span class="hljs-comment">// 与SevereNotification代码结构类似，所以省略...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、桥接模式的注意事项和细节"><a href="#4、桥接模式的注意事项和细节" class="headerlink" title="4、桥接模式的注意事项和细节"></a>4、桥接模式的注意事项和细节</h3><ol><li>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。</li><li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。</li><li>桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本</li><li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程</li><li>桥接模式要求**正确识别出系统中两个独立变化的维度(抽象、和实现)**，因此其使用范围有一定的局限性，即需要有这样的应用场景。</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>结构型</tag>
      
      <tag>代理</tag>
      
      <tag>桥接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02-创建型-工厂&amp;建造者&amp;原型</title>
    <link href="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/"/>
    <url>/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/</url>
    
    <content type="html"><![CDATA[<h2 id="一、工厂模式【常用】"><a href="#一、工厂模式【常用】" class="headerlink" title="一、工厂模式【常用】"></a>一、工厂模式【常用】</h2><ol><li>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。</li><li>在这三种细分的工厂模式中，简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。所以，重点是前两种工厂模式。对于抽象工厂，稍微了解一下即可。</li></ol><h3 id="1、简单工厂"><a href="#1、简单工厂" class="headerlink" title="1、简单工厂"></a>1、简单工厂</h3><p>什么是简单工厂模式？</p><p>简单来说，就是定义一个工厂类，它可以根据不同的参数返回不同类的实例，被创建的实例通常都具有共同的父类。</p><p>通过一个例子来解释一下简单工厂。在下面这段代码中，我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>  <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<br>             <span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>    <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>    <span class="hljs-keyword">return</span> ruleConfig;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>    <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及 parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。重构之后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> createParser(ruleConfigFileExtension);<br>    <span class="hljs-keyword">if</span> (parser == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<br>              <span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>    <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>    <span class="hljs-keyword">return</span> ruleConfig;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>    <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">(String configFormat)</span> &#123;<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> parser;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了让类的职责更加单一(<strong>设计模式原则中的单一职责</strong>，)、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>  <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> RuleConfigParserFactory.createParser(ruleConfigFileExtension);<br>    <span class="hljs-keyword">if</span> (parser == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<br>              <span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>    <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>    <span class="hljs-keyword">return</span> ruleConfig;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>    <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigParserFactory</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">(String configFormat)</span> &#123;<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> parser;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。</li><li>实际上，如果 parser 可以复用，为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。在接下来的讲解中，我们把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作简单工厂模式的第二种实现方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigParserFactory</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">static</span> &#123;<br>    cachedParsers.put(<span class="hljs-string">&quot;json&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>());<br>    cachedParsers.put(<span class="hljs-string">&quot;xml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>());<br>    cachedParsers.put(<span class="hljs-string">&quot;yaml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>());<br>    cachedParsers.put(<span class="hljs-string">&quot;properties&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>());<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">(String configFormat)</span> &#123;<br>    <span class="hljs-keyword">if</span> (configFormat == <span class="hljs-literal">null</span> || configFormat.isEmpty()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//返回null还是IllegalArgumentException全凭你自己说了算</span><br>    &#125;<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> cachedParsers.get(configFormat.toLowerCase());<br>    <span class="hljs-keyword">return</span> parser;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>对于上面两种简单工厂模式的实现方法，如果我们要添加新的 parser，那势必要改动到 RuleConfigParserFactory 的代码，那这是不是违反开闭原则呢？实际上，如果不是需要频繁地添加新的 parser，只是偶尔修改一下 RuleConfigParserFactory 代码，稍微不符合开闭原则，也是完全可以接受的。</li><li>除此之外，在 RuleConfigParserFactory 的第一种代码实现中，有一组 if 分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？实际上，如果 if 分支并不是很多，代码中有 if 分支也是完全可以接受的。应用多态或设计模式来替代 if 分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合<strong>开闭原则</strong>，但也增加了类的个数，牺牲了代码的可读性。</li></ol><h3 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h3><p>看一个需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪pizza、 北京的胡椒pizza 或者是伦敦的奶酪pizza、伦敦的胡椒pizza。</p><p>如何实现？</p><p>思路一：使用简单工厂模式，创建不同的简单工厂类，比如BJPizzaSimpleFactory、 LDPizzaSimpleFactory 等等.从当前这个案例来说，也是可以的，但是考虑到项目的 规模，以及软件的可维护性、可扩展性并不是特别好</p><p>思路二：使用工厂模式</p><p>工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点 餐子类中具体实现。 </p><p>工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。</p><p>再接着上述简单工厂模式的例子，若是非要去掉if呢，怎么办？将代码重构后，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>  IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YamlRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PropertiesRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模式比起简单工厂模式更加符合开闭原则。</p><p>但是上述代码存在很大的问题。问题存在于这些工厂类的使用上。接下来，我们看一下，如何用这些工厂类来实现 RuleConfigSource 的 load() 函数。具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>  <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br><br>    <span class="hljs-type">IRuleConfigParserFactory</span> <span class="hljs-variable">parserFactory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parserFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParserFactory</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parserFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParserFactory</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parserFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParserFactory</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parserFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParserFactory</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);<br>    &#125;<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> parserFactory.createParser();<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>    <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>    <span class="hljs-keyword">return</span> ruleConfig;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>    <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 load() 函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。</li><li>我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。这段话听起来有点绕，代码实现出来，一看就能明白。其中，RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，getParserFactory() 返回的是缓存好的单例工厂对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>  <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br><br>    <span class="hljs-type">IRuleConfigParserFactory</span> <span class="hljs-variable">parserFactory</span> <span class="hljs-operator">=</span> RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);<br>    <span class="hljs-keyword">if</span> (parserFactory == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);<br>    &#125;<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> parserFactory.createParser();<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>    <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>    <span class="hljs-keyword">return</span> ruleConfig;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>    <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//因为工厂类只包含方法，不包含成员变量，完全可以复用，</span><br><span class="hljs-comment">//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigParserFactoryMap</span> &#123; <span class="hljs-comment">//工厂的工厂</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">static</span> &#123;<br>    cachedFactories.put(<span class="hljs-string">&quot;json&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParserFactory</span>());<br>    cachedFactories.put(<span class="hljs-string">&quot;xml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParserFactory</span>());<br>    cachedFactories.put(<span class="hljs-string">&quot;yaml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParserFactory</span>());<br>    cachedFactories.put(<span class="hljs-string">&quot;properties&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParserFactory</span>());<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IRuleConfigParserFactory <span class="hljs-title function_">getParserFactory</span><span class="hljs-params">(String type)</span> &#123;<br>    <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span> || type.isEmpty()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-type">IRuleConfigParserFactory</span> <span class="hljs-variable">parserFactory</span> <span class="hljs-operator">=</span> cachedFactories.get(type.toLowerCase());<br>    <span class="hljs-keyword">return</span> parserFactory;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则。</li><li>实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性，而且，每个 Factory 类只是做简单的 new 操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。</li></ol><p>问题来了：什么时候用简单工厂模式，什么时候用工厂模式？</p><ol><li>前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。</li><li>基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</li><li>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。</li></ol><h3 id="3、抽象工厂"><a href="#3、抽象工厂" class="headerlink" title="3、抽象工厂"></a>3、抽象工厂</h3><p>抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类 </p><p>抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。</p><p>从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。 </p><p>将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以 根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇， 更利于代码的维护和扩展。</p><p>抽象工厂没有前两者常用，简单了解即可。</p><p>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">针对规则配置的解析器：基于接口IRuleConfigParser<br>JsonRuleConfigParser<br>XmlRuleConfigParser<br>YamlRuleConfigParser<br>PropertiesRuleConfigParser<br><br>针对系统配置的解析器：基于接口ISystemConfigParser<br>JsonSystemConfigParser<br>XmlSystemConfigParser<br>YamlSystemConfigParser<br>PropertiesSystemConfigParser<br></code></pre></td></tr></table></figure><ol><li>针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编写一个工厂类，也就是要编写 8 个工厂类。如果我们未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。而我们知道，过多的类也会让系统难维护。这个问题该怎么解决呢？</li><li>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IConfigParserFactory</span> &#123;<br>  IRuleConfigParser <span class="hljs-title function_">createRuleParser</span><span class="hljs-params">()</span>;<br>  ISystemConfigParser <span class="hljs-title function_">createSystemParser</span><span class="hljs-params">()</span>;<br>  <span class="hljs-comment">//此处可以扩展新的parser类型，比如IBizConfigParser</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IConfigParserFactory</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createRuleParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> ISystemConfigParser <span class="hljs-title function_">createSystemParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonSystemConfigParser</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IConfigParserFactory</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createRuleParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> ISystemConfigParser <span class="hljs-title function_">createSystemParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlSystemConfigParser</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span><br></code></pre></td></tr></table></figure><h3 id="4、DI容器"><a href="#4、DI容器" class="headerlink" title="4、DI容器"></a>4、DI容器</h3><p>当创建对象是一个“大工程”的时候，我们一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。那何为“大工程”呢？上面我们讲了两种情况，一种是创建过程涉及复杂的 if-else 分支判断，另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程。</p><p>今天，我们再来讲一个创建对象的“大工程”，依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称 DI 容器。</p><p>DI 容器跟我们讲的工厂模式又有何区别和联系？DI 容器的核心功能有哪些，以及如何实现一个简单的 DI 容器？</p><h4 id="1、工厂模式和DI容器有何区别"><a href="#1、工厂模式和DI容器有何区别" class="headerlink" title="1、工厂模式和DI容器有何区别"></a>1、工厂模式和DI容器有何区别</h4><ol><li>实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</li><li>DI 容器相对于我们上面讲的工厂模式的例子来说，它处理的是更大的对象创建工程。上面讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。</li><li>除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。接下来，我们就详细讲讲，一个简单的 DI 容器应该包含哪些核心功能。</li></ol><h4 id="2、DI容器的核心功能"><a href="#2、DI容器的核心功能" class="headerlink" title="2、DI容器的核心功能"></a>2、DI容器的核心功能</h4><p>一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。</p><blockquote><p>配置解析</p></blockquote><ol><li>在上面讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，我们需要通过一种形式，让应用告知 DI 容器要创建哪些对象。这种形式就是我们要讲的配置。</li><li>我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。</li><li>下面是一个典型的 Spring 容器的配置文件。Spring 容器读取这个配置文件，解析出要创建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：rateLimiter 依赖 redisCounter。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiter</span> &#123;<br>  <span class="hljs-keyword">private</span> RedisCounter redisCounter;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">RateLimiter</span><span class="hljs-params">(RedisCounter redisCounter)</span> &#123;<br>    <span class="hljs-built_in">this</span>.redisCounter = redisCounter;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisCounter</span> &#123;<br>  <span class="hljs-keyword">private</span> String ipAddress;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisCounter</span><span class="hljs-params">(String ipAddress, <span class="hljs-type">int</span> port)</span> &#123;<br>    <span class="hljs-built_in">this</span>.ipAddress = ipAddress;<br>    <span class="hljs-built_in">this</span>.port = port;<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br>配置文件beans.xml：<br>&lt;beans&gt;<br>   &lt;bean id=<span class="hljs-string">&quot;rateLimiter&quot;</span> class=<span class="hljs-string">&quot;com.zb.RateLimiter&quot;</span>&gt;<br>      &lt;constructor-arg ref=<span class="hljs-string">&quot;redisCounter&quot;</span>/&gt;<br>   &lt;/bean&gt;<br> <br>   &lt;bean id=<span class="hljs-string">&quot;redisCounter&quot;</span> class=<span class="hljs-string">&quot;com.zb.redisCounter&quot;</span>&gt;<br>     &lt;constructor-arg type=<span class="hljs-string">&quot;String&quot;</span> value=<span class="hljs-string">&quot;127.0.0.1&quot;</span>&gt;<br>     &lt;constructor-arg type=<span class="hljs-string">&quot;int&quot;</span> value=<span class="hljs-number">1234</span>&gt;<br>   &lt;/bean&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><blockquote><p>对象创建</p></blockquote><ol><li>在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。</li><li>你可能会说，如果要创建的类对象非常多，BeansFactory 中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）呢？实际上并不会。待会讲到 DI 容器的具体实现的时候，我们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。</li></ol><blockquote><p>对象的声明周期管理</p></blockquote><ol><li>上面我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope=prototype 表示返回新创建的对象，scope=singleton 表示返回单例对象。</li><li>除此之外，我们还可以配置对象是否支持懒加载。如果 lazy-init=true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好。</li><li>不仅如此，我们还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。</li></ol><h3 id="5、实现简单的DI容器"><a href="#5、实现简单的DI容器" class="headerlink" title="5、实现简单的DI容器"></a>5、实现简单的DI容器</h3><p>用 Java 语言来实现一个简单的 DI 容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象。</p><h4 id="1、最小原型设计"><a href="#1、最小原型设计" class="headerlink" title="1、最小原型设计"></a>1、最小原型设计</h4><p>因为我们主要是讲解设计模式，所以，在今天的讲解中，我们只实现一个 DI 容器的最小原型。像 Spring 框架这样的 DI 容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">配置文件beans.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rateLimiter&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zb.RateLimiter&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;redisCounter&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;redisCounter&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zb.redisCounter&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span> <span class="hljs-attr">lazy-init</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;127.0.0.1&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">1234</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>&lt;/bean<br></code></pre></td></tr></table></figure><p>最小原型的使用方式跟 Spring 框架非常类似，示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<br>            <span class="hljs-string">&quot;beans.xml&quot;</span>);<br>    <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> (RateLimiter) applicationContext.getBean(<span class="hljs-string">&quot;rateLimiter&quot;</span>);<br>    rateLimiter.test();<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、提供执行入口"><a href="#2、提供执行入口" class="headerlink" title="2、提供执行入口"></a>2、提供执行入口</h4><p>面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类。通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext 和 ClassPathXmlApplicationContext。其中，ApplicationContext 是接口，ClassPathXmlApplicationContext 是接口的实现类。两个类具体实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApplicationContext</span> &#123;<br>  Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanId)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContext</span> &#123;<br>  <span class="hljs-keyword">private</span> BeansFactory beansFactory;<br>  <span class="hljs-keyword">private</span> BeanConfigParser beanConfigParser;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPathXmlApplicationContext</span><span class="hljs-params">(String configLocation)</span> &#123;<br>    <span class="hljs-built_in">this</span>.beansFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeansFactory</span>();<br>    <span class="hljs-built_in">this</span>.beanConfigParser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanConfigParser</span>();<br>    loadBeanDefinitions(configLocation);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(String configLocation)</span> &#123;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      in = <span class="hljs-built_in">this</span>.getClass().getResourceAsStream(<span class="hljs-string">&quot;/&quot;</span> + configLocation);<br>      <span class="hljs-keyword">if</span> (in == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Can not find config file: &quot;</span> + configLocation);<br>      &#125;<br>      List&lt;BeanDefinition&gt; beanDefinitions = beanConfigParser.parse(in);<br>      beansFactory.addBeanDefinitions(beanDefinitions);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">if</span> (in != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          in.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> log error</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanId)</span> &#123;<br>    <span class="hljs-keyword">return</span> beansFactory.getBean(beanId);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的代码中，我们可以看出，ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程：从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后，BeansFactory 根据 BeanDefinition 来创建对象。</p><h4 id="3、配置文件解析"><a href="#3、配置文件解析" class="headerlink" title="3、配置文件解析"></a>3、配置文件解析</h4><p>配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。配置文件的解析比较繁琐，不涉及我们要讲的理论知识，不是我们讲解的重点，所以这里我只给出两个类的大致设计思路，并未给出具体的实现代码。具体的代码框架如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanConfigParser</span> &#123;<br>  List&lt;BeanDefinition&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(InputStream inputStream)</span>;<br>  List&lt;BeanDefinition&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(String configContent)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlBeanConfigParser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanConfigParser</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> List&lt;BeanDefinition&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(InputStream inputStream)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>...</span><br>    <span class="hljs-keyword">return</span> parse(content);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> List&lt;BeanDefinition&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(String configContent)</span> &#123;<br>    List&lt;BeanDefinition&gt; beanDefinitions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>...</span><br>    <span class="hljs-keyword">return</span> beanDefinitions;<br>  &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanDefinition</span> &#123;<br>  <span class="hljs-keyword">private</span> String id;<br>  <span class="hljs-keyword">private</span> String className;<br>  <span class="hljs-keyword">private</span> List&lt;ConstructorArg&gt; constructorArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">Scope</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> Scope.SINGLETON;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">lazyInit</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// 省略必要的getter/setter/constructors</span><br> <br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> scope.equals(Scope.SINGLETON);<br>  &#125;<br><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Scope</span> &#123;<br>    SINGLETON,<br>    PROTOTYPE<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstructorArg</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isRef;<br>    <span class="hljs-keyword">private</span> Class type;<br>    <span class="hljs-keyword">private</span> Object arg;<br>    <span class="hljs-comment">// 省略必要的getter/setter/constructors</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、核心工厂类设计"><a href="#4、核心工厂类设计" class="headerlink" title="4、核心工厂类设计"></a>4、核心工厂类设计</h4><ol><li>最后，我们来看，BeansFactory 是如何设计和实现的。这也是我们这个 DI 容器最核心的一个类了。它负责根据从配置文件解析得到的 BeanDefinition 来创建对象。</li><li>如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中，下次再请求此对象的时候，直接从 map 中取出返回，不需要重新创建。如果对象的 scope 属性是 prototype，那每次请求对象，BeansFactory 都会创建一个新的对象返回。</li><li>实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的==反射==语法：<code>一种动态加载类和创建对象的机制</code>。我们知道，JVM 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 帮我们自动完成了，我们需要利用 Java 提供的反射语法自己去编写代码。</li><li>搞清楚了反射的原理，BeansFactory 的代码就不难看懂了。具体代码实现如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeansFactory</span> &#123;<br>  <span class="hljs-keyword">private</span> ConcurrentHashMap&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBeanDefinitions</span><span class="hljs-params">(List&lt;BeanDefinition&gt; beanDefinitionList)</span> &#123;<br>    <span class="hljs-keyword">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;<br>      <span class="hljs-built_in">this</span>.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;<br>      <span class="hljs-keyword">if</span> (beanDefinition.isLazyInit() == <span class="hljs-literal">false</span> &amp;&amp; beanDefinition.isSingleton()) &#123;<br>        createBean(beanDefinition);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanId)</span> &#123;<br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> beanDefinitions.get(beanId);<br>    <span class="hljs-keyword">if</span> (beanDefinition == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchBeanDefinitionException</span>(<span class="hljs-string">&quot;Bean is not defined: &quot;</span> + beanId);<br>    &#125;<br>    <span class="hljs-keyword">return</span> createBean(beanDefinition);<br>  &#125;<br><br>  <span class="hljs-meta">@VisibleForTesting</span><br>  <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(BeanDefinition beanDefinition)</span> &#123;<br>    <span class="hljs-keyword">if</span> (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;<br>      <span class="hljs-keyword">return</span> singletonObjects.get(beanDefinition.getId());<br>    &#125;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">Class</span> <span class="hljs-variable">beanClass</span> <span class="hljs-operator">=</span> Class.forName(beanDefinition.getClassName());<br>      List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs();<br>      <span class="hljs-keyword">if</span> (args.isEmpty()) &#123;<br>        bean = beanClass.newInstance();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        Class[] argClasses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[args.size()];<br>        Object[] argObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[args.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.size(); ++i) &#123;<br>          BeanDefinition.<span class="hljs-type">ConstructorArg</span> <span class="hljs-variable">arg</span> <span class="hljs-operator">=</span> args.get(i);<br>          <span class="hljs-keyword">if</span> (!arg.getIsRef()) &#123;<br>            argClasses[i] = arg.getType();<br>            argObjects[i] = arg.getArg();<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">refBeanDefinition</span> <span class="hljs-operator">=</span> beanDefinitions.get(arg.getArg());<br>            <span class="hljs-keyword">if</span> (refBeanDefinition == <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchBeanDefinitionException</span>(<span class="hljs-string">&quot;Bean is not defined: &quot;</span> + arg.getArg());<br>            &#125;<br>            argClasses[i] = Class.forName(refBeanDefinition.getClassName());<br>            argObjects[i] = createBean(refBeanDefinition);<br>          &#125;<br>        &#125;<br>        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | IllegalAccessException<br>            | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationFailureException</span>(<span class="hljs-string">&quot;&quot;</span>, e);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span> &amp;&amp; beanDefinition.isSingleton()) &#123;<br>      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);<br>      <span class="hljs-keyword">return</span> singletonObjects.get(beanDefinition.getId());<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>执行入口那里调用<code>addBeanDefinitions</code></li><li>然后<code>addBeanDefinitions</code>再调用createBean利用反射创建对象，如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中</li><li>最后最小原型设计那里再调用getBean从singletonObjects 获取对象。</li></ol><h2 id="二、建造者模式【常用】"><a href="#二、建造者模式【常用】" class="headerlink" title="二、建造者模式【常用】"></a>二、建造者模式【常用】</h2><p>建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。比如，有没有考虑过这样几个问题：直接使用构造函数或者配合 set 方法就能创建对象，为什么还需要建造者模式来创建呢？建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？</p><p>基本介绍： 建造者模式（Builder Pattern） 又叫生成器模式，是一种对象构建模式。它可以 将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方 法可以构造出不同表现（属性）的对象。建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象 的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p><h3 id="1、为何需要建造者模式？"><a href="#1、为何需要建造者模式？" class="headerlink" title="1、为何需要建造者模式？"></a>1、为何需要建造者模式？</h3><ol><li>在平时的开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。但是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？</li><li>假设有这样一道设计面试题：我们需要定义一个资源池配置类 ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个 ResourcePoolConfig 类。</li></ol><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923155455175.png"></p><p>只要稍微有点开发经验，那实现这样一个类并不是件难事。最常见、最容易想到的实现思路如下代码所示。因为 maxTotal、maxIdle、minIdle 不是必填变量，所以在创建 ResourcePoolConfig 对象的时候，我们通过往构造函数中，给这几个参数传递 null 值，来表示使用默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourcePoolConfig</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_TOTAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MIN_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxTotal</span> <span class="hljs-operator">=</span> DEFAULT_MAX_TOTAL;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxIdle</span> <span class="hljs-operator">=</span> DEFAULT_MAX_IDLE;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">minIdle</span> <span class="hljs-operator">=</span> DEFAULT_MIN_IDLE;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourcePoolConfig</span><span class="hljs-params">(String name, Integer maxTotal, Integer maxIdle, Integer minIdle)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;name should not be empty.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.name = name;<br><br>    <span class="hljs-keyword">if</span> (maxTotal != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (maxTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxTotal should be positive.&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.maxTotal = maxTotal;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (maxIdle != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (maxIdle &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxIdle should not be negative.&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.maxIdle = maxIdle;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (minIdle != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (minIdle &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;minIdle should not be negative.&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.minIdle = minIdle;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//...省略getter方法...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在，ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 bug。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 参数太多，导致可读性差、参数可能传递错误</span><br><span class="hljs-type">ResourcePoolConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcePoolConfig</span>(<span class="hljs-string">&quot;dbconnectionpool&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">8</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span> , <span class="hljs-literal">true</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>，<span class="hljs-literal">false</span>， <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>解决这个问题的办法应该也已经想到了，那就是用 set() 函数来给成员变量赋值，以替代冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项 name 是必填的，所以我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 maxTotal、maxIdle、minIdle 都不是必填的，所以我们通过 set() 函数来设置，让使用者自主选择填写或者不填写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourcePoolConfig</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_TOTAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MIN_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxTotal</span> <span class="hljs-operator">=</span> DEFAULT_MAX_TOTAL;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxIdle</span> <span class="hljs-operator">=</span> DEFAULT_MAX_IDLE;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">minIdle</span> <span class="hljs-operator">=</span> DEFAULT_MIN_IDLE;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourcePoolConfig</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;name should not be empty.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMaxTotal</span><span class="hljs-params">(<span class="hljs-type">int</span> maxTotal)</span> &#123;<br>    <span class="hljs-keyword">if</span> (maxTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxTotal should be positive.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.maxTotal = maxTotal;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMaxIdle</span><span class="hljs-params">(<span class="hljs-type">int</span> maxIdle)</span> &#123;<br>    <span class="hljs-keyword">if</span> (maxIdle &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxIdle should not be negative.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.maxIdle = maxIdle;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMinIdle</span><span class="hljs-params">(<span class="hljs-type">int</span> minIdle)</span> &#123;<br>    <span class="hljs-keyword">if</span> (minIdle &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;minIdle should not be negative.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.minIdle = minIdle;<br>  &#125;<br>  <span class="hljs-comment">//...省略getter方法...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们来看新的 ResourcePoolConfig 类该如何使用。我写了一个示例代码，如下所示。没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ResourcePoolConfig使用举例</span><br><span class="hljs-type">ResourcePoolConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcePoolConfig</span>(<span class="hljs-string">&quot;dbconnectionpool&quot;</span>);<br>config.setMaxTotal(<span class="hljs-number">16</span>);<br>config.setMaxIdle(<span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><p>至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过 set() 方法设置可选配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。</p><ul><li>我们刚刚讲到，name 是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。</li><li>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。</li><li>如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。</li></ul><p>为了解决这些问题，建造者模式就派上用场了。我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了。我们用建造者模式重新实现了上面的需求，具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourcePoolConfig</span> &#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxTotal;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxIdle;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> minIdle;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">ResourcePoolConfig</span><span class="hljs-params">(Builder builder)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = builder.name;<br>    <span class="hljs-built_in">this</span>.maxTotal = builder.maxTotal;<br>    <span class="hljs-built_in">this</span>.maxIdle = builder.maxIdle;<br>    <span class="hljs-built_in">this</span>.minIdle = builder.minIdle;<br>  &#125;<br>  <span class="hljs-comment">//...省略getter方法...</span><br><br>  <span class="hljs-comment">//我们将Builder类设计成了ResourcePoolConfig的内部类。</span><br>  <span class="hljs-comment">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_TOTAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MIN_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxTotal</span> <span class="hljs-operator">=</span> DEFAULT_MAX_TOTAL;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxIdle</span> <span class="hljs-operator">=</span> DEFAULT_MAX_IDLE;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">minIdle</span> <span class="hljs-operator">=</span> DEFAULT_MIN_IDLE;<br><br>    <span class="hljs-keyword">public</span> ResourcePoolConfig <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span><br>      <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (maxIdle &gt; maxTotal) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcePoolConfig</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>      <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.name = name;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setMaxTotal</span><span class="hljs-params">(<span class="hljs-type">int</span> maxTotal)</span> &#123;<br>      <span class="hljs-keyword">if</span> (maxTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.maxTotal = maxTotal;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setMaxIdle</span><span class="hljs-params">(<span class="hljs-type">int</span> maxIdle)</span> &#123;<br>      <span class="hljs-keyword">if</span> (maxIdle &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.maxIdle = maxIdle;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setMinIdle</span><span class="hljs-params">(<span class="hljs-type">int</span> minIdle)</span> &#123;<br>      <span class="hljs-keyword">if</span> (minIdle &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.minIdle = minIdle;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span><br><span class="hljs-type">ResourcePoolConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcePoolConfig</span>.Builder()<br>        .setName(<span class="hljs-string">&quot;dbconnectionpool&quot;</span>)<br>        .setMaxTotal(<span class="hljs-number">16</span>)<br>        .setMaxIdle(<span class="hljs-number">10</span>)<br>        .setMinIdle(<span class="hljs-number">12</span>)<br>        .build();<br></code></pre></td></tr></table></figure><p>实际上，使用建造者模式创建对象，还可以避免对象存在无效状态。无效状态是指对象没有实例化完全，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Rectangle</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectange</span>(); <span class="hljs-comment">// r is invalid</span><br>r.setWidth(<span class="hljs-number">2</span>); <span class="hljs-comment">// r is invalid</span><br>r.setHeight(<span class="hljs-number">3</span>); <span class="hljs-comment">// r is valid</span><br></code></pre></td></tr></table></figure><ol><li>为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。==(建造者主要解决参数过多、参数检验、控制对象创建后不可变的问题)==</li><li>实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露 set() 方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍。</li></ol><h3 id="2、与工厂模式有何区别？"><a href="#2、与工厂模式有何区别？" class="headerlink" title="2、与工厂模式有何区别？"></a>2、与工厂模式有何区别？</h3><ol><li>从上面的讲解中，我们可以看出，建造者模式是让建造者类来负责对象的创建工作。上面讲到的工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？</li><li>实际上，工厂模式是用来<code>创建不同但是相关类型的对象</code>（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建<code>一种类型的复杂对象</code>，通过设置不同的可选参数，“定制化”地创建不同的对象。</li></ol><p>网上有一个经典的例子很好地解释了两者的区别:</p><blockquote><p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p></blockquote><h2 id="三、原型模式【不常用】"><a href="#三、原型模式【不常用】" class="headerlink" title="三、原型模式【不常用】"></a>三、原型模式【不常用】</h2><p>现有如下需求：现在有一只羊tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和tom 羊 属性完全相同的10只羊。</p><p>思路：Java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以 将一个Java对象复制一份，但是需要实现clone的Java类必须要实现一个接口Cloneable， 该接口表示该类能够复制且具有复制的能力 =&gt; 原型模式</p><h3 id="1、原型模式原理与应用"><a href="#1、原型模式原理与应用" class="headerlink" title="1、原型模式原理与应用"></a>1、原型模式原理与应用</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。</p><ol><li>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。</li><li>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</li></ol><blockquote><p>举个例子</p></blockquote><ol><li>假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建立一个散列表索引。</li><li>如果你熟悉的是 Java 语言，可以直接使用语言中提供的 HashMap 容器来实现。其中，HashMap 的 key 为搜索关键词，value 为关键词详细信息（比如搜索次数）。我们只需要将数据从数据库中读取出来，放入 HashMap 就可以了。</li><li>不过，我们还有另外一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对 v2 版本的数据进行更新，得到 v3 版本的数据。这里我们假设只有更新和新添关键词，没有删除关键词的行为。</li></ol><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923164243728.png"></p><ol><li>为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统 A 需要定期根据数据库中的数据，更新内存中的索引和数据。</li><li>我们该如何实现这个需求呢？实际上，也不难。我们只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta，从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是找出 Va 版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散列表中。</li><li>按照这个设计思路，我给出的示例代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">private</span> ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastUpdateTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到currentKeywords中</span><br>    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">maxNewUpdatedTime</span> <span class="hljs-operator">=</span> lastUpdateTime;<br>    <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>      <span class="hljs-keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;<br>        maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>      &#125;<br>      <span class="hljs-keyword">if</span> (currentKeywords.containsKey(searchWord.getKeyword())) &#123;<br>        currentKeywords.replace(searchWord.getKeyword(), searchWord);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        currentKeywords.put(searchWord.getKeyword(), searchWord);<br>      &#125;<br>    &#125;<br><br>    lastUpdateTime = maxNewUpdatedTime;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">(<span class="hljs-type">long</span> lastUpdateTime)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，现在，我们有一个特殊的要求：任何时刻，系统 A 中的所有数据都必须是同一个版本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。那刚刚的更新方式就不能满足这个要求了（因为数据很多，一个一个的for循环肯定会出现不同数据版本的问题）。除此之外，我们还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据。</p><ol><li>那我们该如何实现现在这个需求呢？</li><li>实际上，也不难。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在。</li><li>按照这个设计思路，示例代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>    HashMap&lt;String, SearchWord&gt; newKeywords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 从数据库中取出所有的数据，放入到newKeywords中</span><br>    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords();<br>    <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>      newKeywords.put(searchWord.getKeyword(), searchWord);<br>    &#125;<br><br>    currentKeywords = newKeywords;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出所有的数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>不过，在上面的代码实现中，newKeywords 构建的成本比较高。我们需要将这 10 万条数据从数据库中读出，然后计算哈希值，构建 newKeywords。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了。</li><li>我们拷贝 currentKeywords 数据到 newKeywords 中，然后从数据库中只捞出新增或者有更新的关键词，更新到 newKeywords 中。而相对于 10 万条数据来说，每次新增或者更新的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。</li><li>按照这个设计思路，我给出的示例代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastUpdateTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 原型模式就这么简单，拷贝已有对象的数据，更新少量差值</span><br>    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();<br><br>    <span class="hljs-comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br>    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">maxNewUpdatedTime</span> <span class="hljs-operator">=</span> lastUpdateTime;<br>    <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>      <span class="hljs-keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;<br>        maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>      &#125;<br>      <span class="hljs-keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;<br>        <span class="hljs-type">SearchWord</span> <span class="hljs-variable">oldSearchWord</span> <span class="hljs-operator">=</span> newKeywords.get(searchWord.getKeyword());<br>        oldSearchWord.setCount(searchWord.getCount());<br>        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        newKeywords.put(searchWord.getKeyword(), searchWord);<br>      &#125;<br>    &#125;<br><br>    lastUpdateTime = maxNewUpdatedTime;<br>    currentKeywords = newKeywords;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">(<span class="hljs-type">long</span> lastUpdateTime)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>这里利用了 Java 中的 clone() 语法来复制一个对象。如果你熟悉的语言没有这个语法，那把数据从 currentKeywords 中一个个取出来，然后再重新计算哈希值，放入到 newKeywords 中也是可以接受的。毕竟，最耗时的还是从数据库中取数据的操作。相对于数据库的 IO 操作来说，内存操作和 CPU 计算的耗时都是可以忽略的。</li><li>不过，不知道你有没有发现，实际上，刚刚的代码实现是有问题的。要弄明白到底有什么问题，我们需要先了解另外两个概念：深拷贝（Deep Copy）和浅拷贝（Shallow Copy）。</li></ol><h3 id="2、原型模式的实现方式：深拷贝与浅拷贝"><a href="#2、原型模式的实现方式：深拷贝与浅拷贝" class="headerlink" title="2、原型模式的实现方式：深拷贝与浅拷贝"></a>2、原型模式的实现方式：深拷贝与浅拷贝</h3><blockquote><p>拷贝的引入</p></blockquote><p>1、引用拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;Taylor&quot;</span>,<span class="hljs-number">26</span>);<br><span class="hljs-type">Teacher</span> <span class="hljs-variable">otherteacher</span> <span class="hljs-operator">=</span> teacher;<br>System.out.println(teacher);<br>System.out.println(otherteacher);<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">blog.Teacher@355da254<br>blog.Teacher@355da254<br></code></pre></td></tr></table></figure><p>由输出结果可以看出，二者的地址值是相同的，那么肯定就是同一个对象，teacher和otherteacher只是不同的引用而已。</p><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923165539504.png" alt="引用拷贝"></p><p>2、对象拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;Swift&quot;</span>,<span class="hljs-number">26</span>);<br><span class="hljs-type">Teacher</span> <span class="hljs-variable">otherteacher</span> <span class="hljs-operator">=</span> (Teacher)teacher.clone();<br>System.out.println(teacher);<br>System.out.println(otherteacher);<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">blog.Teacher@355da254<br>blog.Teacher@4dc63996<br></code></pre></td></tr></table></figure><p>由结果可以看出，地址值不同，也就是说二者是不同的对象，而不是把原对象的地址赋给了一个新的引用变量,这就叫做对象拷贝。</p><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923165730368.png" alt="对象拷贝"></p><p>==注：深拷贝和浅拷贝都是对象拷贝==</p><blockquote><p>浅拷贝</p></blockquote><ul><li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值拷贝，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据</li><li>对于数据类型是引用数据类型的成员变量(也就是子对象，或者数组啥的)，也就是只是将该成员变量的引用值（引用拷贝【并发引用传递，Java本质还是值传递】）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</li></ul><blockquote><p>深拷贝</p></blockquote><ul><li>对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li><li>也就是说浅拷贝对于子对象只是拷贝了引用值，并没有真正的拷贝整个对象。</li></ul><p>在内存中，用散列表组织的搜索关键词信息是如何存储的。从下图中我们可以发现，散列表索引中，每个结点存储的 key 是搜索关键词，value 是 SearchWord 对象的内存地址。SearchWord 对象本身存储在散列表之外的内存空间中。</p><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923171124069.png"></p><p>浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：</p><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923171203280.png" alt="浅拷贝"></p><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923171227022.png" alt="深拷贝"></p><ol><li>在 Java 语言中，Object 类的 clone() 方法执行的就是浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。</li><li>在上面的代码中，我们通过调用 HashMap 上的 clone() 浅拷贝方法来实现原型模式。当我们通过 newKeywords 更新 SearchWord 对象的时候（比如，更新“设计模式”这个搜索关键词的访问次数），newKeywords 和 currentKeywords 因为指向相同的一组 SearchWord 对象，就会导致 currentKeywords 中指向的 SearchWord，有的是老版本的，有的是新版本的，就没法满足我们之前的需求：currentKeywords 中的数据在任何时刻都是同一个版本的，不存在介于老版本与新版本之间的中间状态。</li></ol><p>我们可以将浅拷贝替换为深拷贝。newKeywords 不仅仅复制 currentKeywords 的索引，还把 SearchWord 对象也复制一份出来，这样 newKeywords 和 currentKeywords 就指向不同的 SearchWord 对象，也就不存在更新 newKeywords 的数据会导致 currentKeywords 的数据也被更新的问题了。</p><p>如何实现深拷贝，有如下两种方法：</p><p>第一种方法：<code>递归拷贝对象、对象的引用对象以及引用对象的引用对象</code>……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。重构之后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastUpdateTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Deep copy</span><br>    HashMap&lt;String, SearchWord&gt; newKeywords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;<br>      <span class="hljs-type">SearchWord</span> <span class="hljs-variable">searchWord</span> <span class="hljs-operator">=</span> e.getValue();<br>      <span class="hljs-type">SearchWord</span> <span class="hljs-variable">newSearchWord</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchWord</span>(<br>              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());<br>      newKeywords.put(e.getKey(), newSearchWord);<br>    &#125;<br><br>    <span class="hljs-comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br>    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">maxNewUpdatedTime</span> <span class="hljs-operator">=</span> lastUpdateTime;<br>    <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>      <span class="hljs-keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;<br>        maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>      &#125;<br>      <span class="hljs-keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;<br>        <span class="hljs-type">SearchWord</span> <span class="hljs-variable">oldSearchWord</span> <span class="hljs-operator">=</span> newKeywords.get(searchWord.getKeyword());<br>        oldSearchWord.setCount(searchWord.getCount());<br>        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        newKeywords.put(searchWord.getKeyword(), searchWord);<br>      &#125;<br>    &#125;<br><br>    lastUpdateTime = maxNewUpdatedTime;<br>    currentKeywords = newKeywords;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">(<span class="hljs-type">long</span> lastUpdateTime)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>第二种方法：<code>先将对象序列化，然后再反序列化成新的对象</code>。具体的示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deepCopy</span><span class="hljs-params">(Object object)</span> &#123;<br>  <span class="hljs-comment">// 序列化</span><br>  <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>  <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bo);<br>  oo.writeObject(object);<br>  <br>  <span class="hljs-comment">// 反序列化</span><br>  <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bo.toByteArray());<br>  <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">oi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bi);<br>  <br>  <span class="hljs-keyword">return</span> oi.readObject();<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对这个应用场景，有没有更快、更省内存的实现方式呢？</li><li>可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题中讲到的，在这个应用场景下，最快速 clone 散列表的方式。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastUpdateTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Shallow copy</span><br>    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();<br><br>    <span class="hljs-comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br>    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">maxNewUpdatedTime</span> <span class="hljs-operator">=</span> lastUpdateTime;<br>    <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>      <span class="hljs-keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;<br>        maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>      &#125;<br>      <span class="hljs-keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;<br>        newKeywords.remove(searchWord.getKeyword());<br>      &#125;<br>      newKeywords.put(searchWord.getKeyword(), searchWord);<br>    &#125;<br><br>    lastUpdateTime = maxNewUpdatedTime;<br>    currentKeywords = newKeywords;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">(<span class="hljs-type">long</span> lastUpdateTime)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>尊重原创，原著文章链接： <a href="https://imlql.cn/post/ba432704.html">https://imlql.cn/post/ba432704.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>工厂</tag>
      
      <tag>建造者</tag>
      
      <tag>原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01-创建型-单例</title>
    <link href="/2022/09/21/01-chuang-jian-xing-dan-li/"/>
    <url>/2022/09/21/01-chuang-jian-xing-dan-li/</url>
    
    <content type="html"><![CDATA[<h2 id="一、单例设计模式介绍"><a href="#一、单例设计模式介绍" class="headerlink" title="一、单例设计模式介绍"></a>一、单例设计模式介绍</h2><p>单例设计模式，就是采用一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。</p><p>为什么要使用单例？单例解决哪类问题？</p><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。</p><p>再比如，唯一递增 ID 号码生成器。如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以，我们应该将 ID 生成器类设计为单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>  <span class="hljs-comment">// AtomicLong是一个Java并发库中提供的一个原子变量类型,</span><br>  <span class="hljs-comment">// 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，</span><br>  <span class="hljs-comment">// 比如下面会用到的incrementAndGet().</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IdGenerator</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-keyword">return</span> id.incrementAndGet();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// IdGenerator使用举例</span><br><span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> IdGenerator.getInstance().getId();<br></code></pre></td></tr></table></figure><h2 id="二、实现单例"><a href="#二、实现单例" class="headerlink" title="二、实现单例"></a>二、实现单例</h2><p>实现单例的八种方式</p><h3 id="1、饿汉式（静态变量）"><a href="#1、饿汉式（静态变量）" class="headerlink" title="1、饿汉式（静态变量）"></a>1、<code>饿汉式（静态变量）</code></h3><p>饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到 IdGenerator 的时候，再创建实例），从名字中我们也可以看出这一点。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123; <br>  <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IdGenerator</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-keyword">return</span> id.incrementAndGet();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优缺点说明：</p><ol><li>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</li><li>缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费</li><li>这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法， 但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果</li><li>结论：这种单例模式可用，可能造成内存浪费</li></ol><h3 id="2、饿汉式（静态代码块）"><a href="#2、饿汉式（静态代码块）" class="headerlink" title="2、饿汉式（静态代码块）"></a>2、<code>饿汉式（静态代码块）</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br><span class="hljs-keyword">static</span> &#123;<br>    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>优缺点说明：</p><ol><li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</li><li>结论：这种单例模式可用，但是可能造成内存浪费</li></ol><h3 id="3、懒汉式（线程不安全）"><a href="#3、懒汉式（线程不安全）" class="headerlink" title="3、懒汉式（线程不安全）"></a>3、懒汉式（线程不安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123; <br>  <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IdGenerator instance;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>      instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-keyword">return</span> id.incrementAndGet();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优缺点说明：</p><ol><li>起到了 <strong>Lazy Loading</strong> 的效果，但是只能在单线程下使用。</li><li>如果在多线程下，一个线程进入了 **if (singleton == null)**判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式</li><li>结论：在实际开发中，不要使用这种方式.</li></ol><h3 id="4、懒汉式（线程安全，同步方法）"><a href="#4、懒汉式（线程安全，同步方法）" class="headerlink" title="4、懒汉式（线程安全，同步方法）"></a>4、懒汉式（线程安全，同步方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>)&#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优缺点说明：</p><ol><li>解决了线程安全问题</li><li>效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低</li><li>结论：在实际开发中，不推荐使用这种方式</li></ol><h3 id="5、懒汉式（线程安全，同步代码块）"><a href="#5、懒汉式（线程安全，同步代码块）" class="headerlink" title="5、懒汉式（线程安全，同步代码块）"></a>5、懒汉式（线程安全，同步代码块）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 懒汉式(线程安全，同步代码块)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、-双重检查"><a href="#6、-双重检查" class="headerlink" title="6、==双重检查=="></a>6、==双重检查==</h3><p>饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123; <br>  <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IdGenerator instance;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">synchronized</span>(IdGenerator.class) &#123; <span class="hljs-comment">// 此处为类级别的锁</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>          instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-keyword">return</span> id.incrementAndGet();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。</p><h3 id="7、-静态内部类"><a href="#7、-静态内部类" class="headerlink" title="7、==静态内部类=="></a>7、==静态内部类==</h3><p>我们再来看一种比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类。它有点类似饿汉式，但又能做到了延迟加载。具体是怎么做到的呢？我们先来看它的代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123; <br>  <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IdGenerator</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> SingletonHolder.instance;<br>  &#125;<br> <br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-keyword">return</span> id.incrementAndGet();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p><h3 id="8、-枚举"><a href="#8、-枚举" class="headerlink" title="8、==枚举=="></a>8、==枚举==</h3><p>最后，我们介绍一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。具体的代码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>  INSTANCE;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br> <br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-keyword">return</span> id.incrementAndGet();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上，可以使用：两个饿汉式；推荐使用：双重检查、静态内部类、枚举</p><h2 id="三、单例模式注意事项"><a href="#三、单例模式注意事项" class="headerlink" title="三、单例模式注意事项"></a>三、单例模式注意事项</h2><ol><li>单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</li><li>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new</li><li>单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、<em><strong>session</strong></em> 工厂等)</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式概述</title>
    <link href="/2022/09/21/she-ji-mo-shi-gai-shu/"/>
    <url>/2022/09/21/she-ji-mo-shi-gai-shu/</url>
    
    <content type="html"><![CDATA[<h2 id="一、设计模式定义"><a href="#一、设计模式定义" class="headerlink" title="一、设计模式定义"></a>一、设计模式定义</h2><p>设计模式是在特定环境下为解决某一通用软件设计问题提供的一套定制的解决方案，该方案描述了对象和类之间的相互作用。</p><p>设计模式一般包含模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式，关键元素为：模式名称、问题、解决方案、效果。</p><h2 id="二、设计模式的分类"><a href="#二、设计模式的分类" class="headerlink" title="二、设计模式的分类"></a>二、设计模式的分类</h2><p>根据目的分类，可分为：</p><ol><li>创建型</li><li>结构型</li><li>行为型</li></ol><p>根据范围分类，可分为：</p><ol><li>类模式</li><li>对象模式</li></ol><h2 id="三、GoF设计模式简介"><a href="#三、GoF设计模式简介" class="headerlink" title="三、GoF设计模式简介"></a>三、GoF设计模式简介</h2><p>在GoF的经典著作中一共描述了23种设计模式。</p><p>按目的分类：</p><blockquote><p>创建型模式</p></blockquote><p>1、工厂模式</p><p>工厂模式（Factory Pattern）是Java中最常用的设计模式之一。</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p>2、抽象工厂模式</p><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p>3、单例模式</p><p>单例模式（Singleton Pattern）是Java中最简单的设计模式之一。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>4、建造者（构建者）模式</p><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。</p><p>一个Builder类会一步一步构造最终的对象。该Builder类是独立于其他对象的。</p><p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p>5、原型模式</p><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。</p><p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><blockquote><p>结构型模式</p></blockquote><p>6、适配器模式</p><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。</p><p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。</p><p>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p>7、装饰器模式</p><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><p>8、代理模式</p><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。</p><p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p><p>为其他对象提供一种代理以控制对这个对象的访问。</p><p>9、外观模式</p><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。</p><p>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p><p>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p>10、桥接模式</p><p>桥接模式（Bridge Pattern）是用于把抽象化与实现化解耦，使得二者可以独立变化。它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p><p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p><p>将抽象部分与实现部分分离，使它们都可以独立的变化。</p><p>又称为柄体（Handle and Body）模式或接口（Interface）模式。</p><p>11、组合模式</p><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了<strong>对象组的树形结构</strong>。</p><p>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p><p>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><p>12、享元模式</p><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p><p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。</p><p>运用共享技术有效地支持大量细粒度的对象。</p><blockquote><p>行为型模式</p></blockquote><p>13、策略模式</p><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的context对象。策略对象改变context对象的执行算法。</p><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。</p><p>14、模板模式</p><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>15、观察者模式</p><p>当对象间存在一对多关系时，则使用观察者模式（ObserverPattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。</p><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>16、迭代器模式</p><p>迭代器模式（Iterator Pattern）是Java和.Net编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p><p>迭代器模式属于行为型模式。</p><p>提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。</p><p>17、责任链模式</p><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。</p><p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p><p>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><p>18、命令模式</p><p>命令模式（Command Pattern）是一种数据驱动的设计模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p><p>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p><p>19、备忘录模式</p><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。</p><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p><p>20、状态模式</p><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。</p><p>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的context对象。</p><p>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p><p>21、访问者模式</p><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p><p>主要将数据结构与数据操作分离。</p><p>主要解决：稳定的数据结构和易变的操作耦合问题。</p><p>22、中介者模式</p><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。</p><p>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>23、解释器模式</p><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在SQL解析、符号处理引擎等。</p><p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p><h2 id="四、面向对象设计原则"><a href="#四、面向对象设计原则" class="headerlink" title="四、面向对象设计原则"></a>四、面向对象设计原则</h2><h3 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h3><p>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。</p><h3 id="2、里氏替换原则"><a href="#2、里氏替换原则" class="headerlink" title="2、里氏替换原则"></a>2、里氏替换原则</h3><p>所有引用基类的地方必须能透明地使用其子类的对象。</p><h3 id="3、依赖倒置原则"><a href="#3、依赖倒置原则" class="headerlink" title="3、依赖倒置原则"></a>3、依赖倒置原则</h3><ol><li>上层模块不应该依赖底层模块，它们都应该依赖于抽象。</li><li>抽象不应该依赖于细节，细节应该依赖于抽象。</li></ol><h3 id="4、接口隔离原则"><a href="#4、接口隔离原则" class="headerlink" title="4、接口隔离原则"></a>4、接口隔离原则</h3><p>每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</p><h3 id="5、迪米特法则（最少知道原则）"><a href="#5、迪米特法则（最少知道原则）" class="headerlink" title="5、迪米特法则（最少知道原则）"></a>5、迪米特法则（最少知道原则）</h3><p>一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p><h3 id="6、合成复用原则"><a href="#6、合成复用原则" class="headerlink" title="6、合成复用原则"></a>6、合成复用原则</h3><p>尽量使用对象组合/聚合，而不是继承关系达到软件复用的目的。</p><h3 id="7、开闭原则"><a href="#7、开闭原则" class="headerlink" title="7、开闭原则"></a>7、开闭原则</h3><p>软件实体应该对扩展开放，对修改关闭</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2022/09/21/lian-biao/"/>
    <url>/2022/09/21/lian-biao/</url>
    
    <content type="html"><![CDATA[<h1 id="一、理论"><a href="#一、理论" class="headerlink" title="一、理论"></a>一、理论</h1><h2 id="1、链表类型"><a href="#1、链表类型" class="headerlink" title="1、链表类型"></a>1、链表类型</h2><h3 id="1、单链表"><a href="#1、单链表" class="headerlink" title="1、单链表"></a>1、单链表</h3><p><img src="/2022/09/21/lian-biao/image-20221011101058417.png"></p><h3 id="2、双链表"><a href="#2、双链表" class="headerlink" title="2、双链表"></a>2、双链表</h3><p><img src="/2022/09/21/lian-biao/image-20221011101124093.png"></p><h3 id="3、循环链表"><a href="#3、循环链表" class="headerlink" title="3、循环链表"></a>3、循环链表</h3><p>循环链表可以用来解决<code>约瑟夫环</code>问题</p><p><img src="/2022/09/21/lian-biao/image-20221011101149273.png"></p><h2 id="2、链表存储方式"><a href="#2、链表存储方式" class="headerlink" title="2、链表存储方式"></a>2、链表存储方式</h2><p>数组在内存中是连续分布的，但链表在内存中不是连续分布的。</p><p>链表是通过指针域的指针来连接各个节点。所以链表的分配机制取决于操作系统的内存管理。</p><h2 id="3、链表的定义"><a href="#3、链表的定义" class="headerlink" title="3、链表的定义"></a>3、链表的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-comment">// 结点的值</span><br>    <span class="hljs-type">int</span> val;<br><br>    <span class="hljs-comment">// 下一个结点</span><br>    ListNode next;<br><br>    <span class="hljs-comment">// 节点的构造函数(无参)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 节点的构造函数(有一个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br><br>    <span class="hljs-comment">// 节点的构造函数(有两个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val, ListNode next)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、链表的基本操作"><a href="#4、链表的基本操作" class="headerlink" title="4、链表的基本操作"></a>4、链表的基本操作</h2><h3 id="1、删除节点"><a href="#1、删除节点" class="headerlink" title="1、删除节点"></a>1、删除节点</h3><p><img src="/2022/09/21/lian-biao/image-20221011101632656.png"></p><p>删除D节点，直接将C节点的next节点指向E即可。java有自己的内存回收机制，不用自己手动释放。</p><h3 id="2、添加节点"><a href="#2、添加节点" class="headerlink" title="2、添加节点"></a>2、添加节点</h3><p><img src="/2022/09/21/lian-biao/image-20221011101738080.png"></p><p>增加F节点，先将F节点的next指向D，再将C节点的next指向F。</p><p>但是有一点需要注意，在C后增加节点，首先得找到C节点，找节点的复杂度是O(n)</p><h2 id="5、链表与数组的性能对比"><a href="#5、链表与数组的性能对比" class="headerlink" title="5、链表与数组的性能对比"></a>5、链表与数组的性能对比</h2><p><img src="/2022/09/21/lian-biao/image-20221011102001636.png"></p><h1 id="二、翻转链表"><a href="#二、翻转链表" class="headerlink" title="二、翻转链表"></a>二、翻转链表</h1><p>先上<code>本次</code>的链表定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">public</span> Node next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、双指针法</p><p>只需要改变链表的next指向即可</p><p><img src="/2022/09/21/lian-biao/image-20220921114419429.png"></p><p>首先定义cur节点，指向head；再定义pre指向null。</p><p>pre节点是cur节点的前序节点</p><p>先将cur.next节点保存在temp里，再进行翻转。保存在temp是为了防止下一个节点丢失。</p><p>到最后cur为null时，pre为最后一个节点，此时返回pre即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reverse</span><span class="hljs-params">(Node head)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;   <span class="hljs-comment">// 以下注释以1 2为例</span><br>        temp = cur.next;   <span class="hljs-comment">// temp指向2</span><br>        cur.next = pre;    <span class="hljs-comment">// 1 和 2 之间已经断链， 1 已经指向了pre，也就是空</span><br><br>        pre = cur;     <span class="hljs-comment">//  同时向后移</span><br>        cur = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、递归法</p><p>递归法其实跟双指针法类似，每一步翻转都有三个过程：</p><ol><li>记录下一个节点</li><li>翻转</li><li>同时往后移</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//  其他代码</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> reverse(<span class="hljs-literal">null</span>, node1);    <span class="hljs-comment">// node1 为已定义好的链表的头结点</span><br>    <span class="hljs-keyword">while</span> (res != <span class="hljs-literal">null</span>) &#123;<br>        System.out.print(res.value + <span class="hljs-string">&quot; &quot;</span>);<br>        res = res.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reverse</span><span class="hljs-params">(Node pre, Node cur)</span> &#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.next;  <span class="hljs-comment">//记录下一个节点</span><br>    cur.next = pre;     <span class="hljs-comment">// 翻转</span><br><br>    <span class="hljs-keyword">return</span> reverse(cur, temp);   <span class="hljs-comment">//向后移</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、环形链表"><a href="#三、环形链表" class="headerlink" title="三、环形链表"></a>三、环形链表</h1><p>环形链表一共有两个问题，第一个问题是验证一个链表是否有环，第二个问题是找到环形链表的入口。</p><p>先来看第一个问题</p><h2 id="1、验证链表是否有环"><a href="#1、验证链表是否有环" class="headerlink" title="1、验证链表是否有环"></a>1、验证链表是否有环</h2><p>判断链表是否有环，可以使用快慢指针法，定义一个fast，以及一个slow，slow每走一步，fast就走两步，若是有环的话，那么最终一定会相遇。</p><p>为什么？</p><p>首先肯定是fast先进环，当slow进环时，slow走一步fast走两步，整体来看就是fast在追赶slow一步，那么只要有环，最终fast就一定会追上slow。</p><h2 id="2、若有环，如何找到入口？"><a href="#2、若有环，如何找到入口？" class="headerlink" title="2、若有环，如何找到入口？"></a>2、若有环，如何找到入口？</h2><p>用公式来表示一下。</p><p>假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：</p><p><img src="/2022/09/21/lian-biao/image-20221013094802419.png"></p><p>那么在相遇时，slow走了（x + y），fast走了(x + y + n * (y + z))。fast有可能在环内走了n圈。根据步长，可以看出fast走的距离是slow的二倍，即：</p><p>2 * (x + y) = x + y + n * (y + z)</p><p>两边消去一个 x + y：</p><p>x + y = n * (y + z)</p><p>要找到入口，那就是要求x的距离，将x放在一边：</p><p>x = n * (y + z) - y</p><p>整理之后就是：</p><p>x = (n - 1) * (y + z) + z</p><p>假设n = 1时，n = 1意味着fast在环内走了一圈就碰见slow了，这时候计算入口时(x = z)，只需要在他们相遇的节点处定义一个index1，在头结点处定义一个index2，令他们每次走一步，相遇即为入口节点。</p><p>若是n &gt; 1时，fast指针在环形转n圈之后才遇到 slow指针。该问题也可简化为n = 1，其实本质上都一样，只不过index1在环内多转了几圈，然后碰到index2。</p><blockquote><p>有个疑问：那为什么在环中相遇时，slow走过的距离一定是x + y，而不是 x + 若干环的距离 + y 呢？</p></blockquote><p>因为当slow进环时，fast一定在环内，而fast和slow每走一次就相当于fast在靠近slow一步，所以当slow还没进入到下一次循环的时候，就会被fast追上。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见架构模式</title>
    <link href="/2022/09/20/chang-jian-jia-gou-mo-shi/"/>
    <url>/2022/09/20/chang-jian-jia-gou-mo-shi/</url>
    
    <content type="html"><![CDATA[<p>扫盲！</p><p>几种常见的架构模式：<strong>Client-Server、Peer to Peer、MVC、Layered、Distribute-Cluster、Micro-Service、Even-Source、Hexagonal</strong></p><p>几种架构模式：</p><h3 id="Client-Server"><a href="#Client-Server" class="headerlink" title="Client-Server"></a>Client-Server</h3><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20220920190951638.png" alt="cs"></p><p>client-server 模式以请求-响应方式工作，客户端发送请求信息，服务端接受请求，作出相应处理，然后发回响应信息。所有我们访问的互联网网站都是这种架构。在桌面程序流行的时代，互联网还没有当前这么发达的时代。Client-Server 还只代表 Desktop Client-Server 模式，使用浏览器的方式称之为 B-S 模式，即 Browser-Server 模式。如今 Browser、Desktop Application、Mobile Application、Mobile Web 等统称为 Client。</p><h3 id="Peer-to-Peer"><a href="#Peer-to-Peer" class="headerlink" title="Peer to Peer"></a>Peer to Peer</h3><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20220920191053669.png" alt="p2p"></p><p>端对端服务模式（Peer to Peer，简称 P2P），亦称为“点对点模式”，是指通过互联网将个人与个人连接起来，绕开中心平台而直接提供服务、完成交易的模式。P2P 的早期含意是计算机通信领域中的“对等网络协议”，它打破了传统的 Client/Server(C/S)模式，使得成千上万台彼此连接的计算机都处于对等地位，网络的参与者直接共享他们所拥有的一部分硬件资源（包括处理能力、存储能力、网络连接能力、打印机等），这些共享资源通过互联网，能被其它对等节点(Peer)直接访问而无需经过统一的中间体。</p><p>P2P 模式流行于文件分享与下载、计算与存储、即时通信和协同共享等领域。</p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20220920191214418.png" alt="mvc"></p><p>Model-View-Controller，MVC 架构是面向对象编程的一大进步。服务将逻辑划分为三个不同的组建：Model——模型，即数据，通常存储在数据库中，在内存中进行逻辑操作。View——用户可见的组建，用于用户交互和数据展示，如 Web GUI。Controller——逻辑操作，连接 Model 和 View 的组件，操作 Model 逻辑和 View 交互展示逻辑。</p><h3 id="Layered"><a href="#Layered" class="headerlink" title="Layered"></a>Layered</h3><p>说起分层架构，最让人熟知的就是经典的三层架构。经典三层架构自顶向下由用户界面层（User Interface Layer）、业务逻辑层（Business Logic Layer）与数据访问层（Data Access Layer）组成。三层架构是简单 Client-Server 架构的升级。</p><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20220920191630251.png" alt="there layer"></p><h3 id="Distribute-Cluster"><a href="#Distribute-Cluster" class="headerlink" title="Distribute-Cluster"></a>Distribute-Cluster</h3><p>之上所提的架构都是在单体架构之下。单体架构和多服务架构是从服务的部署模式、运行模式来考虑。</p><p>单体架构有如下优势：</p><ul><li>易于开发：借助于开发框架，单体应用的开发及其简单，开发人员也很少需要考虑系统、部署、网络等层次的问题。</li><li>易于测试：单体应用部署在一个进程中，环境简单。只要服务启动就可以测试所有的功能。</li><li>易于部署：往往只需要将应用打包成一个简单的包就可。</li><li>易于水平扩展：只需要将程序包部署多个服务即可。</li></ul><p>单体应用的劣势：</p><ul><li>维护成本增加：随着需求的增多，单体系统将越来越臃肿，维护的复杂性也将越来越大。</li><li>持续交互周期长：一方面维护困难，另一方面单体应用在并行开发，并行测试上将十分困难，单体应用十分不适合快速迭代的敏捷开发。</li><li>扩展性差：由于臃肿的系统，将导致系统扩展性变难。系统的升级也需要十分谨慎。</li><li>对新人不友好。</li></ul><p>分布式系统拆分：</p><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20220920191745648.png" alt="service scale"></p><h3 id="Micro-Service"><a href="#Micro-Service" class="headerlink" title="Micro-Service"></a>Micro-Service</h3><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调、相互配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常基于 HTTP 的 RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境。</p><p>Spring Cloud 技术栈:</p><ul><li>SpringBoot：单体服务，快速创建项目，快速集成各种框架，易于测试，易于部署。</li><li>Feign：微服务独立部署，通过相关协议通信。Feign 就是一个简单的申明式通信框架，基于 HTTP restful。</li><li>Eureka：独立服务越来越多，服务实例也越来越多。服务治理便是必须的，Eureka 提供高可用的服务注册和服务发现功能。</li><li>Ribbon：Feign 只负责通信，Ribbon 提供客户端负载均衡，是系统优化的部分。</li><li>Hystrix：微服务将带来服务间复杂的依赖关系，分布式和集群的复杂度也将带来许多难以预料的问题。为防止复杂网络和复杂系统某一点的问题导致整个系统的雪崩状态，便有了 Hystrix，Hystrix 是 Spring Cloud 体系中优秀的断路器，可以在系统发生问题时进行服务降级，防止整体系统崩溃。</li><li>Zuul：统一网关，统一网关是以 Facade 模式，对外提供友好的接口，微服务化之后，服务将越来越多，越来越复杂，为了降低外部系统调用的复杂度，统一网关就是常用解决方案。</li><li>Config：服务划分越多，配置将越多，Spring cloud config 提供统一的配置管理。</li><li>Sleuth：服务监控和治理。监控是复杂系统必需的基础设施。系统感知、问题发现、性能定位都需要监控的加持。</li></ul><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20220920191927004.png" alt="micro service"></p><p>。。。。。。。。。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>架构</tag>
      
      <tag>分布式/微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Second Test</title>
    <link href="/2022/09/20/second-test/"/>
    <url>/2022/09/20/second-test/</url>
    
    <content type="html"><![CDATA[<p>第二次测试</p><p>托拉拽：</p><p><img src="/2022/09/20/second-test/image-20220920171706059.png" alt="不愧是我"></p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Test</title>
    <link href="/2022/09/20/test/"/>
    <url>/2022/09/20/test/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/09/20/test/%E5%90%89%E4%BB%964.jpg" alt="图片测试"></p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习笔记</title>
    <link href="/2022/09/19/docker-xue-xi/"/>
    <url>/2022/09/19/docker-xue-xi/</url>
    
    <content type="html"><![CDATA[<h2 id="一、为何要用Docker"><a href="#一、为何要用Docker" class="headerlink" title="一、为何要用Docker?"></a>一、为何要用Docker?</h2><h3 id="1、什么是Docker"><a href="#1、什么是Docker" class="headerlink" title="1、什么是Docker?"></a>1、什么是Docker?</h3><p>Docker 使用 Google 公司推出的 Go 语言  进行开发实现，基于 Linux 内核 的cgroup，namespace，以及 AUFS 类的 UnionFS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。 由于隔离的进程独立于宿主和其它的隔离的进 程，因此也称其为容器。Docker 最初实现是基于 LXC.</p><p>Docker 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上，构建杰出的软件。</p><p>用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><h3 id="2、Docker的优点："><a href="#2、Docker的优点：" class="headerlink" title="2、Docker的优点："></a>2、Docker的优点：</h3><ul><li><p>环境隔离(‘<strong>隔离，安全</strong>‘)</p><p>Docker 实现了资源隔离，一台机器运行多个容器互无影响。</p></li><li><p>更高效的资源利用(<strong>节约成本</strong>)</p><p>Docker 容器的运行不需要额外的虚拟化管理程序的支持，它是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。</p></li><li><p>更快速的交付部署(<strong>敏捷</strong>)</p><p>使用 Docker，开发人员可以利用镜像快速构建一套标准的研发环境，开发完成后，测试和运维人员可以直接通过使用相同的环境来部署代码。</p></li><li><p>更易迁移扩展(<strong>可移植性</strong>)</p><p>Docker 容器几乎可以在任意的平台上运行，包括虚拟机、公有云、私有云、个人电脑、服务器等，这种兼容性让用户可以在不同平台之间轻松的迁移应用。</p></li><li><p>更简单的更新管理(<strong>高效</strong>)</p><p>使用 Dockerfile，只需要很少的配置修改，就可以替代以往大量的更新工作。并且所有修改都是以增量的方式进行分发和更新，从而实现自动化和高效的容器管理。</p></li></ul><h3 id="3、Docker-的基本组成架构"><a href="#3、Docker-的基本组成架构" class="headerlink" title="3、Docker 的基本组成架构"></a>3、Docker 的基本组成架构</h3><p>具体参考<a href="https://juejin.cn/post/6844904035053486087#heading-2">Docker搭建你的第一个 Node 项目到服务器(完整版)</a></p><h4 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h4><p>镜像仓库，存储大量镜像，可以从镜像仓库拉取和推送镜像。</p><h4 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h4><p>类似虚拟机快照，从仓库拉取，或者在现有工具镜像上创建新镜像。通过镜像可以启动容器。</p><h4 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h4><p>从镜像中创建应用环境，以单进程的方式运行。对外公开服务。是一种短暂的和一次性的环境。</p><h4 id="Docker-数据卷"><a href="#Docker-数据卷" class="headerlink" title="Docker 数据卷"></a>Docker 数据卷</h4><p>数据卷可以完成数据持久化，数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>卷会一直存在，直到没有容器使用</li></ul><h4 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h4><p>Docker 容器之间的网络交互，可以使用<code>端口映射</code>的方式，其他容器可以直接通过端口实现。除该方式外还有一个<code>容器连接（linking）系统</code>也可以达到容器交互。（本文中 node 连接 mongodb 使用的是端口映射的方式）</p><p>关于Docker 网络模块，容器连接详情推荐这篇文章: <a href="https://juejin.cn/post/6844903756920782855">Docker的网络模式详解</a></p><h3 id="4、Docker的常用命令（常用）"><a href="#4、Docker的常用命令（常用）" class="headerlink" title="4、Docker的常用命令（常用）"></a>4、Docker的常用命令（常用）</h3><h4 id="镜像常用命令"><a href="#镜像常用命令" class="headerlink" title="镜像常用命令"></a>镜像常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull [镜像名称:版本] 拉取镜像<br>docker images  镜像列表<br>docker rmi [镜像名称:版本] 删除镜像<br>docker <span class="hljs-built_in">history</span> [镜像名称] 镜像操作记录<br>docker tag [镜像名称:版本][新镜像名称:新版本]<br>docker inspect [镜像名称:版本] 查看镜像详细<br>docker search [关键字] 搜索镜像<br>docker login 镜像登陆<br></code></pre></td></tr></table></figure><h4 id="容器常用命令"><a href="#容器常用命令" class="headerlink" title="容器常用命令"></a>容器常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps -a 容器列表(所有容器)<br>docker ps  查看所有(运行的)容器<br>docker <span class="hljs-built_in">exec</span> -ti &lt;<span class="hljs-built_in">id</span>&gt; bash  以 bash 命令进入容器内<br>docker run -ti --name [容器名称][镜像名称:版本] bash 启动容器并进入<br>docker logs 查看容器日志<br>docker top &lt;container_id&gt; 查看容器最近的一个进程<br>docker run -ti --name [容器名称] -p 8080:80 [镜像名称:版本] bash  端口映射<br>docker <span class="hljs-built_in">rm</span> &lt;container_id&gt; 删除容器<br>docker stop &lt;container_id&gt; 停止容器<br>docker start &lt;container_id&gt; 开启容器<br>docker restart &lt;container_id&gt; 重启容器<br>docker inspect &lt;container_id&gt; 查看容器详情<br>docker commit [容器名称] my_image:v1.0  容器提交为新的镜像<br></code></pre></td></tr></table></figure><h4 id="DockerFile常用命令"><a href="#DockerFile常用命令" class="headerlink" title="DockerFile常用命令"></a>DockerFile常用命令</h4><p>见第六节</p><h2 id="二、CentOs-7-上Docker安装部署"><a href="#二、CentOs-7-上Docker安装部署" class="headerlink" title="二、CentOs 7 上Docker安装部署"></a>二、CentOs 7 上Docker安装部署</h2><h3 id="1、若是以前安装过docker，先执行以下步骤"><a href="#1、若是以前安装过docker，先执行以下步骤" class="headerlink" title="1、若是以前安装过docker，先执行以下步骤"></a>1、若是以前安装过docker，先执行以下步骤</h3><ol><li><p>更新yum包（生产环境中慎重）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y update<br></code></pre></td></tr></table></figure><p>此命令不是必须，有服务器重启一下服务器</p></li><li><p>卸载旧版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum remove docker  docker-common docker-selinux docker-engine<br></code></pre></td></tr></table></figure></li></ol><h3 id="2、安装docker的详细步骤"><a href="#2、安装docker的详细步骤" class="headerlink" title="2、安装docker的详细步骤"></a>2、安装docker的详细步骤</h3><ol><li><p>首先安装需要的软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y yum-utils device-mapper-persistent-data lvm2<br></code></pre></td></tr></table></figure></li><li><p>设置yum源，我使用的是阿里仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure></li><li><p>选择docker版本并安装<br>查看可用的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum list docker-ce --showduplicates | <span class="hljs-built_in">sort</span> -r                 <br></code></pre></td></tr></table></figure><p>选择一个版本并安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install docker-ce-版本号<br></code></pre></td></tr></table></figure><p>我安装的是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y install docker-ce-18.03.1.ce<br></code></pre></td></tr></table></figure></li><li><p>启动docker并设置开机自启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start docker<br>systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure></li></ol><h2 id="三、image文件"><a href="#三、image文件" class="headerlink" title="三、image文件"></a>三、image文件</h2><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出本机的所有 image 文件。</span><br>docker image <span class="hljs-built_in">ls</span><br><br><span class="hljs-comment"># 删除 image 文件</span><br>docker image <span class="hljs-built_in">rm</span> [imageName]<br></code></pre></td></tr></table></figure></blockquote><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/">Docker Hub</a> 是最重要、最常用的 image 仓库。</p><h2 id="四、实例：“Hello-world”"><a href="#四、实例：“Hello-world”" class="headerlink" title="四、实例：“Hello world”"></a>四、实例：“Hello world”</h2><p>通过最简单的“Hello world”实例感受一下image文件</p><p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image pull library/hello-world<br></code></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p><p>由于 Docker 官方提供的 image 文件，都放在<a href="https://hub.docker.com/r/library/"><code>library</code></a>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image pull hello-world<br></code></pre></td></tr></table></figure></blockquote><p>抓取成功以后，就可以在本机看到这个 image 文件了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure></blockquote><p>现在，运行这个 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run hello-world<br></code></pre></td></tr></table></figure></blockquote><p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p><p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p><p>如果运行成功，你会在屏幕上读到下面的输出。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run hello-world<br><br>Hello from Docker!<br>This message shows that your installation appears to be working correctly.<br><br>... ...<br></code></pre></td></tr></table></figure></blockquote><p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p><p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run -it ubuntu bash<br></code></pre></td></tr></table></figure></blockquote><p>对于那些不会自动终止的容器，必须使用<a href="https://docs.docker.com/engine/reference/commandline/container_kill/"><code>docker container kill</code></a> 命令手动终止。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">kill</span> [containID]<br></code></pre></td></tr></table></figure></blockquote><h2 id="五、容器文件"><a href="#五、容器文件" class="headerlink" title="五、容器文件"></a>五、容器文件</h2><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出本机正在运行的容器</span><br>$ docker container <span class="hljs-built_in">ls</span><br><br><span class="hljs-comment"># 列出本机所有容器，包括终止运行的容器</span><br>$ docker container <span class="hljs-built_in">ls</span> --all<br></code></pre></td></tr></table></figure></blockquote><p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p><p>终止运行的容器文件，依然会占据硬盘空间，可以使用<a href="https://docs.docker.com/engine/reference/commandline/container_rm/"><code>docker container rm</code></a>命令删除。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">rm</span> [containerID]<br></code></pre></td></tr></table></figure></blockquote><p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p><h2 id="六、Dockerfile部署Spring-Boot-项目"><a href="#六、Dockerfile部署Spring-Boot-项目" class="headerlink" title="六、Dockerfile部署Spring Boot 项目"></a>六、Dockerfile部署Spring Boot 项目</h2><h3 id="1、将已有的spring-boot-项目打包"><a href="#1、将已有的spring-boot-项目打包" class="headerlink" title="1、将已有的spring boot 项目打包"></a>1、将已有的spring boot 项目打包</h3><h3 id="2、在linux中创建一个文件夹，例如我创建为-root-docker-test-jar01"><a href="#2、在linux中创建一个文件夹，例如我创建为-root-docker-test-jar01" class="headerlink" title="2、在linux中创建一个文件夹，例如我创建为 /root/docker_test/jar01"></a>2、在linux中创建一个文件夹，例如我创建为 /root/docker_test/jar01</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /root/docker_test/jar01<br></code></pre></td></tr></table></figure><h3 id="3、将jar包上传到linux文件夹中"><a href="#3、将jar包上传到linux文件夹中" class="headerlink" title="3、将jar包上传到linux文件夹中"></a>3、将jar包上传到linux文件夹中</h3><p>利用MobaxTerm将jar包上传到jar01中</p><h3 id="4、编写DockerFile文件"><a href="#4、编写DockerFile文件" class="headerlink" title="4、编写DockerFile文件"></a>4、编写DockerFile文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 基于java镜像创建新镜像</span><br>FROM openjdk:11<br><span class="hljs-comment"># 作者</span><br>MAINTAINER zbiao<br><span class="hljs-comment"># 将jar包添加到容器中并更名为app.jar</span><br>ADD  demo-helloworld.jar app.jar<br><span class="hljs-comment"># 运行jar包</span><br>ENTRYPOINT [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;app.jar&quot;</span>]<br></code></pre></td></tr></table></figure><p>ADD 后面是源文件，再后面才是目标文件</p><blockquote><p>注意：ADD、COPY 指令用法一样，唯一不同的是 ADD 支持将归档文件（tar, gzip, bzip2, etc）做提取和解压操作。还有需要注意的是，COPY 指令需要复制的目录一定要放在 Dockerfile 文件的同级目录下。</p></blockquote><p>参考：<a href="http://lpxz.work/2022/07/04/Docker%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6-%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2-updating%E2%80%A6">LPxz的个人博客</a></p><h3 id="5、制作镜像"><a href="#5、制作镜像" class="headerlink" title="5、制作镜像"></a>5、制作镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t zbdemo .<br></code></pre></td></tr></table></figure><p>注意是在jar01目录下</p><h3 id="6、启动容器"><a href="#6、启动容器" class="headerlink" title="6、启动容器"></a>6、启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 8080:8080 --name zbdemo03 zbdemo:latest<br></code></pre></td></tr></table></figure><p>命令参数：</p><ul><li>-d：后台运行</li><li>-p：公开指定端口号</li><li>-name：容器命名</li></ul><p>启动后可通过 <code>docker ps</code> 查看正在运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-10-centos jar01]<span class="hljs-comment"># docker ps</span><br>CONTAINER ID        IMAGE               COMMAND               CREATED             STATUS              PORTS                    NAMES<br>618cf8b1a0a8        zbdemo:latest       <span class="hljs-string">&quot;java -jar app.jar&quot;</span>   14 minutes ago      Up 13 minutes       0.0.0.0:8080-&gt;8080/tcp   zbdemo04<br>45d6deb5444a        zbdemo:latest       <span class="hljs-string">&quot;java -jar app.jar&quot;</span>   16 minutes ago      Up 16 minutes       0.0.0.0:8082-&gt;8082/tcp   zbdemo03<br></code></pre></td></tr></table></figure><h3 id="7、查看启动日志"><a href="#7、查看启动日志" class="headerlink" title="7、查看启动日志"></a>7、查看启动日志</h3><p>我们可以通过 <code>docker logs name</code> 查看指定容器的日志，后面name为容器名，如zbdemo03</p><h3 id="8、DockerFile配置参数"><a href="#8、DockerFile配置参数" class="headerlink" title="8、DockerFile配置参数"></a>8、DockerFile配置参数</h3><p>FROM：FROM 是构建镜像的基础源镜像，该 Image 文件继承官方的 node image。</p><p>详细说明：Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令！ 它引入一个镜像作为我们要构建镜像的基础层，就好像我们首先要安装好操作系统，才可以在操作系统上面安装软件一样。</p><p>RUN：后面跟的是在容器中要执行的命令。</p><p>详细说明：每一个 <code>RUN</code> 指令都会新建立一层，在其上执行这些命令，我们频繁使用 <code>RUN</code> 指令会创建大量镜像层，然而 <code>Union FS</code> 是有最大层数限制的，不能超过 <code>127</code> 层，而且我们应该把每一层中我用文件清除，比如一些没用的依赖，来防止镜像臃肿。</p><p>WORKDIR：容器的工作目录</p><p>COPY：拷贝文件至容器的工作目录下，.dockerignore 指定的文件不会拷贝</p><p>EXPOSE：将容器内的某个端口导出供外部访问</p><p>CMD：Dockerfile 执行写一个 CMD 否则后面的会被覆盖，CMD 后面的命令是容器每次启动执行的命令，多个命令之间可以使用 &amp;&amp; 链接，例如 CMD git pull &amp;&amp; npm start</p><p>详细说明:<code>CMD</code> 指令用来在启动容器的时候，指定默认的容器主进程的启动命令和参数。 </p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>image</tag>
      
      <tag>dockerfile</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法</title>
    <link href="/2022/09/16/tan-xin-suan-fa/"/>
    <url>/2022/09/16/tan-xin-suan-fa/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="贪心算法基础知识"><a href="#贪心算法基础知识" class="headerlink" title="贪心算法基础知识"></a>贪心算法基础知识</h2><p>无套路</p><p>大体思路： 求局部最优，进而求全局最优</p><p>贪心算法一般分为如下四步：</p><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><p>个人思路：将两个数组排序，然后饼干那个一一对应孩子的胃口，若是饼干小了，直接饼干后移，若是孩子小了，仍然直接给出，count+1</p><hr><p>但还有种反向操作，先给大的，后给小的；尽可能多的满足孩子的胃口。</p><p>奥，卡哥跟我想的一样，都是用一个index来避免二次遍历，这道题先满足胃口小的和先满足胃口大的都一样</p><h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p>序列还可以删除，一定要注意这一点</p><p>摆动序列可以转化为求峰值和谷底，求出一个峰值或谷底结果就加一</p><p>result初始化为1，是因为如果初始化0的话，就没有考虑到边界，初始化为1就体现了已经处理左边界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((curDiff &gt; <span class="hljs-number">0</span> &amp;&amp; preDiff &lt;= <span class="hljs-number">0</span>) || (curDiff &lt; <span class="hljs-number">0</span> &amp;&amp; preDiff &gt;= <span class="hljs-number">0</span>)) &#123;<br>count++;<br>preDiff = curDiff;<br>&#125;<br></code></pre></td></tr></table></figure><p>pre处写&lt;=   、 &gt;=  是因为要考虑初始化情况，因为pre初始化为0，所以不管当前大于还是小于，都符合</p><p>同时序列还可以删除，这一点体现在pre = cur的放置位置，放在if里面，意思是只找峰值或谷底，而不去管边界；若是放到if外面，意思是每次都要进行处理，很明显，本题我们要选择放在if里面</p><p>另一种解法是DP,以后再说</p><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p>若全是负数？</p><p>想法：跟上题类似，定义pre和cur，再定义一个最大值，最大值一定是从正数开始，但是若全是负数？？</p><p>行不通，否</p><ol><li>思路一：暴力法，两层for循环，外层遍历，内层从外层开始，找出最大连续和；这样就把每个连续和求出来了，直接返回最大</li><li>思路二：贪心法，重点在于想局部最优，局部最优是：一旦加到了负数，则直接从下一个开始；同时用result记录最大值，由此来确定终止区间。</li><li>思路三：动态规划，目前不涉及</li></ol><p>思路二贪心的实现，有一个问题，若是全是负数呢？又回到了我最初的想法，若全是负数的话，那就应该把result初始化为Integer的最小值，然后先加到sum里，再判断result和sum大小，最后再判断sum是否大于0，这样就完美解决了全是负数的问题。</p><p>我最初是先判断sum是否大于0，若不是则直接continue，这样导致出现全是负数的时候就无法解决。</p><p>卡哥厉害！</p><h2 id="买股票的最佳时机II"><a href="#买股票的最佳时机II" class="headerlink" title="买股票的最佳时机II"></a>买股票的最佳时机II</h2><p>真蠢啊！</p><p>我在想：是否可以像以前那样，定义一个cur，一个pre；找谷峰和谷底，但这样极难实现，或者说就不可以实现</p><p>卡哥是通过计算两天之间的差值，只记录正值即可，并相加；</p><p>还有一种的DP,暂时不考虑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prices.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (prices[i + <span class="hljs-number">1</span>] - prices[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                sum += prices[i + <span class="hljs-number">1</span>] - prices[i];<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>我被秀一脸</p><h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p>回溯？</p><p>看起来像是回溯</p><p>本人想法：局部最优：跳到一个方块，然后找这个方块能跳到的范围内的数值最大的，并且如果最大范围超过了数组，则证明可以跳到，反之不行</p><hr><p>我的想法是不正确的，卡哥的思路：局部最优：找最大覆盖范围，每个都得遍历，若是找到了某个元素覆盖范围覆盖了数组的长度，则可以，反之若是遍历完还是没有返回true，那说明不行了。</p><blockquote><p>也可以这样遍历数组：</p></blockquote><p>​    遍历的是coverMax，而不是整个数组，数组的遍历在for循环里面，看似没遍历数组，实则是对数组的每一个元素都遍历了。</p><h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="==跳跃游戏II=="></a>==跳跃游戏II==</h2><p>这下该找最大了吧</p><p>还是不能找最大，但是讲道理，可行，但是就是跑不通</p><p>卡哥思路：依然是找最大覆盖范围，定义当前最大范围和全体最大范围，当走到当前最大范围时，判断全体最大范围是否大于数组长度，若大于的话，直接+1并且break;若是不大于，就更新当前最大范围到全体最大范围</p><blockquote><p>新思路：最大范围</p></blockquote><h2 id="K次取反后最大化的数组和"><a href="#K次取反后最大化的数组和" class="headerlink" title="K次取反后最大化的数组和"></a>K次取反后最大化的数组和</h2><p>想法：其实只分奇数次和偶数次。需要判断负数的数量，若是负数总数小于k，则先将负数全部转正，然后再减二，直到k为0或1，是0的话不用说了，是1的话将最小的翻转；若负数总数大于k，那么更好办了，直接翻转。</p><p>当然排序会更容易处理一些。</p><p>Yes，跟卡哥想的一样，不过排序是按绝对值大小进行排序，但是我觉得也可以直接排序</p><p>最重要的是，按贪心的思路来想，局部最优，全局最优。</p><p>局部最优是：每次翻转最小的整数</p><p>全局最优是：整个数值达到最大</p><p>确实要按绝对值排序！而且是绝对值从大到小！到最后翻转最后一个数即可；反之绝对值从小到大亦可。</p><h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p>无从下手</p><p>贪心法一：</p><p>进行全局贪心</p><ul><li>情况一：如果gas的总和小于cost总和，那么无论从哪里出发，一定是跑不了一圈的</li><li>情况二：rest[i] = gas[i]-cost[i]为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。</li><li>情况三：如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能这个负数填平，能把这个负数填平的节点就是出发节点。</li></ul><p>贪心法二：</p><p>每个加油站的剩余量rest[i]为gas[i] - cost[i]。</p><p>i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。</p><p><strong>局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置</strong>。</p><p>水</p><h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p>求峰值，或者说是附近位置最大值这种，一般都需要从左到右再从右到左两次遍历确定</p><p>第一次从左到右，判断右边比左边大，则右边+1；</p><p>第二次从右到左，判断左边比右边大，则取原来的和右边+1二者最大值</p><p>注意：原数组进行比较，而不是candy数组进行比较；在这纠结了起码十五分钟！</p><h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h2><p>初步思路：维持一个数组，只保存5和10的个数，还可以求一个sum；局部最优：每次先挑最大的数，也即10，再挑5,；全局最优：所有人都可以找零</p><p>Yes。思路一样，只不过卡哥实现是用两个int型，我用数组，其实用int更好一点。卡哥是遇到直接减，不管是否大于零还是小于零，到最后判断这两个是否都大于等于零即可；我是若是减了大于0，则减。</p><p>卡哥代码更易实现</p><h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h2><p>初步思路：先找ki == 0 的人，然后从小打到再排列，先放小的；然后再找ki == 1的，再从小开始放；然后找ki == 2的，以此类推。</p><p>实现：有一种想法是建两个数组，一个存hi，一个存ki，定义一个函数，功能是交换数组某两个位置的元素。</p><p>思路不可行。我的思路相当于按k排序，但是这种会出现一个问题，[5,2],[7,1]到底谁先呢？出现不确定性。</p><p>卡哥：这种两种维度的题一定要先确定一个维度，若是两个维度都想兼顾到的话就会顾此失彼。</p><p>实现：看了卡哥的，真是厉害！使用自定义函数Arrays.sort()进行排序，之后使用list来遍历</p><blockquote><p>注意：从小到大：o1 - o2;从大到小：o2 - o1</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(people, (a, b) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])<br>                <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];   <span class="hljs-comment">//从小到大</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>];   <span class="hljs-comment">//从大到小</span><br>        &#125;);<br></code></pre></td></tr></table></figure><p>==插入操作==</p><p>使用LinkedList.add(index, value)方法进行插入，第一个参数是插入位置</p><p>最后使用toArray方法进行数组转换。</p><p>卡哥方法使用到位！厉害</p><h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h2><p>数组第一个数组进行排序，从小到大；从结尾出判断，若下面有有数组在这个区间，则将这个区间一同删去（或者说往后遍历）</p><p>思路跟卡哥一样，只是实现是个问题</p><p>首先是排序，二维数组经典排序（从小到大）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(points, (o1, o2) -&gt; Integer.compare(o1[<span class="hljs-number">0</span>], o2[<span class="hljs-number">0</span>]));<br></code></pre></td></tr></table></figure><p>实现：从1处开始遍历，判断上一个的结尾和下一个的开头是否有交集，若无交集，直接count++;若有交集，则更新下一个的右边界，更新为上一个和下一个的最小值，最后返回。</p><h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><p>初步思路：仍然是排序，从小到大排序，若是开端相同，则默认删掉结尾长的那个数组；留下来是下一个的开端大于等于上一个的结尾；若是下一个开端小于上一个结尾，说明有重叠，则直接更新下一个结尾。</p><p>试了一下，果然成功了。</p><p>卡哥思路更简单，也更加全面。分按左区间排序和右区间排序；我上面的思路就是按左区间进行排序的，卡哥用了一个int pre来记录上一次结尾的最小值，每次都更新pre</p><h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h2><p>自己没有思路。。</p><p>卡哥思路：总共26个字母，先把这些字母最后出现字母写进数组，然后再遍历一次字符串，每次更新最大右边界，若当前位置等于当前出现最大值，说明已经到了该划分的时候</p><p>贪心，并没有体现，至少我想象不出。</p><p>开拓视野吧。但是很精彩</p><h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p>貌似不难</p><p>初步思路：对左边界进行排序，只需要判断右边界是否大于左边界即可</p><p>==重要：==</p><p>定义二维数组：</p><p>List&lt;int[]&gt; res = new ArrayList&lt;&gt;();</p><p>list添加二维数组：</p><p>res.add(new int[]{start, intervals[i - 1] [1]});</p><p>list转二维数组：</p><p>res.toArray(new int[res.size()] []);</p><blockquote><p>注意</p></blockquote><p>处理的永远是上一层的末尾，所以最后要单独处理一下最后一层</p><h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h2><p>暴力解法：写一个判断是否单调递增的函数，从这个数开始往下遍历，找到一个符合的立刻返回</p><p>结果自然是超时。哈哈哈哈</p><p>贪心解法：局部最优：首先若是str[i - 1] &gt;  str[i]的话，证明前一位数大，则将str[i-1]–,并让str[i] = 9，这样就可保证局部最大；全局最优：遍历，即可达到全局最优。</p><p>问题在于，是从前往后遍历还是从后往前遍历。当然是从后往前遍历，因为从前往后遍历的时候，比如332，  332 -&gt; 329，Out。从后往前遍历，332 -&gt; 329 -&gt; 299</p><p>本题用到的java方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 整形转string</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.valueOf(n);<br><span class="hljs-comment">// 字符串转字符数组</span><br><span class="hljs-type">char</span>[] chars = s.toCharArray();<br><span class="hljs-comment">// 先转字符串再转整形</span><br>Integer.parseInt(String.valueOf(chars));<br></code></pre></td></tr></table></figure><p>以下都可转string</p><p><img src="/2022/09/16/tan-xin-suan-fa/Typora文件\Typora图片\image-20220621143453592.png" alt="image-20220621143453592"></p><h2 id="买卖股票的最佳时机（含手续费）"><a href="#买卖股票的最佳时机（含手续费）" class="headerlink" title="买卖股票的最佳时机（含手续费）"></a>买卖股票的最佳时机（含手续费）</h2><p>初步思路：遇到极小值的就买入，遇到极大值就卖出</p><p>当然也可能有问题</p><p>卡哥思路：不需要计算具体时间，只需要计算连续收获利润即可</p><p>计算收获利润时：</p><ol><li>收获利润这一天并不是最终收获利润的那一天</li><li>前一天是最终收获利润那一天，今天重新计算</li><li>不作操作，不买不卖</li></ol><p>很巧妙</p><p>每次执行操作时都加上fee，初始化一个buy，遍历数组，若是遇到p + fee &lt; buy的，另buy重置为p + fee，说明需要买入；若是遇到p &gt; buy的，说明有利润，直接加到sum里，并重置buy = p；其他的情况可以不管。</p><p>但其实本题用动态规划更好一点</p><h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><p>个人想法：可以发现，每三层必有一个监控，在第二层设置监控即可。另外再设置一个数组，用来标记是否已经监控，连续两层必有监控。</p><p>细节：但是设置标记数组的话，需要知道树的全部子节点，不易实现。</p><p>卡哥思路：从下到上，从最下面的叶子结点开始，对叶子结点的父节点设置监控。局部最优：从叶节点的父节点开始设置监控；全局最优：使用的摄像头最少</p><p>难点：</p><p>如何遍历树</p><p>如何隔两个节点放置监控</p><ol><li><p>如何遍历树<br>使用后序遍历</p></li><li><p>如何隔两个节点放置监控<br>每个节点三个状态：</p><ul><li>0   无覆盖</li><li>1   有摄像头</li><li>2   有覆盖</li></ul><p>单层处理逻辑四种情况：</p><ul><li>左右孩子都有覆盖<br>则中间节点肯定无覆盖</li><li>左右孩子至少有一个无覆盖<br>中间节点应放置摄像头</li><li>左右节点至少有一个摄像头</li><li>处理头结点</li></ul></li></ol><p>总的来说，一共就那几种情况。</p><p>先判断左右孩子是否至少有一个无覆盖，有则直接放置一个摄像头；再判断左右孩子是否都是有覆盖，若全都有覆盖，则中间节点必定是无覆盖；剩下情况直接返回有覆盖。</p><p>这是一道Hard题，==仔细揣摩==。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法</title>
    <link href="/2022/09/16/hui-su-suan-fa/"/>
    <url>/2022/09/16/hui-su-suan-fa/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯通常隐藏在递归函数的下面</p><p>==for循环横向遍历，递归纵向遍历==</p><p>回溯法是一个纯暴力搜索，并不是高效的算法</p><p>适用于：</p><ol><li>组合问题</li><li>切割问题</li><li>子集问题</li><li>排列问题</li><li>棋盘问题</li></ol><p>回溯法可以抽象为一个树形结构（n叉树）</p><h2 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="回溯法模板"></a>回溯法模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(参数)</span> &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素(树中结点孩子的数量就是集合的大小)) &#123;<br>        处理结点;<br>        backtracking(路径， 选择列表);   <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>        <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p><img src="/2022/09/16/hui-su-suan-fa/Typora文件\Typora图片\image-20220607093535686.png" alt="image-20220607093535686"></p><h2 id="组合总数III"><a href="#组合总数III" class="headerlink" title="组合总数III"></a>组合总数III</h2><ol><li>两个全局变量<br>List&lt;&gt; path;    List&lt;List&lt;&gt;&gt; res;<br>四个参数<br>n, k, index, sum</li><li>终止条件<br>值总和相等</li><li>单层处理逻辑<br>回溯</li></ol><p>剪枝操作：</p><ol><li>已经选择的元素个数：path.size();</li><li>还需要的元素个数为: k - path.size();</li><li>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li></ol><h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p>本题的难点在于：如何将数字与字母相对应？</p><p>可以用一个二维数组，将数字与字母位置写死，需要时可直接取出来；</p><p>还是递归老三部：</p><ol><li>确定递归参数</li><li>确定终止条件</li><li>确定单层处理逻辑</li></ol><p>本题貌似无法剪枝。</p><p>要进行字符串的增加或者删除时，可以使用StringBuilder，其中增加用append，删除用deleteCharAt()，最后转为String 可以用sb.toString()。</p><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p>依然是递归三部曲</p><p>只是这道题与之前的几道题的区别在于，这道题可以重复使用数字，并且没有限定有几个数；</p><p>首先对数组元素进行排序；解决重复使用数字，使用一个index，index用来定位，以前的不可重复递归的时候是index+1，可重复的话就是index；解决没有限定几个数，可以用sum是否大于target来判断</p><h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h2><p>难点在于，每个数字在组合中只能使用一次，==但是==，会出现重复的。</p><p>比如[1,1,2],target = 3,       处理不好的话[1,2],[1,2]会出现两次，就需要去重。回溯去重有两种去重，一种是树枝去重，另一种是树层去重。</p><p>对于本题来说，树枝是可以重复的，因为人家本来就有重复的元素；树层是不可以重复的。</p><p>有如下==两种办法去重==：</p><ol><li><p>使用数组标记<br>先判断，若i &gt; 0并且本次遍历元素与上一个元素相同，同时标记数组为false，则表明为树层重复，应该去掉，直接continue；<br>解释一下标记数组，若已经使用过，则将标记数组置为1，status[i - 1] == 0代表i-1个元素没有使用过<br>那么肯定，若i-1没有使用过，则本次重复为树层重复；若i-1已使用过，则代表已经使用过，为树枝重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; status[i - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)       <br><span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure></li><li><p>不使用数组标记<br>很简单，若是本次与上一个相等，则就是树层重复</p></li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ( i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] ) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><ul><li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个…..。</li><li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…..。</li></ul><p>亦可以抽象为一颗树形结构</p><p><img src="/2022/09/16/hui-su-suan-fa/Typora文件\Typora图片\image-20220610103125075.png" alt="image-20220610103125075"></p><p>难点：</p><ul><li>切割问题可以抽象为组合问题</li><li>如何模拟那些切割线<br>用index来定位</li><li>切割问题中递归如何终止<br>若index大于s.length()，则加入结果并返回</li><li>在递归循环中如何截取子串<br>用s.substring()</li><li>如何判断回文<br>回文好解决，用双指针解决</li></ul><h2 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h2><p>substring() 前闭后开</p><p>==做这类型题，一定注意区间是开还是闭！！！==</p><p>思路一：</p><p>本题可直接对原字符串s进行操作，因为后续会有回溯操作</p><p>需要写一个判断是否有效的函数，思路为：定义一个sum,令sum = sum * 10 + s.charAt(i) - ‘0’;即可求出数值，然后判断是否大于255即可</p><p>还有一个坑：因为要输出ip的时候ip地址中间有’.’，所以进行递归的时候直接i + 2,例如：backtracking(s, i + 2, pointsum);</p><p>同时，本题与其他的回溯不同的是，本题处理单层逻辑时，若是发现数字不是有效数字，则直接跳出，而不是continue；</p><p>思路二:</p><p>剪枝操作，回溯函数参数附带一个index，以及一个number，代表当前的ip段，一共有四段</p><p>终止条件：如果index == 字符串长度， 并且number == 4， 则是正确的，添加进res并返回，否则直接返回</p><p>单层操作：重点在for循环的第二个条件，在第二个条件里就判断是否有效，而不像思路一那样另写一个方法</p><p>==Integer.parseInt(s.substring(start, i + 1)) &gt;= 0 &amp;&amp; Integer.parseInt(s.substring(start, i + 1)) &lt;= 255；==</p><p>（若是面试华为鸿蒙的时候知道这个，说不定写出来了呢？）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length() &amp;&amp; i - start &lt; <span class="hljs-number">3</span> &amp;&amp; Integer.parseInt(s.substring(start, i + <span class="hljs-number">1</span>)) &gt;= <span class="hljs-number">0</span><br>&amp;&amp; Integer.parseInt(s.substring(start, i + <span class="hljs-number">1</span>)) &lt;= <span class="hljs-number">255</span>; i++) &#123;<br><span class="hljs-comment">// 如果ip段的长度大于1，并且第一位为0的话，continue</span><br>    <span class="hljs-comment">// 也就是说，0在第二位或者第三位，反正不在第一位，则令i++</span><br><span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> - start &gt; <span class="hljs-number">1</span> &amp;&amp; s.charAt(start) - <span class="hljs-string">&#x27;0&#x27;</span> == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>stringBuilder.append(s.substring(start, i + <span class="hljs-number">1</span>));<br><span class="hljs-comment">// 当stringBuilder里的网段数量小于3时，才会加点；如果等于3，说明已经有3段了，最后一段不需要再加点</span><br><span class="hljs-keyword">if</span> (number &lt; <span class="hljs-number">3</span>) &#123;<br>stringBuilder.append(<span class="hljs-string">&quot;.&quot;</span>);<br>&#125;<br>number++;<br>restoreIpAddressesHandler(s, i + <span class="hljs-number">1</span>, number);<br>number--;<br><span class="hljs-comment">// 删除当前stringBuilder最后一个网段，注意考虑点的数量的问题</span><br>stringBuilder.delete(start + number, i + number + <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p>难点在于：树枝上的子节点随时可以停下</p><p>个人思路：遍历一个，就把这个加入进去，碰到最大数即返回；所以可能要排序？</p><p>？？？竟然通过了，神奇！细节我还没有扣</p><hr><p>正确解法：</p><p><img src="/2022/09/16/hui-su-suan-fa/Typora文件\Typora图片\image-20220610151529520.png" alt="image-20220610151529520"></p><p>牛！</p><p>本题的res.add()位置就相当有讲究了</p><p>应该放在回溯的开头，为何？因为放在开头会有[]空这个子集，否则就少了一个子集</p><p>但是为什么不需要排序？是因为nums[i]就已经确定相对位置了，for循环从0开始，而num[]不变，就相当于一直往后遍历。这块有点绕，但精彩</p><h2 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h2><p>这个总要排序了吧？</p><p>这个要不排序的话，那么重复元素怎么解决。</p><p><em>倒是有一种解决办法，若这个元素与上个元素相等，则continue；</em>      ==解决不了==    必须要排序，要么排序，要么新建一个used数组</p><p>看了一眼，果然，是树层去重</p><p>Yes!!!!!!!                                   厉害厉害</p><h2 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h2><p>本题去重</p><p><img src="/2022/09/16/hui-su-suan-fa/Typora文件\Typora图片\image-20220613104412019.png" alt="image-20220613104412019"></p><p>昏过了 头，执行代码一直显示超出时间限制，原因是因为粗心大意而写了个死循环</p><p>map.getOrDefault(nums[i], 0)    厉害（我只会说厉害吗?）</p><p>词穷</p><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>排列问题与组合问题不同，组合问题需要一个index来确定遍历的位置，而排列不同，因为[2,1]和[1,2]是不同的，无法使用index，但是要使用一个used数组，或者其他的map等，用来记录是否已使用过</p><p>还是递归三部曲</p><p>参数不同，不需要index，同时可以定义一个全局变量，这样就不需要传参了。</p><h2 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h2><p>去重的时候，或者剪枝的时候</p><p>非常重要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// used[i - 1] == true，说明同一树枝nums[i - 1]使用过</span><br><span class="hljs-comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span><br></code></pre></td></tr></table></figure><p>树枝去重和树层去重；为什么不判断user[i]而要判断user[i - 1]呢，因为已经到了i这一层，那么i-1就一定已经处理过了</p><p>其余还是递归三部曲</p><h2 id="重新安排行程（重要）"><a href="#重新安排行程（重要）" class="headerlink" title="重新安排行程（重要）"></a>重新安排行程（重要）</h2><p>思路：</p><p>递归三部曲</p><p>可以发现，最终行程数 = 机场数 + 1，由此确定终止条件</p><p>回溯方法只考虑逻辑处理，而不考虑数据的输入，数据的输入在主函数完成</p><p>最重要的是各种集合的使用：</p><ul><li><p>集合的遍历：</p><ul><li><p>使用entry遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br> <br><span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;<br> <br>    System.out.println(<span class="hljs-string">&quot;Key = &quot;</span> + entry.getKey() + <span class="hljs-string">&quot;, Value = &quot;</span> + entry.getValue());<br> <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>遍历key或value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br> <br><span class="hljs-comment">//遍历map中的键</span><br> <br><span class="hljs-keyword">for</span> (Integer key : map.keySet()) &#123;<br> <br>    System.out.println(<span class="hljs-string">&quot;Key = &quot;</span> + key);<br> <br>&#125;<br> <br><span class="hljs-comment">//遍历map中的值</span><br> <br><span class="hljs-keyword">for</span> (Integer value : map.values()) &#123;<br> <br>    System.out.println(<span class="hljs-string">&quot;Value = &quot;</span> + value);<br> <br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>TreeMap的使用<br>会对key进行排序</p></li></ul><p>使用TreeMap，就很好的解决了题目要求的按字母大小排序的要求</p><blockquote><p>在进行插入的时候，逻辑是：1、判断是否存在这个key，如果存在，那么先取出原来的值，再赋值最新的值；若不存在，则建立一个TreeMap，再赋值最新的值。</p></blockquote><p>==遍历的时候总是多进一层==</p><blockquote><p>本题还有另外一个注意事项，就是本题的回溯方法返回值是boolean，为什么呢？</p></blockquote><p>因为我们只需要找出一个行程即可，若是找到行程，一路返回true；同时找行程的过程中使用TreeMap，就可以保证返回的行程是按字母表顺序来的</p><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>回溯法的经典题目</p><p>可以写个函数，来判断该位置是否能放皇后，      ==错误==：<em>斜对角的位置判断：数加起来等于一个定值，就说明该斜对角线已经有皇后了，如res[1] [2] 和res[0] [3],就属于同一条斜线</em></p><p>依然是递归三部曲</p><p>参数可以加一个row，用来遍历当前是第几层，同时若是到了最底层，则就返回；这是终止条件</p><p>┗|｀O′|┛ 嗷~~，知道了，判断是否有效不能简单的那么判断，因为上述没有考虑到另一条斜对角线，所以判断是否有效要分列，45°，135°三种情况</p><blockquote><p>不熟悉的方法：</p><ol><li>Arrays.fill（ a1, value ）;    其中a1是数组，后面value是值，数组赋值</li><li>String.copyValueOf(c)；    其中c是一个一维数组，char[] c， 表示将c转化为一个String类型<br>String.copyValueOf(char[] data, int offset, int count);  第二个参数表示子数组的初始偏移量；count表示子数组的长度</li></ol></blockquote><blockquote><p>新思路（新操作）：</p><ul><li>将数组全部置为’.’，满足要求再将数组置为’Q’</li><li>有些时候回溯算法处理单层逻辑时只考虑成功的情况，如   if () {} </li></ul></blockquote><h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h2><p>本题与以上的回溯法不同之处在于，本题是二重循环来进行遍历</p><p>总觉得时间复杂度会极高</p><p>同样，本题也需要单独写一个判断有效函数，有效函数行和列好判断，问题在于九宫格的判断；可以发现，本题数组下标是从0开始的，也就是说 012     345  678，由此可以想到，val除以3，得到start，然后再*三，就得到九宫格</p><blockquote><p>返回值</p></blockquote><p>回溯函数返回值是boolean，目的是找到一个正确的解，一旦找到正确的解就返回；在两层for循环之后，若是还找不到正确的解，就返回false，所以不需要终止条件！</p><blockquote><p>原创数字</p></blockquote><p>如果不注意，就会把人家的原创数字毁掉，这时就需要用continue来跳过原创数字</p><blockquote><p>单层处理逻辑</p></blockquote><p>在进行单层处理时，可以做如下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">board[i][j] = m;<br><span class="hljs-keyword">if</span> (tracking(board))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br></code></pre></td></tr></table></figure><p>2-3行为什么要用if呢，必须的！若是找到了解，则直接返回true；</p><blockquote><p>递归体现在哪里？</p></blockquote><p>上述有个continue操作，遇到数字就跳过，因为上一层中已经新设定了数字，所以这一层就不会动上一层的数字，从而达到回溯效果</p><h2 id="回溯法总结"><a href="#回溯法总结" class="headerlink" title="回溯法总结"></a>回溯法总结</h2><p>可以解决如下问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>子集问题分析：</p><ul><li>时间复杂度：O(2^n)，因为每一个元素的状态无外乎取与不取，所以时间复杂度为O(2^n)</li><li>空间复杂度：O(n)，递归深度为n，所以系统栈所用空间为O(n)，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为O(n)</li></ul><p>排列问题分析：</p><ul><li>时间复杂度：O(n!)，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ….. 1 = n!。</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>组合问题分析：</p><ul><li>时间复杂度：O(2^n)，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>N皇后问题分析：</p><ul><li>时间复杂度：O(n!) ，其实如果看树形图的话，直觉上是O(n^n)，但皇后之间不能见面所以在搜索的过程中是有剪枝的，最差也就是O（n!），n!表示n * (n-1) * …. * 1。</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>解数独问题分析：</p><ul><li>时间复杂度：O(9^m) , m是’.’的数目。</li><li>空间复杂度：O(n^2)，递归的深度是n^2</li></ul><p><strong>一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括吧！</strong></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2022/09/16/er-cha-shu/"/>
    <url>/2022/09/16/er-cha-shu/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树最近公共祖先"><a href="#二叉树最近公共祖先" class="headerlink" title="二叉树最近公共祖先"></a>二叉树最近公共祖先</h2><p>思路：</p><p>找p,q;必须要遍历整棵树，自底向上遍历，采用后序遍历</p><p>找到p或q就返回q或q的结点，找不到则返回空；若是发现左子树和右子树都不为空，那就说明，当前结点root就是最近的公共祖先；若是发现左子树为空，右子树不为空，则说明是通过右子树返回的，返回右子树即可</p><p>所以逻辑就很清楚了：</p><ol><li>先判断root是否为p q null 这几种情况 </li><li>left = 递归方法；</li><li>right = 递归方法；</li><li>再判断左右子树是否为空的情况，据此来返回二叉树最近公共祖先</li></ol><h2 id="二叉树搜索最近公共祖先"><a href="#二叉树搜索最近公共祖先" class="headerlink" title="二叉树搜索最近公共祖先"></a>二叉树搜索最近公共祖先</h2><p>一种思路是上述的二叉树最近公共祖先</p><p>另一种思路就是利用二叉搜索树的性质</p><p>思路：</p><p>如果当前结点同时大于p、q，那么就说明应该在左子树找；反之，在右子树找；如果发现一边大一边小，那么直接返回当前结点，当前结点就是最近公共祖先</p><p>第三种思路，迭代法</p><p>迭代法：</p><p>用一个while循环，若当前结点同时大于p、q，往左子树走；反之，往右子树走；否则，直接返回</p><p><strong>秒！！！</strong></p><h2 id="二叉搜索树的插入操作"><a href="#二叉搜索树的插入操作" class="headerlink" title="二叉搜索树的插入操作"></a>二叉搜索树的插入操作</h2><p>我的想法是，首先备份root结点（通过创建一个新节点），然后while写一个死循环，若找到插入位置，则break，最后返回即可。</p><p>上述为迭代法</p><p>下面是递归法：</p><p>若root为空，则创建一个新结点，说明找到位置了</p><p>若root大于当前结点，则递归左子树调用方法</p><p>若root小于当前结点，则递归右子树调用方法</p><h2 id="删除二叉搜索树中的结点"><a href="#删除二叉搜索树中的结点" class="headerlink" title="删除二叉搜索树中的结点"></a>删除二叉搜索树中的结点</h2><p>递归三部曲</p><ul><li>确定递归函数以及返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ul><p>思路：</p><p>一共有五种情况：</p><ol><li>根节点为空，则返回root，说明递归结束（没找到）；</li><li>根节点左右子树都为空，则返回null，说明是叶子结点，直接删掉；</li><li>根节点左子树为空右子树不为空，返回右子树；</li><li>根节点左子树不为空右子树为空，返回左子树；</li><li>根节点左右子树都不为空，则将左子树放到右子树的最左子树处，返回右子树。</li></ol><h2 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h2><p>剪枝操作</p><p>给定范围(low, high)</p><p>若根节点小于low，直接去操作右子树，左子树已然全部挂</p><p>同理，若根节点大于high，直接去操作左子树</p><p>若root在合理范围内，则递归操作左右子树</p><h2 id="将有序数组转为二叉搜索树"><a href="#将有序数组转为二叉搜索树" class="headerlink" title="将有序数组转为二叉搜索树"></a>将有序数组转为二叉搜索树</h2><p>注意数组越界，在二分法时要注意： int mid = left + ((right - left) / 2);</p><p>思路:</p><p>因为是有序，所以直接按区间划分，每次将中间结点赋值给root结点，然后递归的划分区间</p><h2 id="把二叉搜索树转化为累加树"><a href="#把二叉搜索树转化为累加树" class="headerlink" title="把二叉搜索树转化为累加树"></a>把二叉搜索树转化为累加树</h2><p>因为是二叉搜索树，所以中序遍历就是升序。</p><p>因为本题要累加，如果从最小的开始加的话，无法知道后续大于最小的数的累加；所以只能从最大的开始，从最大的开始的话，那直接对中序遍历做一个右中左的处理，即可达到逆序输出；</p><p>处理结点是先创建一个pre，来保存先前的数，而后一直加下去</p><h2 id="二叉树总结"><a href="#二叉树总结" class="headerlink" title="二叉树总结"></a>二叉树总结</h2><h3 id="1、二叉树的理论基础"><a href="#1、二叉树的理论基础" class="headerlink" title="1、二叉树的理论基础"></a>1、二叉树的理论基础</h3><ul><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于二叉树，你该了解这些！ (opens new window)</a>：二叉树的种类、存储方式、遍历方式、定义方式</li></ul><h3 id="2、二叉树的遍历方式"><a href="#2、二叉树的遍历方式" class="headerlink" title="2、二叉树的遍历方式"></a>2、二叉树的遍历方式</h3><ul><li>深度优先遍历<ul><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">二叉树：前中后序递归法 (opens new window)</a>：递归三部曲初次亮相</li><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">二叉树：前中后序迭代法（一） (opens new window)</a>：通过栈模拟递归</li><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html">二叉树：前中后序迭代法（二）统一风格(opens new window)</a></li></ul></li><li>广度优先遍历<ul><li><a href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">二叉树的层序遍历 (opens new window)</a>：通过队列模拟</li></ul></li></ul><h3 id="3、求二叉树的属性"><a href="#3、求二叉树的属性" class="headerlink" title="3、求二叉树的属性"></a>3、求二叉树的属性</h3><ul><li>二叉树：是否对称(opens new window)<ul><li>递归：后序，比较的是根节点的左子树与右子树是不是相互翻转</li><li>迭代：使用队列/栈将两个节点顺序放入容器中进行比较</li></ul></li><li>二叉树：求最大深度(opens new window)<ul><li>递归：后序，求根节点最大高度就是最大深度，通过递归函数的返回值做计算树的高度</li><li>迭代：层序遍历</li></ul></li><li>二叉树：求最小深度(opens new window)<ul><li>递归：后序，求根节点最小高度就是最小深度，注意最小深度的定义</li><li>迭代：层序遍历</li></ul></li><li>二叉树：求有多少个节点(opens new window)<ul><li>递归：后序，通过递归函数的返回值计算节点数量</li><li>迭代：层序遍历</li></ul></li><li>二叉树：是否平衡(opens new window)<ul><li>递归：后序，注意后序求高度和前序求深度，递归过程判断高度差</li><li>迭代：效率很低，不推荐</li></ul></li><li>二叉树：找所有路径(opens new window)<ul><li>递归：前序，方便让父节点指向子节点，涉及回溯处理根节点到叶子的所有路径</li><li>迭代：一个栈模拟递归，一个栈来存放对应的遍历路径</li></ul></li><li>二叉树：递归中如何隐藏着回溯(opens new window)<ul><li>详解<a href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html">二叉树：找所有路径 (opens new window)</a>中递归如何隐藏着回溯</li></ul></li><li>二叉树：求左叶子之和(opens new window)<ul><li>递归：后序，必须三层约束条件，才能判断是否是左叶子。</li><li>迭代：直接模拟后序遍历</li></ul></li><li>二叉树：求左下角的值(opens new window)<ul><li>递归：顺序无所谓，优先左孩子搜索，同时找深度最大的叶子节点。</li><li>迭代：层序遍历找最后一行最左边</li></ul></li><li>二叉树：求路径总和(opens new window)<ul><li>递归：顺序无所谓，递归函数返回值为bool类型是为了搜索一条边，没有返回值是搜索整棵树。</li><li>迭代：栈里元素不仅要记录节点指针，还要记录从头结点到该节点的路径数值总和</li></ul></li></ul><h3 id="4、二叉树的修改与构造"><a href="#4、二叉树的修改与构造" class="headerlink" title="4、二叉树的修改与构造"></a>4、二叉树的修改与构造</h3><ul><li>翻转二叉树(opens new window)<ul><li>递归：前序，交换左右孩子</li><li>迭代：直接模拟前序遍历</li></ul></li><li>构造二叉树(opens new window)<ul><li>递归：前序，重点在于找分割点，分左右区间构造</li><li>迭代：比较复杂，意义不大</li></ul></li><li>构造最大的二叉树(opens new window)<ul><li>递归：前序，分割点为数组最大值，分左右区间构造</li><li>迭代：比较复杂，意义不大</li></ul></li><li>合并两个二叉树(opens new window)<ul><li>递归：前序，同时操作两个树的节点，注意合并的规则</li><li>迭代：使用队列，类似层序遍历</li></ul></li></ul><h3 id="5、求二叉搜索树的属性"><a href="#5、求二叉搜索树的属性" class="headerlink" title="5、求二叉搜索树的属性"></a>5、求二叉搜索树的属性</h3><ul><li><a href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html">二叉搜索树中的搜索(opens new window)</a><ul><li>递归：二叉搜索树的递归是有方向的</li><li>迭代：因为有方向，所以迭代法很简单</li></ul></li><li><a href="https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">是不是二叉搜索树(opens new window)</a><ul><li>递归：中序，相当于变成了判断一个序列是不是递增的</li><li>迭代：模拟中序，逻辑相同</li></ul></li><li><a href="https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html">求二叉搜索树的最小绝对差(opens new window)</a><ul><li>递归：中序，双指针操作</li><li>迭代：模拟中序，逻辑相同</li></ul></li><li><a href="https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html">求二叉搜索树的众数(opens new window)</a><ul><li>递归：中序，清空结果集的技巧，遍历一遍便可求众数集合</li><li><a href="https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html">二叉搜索树转成累加树(opens new window)</a></li><li>递归：中序，双指针操作累加</li><li>迭代：模拟中序，逻辑相同</li></ul></li></ul><h3 id="6、二叉树公共祖先问题"><a href="#6、二叉树公共祖先问题" class="headerlink" title="6、二叉树公共祖先问题"></a>6、二叉树公共祖先问题</h3><ul><li>二叉树的公共祖先问题(opens new window)<ul><li>递归：后序，回溯，找到左子树出现目标值，右子树节点目标值的节点。</li><li>迭代：不适合模拟回溯</li></ul></li><li>二叉搜索树的公共祖先问题(opens new window)<ul><li>递归：顺序无所谓，如果节点的数值在目标区间就是最近公共祖先</li><li>迭代：按序遍历</li></ul></li></ul><h3 id="7、二叉搜索树的修改与构造"><a href="#7、二叉搜索树的修改与构造" class="headerlink" title="7、二叉搜索树的修改与构造"></a>7、二叉搜索树的修改与构造</h3><ul><li>二叉搜索树中的插入操作(opens new window)<ul><li>递归：顺序无所谓，通过递归函数返回值添加节点</li><li>迭代：按序遍历，需要记录插入父节点，这样才能做插入操作</li></ul></li><li>二叉搜索树中的删除操作(opens new window)<ul><li>递归：前序，想清楚删除非叶子节点的情况</li><li>迭代：有序遍历，较复杂</li></ul></li><li>修剪二叉搜索树(opens new window)<ul><li>递归：前序，通过递归函数返回值删除节点</li><li>迭代：有序遍历，较复杂</li></ul></li><li>构造二叉搜索树(opens new window)<ul><li>递归：前序，数组中间节点分割</li><li>迭代：较复杂，通过三个队列来模拟</li></ul></li></ul><h3 id="8、阶段总结"><a href="#8、阶段总结" class="headerlink" title="8、阶段总结"></a>8、阶段总结</h3><p>大家以上题目都做过了，也一定要看如下阶段小结。</p><p><strong>每周小结都会对大家的疑问做统一解答，并且对每周的内容进行拓展和补充，所以一定要看，将细碎知识点一网打尽！</strong></p><ul><li><a href="https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20200927%E4%BA%8C%E5%8F%89%E6%A0%91%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html">本周小结！（二叉树系列一）(opens new window)</a></li><li><a href="https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201003%E4%BA%8C%E5%8F%89%E6%A0%91%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html">本周小结！（二叉树系列二）(opens new window)</a></li><li><a href="https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201010%E4%BA%8C%E5%8F%89%E6%A0%91%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html">本周小结！（二叉树系列三）(opens new window)</a></li><li><a href="https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201017%E4%BA%8C%E5%8F%89%E6%A0%91%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html">本周小结！（二叉树系列四）(opens new window)</a></li></ul><h3 id="9、最后总结"><a href="#9、最后总结" class="headerlink" title="9、最后总结"></a>9、最后总结</h3><p><strong>在二叉树题目选择什么遍历顺序是不少同学头疼的事情，我们做了这么多二叉树的题目了，Carl给大家大体分分类</strong>。</p><ul><li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li><li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li><li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li></ul><p>注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序，<a href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html">二叉树：找所有路径 (opens new window)</a>也用了前序，这是为了方便让父节点指向子节点。</p><p>所以求普通二叉树的属性还是要具体问题具体分析。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2022/09/16/dan-diao-zhan/"/>
    <url>/2022/09/16/dan-diao-zhan/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>在使用单调栈的时候首先要明确如下几点：</p><ol><li>单调栈里存放的元素是什么？</li></ol><p>单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。</p><ol><li>单调栈里元素是递增呢？ 还是递减呢？</li></ol><p><strong>注意一下顺序为 从栈头到栈底的顺序</strong>，因为单纯的说从左到右或者从前到后，不说栈头朝哪个方向的话，大家一定会越看越懵。</p><h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h2><p>思路一：暴力，两层for循环就可以解决问题</p><p>思路二：单调栈</p><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。</p><p>单调栈时间复杂度为O(n)</p><p>本题使用栈头到栈尾递增，注意单调栈里面放的是元素的下标i</p><p>若是栈尾元素大于等于当前元素，直接进栈；否则栈尾元素小于当前元素的话，先弹出比当前元素小的栈尾（用while判断），再入栈</p><h2 id="下一个更大元素I"><a href="#下一个更大元素I" class="headerlink" title="下一个更大元素I"></a>下一个更大元素I</h2><p>首先想到暴力解法，外层遍历nums1，内层遍历nums2，当然可以，时间复杂度是O(n*2)</p><p>也可使用单调栈</p><p>我是这么想的，先用“每日温度”的思路，把nums2寻找右侧第一个比自己大的元素的位置找到，然后再遍历num1。可以一试；NO，到最后给res赋值的时候，找不到nums2的具体位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(nums2[i] &lt;= nums2[stack.peek()])    <span class="hljs-comment">//  小于等于，继续往里放</span><br>     stack.push(i);<br><span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()]) &#123;<br>           <span class="hljs-keyword">if</span> (hashMap.containsKey(nums2[stack.peek()])) &#123;<br>                  <span class="hljs-type">Integer</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> hashMap.get(nums2[stack.peek()]); <span class="hljs-comment">//先取出nums2的下标，再赋值给nums1</span><br>                  res[index] = nums2[i];<br>           &#125;<br>           stack.pop();<br>     &#125;<br>     stack.push(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>重点是第6、7行的代码</p><p>目的是nums1要从nums2中取出数；比如下面的nums[1],   nums[1] = 1,计算nums2中1的右边第一个大的元素，返回的是nums2[1]而不是下标1</p><p><img src="/2022/09/16/dan-diao-zhan/Typora文件\Typora图片\image-20220915111659905.png" alt="image-20220915111659905"></p><h2 id="下一个更大元素II"><a href="#下一个更大元素II" class="headerlink" title="下一个更大元素II"></a>下一个更大元素II</h2><p>本题加了个循环，个人想法是两遍，数组遍历两遍，当成一个数组来做</p><p>确实可以，但是做了无用功，例如扩充数组，扩充数组就不说了，最后还需要将res数组又缩小</p><p>卡哥思路：跟上题大体上类似，只不过本题是遍历了2倍的数组，然后循环的时候计算用i%size来计算</p><p>这种单调栈，我觉得最重要的是赋值的处理，循环内的关键代码的书写</p><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>三种思路：</p><p>一、双指针法</p><p>要求雨水，按列来求，雨水的高度等于该列左侧最高高度和右侧最高高度中低的那个，只需要将左右侧低的那个柱子的高度减去当前列柱子的高度，就可求出该列的雨水，然后从0循环，求总和</p><p>二、动态规划法</p><p>牛蛙牛蛙</p><p>动态规划思路和双指针法其实差不多，只不过由于双指针法存在着大量重复的操作，动态规划优化了一下而已</p><p>动态规划要求将左侧最高高度和右侧最高高度都保存在对应的一个数组里，如maxleft[], maxright[]</p><p>递推公式：左边的最高高度为上一个的最高高度和当前的高度取最大值，右侧同理</p><p>从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);</p><p>从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);</p><p>最后求和</p><p>本题动态规划最简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] maxleft = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[height.length];<br><span class="hljs-type">int</span>[] maxright = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[height.length];<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>maxleft[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>maxright[height.length - <span class="hljs-number">1</span>] = height[height.length - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; height.length; i++) &#123;<br>     maxleft[i] = Math.max(maxleft[i - <span class="hljs-number">1</span>], height[i]);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> height.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>     maxright[i] = Math.max(maxright[i + <span class="hljs-number">1</span>], height[i]);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; height.length; i++) &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> Math.min(maxleft[i], maxright[i]) - height[i];<br>     <span class="hljs-keyword">if</span> (area &gt; <span class="hljs-number">0</span>)<br>          sum += area;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br></code></pre></td></tr></table></figure><p>三、单调栈法</p><p>单调栈法比较难理解，单调栈法是维持栈内从栈头到栈尾从小到大的顺序排列，一旦发现新入栈的元素值大于栈顶元素，就弹出栈顶元素，此时栈顶元素就是底部，再弹出栈顶元素，栈顶元素就是左侧柱子，新入栈的元素就是右侧柱子；</p><p>思路有了，其中还有一些小细节。</p><p>求雨水的高度就是长乘宽，长是高度，宽是右侧与左侧柱子之间的距离，相加。</p><blockquote><p>关键代码：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stacktop]) &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">bottom</span> <span class="hljs-operator">=</span> stack.pop();    <span class="hljs-comment">//先把底柱的编号取出</span><br>     <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;   <span class="hljs-comment">//若是栈不为空的话，进行操作</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(height[i], height[stack.peek()]);    <span class="hljs-comment">//取出左边和右边的最小值，注意左柱为弹出</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> (min - height[bottom]) * (i - stack.peek() - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 求面积</span><br>          <span class="hljs-keyword">if</span> (area &gt; <span class="hljs-number">0</span>)<br>                sum += area;<br>          stacktop = stack.peek();   <span class="hljs-comment">//注意：左柱并没有弹出，而是更新栈顶元素，接着判断，因为是while</span><br>     &#125;<br>&#125;<br>stack.push(i);   <span class="hljs-comment">//最后再将当前元素进栈，进行下一次循环</span><br></code></pre></td></tr></table></figure><h2 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h2><p>感觉这类题动态规划可能好一点？</p><p>本题跟接雨水那道题类似，只不过本题换成了求当前柱子左右两边第一个小于该柱子的柱子</p><p>还有一个区别，是本题要记录下标，而不是高度</p><blockquote><p>思路一：动态规划</p></blockquote><p>动态规划主要体现在求两侧第一个小于该柱子的柱子上</p><ul><li>求左侧：<br>从0开始遍历，使用一个变量t来记录，碰到大的，再往左走；碰到小的直接赋值</li><li>求右侧：<br>从length-2开始遍历，跟求左侧一样</li></ul><p>最后求和，求最大</p><blockquote><p>思路二：单调栈</p></blockquote><p>也能成功AC，但是很明显，单调栈的用时更长</p><p>维持一个栈头到栈尾由大到小的栈，若是遇到当前元素大于栈头元素的，直接进栈；等于也是直接进栈；当前元素小于栈头元素的，那么当前栈顶元素就是底柱，栈顶弹出后，当前元素的栈顶是左柱，i是右柱；即可求出面积，并同求最大值。</p><p>但是需要数组扩容，两边同时扩一下；可能是为了防止i = 1的时候前面没有元素可弹出现栈溢出的错误吧。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2022/09/16/dong-tai-gui-hua/"/>
    <url>/2022/09/16/dong-tai-gui-hua/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划通俗来讲就是由上一个状态推导出来的</p><p>状态转移公式</p><p>一般解题步骤有以下五步：</p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p>动态规划Debug</p><p>先确定状态转移公式，做到心中有数；若没通过，打印出来，看看与自己心中所想是否一样；若是一样的，那就是递推公式、初始化或者遍历顺序有问题了。</p><p>==问题要问的专业==</p><h2 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h2><p>DP五部曲：</p><ol><li><p>确定dp数组以及下标含义：dp[i]的定义：第i个数的斐波那契数值是dp[i]</p></li><li><p>确定递推公式：题目已经给了，<strong>状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p></li><li><p>如何初始化：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">dp[0] = 0;<br>dp[1] = 1;<br></code></pre></td></tr></table></figure></li><li><p>确定遍历顺序：从前往后遍历</p></li><li><p>举例推导dp数组：按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p><p>0 1 1 2 3 5 8 13 21 34 55</p></li></ol><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p>dp[i]的定义：  第i个阶梯有多少种爬楼梯的方式</p><p>递推公式：  </p><p>Out！</p><p>卡哥思路：</p><ol><li>dp[i]的定义：  第i个阶梯有多少种爬楼梯的方式</li><li>递推公式：<br>先想dp[i - 1]，dp[i - 1] 再爬上一阶就是dp[i];再想dp[i - 2]，dp[i - 2]再爬上两阶就是dp[i]；<br>所以dp[i] = dp[i - 1] + dp[i - 2];</li><li>初始化就有争议了：但是注意看题目的范围，题目说的是n为整数，那么自然从1开始喽，初始化1、2，然后从3开始遍历</li><li>确定遍历顺序：从前往后遍历</li><li>举例推导dp数组：<br><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220624112625495.png" alt="image-20220624112625495"></li></ol><p>递推公式这样想： i层 = i - 1 层 + i- 2 层的</p><p>有多少种方法达到i-1层，先记为n1,；有多少种方法达到i-2层，再记为n2；让这俩相加即可</p><h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h2><p>但是这道题好像也可以用贪心？</p><ol><li>dp[i]表示前i阶楼梯所用的花费</li><li>递推公式：<br>不会了</li></ol><p>不能用贪心</p><p>接着来</p><ol><li>dp[i]表示前i阶楼梯所用的花费</li><li>递推公式：<br>从i-1和i-2处下手，dp[i] = min(dp[i-1], dp[i - 2]) + cost[i];<br>不会递推公式了就从i-1和i-2下手</li><li>初始化：只需初始化dp[0]和dp[1]即可</li><li>确定遍历顺序，本体显然是从前到后</li><li>举例推导</li></ol><p>个人觉得dp完了之后还要验算一下结尾情况</p><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义，dp[i] [j]表示到达这一步有多少种走法，最后返回dp[m] [n]即可</li><li>递推公式：<br>dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1];</li><li>初始化：<br>dp[0] [0] = 1；dp[0] [1] = 1；dp[1] [0] = 1；</li><li>二维数组进行遍历，双重循环</li><li>举例推导</li></ol><p>上述五部曲中，有问题的是第三点和第四点。首先第三点初始化，初始化只初始化了  0 1   和 1 0，但是要是碰到0 2 和2 0 呢？会报错，所以边界都要考虑到位，至于说是具体是几种走法，当然是一种啦，因为边界，只有从边界这一侧走过来；第四点遍历顺序，不够细致，是从左到右为主呢还是从上到下为主，其实我觉得都可以，但是要写出来，从左到右顺理成章。</p><p>成功AC</p><p>还有一种思路：</p><p>数论方法：</p><p>组合数学中学到的蚂蚁上树问题，厉害厉害！</p><p>组合问题，从（0，0）到（m, n），共需要 m + n - 2步，需要m - 1步的向右，所以就是</p><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220627101912530.png" alt="image-20220627101912530"></p><p>Yse, AC !</p><p>long 转int:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回int型</span><br><span class="hljs-type">long</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">300</span>;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)a;<br></code></pre></td></tr></table></figure><h2 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h2><p>中间有障碍物了；</p><p>个人思路：与上一题dp一样，只不过多了一个障碍物判断</p><ol><li>确定dp数组的含义，dp[i] [j]表示到达这一步有多少种走法，最后返回dp[m] [n]即可</li><li>递推公式：<br>dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1];中间加一个判断是否为障碍物</li><li>初始化：<br>所有边界都初始化为1</li><li>一层一层的来，从左到右，从上到下</li><li>举例推导</li></ol><p>Yes   成功AC，改了半天bug，问题在于初始化，若是碰到在边界的障碍物，该怎么初始化？应该将其以及其后面的边界全置位0</p><p>看了卡哥的代码，感觉自己好蠢啊，其实可以不用分的这么细，只考虑需要的情况即可，例如进行初始化时我是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; obstacleGrid.length; i++) &#123;<br>          <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)<br>              flag = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>)<br>              dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">else</span><br>              dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>      &#125;<br>      flag = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; obstacleGrid[<span class="hljs-number">0</span>].length; j++) &#123;<br>          <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>)<br>              flag = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>)<br>              dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">else</span><br>              dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>      &#125;<br></code></pre></td></tr></table></figure><p>卡哥是这样的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>   <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//一旦遇到障碍，后续都到不了</span><br>   dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>   <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">////一旦遇到障碍，后续都到不了</span><br>   dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      &#125;<br></code></pre></td></tr></table></figure><p>遍历优化,我的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obstacleGrid[i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span> &amp;&amp; obstacleGrid[i][j - <span class="hljs-number">1</span>] != <span class="hljs-number">1</span>)<br>dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obstacleGrid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> &amp;&amp; obstacleGrid[i - <span class="hljs-number">1</span>][j] != <span class="hljs-number">1</span>)<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br><span class="hljs-keyword">else</span><br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>但其实，这三种可以合为一种，因为碰到一种情况时，另一个dp就为0，所以加上也无所谓</p><p>可以直接合为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><p>动态规划五部曲：</p><ol><li>确定dp[i]的意思：dp[i]表示 i可以拆分成的最大乘积。下面想不通了可以回来想想dp[i]的含义；</li><li>确定递推公式：递归公式若是不好想的话，可以往回想想，想想i - 1或者是dp[i]是怎么得来的。可以分为两部分：  j *(i - j)或者 j *dp[i - j]，二者取最大值。这为什么可以呢，第一个是把 i直接分为两个数的乘积，第二个是把i分为两个以上的乘积，j从1开始遍历，一直去最大值即可；</li><li>初始化：dp[1] = 1;dp[2] = 1; dp[3] = 2;</li><li>遍历顺序从前到后，两层遍历；外层是i: 3到i，内层是j: 1到i</li><li>举例推导</li></ol><p>这道题遍历的时候，卡哥内层是从1遍历到i - j，卡哥说是后面重复了，但是由于我还没有相同，所以直接用的 1到i</p><h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h2><p>动态规划五部曲：</p><ol><li>确定dp[i]的意思：dp[i]的意思是i个节点的二叉搜索树共有dp[i]种</li><li>确定递推公式：往回想，如果求dp[3]的时候，先想dp[2],然后再怎么演化为dp[3]，但是演化，我想到的是：分为大于部分和小于部分，但是中间部分呢？<br>dp[i] = 2 * dp[i - 1] + 1？</li><li>初始化：</li></ol><p>卒！</p><p>第二步就错了。</p><p>卡哥思路：画图，先画出一个节点的数量，再画出两个节点的数量；然后画第三个节点的时候，分为几种情况，1为节点头，2为节点头，3为节点头。</p><p>1为节点头时，数量就是dp[2]；2为节点头时，数量就是d[1]*d[1];3为节点头时，数量就是dp[2]。</p><p>所以接着上述：</p><ol><li></li><li>递推公式：dp[i]  += dp[j - 1] * dp[i - j];  j从1开始</li><li>初始化：只需初始化dp[0] = 1即可</li><li>遍历顺序当然是从前往后遍历</li><li>举例推导 </li></ol><p>成功AC！但是递推公式到底怎么想出来的。</p><p>当i = 3时，   0 2；  1 1； 2 0  </p><p>j从0开始，到i - 1。</p><p>递推公式依然是从前面几个入手，从而推出i是怎么来到 。</p><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220628110720342.png" alt="image-20220628110720342"></p><h3 id="01背包问题（二维数组）"><a href="#01背包问题（二维数组）" class="headerlink" title="01背包问题（二维数组）"></a>01背包问题（二维数组）</h3><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>动态规划五部曲：</p><ol><li><p>确定dp数组以及含义：对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p></li><li><p>那么可以有两个方向推出来dp[i] [j]，</p><ul><li><strong>不放物品i</strong>：由dp[i - 1] [j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1] [j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</li><li><strong>放物品i</strong>：由dp[i - 1] [j - weight[i]]推出，dp[i - 1] [j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1] [j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li></ul><p>递归公式： dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);</p></li><li><p>初始化：首先从dp[i] [j]的定义出发，如果背包容量j为0的话，即dp[i] [0]，无论是选取哪些物品，背包价值总和一定为0。</p><p>状态转移方程 dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p><p>dp[0] [j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p><p>那么很明显当 j &lt; weight[0]的时候，dp[0] [j] 应该是 0，因为背包容量比编号0的物品重量还小。</p><p>当j &gt;= weight[0]时，dp[0] [j] 应该是value[0]，因为背包容量放足够放编号0物品。</p><p>代码初始化如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; j &lt; weight[<span class="hljs-number">0</span>]; j++) &#123;  <span class="hljs-comment">// 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。</span><br>    dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 正序遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>其他的下标可以初始化为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化 dp</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(weight.size()</span>, vector&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220628112932740.png" alt="image-20220628112932740"></p></li><li><p>确定遍历顺序，先遍历物品后遍历背包重量和先遍历背包重量后遍历物品都可以，只是先遍历物品更容易理解。<br>先遍历物品：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]; <br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先遍历背包重量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>举例推导</p></li></ol><p>Java完整01背包代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>        <span class="hljs-type">int</span>[] value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bagsize</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>        testweightbagproblem(weight, value, bagsize);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testweightbagproblem</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weight, <span class="hljs-type">int</span>[] value, <span class="hljs-type">int</span> bagsize)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">wlen</span> <span class="hljs-operator">=</span> weight.length, value0 = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//定义dp数组：dp[i][j]表示背包容量为j时，前i个物品能获得的最大价值</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[wlen + <span class="hljs-number">1</span>][bagsize + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//初始化：背包容量为0时，能获得的价值都为0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= wlen; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = value0;<br>        &#125;<br>        <span class="hljs-comment">//遍历顺序：先遍历物品，再遍历背包容量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= wlen; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= bagsize; j++)&#123;<br>                <span class="hljs-keyword">if</span> (j &lt; weight[i - <span class="hljs-number">1</span>])&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i - <span class="hljs-number">1</span>]] + value[i - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//打印dp数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= wlen; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagsize; j++)&#123;<br>                System.out.print(dp[i][j] + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.print(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="01背包问题（滚动数组）"><a href="#01背包问题（滚动数组）" class="headerlink" title="01背包问题（滚动数组）"></a>01背包问题（滚动数组）</h3><p>滚动数组其实就是一维数组</p><p>动态规划五部曲：</p><ol><li><p>确定dp数组的定义<br>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p></li><li><p>一维dp数组的递推公式</p><p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p><p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p><p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1] [j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，所以递归公式为：   dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p></li><li><p>初始化数组，初始化一定要和定义联系在一起<br>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。<br>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p></li><li><p>遍历顺序：遍历顺序一定是先遍历物品，再遍历背包容量。并且遍历背包容量的时候，滚动数组一定是从大到小的遍历。为什么呢？因为滚动数组遍历的时候需要前面的值，但是前面的值一直变化，而从后往前的 话，前面的值就一直为0。</p></li><li><p>举例推导</p><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220629111108557.png" alt="image-20220629111108557"></p></li></ol><p>滚动数组遍历全代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-type">int</span>[] weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>       <span class="hljs-type">int</span>[] value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">bagWight</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>       testWeightBagProblem(weight, value, bagWight);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWeightBagProblem</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weight, <span class="hljs-type">int</span>[] value, <span class="hljs-type">int</span> bagWeight)</span>&#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">wLen</span> <span class="hljs-operator">=</span> weight.length;<br>       <span class="hljs-comment">//定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值</span><br>       <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bagWeight + <span class="hljs-number">1</span>];<br>       <span class="hljs-comment">//遍历顺序：先遍历物品，再遍历背包容量</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; wLen; i++)&#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bagWeight; j &gt;= weight[i]; j--)&#123;<br>               dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">//打印dp数组</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagWeight; j++)&#123;<br>           System.out.print(dp[j] + <span class="hljs-string">&quot; &quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>其实我还没完全理解明白！</p><h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2><p>这完全看不出来是要用动态规划啊。个人思路：先进行排序，然后从中间分成两个数组，每次判断是否相等，若是不相等，则从大的那边匀一个给小的，以此类推；最后要是发现大的那边最终小于小的那边了，则证明没有，返回false。</p><blockquote><p>回溯法：</p><ul><li>698.划分为k个相等的子集</li><li>473.火柴拼正方形</li></ul></blockquote><p>以上我的思路是也称为回溯暴力法，但是超时。直接上01背包</p><p>重点是要理解为何能嵌套01背包，以及重量以及容量都对应着什么。</p><p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p><ul><li>背包的体积为sum / 2</li><li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li><li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。</li><li>背包中每一个元素是不可重复放入。</li></ul><p>动态规划五部曲：</p><ol><li><p>确定dp数组含义：<br>**dp[j]表示 背包总容量是j，最大可以凑成j的子集总和为dp[j]**。</p></li><li><p>确定递推公式：<br>本题相当于背包里放数值，那么重量也就是nums[i]，其价值也是nums[i]<br>dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</p></li><li><p>如何初始化，跟滚动数组初始化一样，0初始化为0，其余整数初始化为0，负数初始化为负无穷</p></li><li><p>遍历顺序，同滚动数组，先遍历物品，放到这道题也就是nums[i]；嵌套遍历价值</p></li><li><p>举例推导</p><p>dp[j]的数值一定是小于等于j的。</p><p><strong>如果dp[j] == j 说明，集合中的子集总和正好可以凑成总和j，理解这一点很重要。</strong></p></li></ol><p>好好想想！！！</p><p>一层遍历最后的结果，也是一层一层，还是相当于两层遍历的结果，只不过最后保存的是i = nums.length 的值</p><h2 id="最后一块石头的重量II"><a href="#最后一块石头的重量II" class="headerlink" title="最后一块石头的重量II"></a>最后一块石头的重量II</h2><p>与昨天的分割等子集和类似，都是分割成两块重量相差最小的块，然后相减即可。<em>不过这道题与上题不同的是，其中一块的具体重量无法确定</em></p><p>本题物品重量store[], 价值也为store[]；对应01背包问题的物品重量和价值</p><ol><li>确定dp数组的含义：dp[j]表示j块石头相加得出来的总重量</li><li>确定递归函数：可以分为两步考虑，一个是不放第j块，另一个是放第j块；不放就是dp[j ], 放就是dp[j - store[j] ] + store[j]<br>所以：dp[j] = max(dp[j], dp[j - store[j] ] + store[j]  )</li><li>初始化：先全部初始化为0，之后肯定会一层一层的遍历；至于dp数组开到多大，一种做法是所有数相加再除以二；还有一种是看题目给的范围，直接范围除以二</li><li>遍历顺序：外层从前往后，内层从后往前</li><li>举例推导</li></ol><p>最后判断的时候，dp[j]表示可以装多大的重量，那么另一边就是sum - dp[j],那么相差最小就是 sum - dp[j] - dp[j]</p><p>上面斜体字写得 那一段，真是愚蠢！</p><p>dp不管如何分，只管target的大小，也就是总和 / 2；</p><p>其实动态规划二维数组和一维数组，本质上还是二维数组，只不过每次二维数组一次遍历，而一维数组进行多次遍历，最后只保留最后一次遍历的那次结果。</p><h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h2><p>瞟了一眼卡哥的思路，我只能说牛</p><p>首先给出了一个target，那么一定会有left 和right；   同时left + right = sum; 但是 target = left - (sum - left); 所以left = (target + sum) / 2,本题也就转换为求数组中有多少个和是left的组合</p><p>同样，动态规划五部曲：</p><ol><li><p>确定dp[]数组的含义：dp[j]数组表示和为j的有多少种方法</p></li><li><p>确定递归函数</p><p>确定递归函数的时候，考虑一下来源；来源有哪些呢？不考虑nums[i]的情况下，填满容量为j - nums[i]的背包，有dp[j - nums[i]]种方法。<br>考虑nums[i]的情况下，凑成dp[j]就有dp[j - nums[i]]种方法。</p><p>例如：dp[j]，j 为5，</p><ul><li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 dp[5]。</li><li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 dp[5]。</li><li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 dp[5]</li><li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 dp[5]</li><li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 dp[5]</li></ul><p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来</p><p>组合问题的公式：dp[j] += dp[j - nums[i]]</p></li><li><p>初始化：全初始化为0</p></li><li><p>遍历顺序：外层从前往后，内层从后往前</p></li><li><p>举例推导</p></li></ol><p>可以记住：在求装满背包有几种方法的时候，递推公式一般为：dp[j] += dp[j - nums[i]];</p><p>到最后动态规划总结的 时候，==一定要多总结各种dp公式==！！</p><h2 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h2><p>动态规划？</p><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]数组表示</li></ol><p>破功</p><p>动规五部曲：</p><ol><li><p>确定dp数组的含义：**dp[i] [j]：最多有i个0和j个1的strs的最大子集的大小为dp[i] [j]**。</p></li><li><p>确定递推公式</p><p>dp[i] [j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。</p><p>dp[i] [j] 就可以是 dp[i - zeroNum] [j - oneNum] + 1。</p><p>然后我们在遍历的过程中，取dp[i] [j]的最大值。</p><p>所以递推公式：dp[i] [j] = max(dp[i][j], dp[i - zeroNum] [j - oneNum] + 1);</p></li><li><p>dp数组如何初始化，初始化为0即可，因为物品重量不可能为0，所以只需初始化为0；</p></li><li><p>确定遍历顺序<br>外层for循环遍历物品，内层for循环遍历背包容量且从后向前遍历！</p></li><li><p>举例推导</p></li></ol><h2 id="零钱兑换II"><a href="#零钱兑换II" class="headerlink" title="零钱兑换II"></a>零钱兑换II</h2><p>一看到题目中的是钱币不限，就知道要用完全背包</p><ol><li>确定dp数组含义：dp[j]表示总金额为j的货币组合数为dp[j]</li><li>确定递推公式：dp[j]就是dp[j - coins[i]]（不考虑coins[i]）相加。<br>所以：dp[j] += dp[j - coins[i]]</li><li>如何初始化：dp[0] = 1,这是开始，其余初始化为0；</li><li>确定遍历顺序<br>到底是先遍历背包再遍历重量还是先遍历重量再遍历背包；先试想一下，若是先遍历背包再遍历重量，那么重量就会遍历好几次，可能就是排列；而先遍历重量再遍历背包的话，就是组合。若是是在无法确定，自己手动演示一遍</li><li>举例推导</li></ol><p>要想清楚，背包和物品套在本题是对应哪一部分</p><blockquote><p>再来理解一下递推公式：     dp[j] += dp[j - coins[i]]   ；代表遍历每个 coins，那么dp[j]就等于 前一个的相加，而前一个就用coins[i]来表示；所以会有   += 的出现。</p></blockquote><p><strong>注意：求装满背包有几种方法类似的题目，递推公式基本都是这样的</strong>。</p><h2 id="组合总和IV"><a href="#组合总和IV" class="headerlink" title="组合总和IV"></a>组合总和IV</h2><p>不对，自己哪里出了问题</p><ol><li>确定dp数组含义：dp[j]表示总和为j的组合数为dp[j]</li><li>确定递推公式：dp[j]就是dp[j - nums[i]]（不考虑nums[i]）相加。<br>所以：dp[j] += dp[j - nums[i]]</li><li>如何初始化：dp[0] = 1,这是开始，其余初始化为0；</li><li>确定遍历顺序<br>到底是先遍历背包再遍历重量还是先遍历重量再遍历背包；先试想一下，若是先遍历背包再遍历重量，那么重量就会遍历好几次，可能就是排列；而先遍历重量再遍历背包的话，就是组合。若是是在无法确定，自己手动演示一遍<br>那么本题，要求的是排列数，那就先遍历背包再遍历重量;</li><li>举例推导</li></ol><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><h2 id="爬楼梯-进阶版"><a href="#爬楼梯-进阶版" class="headerlink" title="爬楼梯(进阶版)"></a>爬楼梯(进阶版)</h2><ol><li>确定dp数组以及下标的含义<br><strong>dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法</strong>。</li><li>确定递推公式：<br>dp[i]有几种来源，dp[i-1],dp[i-2],dp[i-3]等等。dp[i] += dp[i - j]</li><li>dp如何初始化<br>dp[0] = 1,其余都初始化为0</li><li>确定遍历顺序<br>首先明确要求排列还是求组合，这是求排列问题；那么先遍历背包，再遍历重量</li><li>举例推导</li></ol><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>总金额为背包，coins为物品重量；要求件数最少</p><p>动态规划五部曲：</p><ol><li>确定dp数组含义：<br>dp[i]表示总金额为i的最少的硬币个数</li><li>确定递推公式：<br>先考虑dp[i]怎么来的，dp[i]由 dp[i - coins[j]]，然后一直遍历；那么就是dp[i] += dp[i - coins[j]]</li><li>初始化<br>dp[0] = 1,其余都为0</li><li>遍历顺序<br>组合还是排列？组合，那就先物品重量，再背包</li><li>举例推导</li></ol><p>错！</p><ol><li><p>确定dp数组含义：<br>dp[i]表示总金额为i的最少的硬币个数</p></li><li><p>确定递推公式：<br>先考虑dp[j]怎么来的，dp[j]由 dp[j - coins[i]]，</p><p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）</p><p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p><p>递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);</p></li><li><p>初始化<br>dp[0] = 0,其他的初始化的时候，要考虑要求最大值还是求最小值，题目是要求最小值，那么就赋值最大值，否则就会被dp[0]一直覆盖</p></li><li><p>遍历顺序<br>本题组合和排列均可，那就先背包还是先物品都可以</p></li><li><p>举例推导</p></li></ol><p>动态规划就算知道了五部曲，到现在还有两个难点：</p><ul><li>遍历时i 和 j的初始值赋值问题，尤其是内层循环，是从 0开始还是从coins[i]开始</li><li>写递推公式的判定问题，是直接写还是要满足什么条件再写</li></ul><h2 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h2><p>告诉你用动态规划，要怎么套</p><p>背包是整数n，重量是每个完全平方数，完全平方数可以重复使用，相当于完全背包问题；<strong>但是重量需要判断</strong></p><ol><li>确定dp数组的含义：dp[j]表示和为j的完全平方数的最少数量</li><li>确定递推公式：<br>dp[j]可以由dp[j - i *i] 得来，所以dp[j] = min(dp[j], dp[j - i * i] + 1);</li><li>初始化：因为要求最小值，所以初始化为最大值；dp[0] = 0;</li><li>确定遍历顺序：遍历顺序都可，就先遍历背包，再遍历重量吧</li><li>举例推导</li></ol><blockquote><p>突然发现一个特点，那就是遍历的时候，dp[j]还是dp[i]，是谁不知道，但是一定要满足的是，要从头开始遍历，不能断断续续，这也能确定一部分是i还是j</p></blockquote><p>==举例推导也很重要==</p><p>但是本题重要不需要判断，那么题目中要求的完全平方数体现在哪里呢？体现在递推公式上，递推公式是dp[j - i * i]，后面i * i就已经把那些不是完全平方数的排除了，不手动进行筛选，只在for循环里面进行筛选；也是一种思路</p><p>奥！我突然知道了，最内层循环的关键代码，dp[i]还是dp[j]要取决于代表的意义，==若i代表的是背包，则是dp[i]；反之==</p><h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h2><p>套动态规划、</p><p>字符串s相当于背包总重量，wordDict数组相当于物品重量；要求的是排列，组合肯定不行；</p><ol><li>确定dp数组的含义：dp[i]表示第i个位置可以匹配到</li><li></li></ol><p>OUT</p><p>思路不对。我的思路是求排列，但是若是遇到重复的 ？所以只需要组合</p><ol><li>确定dp数组的含义：dp[i]表示第i个位置可以匹配到</li><li>确定递推公式：<br>首先若是dp[j]为true的时候，说明  0-j 都可以遍历成功；那么若是存在   i - j 的字符串，则dp[i ]设置为true；if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true。</li><li>初始化：dp[0] = true；0是一定要初始化的，因为所有的判断都是以前面的为基础</li><li>遍历顺序：先遍历背包和先遍历物品都可以；但是推荐先遍历背包，若是先遍历物品的话，那就需要提前先把所有物品放进容器里</li><li>举例推导</li></ol><p>好难！ </p><h2 id="背包问题总结"><a href="#背包问题总结" class="headerlink" title="==背包问题总结=="></a>==背包问题总结==</h2><p>背包递推公式：</p><ul><li>问能否装满背包：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</li><li>问装满背包有几种方法：dp[j] += dp[j - nums[i]] ；</li><li>问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); </li><li>问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); </li></ul><p>遍历顺序：</p><ol><li><p>01背包<br>二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。</p></li><li><p>完全背包</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。<br>如果求最小数，那么两层for循环的先后顺序就无所谓了。</p></li></ol><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]表示前i个元素可以偷取的最大金额</li><li>确定递推公式：<br>我感觉要建立一个数组，确定是否已经选取；先假定选取第一个，然后不选第二个，再选第三个的时候判断第一个大还是第二个大；<br>dp[j]  += max(dp[j - 1], dp[j] )</li></ol><p>但是判定数组如何使用？</p><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]表示前i个元素可以偷取的最大金额</li><li>确定递推公式：<br>决定dp[i]的因素就是第i房间偷还是不偷。如果偷，那么就dp[i] = dp[i - 2] + nums[i]；若是不偷，则dp[i] = dp[i - 1]。但是这里要判断一下，这俩个那两个大，那么就是：dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])</li><li>初始化：直接初始化dp[0] = nums[0]，dp[1] = max(nums[0], nums[1])</li><li>确定遍历顺序：一层循环？从前往后遍历</li><li>举例推导</li></ol><p>动态规划并不是非要套什么01背包问题，像本题就不用，且单层循环</p><p>还要注意要判空处理，比如数组只有一个数或者是数组为空的情况</p><h2 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a>打家劫舍II</h2><p>本题相比上题，多了一个循环，也就是收尾是相连的；换句话说，就是选首不能选尾，选尾不能选首。可以把第一个数加到最后一个数后面这样处理吗？</p><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]表示前i个元素可以偷取的最大金额</li><li>确定递推公式：<br>决定dp[i]的因素就是第i房间偷还是不偷。如果偷，那么就dp[i] = dp[i - 2] + nums[i]；若是不偷，则dp[i] = dp[i - 1]。但是这里要判断一下，这俩个那两个大，那么就是：dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])</li><li>初始化：直接初始化dp[0] = nums[0]，dp[1] = max(nums[0], nums[1])</li><li>确定遍历顺序：一层循环？从前往后遍历</li><li>举例推导</li></ol><p>卡哥厉害！</p><p>分析如下：</p><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220708113513360.png" alt="image-20220708113513360"></p><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220708113521374.png" alt="image-20220708113521374"></p><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220708113529354.png" alt="image-20220708113529354"></p><p>既然首尾不能同时存在，那么我手动切去首或者尾不就行了。</p><p>情况二三可以包含情况一，所以代码总体逻辑还是跟上题类似，只不过本题需要比较情况二和情况三谁大谁小</p><blockquote><p>两个问题（已理顺）</p></blockquote><ol><li>主函数边界问题<br>主函数边界问题要深入到动态规划函数里面，发现里面的前闭后开的，解决。</li><li>不用数组进行动态规划遍历问题<br>首先要清楚，遍历要用到i-1和i-2的，那么就要定义三个变量，一个是i-2，一个是i-1，一个是i；分别用x,y,z来表示。由于初始化全为0，所以先赋值i - 1；再赋值当前的i，也就是动态规划递推公式，最后更新i -2,也就是x</li></ol><h2 id="打家劫舍III"><a href="#打家劫舍III" class="headerlink" title="打家劫舍III"></a>打家劫舍III</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[j]表示到第j层可以偷到的最大金额</li><li>确定递推公式：  考虑dp[j]，dp[j]要么是j-2个加上j的，要么是j-1的；具体是哪个取决于哪个比较大。<br>所以递推公式：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j])</li><li>初始化：第一层初始化为root，第二层初始化为第一层和第二层的最大值；</li><li>遍历顺序：使用层序遍历，一层一层</li><li>举例推导</li></ol><p>卡哥思路：</p><p>树形动态规划又是另外一种情况：</p><ol><li><p>确定递归函数的参数和返回值<br>返回的就是dp数组</p></li><li><p>确定终止条件<br>在遍历的过程中，若遇到空节点，无论是偷或者不偷，都初始化为0；注意，是数组</p></li><li><p>确定遍历顺序：<br>使用后序遍历；通过递归左节点，得到左节点偷与不偷的金钱；通过递归右节点，得到左节点偷与不偷的金钱</p></li><li><p>确定单层递归的逻辑</p><p>首先明确一点，res[0, 1];res[0]代表不偷当前节点，res[1]代表偷当前节点<br>分两种情况，若是偷当前节点，则左右节点不能偷，val1 = cur-&gt;val + left[0] + right[0];若是不偷当前节点，那么就要偷左右节点，既然是偷左右节点，那当然是要找左右节点的最大值，val2 = max(left[0], left[1]) + max(right[0], right[1])</p></li><li><p>举例推导</p></li></ol><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>贪心：</p><p>牛！计算最左最小值，最优最大值，计算差值即可</p><p>动态规划五部曲：</p><ol><li>确定dp数组含义：dp[i] [0]表示今天持有股票所得的价值；dp[i] [1]表示今天不持有股票所得的价值</li><li>确定动态规划递推公式：首先要明确，持有并不代表今天买入，同样，不持有并不代表是今天卖出的；<br>那么问题明朗了，持有分两种情况，一种是今天买入，一种是今天不买入；所以dp[i] [0] = max(- prices[i], dp[i - 1] [0]);<br>不持有分两种情况，一种是今天卖出，一种是今天不卖出；所以dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</li><li>初始化：从递推公式上可以看出，都是基于前一个来进行递推，所以初始化dp[0] [0] = -prices[0], dp[0] [1] = 0;</li><li>遍历顺序：从前往后遍历</li><li>举例推导</li></ol><blockquote><p>注意，确定动态规划递推公式的时候，注意正负号；</p></blockquote><p>动态规划确定dp数组的时候，思路要打开，有可能二维数组是因为有两个不同的维度，比如物品重量和物品价值；但也有可能是做一个标记，0 和 1；</p><h2 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h2><p>动态规划五部曲：</p><ol><li>确定dp数组含义：dp[i] [0]表示今天持有股票所得的价值；dp[i] [1]表示今天不持有股票所得的价值</li><li>确定动态规划递推公式：首先要明确，持有并不代表今天买入，同样，不持有并不代表是今天卖出的；<br>那么问题明朗了，持有分两种情况，一种是今天买入，一种是今天不买入；今天买入的情况，要用昨天未买入的价值减去prices[i]，<strong>这一点也是与前一道题有所不同</strong>， 所以dp[i] [0] = max(dp[i - 1] [1] - prices[i], dp[i - 1] [0]);<br>不持有分两种情况，一种是今天卖出，一种是今天不卖出；所以dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</li><li>初始化：从递推公式上可以看出，都是基于前一个来进行递推，所以初始化dp[0] [0] = -proces[0], dp[0] [1] = 0;</li><li>遍历顺序：从前往后遍历</li><li>举例推导</li></ol><h2 id="买卖股票的最佳时机III"><a href="#买卖股票的最佳时机III" class="headerlink" title="买卖股票的最佳时机III"></a>买卖股票的最佳时机III</h2><p>动态规划五部曲：</p><ol><li><p>确定dp数组的含义：dp[i] [j], j 从 0 到4 ，分别代表着不操作，第一次买卖股票，第二次买卖股票</p></li><li><p>确定动态规划递推公式：<br>不操作就不用说了，达到dp[i] [1]有两种途径：</p><ul><li>今天购买，dp[i] [1] = dp[i - 1] [0] - prices[i]</li><li>今天沿用昨天的状态，dp[i] [1] = dp[i - 1] [1]</li></ul><p>取最大值：  dp[i] [1] = max(dp[i - 1] [0] - prices[i], dp[i - 1] [1])<br>同样 dp[i] [2] = max(dp[i - 1] [1] + prices[i], dp[i - 1] [2])</p><p>同理 dp[i] [3] = max(dp[i - 1] [2] - prices[i], dp[i - 1] [3])</p><p>​         dp[i] [4] = max(dp[i - 1] [3] + prices[i], dp[i - 1] [4])</p></li><li><p>如何初始化：<br>dp[0] [0] = 0;  dp[0] [1] = -prices[0];  dp[0] [2] = 0; dp[0] [3] = -prices[0];  dp[0] [4] = 0; </p></li><li><p>确定遍历顺序：从前往后遍历</p></li><li><p>举例推导</p></li></ol><h2 id="买卖股票的最佳时机IV-再考虑考虑"><a href="#买卖股票的最佳时机IV-再考虑考虑" class="headerlink" title="买卖股票的最佳时机IV(再考虑考虑)"></a>买卖股票的最佳时机IV(再考虑考虑)</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j],代表第i天的状态为j所剩下的最大现金<ul><li>j的状态表示为：<br>0代表什么都不干，；<br>1代表第一次买入<br>2代表第一次卖出<br>3代表第二次买入<br>4代表第二次卖出    那么j的范围就可以定义为2*k + 1</li></ul></li><li>确定动态规划递推公式：<br>要想达到dp[i] [1]有两种：今天买，或者今天沿用昨天的状态；  dp[i] [1] = dp[i - 1] [0] - prices[i]  ； dp[i] [1] = dp[i - 1] [1]   ，选最大的<br>同样，达到dp[i] [2]也有两种：今天卖，今天沿用昨天的状态；  dp[i] [2] = max(dp[i - 1] [1] + prices[i], dp[i - 1] [2])<br>遍历j，从0到2*k + 1即可</li><li>初始化：<br>dp[0] [0] = 0;   第一次买入的话，dp[0] [1] = -prices[i]  ;第一次卖出的话，dp[0] [2] = 0;同理，之后只要是买入，不管第几次，都是-prices[i]</li><li>确定遍历顺序：从前往后</li><li>举例推导</li></ol><h2 id="最佳买卖股票时机含冷冻期-再考虑考虑"><a href="#最佳买卖股票时机含冷冻期-再考虑考虑" class="headerlink" title="最佳买卖股票时机含冷冻期(再考虑考虑)"></a>最佳买卖股票时机含冷冻期(再考虑考虑)</h2><p>动态规划五部曲：</p><ol><li><p>确定dp数组的含义：dp[i] [j],代表第i天的状态为j所剩下的最大现金</p><ul><li>j的第一个状态：0，表示今天买入</li><li>j的第一个状态：1，表示今天保持卖出状态，且度过冷冻期</li><li>j的第一个状态：2，表示今天卖出</li><li>j的第一个状态：3，表示今天为冷冻期</li></ul></li><li><p>确定递推公式：<br>==!==想想dp[i] [0] 如何来的，也就是今天买入，一种是今天买入，另一种是今天保持买入状态。二者取最大：max(dp[i - 1] [0] + prices[i] , dp[i - 1] [0]);;<br>以上错误，没有考虑到冷冻期的存在</p><p>达到买入股票状态（状态一）即：dp[i] [0]，有两个具体操作：</p><ul><li>操作一：前一天就是持有股票状态（状态一），dp[i] [0] = dp[i - 1] [0]</li><li>操作二：今天买入了，有两种情况<ul><li>前一天是冷冻期（状态四），dp[i - 1] [3] - prices[i]</li><li>前一天是保持卖出股票状态（状态二），dp[i - 1] [1] - prices[i]</li></ul></li></ul><p>所以操作二取最大值，即：max(dp[i - 1] [3], dp[i - 1] [1]) - prices[i]</p><p>那么dp[i] [0] = max(dp[i - 1] [0], max(dp[i - 1] [3], dp[i - 1] [1]) - prices[i]);</p><p>达到保持卖出股票状态（状态二）即：dp[i] [1]，有两个具体操作：</p><ul><li>操作一：前一天就是状态二</li><li>操作二：前一天是冷冻期（状态四）</li></ul><p>dp[i] [1] = max(dp[i - 1] [1], dp[i - 1] [3]);</p><p>达到今天就卖出股票状态（状态三），即：dp[i] [2] ，只有一个操作：</p><ul><li>操作一：昨天一定是买入股票状态（状态一），今天卖出</li></ul><p>即：dp[i] [2] = dp[i - 1] [0] + prices[i];</p><p>达到冷冻期状态（状态四），即：dp[i] [3]，只有一个操作：</p><ul><li>操作一：昨天卖出了股票（状态三）</li></ul><p>dp[i] [3] = dp[i - 1] [2];<br>==注意：讨论的是买卖股票的状态，并不是今天一定要买卖==</p></li><li><p>初始化<br>主要考虑第0天如何初始化即可。<br>dp[0] [0] = -prices[0]<br>dp[0] [1] = 0 ,第0天没有卖出，初始化为0即可<br>dp[0] [2] = 0, dp[0] [3] = 0</p></li><li><p>遍历顺序，从前往后</p></li><li><p>举例推导</p></li></ol><p>本题官方给的答案也很清晰</p><h2 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a>买卖股票的最佳时机含手续费</h2><ol><li><p>确定dp数组的含义：dp[i] [0],  dp[i] [1]，分别代表着持有股票所得的最大收入和不持有股票所得的最大收入</p></li><li><p>确定动态规划递推公式：<br>达到dp[i] [0]有两种途径：</p><ul><li>昨天已购买，dp[i] [0] = dp[i - 1] [0]</li><li>今天购买，dp[i] [0] = dp[i - 1] [1] -  prices[i]</li></ul><p>达到dp[i] [1] 有两种途径</p><ul><li>昨天已卖出，dp[i] [1] = dp[i - 1] [1]</li><li>今天卖出，要加上手续费，dp[i] [1] = dp[i - 1] [0] + prices[i] -fee</li></ul></li><li><p>如何初始化：<br>dp[0] [1] = 0;  dp[0] [0] = -prices[0]; </p></li><li><p>确定遍历顺序：从前往后遍历</p></li><li><p>举例推导</p></li></ol><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]表示i之前包括i的最长递增子序列的个数</li><li>确定递推公式：<br>个人想法是从当前位置向前找第一个小于i的那个，然后+1<br>其实道理都一样，卡哥是用dp[i]和dp[j]+1中取最大值，j的范围是0 到 i - 1</li><li>初始化：先全部初始化为1；   遍历为二次循环，而不是一次循环</li><li>遍历顺序：从前往后    i外层，j内层</li><li>举例推导 </li></ol><h2 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]表示i之前包括i的最长连续递增子序列的个数</li><li>确定递推公式：<br>只需要判断nums[i] 和nums[i-1]谁大谁小，若i大，则dp[i] = dp[i - 1] + 1，否则令dp[i] = 1</li><li>初始化：先全部初始化为1； </li><li>遍历顺序：从前往后   </li><li>举例推导</li></ol><p>So Easy！</p><h2 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j] 表示以下标i-1结尾的a和以下标j-1结尾的b的最长重复子数组</li><li>确定递推公式：<br>通过以前的状态来判断，若是A和B数组相等，那么就令dp[i] [j] = dp[i - 1] [j - 1] + 1;</li><li>初始化：首先dp[0] [0]是无意义的，但为了方便后续，将dp[0] [0]  dp[0] [j] dp[i] [0]全部初始化为0；其实初不初始化的无所谓</li><li>遍历顺序，两层遍历</li><li>举例推导</li></ol><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j]表示从0到i-1的字符串1和从0到j-1的字符串2的最长公共子序列</li><li>确定递推公式：<br>两种结果：相等、不等；相等的情况：dp[i] [j] = dp[i - 1] [j - 1] + 1;不等的情况：取dp[i - 1] [j - 2]和dp[i - 2] [j - 1]的最大值</li><li>初始化：将带0的初始化为0，带0的毫无意义</li><li>遍历顺序：从递推公式可以看出，一定是从前到后，从上到下</li><li>举例推导</li></ol><h2 id="不相交的线"><a href="#不相交的线" class="headerlink" title="不相交的线"></a>不相交的线</h2><p>与上述最长公共子序列代码95%一致</p><h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]表示前i个数的最大子序和</li><li>确定递推公式：<br>这么想，第i个数有两种情况，一种是直接加入dp[i]，另一种是从头算起，二者取最大</li><li>初始化：dp[0] = nums[0]</li><li>遍历顺序：从前到后</li><li>举例推导</li></ol><h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j]表示前i-1和前j - 1的字符串为子序列的个数</li><li>确定递推公式：<br>考虑两种情况：1、  i - 1 == j - 1，则dp[i] [j] = dp[i - 1] [ j - 1] + 1;2、i - 1 ！= j - 1，若不相等，那么T就要“删除”掉j - 1了，那么从数值上来看就相当于dp[i] [ j] = dp[i] [j - 1]</li><li>初始化：将带0的全部初始化为0</li><li>遍历顺序，两层循环，外层是i，遍历s；</li><li>举例推导</li></ol><p>==注意边界，每次都是边界出错；最后判断的是dp[s.length()] [t.length()]而不是dp[s.length()+1] [t.length()+1]==</p><blockquote><p>因为s.length()本身就不包括最后一个元素，属于是前闭后开</p></blockquote><h2 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j]表示前i-1和前j - 1的字符串为不同子序列的个数</li><li>确定递推公式：<br>两大块：1、相等  2、不等<br>1、相等： 可以用dp[i - 1] [j - 1]，也可以不用，为什么不用呢，是因为不同的子序列，可能得到的结果不同，所以就是dp[i - 2] [j - 1];二者相加，也即dp[i] [j] = dp[i - 1] [j - 1] + dp[i - 1] [j];<br>2、不等： 不等直接就是dp[i - 1] [j]，即dp[i] [j] = dp[i - 1] [j];</li><li>初始化：首先带0的肯定是要初始化的，至于怎么初始化，看dp[i] [0]，代表的含义以i-1为结尾的s可以随便删除元素，出现空字符串的个数；那么s删除所以元素才能 出现空字符串，也就是只有一种情况，所以就是dp[i] [0] = 1; dp[0] [j] 代表的含义是以j-1为结尾的t可以随便删除元素，出现空字符串的个数，那么肯定就是0，因为s为空，是无论如何都不可能变为j的；最后看dp[0] [0]，初始化为1</li><li>遍历顺序：从左到右，从上到下</li><li>举例推导</li></ol><blockquote><p>又是那个问题，边界没有注意到</p></blockquote><h2 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h2><p>两种动态规划的思路：</p><p>思路一：与上述的最长公共子序列相同，只不过多了一步用两个字符串的总长度减去最长公共子序列的长度</p><p>思路二：</p><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</li><li>确定递推公式：<br>word[i] 和word[j]相等：相等好说，直接dp[i] [j] = dp[i - 1] [j - 1]<br>word[i] 和word[j]不等：不等又有三种情况可以操作，删掉i+1，删掉j+1，同时删掉i和j+2；取最小值</li><li>初始化：dp[i] [0] 和dp[j] [0] 和dp[0] [0]是必须要初始化的；dp[i] [0]初始化为i，dp[0] [j]初始化为j，dp[0] [0]初始化为0</li><li>遍历顺序：两层循环，外层i</li><li>举例推导</li></ol><blockquote><p>1、Math.min() 该方法只能比较两个数的大小，碰到三个的就用两次该方法吧</p><p>2、要求最小值，那么每一次操作的+1必不可少</p></blockquote><h2 id="编辑距离-（经典）"><a href="#编辑距离-（经典）" class="headerlink" title="==编辑距离==（经典）"></a>==编辑距离==（经典）</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要操作元素的最少次数。</li><li>确定递推公式：<br>分两种情况：要么相等、要么不等<br>相等的情况：直接dp[i] [j] = dp[i - 1] [j - 1]<br>不等的情况：又分三种情况，需要word1增、删、改<pre><code class="hljs">                   增：word1增也即word2删，即dp[i] [j] = dp[i] [j - 1] + 1                   删：dp[i] [j] = dp[i - 1] [j] + 1                   改：改意思是word1 和 word2 相等，即dp[i] [j] = dp[i - 1] [j - 1] + 1</code></pre>取最小值</li><li>初始化：从递推公式可以看出，带0的必须初始化，dp[i] [0]初始化为i，dp[0] [j] 初始化为j</li><li>遍历顺序：两层循环，外层i</li><li>举例推导</li></ol><p>我愿称之为经典</p><h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j] 表示i到j的回文数</li><li>确定递推公式：<br>同样，s[i] 和s[j] 分相等和不等<br>不等：dp[i] [j] = false<br>相等：i和j相等或相差1，如a,   aa;   i 和j相差大于1，大于1，说明两个边已经是回文了，那么就判断里面是否也是回文，也即判断i+1 和 j - 1；</li><li>初始化：dp[i] [j]初始化为false</li><li>遍历顺序：dp[i] [j] 用到了 dp[i+1] [j-1]。意思是要用到左下角的数据，所以是从下到上，从左到右</li><li>举例推导</li></ol><blockquote><p>if (dp[i] [j])  和 if (dp[i] [j] == true)是判断是否为true<br>if (dp[i] [j] = true) 是赋值</p></blockquote><p>还有一种思路：</p><p>中心扩散法。  遍历每个回文中心，若相等同时向两边扩散，同时总数+1</p><h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j] 表示i到j的回文数</li><li>确定递推公式：<br>两种情况，s[i] 和 s[j] 相等，不等<br>相等：  那么向里边扩散，即dp[i] [j] = dp[i + 1] [ j -1] + 2<br>不等： 判断向左大还是向右，即dp[i] [j] = max(dp[i + 1] [j], dp[i] [ j - 1], dp[i] [j])</li><li>初始化：dp[i] [i] 初始化为1，其余初始化为0</li><li>遍历顺序：遍历顺序从递推公式开始，可以看出，这一行用到的数据需要用到下一行的数据，那也就是从下到上，从左到右</li><li>举例推导</li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2022/09/15/wo-de-di-yi-pian-bo-ke-wen-zhang/"/>
    <url>/2022/09/15/wo-de-di-yi-pian-bo-ke-wen-zhang/</url>
    
    <content type="html"><![CDATA[<p>第一章</p><p>第二章</p><p>内容</p><p>参考文献</p><p>域名</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/15/hello-world/"/>
    <url>/2022/09/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
