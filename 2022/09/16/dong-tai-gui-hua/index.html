

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid5.png">
  <link rel="icon" href="/img/fluid5.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Zbiao">
  <meta name="keywords" content="">
  
    <meta name="description" content="动态规划动态规划通俗来讲就是由上一个状态推导出来的 状态转移公式 一般解题步骤有以下五步：  确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组  动态规划Debug 先确定状态转移公式，做到心中有数；若没通过，打印出来，看看与自己心中所想是否一样；若是一样的，那就是递推公式、初始化或者遍历顺序有问题了。 &#x3D;&#x3D;问题要问的专业&#x3D;&#x3D; 斐波那">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划">
<meta property="og:url" content="http://example.com/2022/09/16/dong-tai-gui-hua/index.html">
<meta property="og:site_name" content="Zbiao | 多吃一点">
<meta property="og:description" content="动态规划动态规划通俗来讲就是由上一个状态推导出来的 状态转移公式 一般解题步骤有以下五步：  确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组  动态规划Debug 先确定状态转移公式，做到心中有数；若没通过，打印出来，看看与自己心中所想是否一样；若是一样的，那就是递推公式、初始化或者遍历顺序有问题了。 &#x3D;&#x3D;问题要问的专业&#x3D;&#x3D; 斐波那">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/09/16/dong-tai-gui-hua/Typora文件/Typora图片/image-20220624112625495.png">
<meta property="og:image" content="http://example.com/2022/09/16/dong-tai-gui-hua/Typora文件/Typora图片/image-20220627101912530.png">
<meta property="og:image" content="http://example.com/2022/09/16/dong-tai-gui-hua/Typora文件/Typora图片/image-20220628110720342.png">
<meta property="og:image" content="http://example.com/2022/09/16/dong-tai-gui-hua/Typora文件/Typora图片/image-20220628112932740.png">
<meta property="og:image" content="http://example.com/2022/09/16/dong-tai-gui-hua/Typora文件/Typora图片/image-20220629111108557.png">
<meta property="og:image" content="http://example.com/2022/09/16/dong-tai-gui-hua/Typora文件/Typora图片/image-20220708113513360.png">
<meta property="og:image" content="http://example.com/2022/09/16/dong-tai-gui-hua/Typora文件/Typora图片/image-20220708113521374.png">
<meta property="og:image" content="http://example.com/2022/09/16/dong-tai-gui-hua/Typora文件/Typora图片/image-20220708113529354.png">
<meta property="article:published_time" content="2022-09-16T09:42:49.000Z">
<meta property="article:modified_time" content="2022-10-22T10:59:00.964Z">
<meta property="article:author" content="Zbiao">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/09/16/dong-tai-gui-hua/Typora文件/Typora图片/image-20220624112625495.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>动态规划 - Zbiao | 多吃一点</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/toubudaziji.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/gundongtiao.css# 滚动条颜色.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":true,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>ZBiao&#39; Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default3.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="动态规划"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-16 17:42" pubdate>
          2022年9月16日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          163 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="算法"
        id="heading-046a899ee7a6ec88d370211a518c9e80" role="tab" data-toggle="collapse" href="#collapse-046a899ee7a6ec88d370211a518c9e80"
        aria-expanded="true"
      >
        算法
        <span class="list-group-count">(8)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-046a899ee7a6ec88d370211a518c9e80"
           role="tabpanel" aria-labelledby="heading-046a899ee7a6ec88d370211a518c9e80">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2022/10/13/v2-ha-xi-biao/" title="v2-哈希表"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">v2-哈希表</span>
        </a>
      
    
      
      
        <a href="/2022/10/08/v2-shu-zu/" title="v2-数组"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">v2-数组</span>
        </a>
      
    
      
      
        <a href="/2022/09/16/er-cha-shu/" title="二叉树"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">二叉树</span>
        </a>
      
    
      
      
        <a href="/2022/09/16/dong-tai-gui-hua/" title="动态规划"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">动态规划</span>
        </a>
      
    
      
      
        <a href="/2022/09/16/dan-diao-zhan/" title="单调栈"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">单调栈</span>
        </a>
      
    
      
      
        <a href="/2022/09/16/hui-su-suan-fa/" title="回溯算法"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">回溯算法</span>
        </a>
      
    
      
      
        <a href="/2022/09/16/tan-xin-suan-fa/" title="贪心算法"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">贪心算法</span>
        </a>
      
    
      
      
        <a href="/2022/09/21/lian-biao/" title="链表"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">链表</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">动态规划</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划通俗来讲就是由上一个状态推导出来的</p>
<p>状态转移公式</p>
<p>一般解题步骤有以下五步：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<p>动态规划Debug</p>
<p>先确定状态转移公式，做到心中有数；若没通过，打印出来，看看与自己心中所想是否一样；若是一样的，那就是递推公式、初始化或者遍历顺序有问题了。</p>
<p>==问题要问的专业==</p>
<h2 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h2><p>DP五部曲：</p>
<ol>
<li><p>确定dp数组以及下标含义：dp[i]的定义：第i个数的斐波那契数值是dp[i]</p>
</li>
<li><p>确定递推公式：题目已经给了，<strong>状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p>
</li>
<li><p>如何初始化：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">dp[0] = 0;<br>dp[1] = 1;<br></code></pre></td></tr></table></figure></li>
<li><p>确定遍历顺序：从前往后遍历</p>
</li>
<li><p>举例推导dp数组：按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p>
<p>0 1 1 2 3 5 8 13 21 34 55</p>
</li>
</ol>
<h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p>dp[i]的定义：  第i个阶梯有多少种爬楼梯的方式</p>
<p>递推公式：  </p>
<p>Out！</p>
<p>卡哥思路：</p>
<ol>
<li>dp[i]的定义：  第i个阶梯有多少种爬楼梯的方式</li>
<li>递推公式：<br>先想dp[i - 1]，dp[i - 1] 再爬上一阶就是dp[i];再想dp[i - 2]，dp[i - 2]再爬上两阶就是dp[i]；<br>所以dp[i] = dp[i - 1] + dp[i - 2];</li>
<li>初始化就有争议了：但是注意看题目的范围，题目说的是n为整数，那么自然从1开始喽，初始化1、2，然后从3开始遍历</li>
<li>确定遍历顺序：从前往后遍历</li>
<li>举例推导dp数组：<br><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220624112625495.png" srcset="/img/loading.gif" lazyload alt="image-20220624112625495"></li>
</ol>
<p>递推公式这样想： i层 = i - 1 层 + i- 2 层的</p>
<p>有多少种方法达到i-1层，先记为n1,；有多少种方法达到i-2层，再记为n2；让这俩相加即可</p>
<h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h2><p>但是这道题好像也可以用贪心？</p>
<ol>
<li>dp[i]表示前i阶楼梯所用的花费</li>
<li>递推公式：<br>不会了</li>
</ol>
<p>不能用贪心</p>
<p>接着来</p>
<ol>
<li>dp[i]表示前i阶楼梯所用的花费</li>
<li>递推公式：<br>从i-1和i-2处下手，dp[i] = min(dp[i-1], dp[i - 2]) + cost[i];<br>不会递推公式了就从i-1和i-2下手</li>
<li>初始化：只需初始化dp[0]和dp[1]即可</li>
<li>确定遍历顺序，本体显然是从前到后</li>
<li>举例推导</li>
</ol>
<p>个人觉得dp完了之后还要验算一下结尾情况</p>
<h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><p>动态规划五部曲：</p>
<ol>
<li>确定dp数组的含义，dp[i] [j]表示到达这一步有多少种走法，最后返回dp[m] [n]即可</li>
<li>递推公式：<br>dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1];</li>
<li>初始化：<br>dp[0] [0] = 1；dp[0] [1] = 1；dp[1] [0] = 1；</li>
<li>二维数组进行遍历，双重循环</li>
<li>举例推导</li>
</ol>
<p>上述五部曲中，有问题的是第三点和第四点。首先第三点初始化，初始化只初始化了  0 1   和 1 0，但是要是碰到0 2 和2 0 呢？会报错，所以边界都要考虑到位，至于说是具体是几种走法，当然是一种啦，因为边界，只有从边界这一侧走过来；第四点遍历顺序，不够细致，是从左到右为主呢还是从上到下为主，其实我觉得都可以，但是要写出来，从左到右顺理成章。</p>
<p>成功AC</p>
<p>还有一种思路：</p>
<p>数论方法：</p>
<p>组合数学中学到的蚂蚁上树问题，厉害厉害！</p>
<p>组合问题，从（0，0）到（m, n），共需要 m + n - 2步，需要m - 1步的向右，所以就是</p>
<p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220627101912530.png" srcset="/img/loading.gif" lazyload alt="image-20220627101912530"></p>
<p>Yse, AC !</p>
<p>long 转int:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回int型</span><br><span class="hljs-type">long</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">300</span>;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)a;<br></code></pre></td></tr></table></figure>

<h2 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h2><p>中间有障碍物了；</p>
<p>个人思路：与上一题dp一样，只不过多了一个障碍物判断</p>
<ol>
<li>确定dp数组的含义，dp[i] [j]表示到达这一步有多少种走法，最后返回dp[m] [n]即可</li>
<li>递推公式：<br>dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1];中间加一个判断是否为障碍物</li>
<li>初始化：<br>所有边界都初始化为1</li>
<li>一层一层的来，从左到右，从上到下</li>
<li>举例推导</li>
</ol>
<p>Yes   成功AC，改了半天bug，问题在于初始化，若是碰到在边界的障碍物，该怎么初始化？应该将其以及其后面的边界全置位0</p>
<p>看了卡哥的代码，感觉自己好蠢啊，其实可以不用分的这么细，只考虑需要的情况即可，例如进行初始化时我是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; obstacleGrid.length; i++) &#123;<br>          <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)<br>              flag = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>)<br>              dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">else</span><br>              dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>      &#125;<br>      flag = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; obstacleGrid[<span class="hljs-number">0</span>].length; j++) &#123;<br>          <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>)<br>              flag = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>)<br>              dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">else</span><br>              dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>      &#125;<br></code></pre></td></tr></table></figure>

<p>卡哥是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>   	<span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//一旦遇到障碍，后续都到不了</span><br>   	dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>   	<span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">////一旦遇到障碍，后续都到不了</span><br>   	dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      &#125;<br></code></pre></td></tr></table></figure>

<p>遍历优化,我的代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obstacleGrid[i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span> &amp;&amp; obstacleGrid[i][j - <span class="hljs-number">1</span>] != <span class="hljs-number">1</span>)<br>	dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obstacleGrid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> &amp;&amp; obstacleGrid[i - <span class="hljs-number">1</span>][j] != <span class="hljs-number">1</span>)<br>	dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br><span class="hljs-keyword">else</span><br>	dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure>

<p>但其实，这三种可以合为一种，因为碰到一种情况时，另一个dp就为0，所以加上也无所谓</p>
<p>可以直接合为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><p>动态规划五部曲：</p>
<ol>
<li>确定dp[i]的意思：dp[i]表示 i可以拆分成的最大乘积。下面想不通了可以回来想想dp[i]的含义；</li>
<li>确定递推公式：递归公式若是不好想的话，可以往回想想，想想i - 1或者是dp[i]是怎么得来的。可以分为两部分：  j *(i - j)或者 j *dp[i - j]，二者取最大值。这为什么可以呢，第一个是把 i直接分为两个数的乘积，第二个是把i分为两个以上的乘积，j从1开始遍历，一直去最大值即可；</li>
<li>初始化：dp[1] = 1;dp[2] = 1; dp[3] = 2;</li>
<li>遍历顺序从前到后，两层遍历；外层是i: 3到i，内层是j: 1到i</li>
<li>举例推导</li>
</ol>
<p>这道题遍历的时候，卡哥内层是从1遍历到i - j，卡哥说是后面重复了，但是由于我还没有相同，所以直接用的 1到i</p>
<h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h2><p>动态规划五部曲：</p>
<ol>
<li>确定dp[i]的意思：dp[i]的意思是i个节点的二叉搜索树共有dp[i]种</li>
<li>确定递推公式：往回想，如果求dp[3]的时候，先想dp[2],然后再怎么演化为dp[3]，但是演化，我想到的是：分为大于部分和小于部分，但是中间部分呢？<br>dp[i] = 2 * dp[i - 1] + 1？</li>
<li>初始化：</li>
</ol>
<p>卒！</p>
<p>第二步就错了。</p>
<p>卡哥思路：画图，先画出一个节点的数量，再画出两个节点的数量；然后画第三个节点的时候，分为几种情况，1为节点头，2为节点头，3为节点头。</p>
<p>1为节点头时，数量就是dp[2]；2为节点头时，数量就是d[1]*d[1];3为节点头时，数量就是dp[2]。</p>
<p>所以接着上述：</p>
<ol>
<li></li>
<li>递推公式：dp[i]  += dp[j - 1] * dp[i - j];  j从1开始</li>
<li>初始化：只需初始化dp[0] = 1即可</li>
<li>遍历顺序当然是从前往后遍历</li>
<li>举例推导 </li>
</ol>
<p>成功AC！但是递推公式到底怎么想出来的。</p>
<p>当i = 3时，   0 2；  1 1； 2 0  </p>
<p>j从0开始，到i - 1。</p>
<p>递推公式依然是从前面几个入手，从而推出i是怎么来到 。</p>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220628110720342.png" srcset="/img/loading.gif" lazyload alt="image-20220628110720342"></p>
<h3 id="01背包问题（二维数组）"><a href="#01背包问题（二维数组）" class="headerlink" title="01背包问题（二维数组）"></a>01背包问题（二维数组）</h3><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p>动态规划五部曲：</p>
<ol>
<li><p>确定dp数组以及含义：对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p>
</li>
<li><p>那么可以有两个方向推出来dp[i] [j]，</p>
<ul>
<li><strong>不放物品i</strong>：由dp[i - 1] [j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1] [j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</li>
<li><strong>放物品i</strong>：由dp[i - 1] [j - weight[i]]推出，dp[i - 1] [j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1] [j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li>
</ul>
<p>递归公式： dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);</p>
</li>
<li><p>初始化：首先从dp[i] [j]的定义出发，如果背包容量j为0的话，即dp[i] [0]，无论是选取哪些物品，背包价值总和一定为0。</p>
<p>状态转移方程 dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p>
<p>dp[0] [j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p>
<p>那么很明显当 j &lt; weight[0]的时候，dp[0] [j] 应该是 0，因为背包容量比编号0的物品重量还小。</p>
<p>当j &gt;= weight[0]时，dp[0] [j] 应该是value[0]，因为背包容量放足够放编号0物品。</p>
<p>代码初始化如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; j &lt; weight[<span class="hljs-number">0</span>]; j++) &#123;  <span class="hljs-comment">// 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。</span><br>    dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 正序遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其他的下标可以初始化为0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化 dp</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(weight.size()</span>, vector&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220628112932740.png" srcset="/img/loading.gif" lazyload alt="image-20220628112932740"></p>
</li>
<li><p>确定遍历顺序，先遍历物品后遍历背包重量和先遍历背包重量后遍历物品都可以，只是先遍历物品更容易理解。<br>先遍历物品：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]; <br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>先遍历背包重量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>举例推导</p>
</li>
</ol>
<p>Java完整01背包代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>        <span class="hljs-type">int</span>[] value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bagsize</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>        testweightbagproblem(weight, value, bagsize);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testweightbagproblem</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weight, <span class="hljs-type">int</span>[] value, <span class="hljs-type">int</span> bagsize)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">wlen</span> <span class="hljs-operator">=</span> weight.length, value0 = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//定义dp数组：dp[i][j]表示背包容量为j时，前i个物品能获得的最大价值</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[wlen + <span class="hljs-number">1</span>][bagsize + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//初始化：背包容量为0时，能获得的价值都为0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= wlen; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = value0;<br>        &#125;<br>        <span class="hljs-comment">//遍历顺序：先遍历物品，再遍历背包容量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= wlen; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= bagsize; j++)&#123;<br>                <span class="hljs-keyword">if</span> (j &lt; weight[i - <span class="hljs-number">1</span>])&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i - <span class="hljs-number">1</span>]] + value[i - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//打印dp数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= wlen; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagsize; j++)&#123;<br>                System.out.print(dp[i][j] + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.print(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="01背包问题（滚动数组）"><a href="#01背包问题（滚动数组）" class="headerlink" title="01背包问题（滚动数组）"></a>01背包问题（滚动数组）</h3><p>滚动数组其实就是一维数组</p>
<p>动态规划五部曲：</p>
<ol>
<li><p>确定dp数组的定义<br>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>
</li>
<li><p>一维dp数组的递推公式</p>
<p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p>
<p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p>
<p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1] [j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，所以递归公式为：   dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p>
</li>
<li><p>初始化数组，初始化一定要和定义联系在一起<br>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。<br>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p>
</li>
<li><p>遍历顺序：遍历顺序一定是先遍历物品，再遍历背包容量。并且遍历背包容量的时候，滚动数组一定是从大到小的遍历。为什么呢？因为滚动数组遍历的时候需要前面的值，但是前面的值一直变化，而从后往前的 话，前面的值就一直为0。</p>
</li>
<li><p>举例推导</p>
<p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220629111108557.png" srcset="/img/loading.gif" lazyload alt="image-20220629111108557"></p>
</li>
</ol>
<p>滚动数组遍历全代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-type">int</span>[] weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>       <span class="hljs-type">int</span>[] value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">bagWight</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>       testWeightBagProblem(weight, value, bagWight);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWeightBagProblem</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weight, <span class="hljs-type">int</span>[] value, <span class="hljs-type">int</span> bagWeight)</span>&#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">wLen</span> <span class="hljs-operator">=</span> weight.length;<br>       <span class="hljs-comment">//定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值</span><br>       <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bagWeight + <span class="hljs-number">1</span>];<br>       <span class="hljs-comment">//遍历顺序：先遍历物品，再遍历背包容量</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; wLen; i++)&#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bagWeight; j &gt;= weight[i]; j--)&#123;<br>               dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">//打印dp数组</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagWeight; j++)&#123;<br>           System.out.print(dp[j] + <span class="hljs-string">&quot; &quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>



<p>其实我还没完全理解明白！</p>
<h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2><p>这完全看不出来是要用动态规划啊。个人思路：先进行排序，然后从中间分成两个数组，每次判断是否相等，若是不相等，则从大的那边匀一个给小的，以此类推；最后要是发现大的那边最终小于小的那边了，则证明没有，返回false。</p>
<blockquote>
<p>回溯法：</p>
<ul>
<li>698.划分为k个相等的子集</li>
<li>473.火柴拼正方形</li>
</ul>
</blockquote>
<p>以上我的思路是也称为回溯暴力法，但是超时。直接上01背包</p>
<p>重点是要理解为何能嵌套01背包，以及重量以及容量都对应着什么。</p>
<p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p>
<ul>
<li>背包的体积为sum / 2</li>
<li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li>
<li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。</li>
<li>背包中每一个元素是不可重复放入。</li>
</ul>
<p>动态规划五部曲：</p>
<ol>
<li><p>确定dp数组含义：<br>**dp[j]表示 背包总容量是j，最大可以凑成j的子集总和为dp[j]**。</p>
</li>
<li><p>确定递推公式：<br>本题相当于背包里放数值，那么重量也就是nums[i]，其价值也是nums[i]<br>dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</p>
</li>
<li><p>如何初始化，跟滚动数组初始化一样，0初始化为0，其余整数初始化为0，负数初始化为负无穷</p>
</li>
<li><p>遍历顺序，同滚动数组，先遍历物品，放到这道题也就是nums[i]；嵌套遍历价值</p>
</li>
<li><p>举例推导</p>
<p>dp[j]的数值一定是小于等于j的。</p>
<p><strong>如果dp[j] == j 说明，集合中的子集总和正好可以凑成总和j，理解这一点很重要。</strong></p>
</li>
</ol>
<p>好好想想！！！</p>
<p>一层遍历最后的结果，也是一层一层，还是相当于两层遍历的结果，只不过最后保存的是i = nums.length 的值</p>
<h2 id="最后一块石头的重量II"><a href="#最后一块石头的重量II" class="headerlink" title="最后一块石头的重量II"></a>最后一块石头的重量II</h2><p>与昨天的分割等子集和类似，都是分割成两块重量相差最小的块，然后相减即可。<em>不过这道题与上题不同的是，其中一块的具体重量无法确定</em></p>
<p>本题物品重量store[], 价值也为store[]；对应01背包问题的物品重量和价值</p>
<ol>
<li>确定dp数组的含义：dp[j]表示j块石头相加得出来的总重量</li>
<li>确定递归函数：可以分为两步考虑，一个是不放第j块，另一个是放第j块；不放就是dp[j ], 放就是dp[j - store[j] ] + store[j]<br>所以：dp[j] = max(dp[j], dp[j - store[j] ] + store[j]  )</li>
<li>初始化：先全部初始化为0，之后肯定会一层一层的遍历；至于dp数组开到多大，一种做法是所有数相加再除以二；还有一种是看题目给的范围，直接范围除以二</li>
<li>遍历顺序：外层从前往后，内层从后往前</li>
<li>举例推导</li>
</ol>
<p>最后判断的时候，dp[j]表示可以装多大的重量，那么另一边就是sum - dp[j],那么相差最小就是 sum - dp[j] - dp[j]</p>
<p>上面斜体字写得 那一段，真是愚蠢！</p>
<p>dp不管如何分，只管target的大小，也就是总和 / 2；</p>
<p>其实动态规划二维数组和一维数组，本质上还是二维数组，只不过每次二维数组一次遍历，而一维数组进行多次遍历，最后只保留最后一次遍历的那次结果。</p>
<h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h2><p>瞟了一眼卡哥的思路，我只能说牛</p>
<p>首先给出了一个target，那么一定会有left 和right；   同时left + right = sum; 但是 target = left - (sum - left); 所以left = (target + sum) / 2,本题也就转换为求数组中有多少个和是left的组合</p>
<p>同样，动态规划五部曲：</p>
<ol>
<li><p>确定dp[]数组的含义：dp[j]数组表示和为j的有多少种方法</p>
</li>
<li><p>确定递归函数</p>
<p>确定递归函数的时候，考虑一下来源；来源有哪些呢？不考虑nums[i]的情况下，填满容量为j - nums[i]的背包，有dp[j - nums[i]]种方法。<br>考虑nums[i]的情况下，凑成dp[j]就有dp[j - nums[i]]种方法。</p>
<p>例如：dp[j]，j 为5，</p>
<ul>
<li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 dp[5]。</li>
<li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 dp[5]。</li>
<li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 dp[5]</li>
<li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 dp[5]</li>
<li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 dp[5]</li>
</ul>
<p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来</p>
<p>组合问题的公式：dp[j] += dp[j - nums[i]]</p>
</li>
<li><p>初始化：全初始化为0</p>
</li>
<li><p>遍历顺序：外层从前往后，内层从后往前</p>
</li>
<li><p>举例推导</p>
</li>
</ol>
<p>可以记住：在求装满背包有几种方法的时候，递推公式一般为：dp[j] += dp[j - nums[i]];</p>
<p>到最后动态规划总结的 时候，==一定要多总结各种dp公式==！！</p>
<h2 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h2><p>动态规划？</p>
<p>动态规划五部曲：</p>
<ol>
<li>确定dp数组的含义：dp[i]数组表示</li>
</ol>
<p>破功</p>
<p>动规五部曲：</p>
<ol>
<li><p>确定dp数组的含义：**dp[i] [j]：最多有i个0和j个1的strs的最大子集的大小为dp[i] [j]**。</p>
</li>
<li><p>确定递推公式</p>
<p>dp[i] [j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。</p>
<p>dp[i] [j] 就可以是 dp[i - zeroNum] [j - oneNum] + 1。</p>
<p>然后我们在遍历的过程中，取dp[i] [j]的最大值。</p>
<p>所以递推公式：dp[i] [j] = max(dp[i][j], dp[i - zeroNum] [j - oneNum] + 1);</p>
</li>
<li><p>dp数组如何初始化，初始化为0即可，因为物品重量不可能为0，所以只需初始化为0；</p>
</li>
<li><p>确定遍历顺序<br>外层for循环遍历物品，内层for循环遍历背包容量且从后向前遍历！</p>
</li>
<li><p>举例推导</p>
</li>
</ol>
<h2 id="零钱兑换II"><a href="#零钱兑换II" class="headerlink" title="零钱兑换II"></a>零钱兑换II</h2><p>一看到题目中的是钱币不限，就知道要用完全背包</p>
<ol>
<li>确定dp数组含义：dp[j]表示总金额为j的货币组合数为dp[j]</li>
<li>确定递推公式：dp[j]就是dp[j - coins[i]]（不考虑coins[i]）相加。<br>所以：dp[j] += dp[j - coins[i]]</li>
<li>如何初始化：dp[0] = 1,这是开始，其余初始化为0；</li>
<li>确定遍历顺序<br>到底是先遍历背包再遍历重量还是先遍历重量再遍历背包；先试想一下，若是先遍历背包再遍历重量，那么重量就会遍历好几次，可能就是排列；而先遍历重量再遍历背包的话，就是组合。若是是在无法确定，自己手动演示一遍</li>
<li>举例推导</li>
</ol>
<p>要想清楚，背包和物品套在本题是对应哪一部分</p>
<blockquote>
<p>再来理解一下递推公式：     dp[j] += dp[j - coins[i]]   ；代表遍历每个 coins，那么dp[j]就等于 前一个的相加，而前一个就用coins[i]来表示；所以会有   += 的出现。</p>
</blockquote>
<p><strong>注意：求装满背包有几种方法类似的题目，递推公式基本都是这样的</strong>。</p>
<h2 id="组合总和IV"><a href="#组合总和IV" class="headerlink" title="组合总和IV"></a>组合总和IV</h2><p>不对，自己哪里出了问题</p>
<ol>
<li>确定dp数组含义：dp[j]表示总和为j的组合数为dp[j]</li>
<li>确定递推公式：dp[j]就是dp[j - nums[i]]（不考虑nums[i]）相加。<br>所以：dp[j] += dp[j - nums[i]]</li>
<li>如何初始化：dp[0] = 1,这是开始，其余初始化为0；</li>
<li>确定遍历顺序<br>到底是先遍历背包再遍历重量还是先遍历重量再遍历背包；先试想一下，若是先遍历背包再遍历重量，那么重量就会遍历好几次，可能就是排列；而先遍历重量再遍历背包的话，就是组合。若是是在无法确定，自己手动演示一遍<br>那么本题，要求的是排列数，那就先遍历背包再遍历重量;</li>
<li>举例推导</li>
</ol>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<h2 id="爬楼梯-进阶版"><a href="#爬楼梯-进阶版" class="headerlink" title="爬楼梯(进阶版)"></a>爬楼梯(进阶版)</h2><ol>
<li>确定dp数组以及下标的含义<br><strong>dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法</strong>。</li>
<li>确定递推公式：<br>dp[i]有几种来源，dp[i-1],dp[i-2],dp[i-3]等等。dp[i] += dp[i - j]</li>
<li>dp如何初始化<br>dp[0] = 1,其余都初始化为0</li>
<li>确定遍历顺序<br>首先明确要求排列还是求组合，这是求排列问题；那么先遍历背包，再遍历重量</li>
<li>举例推导</li>
</ol>
<h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>总金额为背包，coins为物品重量；要求件数最少</p>
<p>动态规划五部曲：</p>
<ol>
<li>确定dp数组含义：<br>dp[i]表示总金额为i的最少的硬币个数</li>
<li>确定递推公式：<br>先考虑dp[i]怎么来的，dp[i]由 dp[i - coins[j]]，然后一直遍历；那么就是dp[i] += dp[i - coins[j]]</li>
<li>初始化<br>dp[0] = 1,其余都为0</li>
<li>遍历顺序<br>组合还是排列？组合，那就先物品重量，再背包</li>
<li>举例推导</li>
</ol>
<p>错！</p>
<ol>
<li><p>确定dp数组含义：<br>dp[i]表示总金额为i的最少的硬币个数</p>
</li>
<li><p>确定递推公式：<br>先考虑dp[j]怎么来的，dp[j]由 dp[j - coins[i]]，</p>
<p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）</p>
<p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p>
<p>递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);</p>
</li>
<li><p>初始化<br>dp[0] = 0,其他的初始化的时候，要考虑要求最大值还是求最小值，题目是要求最小值，那么就赋值最大值，否则就会被dp[0]一直覆盖</p>
</li>
<li><p>遍历顺序<br>本题组合和排列均可，那就先背包还是先物品都可以</p>
</li>
<li><p>举例推导</p>
</li>
</ol>
<p>动态规划就算知道了五部曲，到现在还有两个难点：</p>
<ul>
<li>遍历时i 和 j的初始值赋值问题，尤其是内层循环，是从 0开始还是从coins[i]开始</li>
<li>写递推公式的判定问题，是直接写还是要满足什么条件再写</li>
</ul>
<h2 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h2><p>告诉你用动态规划，要怎么套</p>
<p>背包是整数n，重量是每个完全平方数，完全平方数可以重复使用，相当于完全背包问题；<strong>但是重量需要判断</strong></p>
<ol>
<li>确定dp数组的含义：dp[j]表示和为j的完全平方数的最少数量</li>
<li>确定递推公式：<br>dp[j]可以由dp[j - i *i] 得来，所以dp[j] = min(dp[j], dp[j - i * i] + 1);</li>
<li>初始化：因为要求最小值，所以初始化为最大值；dp[0] = 0;</li>
<li>确定遍历顺序：遍历顺序都可，就先遍历背包，再遍历重量吧</li>
<li>举例推导</li>
</ol>
<blockquote>
<p>突然发现一个特点，那就是遍历的时候，dp[j]还是dp[i]，是谁不知道，但是一定要满足的是，要从头开始遍历，不能断断续续，这也能确定一部分是i还是j</p>
</blockquote>
<p>==举例推导也很重要==</p>
<p>但是本题重要不需要判断，那么题目中要求的完全平方数体现在哪里呢？体现在递推公式上，递推公式是dp[j - i * i]，后面i * i就已经把那些不是完全平方数的排除了，不手动进行筛选，只在for循环里面进行筛选；也是一种思路</p>
<p>奥！我突然知道了，最内层循环的关键代码，dp[i]还是dp[j]要取决于代表的意义，==若i代表的是背包，则是dp[i]；反之==</p>
<h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h2><p>套动态规划、</p>
<p>字符串s相当于背包总重量，wordDict数组相当于物品重量；要求的是排列，组合肯定不行；</p>
<ol>
<li>确定dp数组的含义：dp[i]表示第i个位置可以匹配到</li>
<li></li>
</ol>
<p>OUT</p>
<p>思路不对。我的思路是求排列，但是若是遇到重复的 ？所以只需要组合</p>
<ol>
<li>确定dp数组的含义：dp[i]表示第i个位置可以匹配到</li>
<li>确定递推公式：<br>首先若是dp[j]为true的时候，说明  0-j 都可以遍历成功；那么若是存在   i - j 的字符串，则dp[i ]设置为true；if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true。</li>
<li>初始化：dp[0] = true；0是一定要初始化的，因为所有的判断都是以前面的为基础</li>
<li>遍历顺序：先遍历背包和先遍历物品都可以；但是推荐先遍历背包，若是先遍历物品的话，那就需要提前先把所有物品放进容器里</li>
<li>举例推导</li>
</ol>
<p>好难！ </p>
<h2 id="背包问题总结"><a href="#背包问题总结" class="headerlink" title="==背包问题总结=="></a>==背包问题总结==</h2><p>背包递推公式：</p>
<ul>
<li>问能否装满背包：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</li>
<li>问装满背包有几种方法：dp[j] += dp[j - nums[i]] ；</li>
<li>问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); </li>
<li>问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); </li>
</ul>
<p>遍历顺序：</p>
<ol>
<li><p>01背包<br>二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。</p>
</li>
<li><p>完全背包</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。<br>如果求最小数，那么两层for循环的先后顺序就无所谓了。</p>
</li>
</ol>
<h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><p>动态规划五部曲：</p>
<ol>
<li>确定dp数组的含义：dp[i]表示前i个元素可以偷取的最大金额</li>
<li>确定递推公式：<br>我感觉要建立一个数组，确定是否已经选取；先假定选取第一个，然后不选第二个，再选第三个的时候判断第一个大还是第二个大；<br>dp[j]  += max(dp[j - 1], dp[j] )</li>
</ol>
<p>但是判定数组如何使用？</p>
<p>动态规划五部曲：</p>
<ol>
<li>确定dp数组的含义：dp[i]表示前i个元素可以偷取的最大金额</li>
<li>确定递推公式：<br>决定dp[i]的因素就是第i房间偷还是不偷。如果偷，那么就dp[i] = dp[i - 2] + nums[i]；若是不偷，则dp[i] = dp[i - 1]。但是这里要判断一下，这俩个那两个大，那么就是：dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])</li>
<li>初始化：直接初始化dp[0] = nums[0]，dp[1] = max(nums[0], nums[1])</li>
<li>确定遍历顺序：一层循环？从前往后遍历</li>
<li>举例推导</li>
</ol>
<p>动态规划并不是非要套什么01背包问题，像本题就不用，且单层循环</p>
<p>还要注意要判空处理，比如数组只有一个数或者是数组为空的情况</p>
<h2 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a>打家劫舍II</h2><p>本题相比上题，多了一个循环，也就是收尾是相连的；换句话说，就是选首不能选尾，选尾不能选首。可以把第一个数加到最后一个数后面这样处理吗？</p>
<p>动态规划五部曲：</p>
<ol>
<li>确定dp数组的含义：dp[i]表示前i个元素可以偷取的最大金额</li>
<li>确定递推公式：<br>决定dp[i]的因素就是第i房间偷还是不偷。如果偷，那么就dp[i] = dp[i - 2] + nums[i]；若是不偷，则dp[i] = dp[i - 1]。但是这里要判断一下，这俩个那两个大，那么就是：dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])</li>
<li>初始化：直接初始化dp[0] = nums[0]，dp[1] = max(nums[0], nums[1])</li>
<li>确定遍历顺序：一层循环？从前往后遍历</li>
<li>举例推导</li>
</ol>
<p>卡哥厉害！</p>
<p>分析如下：</p>
<p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220708113513360.png" srcset="/img/loading.gif" lazyload alt="image-20220708113513360"></p>
<p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220708113521374.png" srcset="/img/loading.gif" lazyload alt="image-20220708113521374"></p>
<p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220708113529354.png" srcset="/img/loading.gif" lazyload alt="image-20220708113529354"></p>
<p>既然首尾不能同时存在，那么我手动切去首或者尾不就行了。</p>
<p>情况二三可以包含情况一，所以代码总体逻辑还是跟上题类似，只不过本题需要比较情况二和情况三谁大谁小</p>
<blockquote>
<p>两个问题（已理顺）</p>
</blockquote>
<ol>
<li>主函数边界问题<br>主函数边界问题要深入到动态规划函数里面，发现里面的前闭后开的，解决。</li>
<li>不用数组进行动态规划遍历问题<br>首先要清楚，遍历要用到i-1和i-2的，那么就要定义三个变量，一个是i-2，一个是i-1，一个是i；分别用x,y,z来表示。由于初始化全为0，所以先赋值i - 1；再赋值当前的i，也就是动态规划递推公式，最后更新i -2,也就是x</li>
</ol>
<h2 id="打家劫舍III"><a href="#打家劫舍III" class="headerlink" title="打家劫舍III"></a>打家劫舍III</h2><p>动态规划五部曲：</p>
<ol>
<li>确定dp数组的含义：dp[j]表示到第j层可以偷到的最大金额</li>
<li>确定递推公式：  考虑dp[j]，dp[j]要么是j-2个加上j的，要么是j-1的；具体是哪个取决于哪个比较大。<br>所以递推公式：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j])</li>
<li>初始化：第一层初始化为root，第二层初始化为第一层和第二层的最大值；</li>
<li>遍历顺序：使用层序遍历，一层一层</li>
<li>举例推导</li>
</ol>
<p>卡哥思路：</p>
<p>树形动态规划又是另外一种情况：</p>
<ol>
<li><p>确定递归函数的参数和返回值<br>返回的就是dp数组</p>
</li>
<li><p>确定终止条件<br>在遍历的过程中，若遇到空节点，无论是偷或者不偷，都初始化为0；注意，是数组</p>
</li>
<li><p>确定遍历顺序：<br>使用后序遍历；通过递归左节点，得到左节点偷与不偷的金钱；通过递归右节点，得到左节点偷与不偷的金钱</p>
</li>
<li><p>确定单层递归的逻辑</p>
<p>首先明确一点，res[0, 1];res[0]代表不偷当前节点，res[1]代表偷当前节点<br>分两种情况，若是偷当前节点，则左右节点不能偷，val1 = cur-&gt;val + left[0] + right[0];若是不偷当前节点，那么就要偷左右节点，既然是偷左右节点，那当然是要找左右节点的最大值，val2 = max(left[0], left[1]) + max(right[0], right[1])</p>
</li>
<li><p>举例推导</p>
</li>
</ol>
<h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>贪心：</p>
<p>牛！计算最左最小值，最优最大值，计算差值即可</p>
<p>动态规划五部曲：</p>
<ol>
<li>确定dp数组含义：dp[i] [0]表示今天持有股票所得的价值；dp[i] [1]表示今天不持有股票所得的价值</li>
<li>确定动态规划递推公式：首先要明确，持有并不代表今天买入，同样，不持有并不代表是今天卖出的；<br>那么问题明朗了，持有分两种情况，一种是今天买入，一种是今天不买入；所以dp[i] [0] = max(- prices[i], dp[i - 1] [0]);<br>不持有分两种情况，一种是今天卖出，一种是今天不卖出；所以dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</li>
<li>初始化：从递推公式上可以看出，都是基于前一个来进行递推，所以初始化dp[0] [0] = -prices[0], dp[0] [1] = 0;</li>
<li>遍历顺序：从前往后遍历</li>
<li>举例推导</li>
</ol>
<blockquote>
<p>注意，确定动态规划递推公式的时候，注意正负号；</p>
</blockquote>
<p>动态规划确定dp数组的时候，思路要打开，有可能二维数组是因为有两个不同的维度，比如物品重量和物品价值；但也有可能是做一个标记，0 和 1；</p>
<h2 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h2><p>动态规划五部曲：</p>
<ol>
<li>确定dp数组含义：dp[i] [0]表示今天持有股票所得的价值；dp[i] [1]表示今天不持有股票所得的价值</li>
<li>确定动态规划递推公式：首先要明确，持有并不代表今天买入，同样，不持有并不代表是今天卖出的；<br>那么问题明朗了，持有分两种情况，一种是今天买入，一种是今天不买入；今天买入的情况，要用昨天未买入的价值减去prices[i]，<strong>这一点也是与前一道题有所不同</strong>， 所以dp[i] [0] = max(dp[i - 1] [1] - prices[i], dp[i - 1] [0]);<br>不持有分两种情况，一种是今天卖出，一种是今天不卖出；所以dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</li>
<li>初始化：从递推公式上可以看出，都是基于前一个来进行递推，所以初始化dp[0] [0] = -proces[0], dp[0] [1] = 0;</li>
<li>遍历顺序：从前往后遍历</li>
<li>举例推导</li>
</ol>
<h2 id="买卖股票的最佳时机III"><a href="#买卖股票的最佳时机III" class="headerlink" title="买卖股票的最佳时机III"></a>买卖股票的最佳时机III</h2><p>动态规划五部曲：</p>
<ol>
<li><p>确定dp数组的含义：dp[i] [j], j 从 0 到4 ，分别代表着不操作，第一次买卖股票，第二次买卖股票</p>
</li>
<li><p>确定动态规划递推公式：<br>不操作就不用说了，达到dp[i] [1]有两种途径：</p>
<ul>
<li>今天购买，dp[i] [1] = dp[i - 1] [0] - prices[i]</li>
<li>今天沿用昨天的状态，dp[i] [1] = dp[i - 1] [1]</li>
</ul>
<p>取最大值：  dp[i] [1] = max(dp[i - 1] [0] - prices[i], dp[i - 1] [1])<br>同样 dp[i] [2] = max(dp[i - 1] [1] + prices[i], dp[i - 1] [2])</p>
<p>同理 dp[i] [3] = max(dp[i - 1] [2] - prices[i], dp[i - 1] [3])</p>
<p>​         dp[i] [4] = max(dp[i - 1] [3] + prices[i], dp[i - 1] [4])</p>
</li>
<li><p>如何初始化：<br>dp[0] [0] = 0;  dp[0] [1] = -prices[0];  dp[0] [2] = 0; dp[0] [3] = -prices[0];  dp[0] [4] = 0; </p>
</li>
<li><p>确定遍历顺序：从前往后遍历</p>
</li>
<li><p>举例推导</p>
</li>
</ol>
<h2 id="买卖股票的最佳时机IV-再考虑考虑"><a href="#买卖股票的最佳时机IV-再考虑考虑" class="headerlink" title="买卖股票的最佳时机IV(再考虑考虑)"></a>买卖股票的最佳时机IV(再考虑考虑)</h2><p>动态规划五部曲：</p>
<ol>
<li>确定dp数组的含义：dp[i] [j],代表第i天的状态为j所剩下的最大现金<ul>
<li>j的状态表示为：<br>0代表什么都不干，；<br>1代表第一次买入<br>2代表第一次卖出<br>3代表第二次买入<br>4代表第二次卖出    那么j的范围就可以定义为2*k + 1</li>
</ul>
</li>
<li>确定动态规划递推公式：<br>要想达到dp[i] [1]有两种：今天买，或者今天沿用昨天的状态；  dp[i] [1] = dp[i - 1] [0] - prices[i]  ； dp[i] [1] = dp[i - 1] [1]   ，选最大的<br>同样，达到dp[i] [2]也有两种：今天卖，今天沿用昨天的状态；  dp[i] [2] = max(dp[i - 1] [1] + prices[i], dp[i - 1] [2])<br>遍历j，从0到2*k + 1即可</li>
<li>初始化：<br>dp[0] [0] = 0;   第一次买入的话，dp[0] [1] = -prices[i]  ;第一次卖出的话，dp[0] [2] = 0;同理，之后只要是买入，不管第几次，都是-prices[i]</li>
<li>确定遍历顺序：从前往后</li>
<li>举例推导</li>
</ol>
<h2 id="最佳买卖股票时机含冷冻期-再考虑考虑"><a href="#最佳买卖股票时机含冷冻期-再考虑考虑" class="headerlink" title="最佳买卖股票时机含冷冻期(再考虑考虑)"></a>最佳买卖股票时机含冷冻期(再考虑考虑)</h2><p>动态规划五部曲：</p>
<ol>
<li><p>确定dp数组的含义：dp[i] [j],代表第i天的状态为j所剩下的最大现金</p>
<ul>
<li>j的第一个状态：0，表示今天买入</li>
<li>j的第一个状态：1，表示今天保持卖出状态，且度过冷冻期</li>
<li>j的第一个状态：2，表示今天卖出</li>
<li>j的第一个状态：3，表示今天为冷冻期</li>
</ul>
</li>
<li><p>确定递推公式：<br>==!==想想dp[i] [0] 如何来的，也就是今天买入，一种是今天买入，另一种是今天保持买入状态。二者取最大：max(dp[i - 1] [0] + prices[i] , dp[i - 1] [0]);;<br>以上错误，没有考虑到冷冻期的存在</p>
<p>达到买入股票状态（状态一）即：dp[i] [0]，有两个具体操作：</p>
<ul>
<li>操作一：前一天就是持有股票状态（状态一），dp[i] [0] = dp[i - 1] [0]</li>
<li>操作二：今天买入了，有两种情况<ul>
<li>前一天是冷冻期（状态四），dp[i - 1] [3] - prices[i]</li>
<li>前一天是保持卖出股票状态（状态二），dp[i - 1] [1] - prices[i]</li>
</ul>
</li>
</ul>
<p>所以操作二取最大值，即：max(dp[i - 1] [3], dp[i - 1] [1]) - prices[i]</p>
<p>那么dp[i] [0] = max(dp[i - 1] [0], max(dp[i - 1] [3], dp[i - 1] [1]) - prices[i]);</p>
<p>达到保持卖出股票状态（状态二）即：dp[i] [1]，有两个具体操作：</p>
<ul>
<li>操作一：前一天就是状态二</li>
<li>操作二：前一天是冷冻期（状态四）</li>
</ul>
<p>dp[i] [1] = max(dp[i - 1] [1], dp[i - 1] [3]);</p>
<p>达到今天就卖出股票状态（状态三），即：dp[i] [2] ，只有一个操作：</p>
<ul>
<li>操作一：昨天一定是买入股票状态（状态一），今天卖出</li>
</ul>
<p>即：dp[i] [2] = dp[i - 1] [0] + prices[i];</p>
<p>达到冷冻期状态（状态四），即：dp[i] [3]，只有一个操作：</p>
<ul>
<li>操作一：昨天卖出了股票（状态三）</li>
</ul>
<p>dp[i] [3] = dp[i - 1] [2];<br>==注意：讨论的是买卖股票的状态，并不是今天一定要买卖==</p>
</li>
<li><p>初始化<br>主要考虑第0天如何初始化即可。<br>dp[0] [0] = -prices[0]<br>dp[0] [1] = 0 ,第0天没有卖出，初始化为0即可<br>dp[0] [2] = 0, dp[0] [3] = 0</p>
</li>
<li><p>遍历顺序，从前往后</p>
</li>
<li><p>举例推导</p>
</li>
</ol>
<p>本题官方给的答案也很清晰</p>
<h2 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a>买卖股票的最佳时机含手续费</h2><ol>
<li><p>确定dp数组的含义：dp[i] [0],  dp[i] [1]，分别代表着持有股票所得的最大收入和不持有股票所得的最大收入</p>
</li>
<li><p>确定动态规划递推公式：<br>达到dp[i] [0]有两种途径：</p>
<ul>
<li>昨天已购买，dp[i] [0] = dp[i - 1] [0]</li>
<li>今天购买，dp[i] [0] = dp[i - 1] [1] -  prices[i]</li>
</ul>
<p>达到dp[i] [1] 有两种途径</p>
<ul>
<li>昨天已卖出，dp[i] [1] = dp[i - 1] [1]</li>
<li>今天卖出，要加上手续费，dp[i] [1] = dp[i - 1] [0] + prices[i] -fee</li>
</ul>
</li>
<li><p>如何初始化：<br>dp[0] [1] = 0;  dp[0] [0] = -prices[0]; </p>
</li>
<li><p>确定遍历顺序：从前往后遍历</p>
</li>
<li><p>举例推导</p>
</li>
</ol>
<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>动态规划五部曲：</p>
<ol>
<li>确定dp数组的含义：dp[i]表示i之前包括i的最长递增子序列的个数</li>
<li>确定递推公式：<br>个人想法是从当前位置向前找第一个小于i的那个，然后+1<br>其实道理都一样，卡哥是用dp[i]和dp[j]+1中取最大值，j的范围是0 到 i - 1</li>
<li>初始化：先全部初始化为1；   遍历为二次循环，而不是一次循环</li>
<li>遍历顺序：从前往后    i外层，j内层</li>
<li>举例推导 </li>
</ol>
<h2 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h2><p>动态规划五部曲：</p>
<ol>
<li>确定dp数组的含义：dp[i]表示i之前包括i的最长连续递增子序列的个数</li>
<li>确定递推公式：<br>只需要判断nums[i] 和nums[i-1]谁大谁小，若i大，则dp[i] = dp[i - 1] + 1，否则令dp[i] = 1</li>
<li>初始化：先全部初始化为1； </li>
<li>遍历顺序：从前往后   </li>
<li>举例推导</li>
</ol>
<p>So Easy！</p>
<h2 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h2><p>动态规划五部曲：</p>
<ol>
<li>确定dp数组的含义：dp[i] [j] 表示以下标i-1结尾的a和以下标j-1结尾的b的最长重复子数组</li>
<li>确定递推公式：<br>通过以前的状态来判断，若是A和B数组相等，那么就令dp[i] [j] = dp[i - 1] [j - 1] + 1;</li>
<li>初始化：首先dp[0] [0]是无意义的，但为了方便后续，将dp[0] [0]  dp[0] [j] dp[i] [0]全部初始化为0；其实初不初始化的无所谓</li>
<li>遍历顺序，两层遍历</li>
<li>举例推导</li>
</ol>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>动态规划五部曲：</p>
<ol>
<li>确定dp数组的含义：dp[i] [j]表示从0到i-1的字符串1和从0到j-1的字符串2的最长公共子序列</li>
<li>确定递推公式：<br>两种结果：相等、不等；相等的情况：dp[i] [j] = dp[i - 1] [j - 1] + 1;不等的情况：取dp[i - 1] [j - 2]和dp[i - 2] [j - 1]的最大值</li>
<li>初始化：将带0的初始化为0，带0的毫无意义</li>
<li>遍历顺序：从递推公式可以看出，一定是从前到后，从上到下</li>
<li>举例推导</li>
</ol>
<h2 id="不相交的线"><a href="#不相交的线" class="headerlink" title="不相交的线"></a>不相交的线</h2><p>与上述最长公共子序列代码95%一致</p>
<h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p>动态规划五部曲：</p>
<ol>
<li>确定dp数组的含义：dp[i]表示前i个数的最大子序和</li>
<li>确定递推公式：<br>这么想，第i个数有两种情况，一种是直接加入dp[i]，另一种是从头算起，二者取最大</li>
<li>初始化：dp[0] = nums[0]</li>
<li>遍历顺序：从前到后</li>
<li>举例推导</li>
</ol>
<h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2><p>动态规划五部曲：</p>
<ol>
<li>确定dp数组的含义：dp[i] [j]表示前i-1和前j - 1的字符串为子序列的个数</li>
<li>确定递推公式：<br>考虑两种情况：1、  i - 1 == j - 1，则dp[i] [j] = dp[i - 1] [ j - 1] + 1;2、i - 1 ！= j - 1，若不相等，那么T就要“删除”掉j - 1了，那么从数值上来看就相当于dp[i] [ j] = dp[i] [j - 1]</li>
<li>初始化：将带0的全部初始化为0</li>
<li>遍历顺序，两层循环，外层是i，遍历s；</li>
<li>举例推导</li>
</ol>
<p>==注意边界，每次都是边界出错；最后判断的是dp[s.length()] [t.length()]而不是dp[s.length()+1] [t.length()+1]==</p>
<blockquote>
<p>因为s.length()本身就不包括最后一个元素，属于是前闭后开</p>
</blockquote>
<h2 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h2><p>动态规划五部曲：</p>
<ol>
<li>确定dp数组的含义：dp[i] [j]表示前i-1和前j - 1的字符串为不同子序列的个数</li>
<li>确定递推公式：<br>两大块：1、相等  2、不等<br>1、相等： 可以用dp[i - 1] [j - 1]，也可以不用，为什么不用呢，是因为不同的子序列，可能得到的结果不同，所以就是dp[i - 2] [j - 1];二者相加，也即dp[i] [j] = dp[i - 1] [j - 1] + dp[i - 1] [j];<br>2、不等： 不等直接就是dp[i - 1] [j]，即dp[i] [j] = dp[i - 1] [j];</li>
<li>初始化：首先带0的肯定是要初始化的，至于怎么初始化，看dp[i] [0]，代表的含义以i-1为结尾的s可以随便删除元素，出现空字符串的个数；那么s删除所以元素才能 出现空字符串，也就是只有一种情况，所以就是dp[i] [0] = 1; dp[0] [j] 代表的含义是以j-1为结尾的t可以随便删除元素，出现空字符串的个数，那么肯定就是0，因为s为空，是无论如何都不可能变为j的；最后看dp[0] [0]，初始化为1</li>
<li>遍历顺序：从左到右，从上到下</li>
<li>举例推导</li>
</ol>
<blockquote>
<p>又是那个问题，边界没有注意到</p>
</blockquote>
<h2 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h2><p>两种动态规划的思路：</p>
<p>思路一：与上述的最长公共子序列相同，只不过多了一步用两个字符串的总长度减去最长公共子序列的长度</p>
<p>思路二：</p>
<p>动态规划五部曲：</p>
<ol>
<li>确定dp数组的含义：dp[i] [j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</li>
<li>确定递推公式：<br>word[i] 和word[j]相等：相等好说，直接dp[i] [j] = dp[i - 1] [j - 1]<br>word[i] 和word[j]不等：不等又有三种情况可以操作，删掉i+1，删掉j+1，同时删掉i和j+2；取最小值</li>
<li>初始化：dp[i] [0] 和dp[j] [0] 和dp[0] [0]是必须要初始化的；dp[i] [0]初始化为i，dp[0] [j]初始化为j，dp[0] [0]初始化为0</li>
<li>遍历顺序：两层循环，外层i</li>
<li>举例推导</li>
</ol>
<blockquote>
<p>1、Math.min() 该方法只能比较两个数的大小，碰到三个的就用两次该方法吧</p>
<p>2、要求最小值，那么每一次操作的+1必不可少</p>
</blockquote>
<h2 id="编辑距离-（经典）"><a href="#编辑距离-（经典）" class="headerlink" title="==编辑距离==（经典）"></a>==编辑距离==（经典）</h2><p>动态规划五部曲：</p>
<ol>
<li>确定dp数组的含义：dp[i] [j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要操作元素的最少次数。</li>
<li>确定递推公式：<br>分两种情况：要么相等、要么不等<br>相等的情况：直接dp[i] [j] = dp[i - 1] [j - 1]<br>不等的情况：又分三种情况，需要word1增、删、改<pre><code class="hljs">                   增：word1增也即word2删，即dp[i] [j] = dp[i] [j - 1] + 1
                   删：dp[i] [j] = dp[i - 1] [j] + 1
                   改：改意思是word1 和 word2 相等，即dp[i] [j] = dp[i - 1] [j - 1] + 1
</code></pre>
取最小值</li>
<li>初始化：从递推公式可以看出，带0的必须初始化，dp[i] [0]初始化为i，dp[0] [j] 初始化为j</li>
<li>遍历顺序：两层循环，外层i</li>
<li>举例推导</li>
</ol>
<p>我愿称之为经典</p>
<h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><p>动态规划五部曲：</p>
<ol>
<li>确定dp数组的含义：dp[i] [j] 表示i到j的回文数</li>
<li>确定递推公式：<br>同样，s[i] 和s[j] 分相等和不等<br>不等：dp[i] [j] = false<br>相等：i和j相等或相差1，如a,   aa;   i 和j相差大于1，大于1，说明两个边已经是回文了，那么就判断里面是否也是回文，也即判断i+1 和 j - 1；</li>
<li>初始化：dp[i] [j]初始化为false</li>
<li>遍历顺序：dp[i] [j] 用到了 dp[i+1] [j-1]。意思是要用到左下角的数据，所以是从下到上，从左到右</li>
<li>举例推导</li>
</ol>
<blockquote>
<p>if (dp[i] [j])  和 if (dp[i] [j] == true)是判断是否为true<br>if (dp[i] [j] = true) 是赋值</p>
</blockquote>
<p>还有一种思路：</p>
<p>中心扩散法。  遍历每个回文中心，若相等同时向两边扩散，同时总数+1</p>
<h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p>动态规划五部曲：</p>
<ol>
<li>确定dp数组的含义：dp[i] [j] 表示i到j的回文数</li>
<li>确定递推公式：<br>两种情况，s[i] 和 s[j] 相等，不等<br>相等：  那么向里边扩散，即dp[i] [j] = dp[i + 1] [ j -1] + 2<br>不等： 判断向左大还是向右，即dp[i] [j] = max(dp[i + 1] [j], dp[i] [ j - 1], dp[i] [j])</li>
<li>初始化：dp[i] [i] 初始化为1，其余初始化为0</li>
<li>遍历顺序：遍历顺序从递推公式开始，可以看出，这一行用到的数据需要用到下一行的数据，那也就是从下到上，从左到右</li>
<li>举例推导</li>
</ol>
<hr>
<h4 id="1235-规划兼职工作"><a href="#1235-规划兼职工作" class="headerlink" title="1235. 规划兼职工作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-profit-in-job-scheduling/">1235. 规划兼职工作</a></h4>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/java/">#java</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>动态规划</div>
      <div>http://example.com/2022/09/16/dong-tai-gui-hua/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Zbiao</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月16日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/16/dan-diao-zhan/" title="单调栈">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">单调栈</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/09/15/wo-de-di-yi-pian-bo-ke-wen-zhang/" title="我的第一篇博客文章">
                        <span class="hidden-mobile">我的第一篇博客文章</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="/js/diy/timeDate.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/jingtaisidai.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiantiao.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiaoxingxing.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
