<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2022/11/11/rabbitmq/"/>
      <url>/2022/11/11/rabbitmq/</url>
      
        <content type="html"><![CDATA[<h1>1、消息队列</h1><h2 id="1、什么是MQ">1、什么是MQ</h2><p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。</p><h2 id="2、MQ的优势">2、MQ的优势</h2><h3 id="1-流量消峰">1.流量消峰</h3><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正 常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p><h3 id="2-应用解耦">2.应用解耦</h3><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p><p><img src="/2022/11/11/rabbitmq/image-20221111190440644.png" alt></p><h3 id="3-异步处理">3.异步处理</h3><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可 以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消 息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用 做这些操作。A 服务还能及时的得到异步处理成功的消息。</p><p><img src="/2022/11/11/rabbitmq/image-20221111190551875.png" alt></p><h2 id="3、多种MQ">3、多种MQ</h2><h3 id="1、ActiveMQ">1、ActiveMQ</h3><p><a href="https://blog.csdn.net/liuyuanq123/article/details/79109218">ActiveMQ详细入门使用教程</a></p><p>优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据</p><p>缺点：官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。</p><h3 id="2、Kafka">2、Kafka</h3><p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为<code>大数据</code>而生的消息中间件， 以其<code>百万级 TPS</code> 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</p><p>优点: 性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是<code>吞吐量高</code>。时效性 ms 级可用性非 常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采 用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持： 功能 较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及<code>日志采集</code>被大规模使用</p><p>缺点：Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消 息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，<code>社区更新较慢</code>；</p><h3 id="3、RocketMQ">3、RocketMQ</h3><p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。</p><p>优点:单机吞吐量十万级,可用性非常高，分布式架构,消息可以做到 0 丢失,MQ 功能较为完善，还是分布式的，扩展性好,支持 10 亿级别的消息堆积，不会因为堆积导致性能下降,源码是 java 我们可以自己阅 读源码，定制自己公司的 MQ</p><p>缺点：支持的客户端语言不多，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在MQ 核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码</p><h3 id="4、RabbitMQ">4、RabbitMQ</h3><p>2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最 主流的消息中间件之一。</p><p>优点:由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易 用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高</p><blockquote><p>官网：<a href="https://www.rabbitmq.com/news.html">https://www.rabbitmq.com/news.html</a></p></blockquote><p>缺点：商业版需要收费,学习成本较高</p><h2 id="4、如何选择使用哪种MQ">4、如何选择使用哪种MQ</h2><h3 id="1、Kafka">1、Kafka</h3><p>Kafka 主要特点是基于Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集 和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能， 肯定是首选 kafka 了。</p><h3 id="2、RocketMQ">2、RocketMQ</h3><p>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削 峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务 场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p><h3 id="3、RabbitMQ">3、RabbitMQ</h3><p>结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分 方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 RabbitMQ。</p><h2 id="5、RabbitMQ">5、RabbitMQ</h2><p>RabbitMQ 是一个消息中间件：它接受并转发消息。</p><h3 id="1、核心概念">1、核心概念</h3><h4 id="1、生产者">1、生产者</h4><p>产生数据发送消息的程序是生产者</p><h4 id="2、交换机">2、交换机</h4><p>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推 送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p><h4 id="3、队列">3、队列</h4><p>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存 储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可 以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p><h4 id="4、消费者">4、消费者</h4><p>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费 者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p><h3 id="2、工作原理">2、工作原理</h3><p><img src="/2022/11/11/rabbitmq/image-20221111191823094.png" alt></p><p><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p><p><strong>Connection</strong>：publisher／consumer 和 broker 之间的 TCP 连接</p><p><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程 序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销</p><h3 id="3、核心部分">3、核心部分</h3><p><img src="/2022/11/11/rabbitmq/image-20221111192022450.png" alt></p><h3 id="4、安装">4、安装</h3><p>参考<a href="https://blog.csdn.net/qq_45173404/article/details/116429302">RabbitMQ超详细安装教程（Linux）</a></p><h1>2、Hello World</h1><p>在下图中，“ P”是我们的生产者，“ C”是我们的消费者。中间的框是一个队列-RabbitMQ 代 表使用者保留的消息缓冲区</p><p><img src="/2022/11/11/rabbitmq/image-20221111192322099.png" alt></p><h2 id="1、导入依赖">1、导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--rabbitmq 依赖客户端--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--操作文件流的一个依赖--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2、生产者关键代码">2、生产者关键代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个连接工厂</span><br><span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>factory.setHost(<span class="hljs-string">&quot;xx.xx.xx.xx&quot;</span>);<br>factory.setUsername(<span class="hljs-string">&quot;guest&quot;</span>);<br>factory.setPassword(<span class="hljs-string">&quot;guest&quot;</span>);<br><span class="hljs-comment">//channel 实现了自动 close 接口 自动关闭 不需要显示关闭</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel()) &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * 生成一个队列</span><br><span class="hljs-comment">      * 1.队列名称</span><br><span class="hljs-comment">      * 2.队列里面的消息是否持久化 默认消息存储在内存中</span><br><span class="hljs-comment">      * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费</span><br><span class="hljs-comment">      * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除</span><br><span class="hljs-comment">      * 5.其他参数</span><br><span class="hljs-comment">      */</span><br>channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zbiao is a cool guy&quot;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * 发送一个消息</span><br><span class="hljs-comment">      * 1.发送到那个交换机</span><br><span class="hljs-comment">      * 2.路由的 key 是哪个</span><br><span class="hljs-comment">      * 3.其他的参数信息</span><br><span class="hljs-comment">      * 4.发送消息的消息体</span><br><span class="hljs-comment">      */</span><br>    channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, message.getBytes());<br>    System.out.println(<span class="hljs-string">&quot;消息发送完毕&quot;</span>);<br></code></pre></td></tr></table></figure><p>思路就是：</p><ol><li>先创建一个连接工厂</li><li>在工厂的实例对象设置相关信息，包括服务器的ip地址，以及rabbitmq用户的账号密码</li><li>工厂的实例对象新建连接</li><li>connection常见实例对象channel</li><li>首先声明一个队列，使用channel.queueDeclare()，参数信息详情看注释</li><li>然后再发送消息，channel.basicPublish()，参数信息详情看注释</li></ol><h2 id="3、消费者关键代码">3、消费者关键代码</h2><p>消费者跟生产者类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//推送的消息如何进行消费的接口回调</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag,delivery) -&gt; &#123;<br>            String message= <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            System.out.println(message);<br>        &#125;;<br>        <span class="hljs-comment">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span><br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelCallback</span> <span class="hljs-operator">=</span> (consumerTag) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;消息消费被中断&quot;</span>);<br>        &#125;;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 消费者消费消息</span><br><span class="hljs-comment">         * 1.消费哪个队列</span><br><span class="hljs-comment">         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答</span><br><span class="hljs-comment">         * 3.消费者未成功消费的回调</span><br><span class="hljs-comment">         * 4.消费者取消回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(QUEUE_NAME,<span class="hljs-literal">true</span>,deliverCallback,cancelCallback);<br></code></pre></td></tr></table></figure><p>前面的对channel的实例化跟生产者类似，消费者还需要<code>手动编写回调函数</code></p><h1>3、Work Queues</h1><p>工作队列(又称任务队列)的主要思想是<code>避免立即执行资源密集型任务</code>，而不得不等待它完成。 相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进 程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。</p><h2 id="1、轮训分发消息">1、轮训分发消息</h2><p>在这个案例中我会启动两个工作线程，一个消息发送线程，来看看他们两个工作线程 是如何工作的。</p><p>首先创建一个消息发送线程，代码跟上节类似，其实这里可以将创建channel的过程进行抽取，将其封装为一个工具类，这样就避免多次编写重复代码。在创建两个工作线程，也就是消费者。</p><p>启动消息发送线程，再启动两个工作线程，发送如下数据： AA 、BB、 CC、 DD</p><p>会发现，第一个工作线程接收到 AA 和CC，第二个工作线程接收到BB和DD。</p><p>这就是轮训分发消息。</p><h2 id="2、消息应答">2、消息应答</h2><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成 了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消 息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续 发送给该消费这的消息，因为它无法接收到。</p><p>为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是:<strong>消费者在接收 到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong></p><h3 id="1、自动应答">1、自动应答</h3><p>消息发送后立即被认为已经传送成功，这种模式需要在<code>高吞吐量和数据传输安全性方面做权 衡</code>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失 了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当 然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使 得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在<code>消费者可以高效并以 某种速率能够处理这些消息的情况下使用</code>。</p><p>简单来说就是不太靠谱。。。</p><blockquote><p>消息应答的方法</p></blockquote><p>Channel.basicAck(用于肯定确认)  RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了</p><p>Channel.basicNack(用于否定确认)</p><p>Channel.basicReject(用于否定确认)  与 Channel.basicNack 相比少一个参数 不处理该消息了直接拒绝，可以将其丢弃了</p><blockquote><p>Multiple参数详解</p></blockquote><p>手动应答的好处是可以批量应答并且减少网络拥堵</p><p>multiple 的 true 和 false 代表不同意思 ：</p><ul><li>true 代表批量应答 channel 上未应答的消息 比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是8 那么此时 5-8 的这些还未应答的消息都会被确认收到消息应答</li><li>false 同上面相比 只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答</li></ul><p><img src="/2022/11/11/rabbitmq/image-20221111194610086.png" alt></p><blockquote><p>消息自动重新入队</p></blockquote><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息 未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者 可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确 保不会丢失任何消息。</p><h3 id="2、手动应答">2、手动应答</h3><p><code>默认消息采用的是自动应答</code>，所以我们要想实现消息消费过程中不丢失，需要把自动应答改 为手动应答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">DeliverCallback deliverCallback=(consumerTag,delivery) -&gt; &#123;<br>            String message= <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            SleepUtils.sleep(<span class="hljs-number">1</span>);<br>            System.out.println(<span class="hljs-string">&quot;接收到消息:&quot;</span>+message);<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 1.消息标记 tag</span><br><span class="hljs-comment">             * 2.是否批量应答未应答消息</span><br><span class="hljs-comment">             */</span><br>            channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="hljs-literal">false</span>);<br>        &#125;;<br><br><span class="hljs-comment">//采用手动应答</span><br>        <span class="hljs-type">boolean</span> autoAck=<span class="hljs-literal">false</span>;<br>        channel.basicConsume(ACK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag)-&gt;&#123;<br>            System.out.println(consumerTag+<span class="hljs-string">&quot;消费者取消消费接口回调逻辑&quot;</span>);<br>        &#125;);<br></code></pre></td></tr></table></figure><p>消费者的 回调函数中需要增加第9行代码 ，并且将channel.basicConsume()的第二个参数改为 false</p><p>手动应答效果：发送如下数据： AA 、BB、 CC、 DD，将第二个消费者的线程睡30s，正常情况下是C1 收到 AA、CC ，C2收到BB、DD。但是在C2收到DD之前，将C2关掉，那么DD会不会丢失？不会，DD由C1来接收，这就是手动应答</p><h2 id="3、RabbitMQ持久化">3、RabbitMQ持久化</h2><p>刚刚我们已经看到了如何处理任务不丢失的情况，但是如何保障当 RabbitMQ 服务停掉以后消 息生产者发送过来的消息不丢失。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列 和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<code>我们需要将队列和消息都标 记为持久化</code>。</p><h3 id="1、队列持久化">1、队列持久化</h3><p>之前我们创建的队列都是非持久化的，rabbitmq 如果重启的化，该队列就会被删除掉，如果 要队列实现持久化 需要在声明队列的时候把 durable 参数设置为持久化</p><p><img src="/2022/11/11/rabbitmq/image-20221111195627548.png" alt></p><p>这里要注意，要先删掉之前声明的队列，然后再声明持久化队列（若是队列名称一样的话）</p><p>持久化队列后，即使重启RabbitMQ队列也依然在</p><h3 id="2、消息持久化">2、消息持久化</h3><p>要想让消息实现持久化需要在消息生产者修改代码，MessageProperties.PERSISTENT_TEXT_PLAIN 添 加这个属性。</p><p><img src="/2022/11/11/rabbitmq/image-20221111195848961.png" alt></p><p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是 这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。</p><h3 id="3、不公平分发">3、不公平分发</h3><p>轮训分发有一个弊端，在某种特定的场景下并不是很好，若是有两个消费者处理任务，其中一个处理速度非常快，一个处理非常慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间 处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p><p>为了避免这种情况，我们可以设置参数 channel.basicQos(1)；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">prefetchCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>channel.basicQos(prefetchCount);<br></code></pre></td></tr></table></figure><p>意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个 任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完 成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加 新的 worker 或者改变其他存储任务的策略。</p><h3 id="4、预取值">4、预取值</h3><p>存在一个未确认的消息缓冲区，开发人员希望能限制此 缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。这个时候就可以通过使用 basic.qos 方法设 置“预取计数”值来完成的。该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认。</p><p>例如，假设在通道上有 未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时RabbitMQ 将不会在该通道上再传递任何 消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知 这个情况到并再发送一条消息。</p><p>消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高 向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗(<code>随机存取存储器</code>)应该小心使用具有无限预处理 的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的 内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。</p><p>预取值为 1 是最保守的。当然这 将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p><h1>4、发布确认</h1><p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消 息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会 发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了， 如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产 者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p><p>confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道 返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方 法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。</p><h2 id="1、发布确认的策略">1、发布确认的策略</h2><p>发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布 确认，都需要在 channel 上调用该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.confirmSelect();<br></code></pre></td></tr></table></figure><h3 id="1、单个确认发布">1、单个确认发布</h3><p>这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它 被确认发布，后续的消息才能继续发布,waitForConfirmsOrDie(long)这个方法只有在消息被确认 的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p><p>这种确认方式有一个最大的缺点就是:发布速度特别的慢，因为如果没有确认发布的消息就会 阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某 些应用程序来说这可能已经足够了。</p><p>关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-comment">//开启发布确认</span><br>channel.confirmSelect();<br><span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> i + <span class="hljs-string">&quot;&quot;</span>;<br>channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, queueName, <span class="hljs-literal">null</span>, message.getBytes());<br><span class="hljs-comment">//服务端返回 false 或超时时间内未返回，生产者可以消息重发</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> channel.waitForConfirms();<br><span class="hljs-keyword">if</span>(flag)&#123;<br>System.out.println(<span class="hljs-string">&quot;消息发送成功&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>System.out.println(<span class="hljs-string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="hljs-string">&quot;个单独确认消息,耗时&quot;</span> + (end - begin) + <span class="hljs-string">&quot;ms&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="2、批量确认发布">2、批量确认发布</h3><p>先发布一批消息然后一起确认可以极大地 提高吞吐量，当然这种方式的缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种 方案仍然是同步的，也一样阻塞消息的发布。</p><p>关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-comment">//开启发布确认</span><br>channel.confirmSelect();<br><span class="hljs-comment">//批量确认消息大小</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">batchSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-comment">//未确认消息个数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">outstandingMessageCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> i + <span class="hljs-string">&quot;&quot;</span>;<br>channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, queueName, <span class="hljs-literal">null</span>, message.getBytes());<br>outstandingMessageCount++;<br><span class="hljs-keyword">if</span> (outstandingMessageCount == batchSize) <br>&#123;<br>        channel.waitForConfirms();<br>outstandingMessageCount = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//为了确保还有剩余没有确认消息 再次确认</span><br><span class="hljs-keyword">if</span> (outstandingMessageCount &gt; <span class="hljs-number">0</span>) <br>&#123;<br>    channel.waitForConfirms();<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>System.out.println(<span class="hljs-string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="hljs-string">&quot;个批量确认消息,耗时&quot;</span> + (end - begin) + <span class="hljs-string">&quot;ms&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="3、异步确认发布">3、异步确认发布</h3><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功</p><p><img src="/2022/11/11/rabbitmq/image-20221111201143322.png" alt></p><p>关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-comment">//开启发布确认</span><br> channel.confirmSelect();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 线程安全有序的一个哈希表，适用于高并发的情况</span><br><span class="hljs-comment"> * 1.轻松的将序号与消息进行关联</span><br><span class="hljs-comment"> * 2.轻松批量删除条目 只要给到序列号</span><br><span class="hljs-comment"> * 3.支持并发访问</span><br><span class="hljs-comment"> */</span><br>ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentSkipListMap</span>&lt;&gt;();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 确认收到消息的一个回调</span><br><span class="hljs-comment"> * 1.消息序列号</span><br><span class="hljs-comment"> * 2.true 可以确认小于等于当前序列号的消息</span><br><span class="hljs-comment"> * false 确认当前序列号消息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">ConfirmCallback</span> <span class="hljs-variable">ackCallback</span> <span class="hljs-operator">=</span> (sequenceNumber, multiple) -&gt; &#123;<br><span class="hljs-keyword">if</span> (multiple) &#123;<br><span class="hljs-comment">//返回的是小于等于当前序列号的未确认消息 是一个 map</span><br>ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outstandingConfirms.headMap(sequenceNumber, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">//清除该部分未确认消息</span><br> confirmed.clear();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//只清除当前序列号的消息</span><br> outstandingConfirms.remove(sequenceNumber);<br>&#125;<br>&#125;;<br><span class="hljs-type">ConfirmCallback</span> <span class="hljs-variable">nackCallback</span> <span class="hljs-operator">=</span> (sequenceNumber, multiple) -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> outstandingConfirms.get(sequenceNumber);<br>System.out.println(<span class="hljs-string">&quot;发布的消息&quot;</span>+message+<span class="hljs-string">&quot;未被确认，序列号&quot;</span>+sequenceNumber);<br>&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 添加一个异步确认的监听器</span><br><span class="hljs-comment"> * 1.确认收到消息的回调</span><br><span class="hljs-comment"> * 2.未收到消息的回调</span><br><span class="hljs-comment"> */</span><br>channel.addConfirmListener(ackCallback, <span class="hljs-literal">null</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;消息&quot;</span> + i;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* channel.getNextPublishSeqNo()获取下一个消息的序列号</span><br><span class="hljs-comment"> * 通过序列号与消息体进行一个关联</span><br><span class="hljs-comment"> * 全部都是未确认的消息体</span><br><span class="hljs-comment"> */</span><br>outstandingConfirms.put(channel.getNextPublishSeqNo(), message);<br>channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, queueName, <span class="hljs-literal">null</span>, message.getBytes());<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>System.out.println(<span class="hljs-string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="hljs-string">&quot;个异步确认消息,耗时&quot;</span> + (end - begin) + <span class="hljs-string">&quot;ms&quot;</span>);<br></code></pre></td></tr></table></figure><p>如何处理异步未确认消息？</p><p>最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传 递。</p><h2 id="2、以上-3-种发布确认速度对比">2、以上 3 种发布确认速度对比</h2><p>单独发布消息：</p><p>同步等待确认，简单，但吞吐量非常有限。</p><p>批量发布消息 ：</p><p>批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条 消息出现了问题。</p><p>异步处理：</p><p>最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</p><h1>5、交换机</h1><h2 id="1、Exchange">1、Exchange</h2><p>RabbitMQ 消息传递模型的核心思想是: <code>生产者生产的消息从不会直接发送到队列</code>。实际上，通常生产 者甚至都不知道这些消息传递传递到了哪些队列中。</p><p>相反，生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来 自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消 息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p><p><img src="/2022/11/11/rabbitmq/image-20221115165238393.png" alt></p><h2 id="2、Exchange类型">2、Exchange类型</h2><ul><li>直接(direct),</li><li>主题(topic)</li><li>标题(headers) ,</li><li>扇出(fanout)</li></ul><p>还有一种就是默认，也就是无名Exchange，通过空字符串(“”)进行标识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-literal">null</span>, message.getBytes());<br></code></pre></td></tr></table></figure><p>第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实 是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的话</p><h2 id="3、Fanout">3、Fanout</h2><p>Fanout 又称为发布订阅。Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的 所有队列中。</p><p><img src="/2022/11/11/rabbitmq/image-20221115165654132.png" alt></p><p>消费者关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;logs&quot;</span>;<br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtils.getChannel();<br>channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;fanout&quot;</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 生成一个临时的队列 队列的名称是随机的</span><br><span class="hljs-comment"> * 当消费者断开和该队列的连接时 队列自动删除</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br><span class="hljs-comment">//把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串</span><br>channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;等待接收消息,把接收到的消息打印在屏幕........... &quot;</span>);<br><span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;控制台打印接收到的消息&quot;</span>+message);<br>&#125;;<br>channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);<br></code></pre></td></tr></table></figure><blockquote><p>第八行代码为创建临时队列</p></blockquote><p>生产者关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;logs&quot;</span>;<br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtils.getChannel();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 声明一个 exchange</span><br><span class="hljs-comment">* 1.exchange 的名称</span><br><span class="hljs-comment"> * 2.exchange 的类型</span><br><span class="hljs-comment"> */</span><br>channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;fanout&quot;</span>);<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入信息&quot;</span>);<br><span class="hljs-keyword">while</span> (sc.hasNext()) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> sc.nextLine();<br>channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">null</span>, message.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;生产者发出消息&quot;</span> + message);<br>&#125;<br></code></pre></td></tr></table></figure><p>生产者和消费者都指定一个交换机，并且消费者都指定routingKey，无论有几个消费者，只要生产者一发送消息，所有消费者都能接受到消息。</p><h2 id="4、Direct-exchange">4、Direct exchange</h2><p>再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： 队列只对它绑定的交换机的消息感兴趣。绑定用参数：routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码: channel.queueBind(queueName, EXCHANGE_NAME, “routingKey”);绑定之后的 意义由其交换类型决定。</p><p>Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。</p><h3 id="1、直接绑定">1、直接绑定</h3><p><img src="/2022/11/11/rabbitmq/image-20221115170843291.png" alt></p><p>在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green。</p><p>在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 black和green 的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p><h3 id="2、多重绑定">2、多重绑定</h3><p><img src="/2022/11/11/rabbitmq/image-20221115171018692.png" alt></p><p>当然如果 exchange 的绑定类型是direct，但是它绑定的多个队列的 key 如果都相同，在这种情 况下虽然绑定类型是 direct 但是它表现的就和 fanout 有点类似了，就跟广播差不多，如上图所示。</p><p>消费者关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;direct_logs&quot;</span>;<br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtils.getChannel();<br>channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;console&quot;</span>;<br>channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;info&quot;</span>);<br>channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;warning&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;等待接收消息........... &quot;</span>);<br><span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot; 接收绑定键 :&quot;</span>+delivery.getEnvelope().getRoutingKey()+<span class="hljs-string">&quot;, 消息:&quot;</span>+message);<br>&#125;;<br>channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);<br></code></pre></td></tr></table></figure><p>生产者关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;direct_logs&quot;</span>;<br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtils.getChannel();<br>channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入信息&quot;</span>);<br><span class="hljs-keyword">while</span> (sc.hasNext()) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> sc.nextLine();<br>channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;console&quot;</span>, <span class="hljs-literal">null</span>, message.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;生产者发出消息&quot;</span> + message);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>交换机只是设定不同的routingKey 即可</p></blockquote><h2 id="5、Topics">5、Topics</h2><p>尽管使用direct 交换机提高了灵活性，但是它仍然存在局限性。比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 topic 类型</p><p>发送的类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。这些单词可以是任意单词，比如说：“stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit” 这种类型的。当然这个单词列表最多不能超过 255 个字节。</p><p>在这个规则列表中，其中有两个替换符是需要注意的：</p><ol><li>*(星号)可以代替一个单词</li><li>#(井号)可以替代零个或多个单词</li></ol><blockquote><p>Topic匹配案例</p></blockquote><p>下图绑定关系如下</p><p>​Q1–&gt;绑定的是</p><p>​中间带 orange 带 3 个单词的字符串(<em>.orange.</em>)</p><p>​Q2–&gt;绑定的是</p><p>​最后一个单词是 rabbit 的 3 个单词(<em>.</em>.rabbit)</p><p>​第一个单词是 lazy 的多个单词(lazy.#)</p><p><img src="/2022/11/11/rabbitmq/image-20221115171829832.png" alt></p><p>当队列绑定关系是下列这种情况时需要引起注意</p><p><strong>当一个队列绑定键是#,那么这个队列将接收所有数据，就有点像 fanout 了</strong></p><p><strong>如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了</strong></p><p>其实代码都差不多，只是绑定键不同而已</p><p>消费者关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;topic_logs&quot;</span>;<br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtils.getChannel();<br>channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;topic&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;console&quot;</span>;<br>channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;*.orange.*&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;等待接收消息........... &quot;</span>);<br><span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot; 接收绑定键 :&quot;</span>+delivery.getEnvelope().getRoutingKey()+<span class="hljs-string">&quot;, 消息:&quot;</span>+message);<br>&#125;;<br>channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);<br></code></pre></td></tr></table></figure><p>生产者关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;topic_logs&quot;</span>;<br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitUtils.getChannel();<br>channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;topic&quot;</span>);<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入信息&quot;</span>);<br><span class="hljs-keyword">while</span> (sc.hasNext()) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> sc.nextLine();<br>channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;lazy.orange.elephant&quot;</span>, <span class="hljs-literal">null</span>, message.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;生产者发出消息&quot;</span> + message);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码生产者发出消息后，能被队列 Q1Q2 接收到</p><h1>6、死信队列</h1><h2 id="1、概念">1、概念</h2><p>死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有 后续的处理，就变成了死信，有死信自然就有了死信队列。</p><p>应用场景:为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息 消费发生异常时，将消息投入死信队列中.还有比如说: 用户在商城下单成功并点击去支付后在指定时 间未支付时自动失效</p><h2 id="2、来源">2、来源</h2><ol><li>消息 TTL 过期</li><li>队列达到最大长度(队列满了，无法再添加数据到 mq 中)</li><li>消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false.</li></ol><h2 id="3、Demo">3、Demo</h2><p>代码架构图如下：</p><p><img src="/2022/11/11/rabbitmq/image-20221115211517167.png" alt></p><h3 id="1、消息TTL过期">1、消息TTL过期</h3><p>生产者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> &#123;<br>    <span class="hljs-comment">//普通交换机名称</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NORMAL_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normal_exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getChannel();<br>        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);<br>        <span class="hljs-comment">//设置消息的 TTL 时间 , 单位是ms</span><br>        AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties().builder().expiration(<span class="hljs-string">&quot;10000&quot;</span>).build();<br>        <span class="hljs-comment">//该信息是用作演示队列个数限制</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;<span class="hljs-number">11</span> ; i++) &#123;<br>            String message=<span class="hljs-string">&quot;info&quot;</span>+i;<br>            channel.basicPublish(NORMAL_EXCHANGE,<span class="hljs-string">&quot;zhangsan&quot;</span>, properties, message.getBytes());<br>            System.out.println(<span class="hljs-string">&quot;生产者发送消息:&quot;</span>+message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者C1代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer01</span> &#123;<br>    <span class="hljs-comment">//普通交换机名称</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NORMAL_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normal_exchange&quot;</span>;<br>    <span class="hljs-comment">//死信交换机名称</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dead_exchange&quot;</span>;<br>    <span class="hljs-comment">//声明死信队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">deadQueue</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dead-queue&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">normalQueue</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normal-queue&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getChannel();<br>        <span class="hljs-comment">//声明死信和普通交换机 类型为 direct</span><br>        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);<br>        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);<br><br>        channel.queueDeclare(deadQueue, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//死信队列绑定死信交换机与 routingkey</span><br>        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="hljs-string">&quot;lisi&quot;</span>);<br>        <span class="hljs-comment">//正常队列绑定死信队列信息</span><br>        Map&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 设置过期时间</span><br>        <span class="hljs-comment">//params.put(&quot;x-message-ttl&quot;, 100000);</span><br>        <span class="hljs-comment">//params.put(&quot;x-max-length&quot;, 6);</span><br>        <span class="hljs-comment">//正常队列设置死信交换机 参数 key 是固定值</span><br>        params.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);<br>        <span class="hljs-comment">//正常队列设置死信 routing-key 参数 key 是固定值</span><br>        params.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="hljs-string">&quot;lisi&quot;</span>);<br><br>        channel.queueDeclare(normalQueue, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, params);<br>        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;等待接收消息........... &quot;</span>);<br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            <span class="hljs-keyword">if</span> (message.equals(<span class="hljs-string">&quot;info5&quot;</span>)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Consumer01 接收到消息&quot;</span>+message+<span class="hljs-string">&quot;:此消息被拒绝&quot;</span>);<br>                channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Consumer01 接收到消息&quot;</span>+message);<br>                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>            &#125;<br><br>        &#125;;<br>        <span class="hljs-comment">// 开启手动应答</span><br>        channel.basicConsume(normalQueue, <span class="hljs-literal">false</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者需要定义两个交换机，两个队列。第22行到第28行为设置从正常队列到死信队列的映射。</p><p>结果就是关闭C1，生产者发送十条正常消息，会发现死信队列里面堆积了十条消息，这是启动C2即可消费十条消息。</p><h3 id="2、队列达到最大长度">2、队列达到最大长度</h3><p>生产者代码不变</p><p>消费者加上限制最大长度的代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>params.put(<span class="hljs-string">&quot;x-max-length&quot;</span>, <span class="hljs-number">6</span>);<br>channel.queueDeclare(normalQueue, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, params);<br></code></pre></td></tr></table></figure><p>同样的操作，启动并关闭C1，生产者发送十条消息，会发现正常队列里堆积六条消息，死信队列里面堆积四条消息，启动C1和C2可分别消费消息。</p><h3 id="3、消息被拒">3、消息被拒</h3><p>生产者代码不变</p><p>消费者C1代码只需将某条消息拒绝即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>    <span class="hljs-keyword">if</span> (message.equals(<span class="hljs-string">&quot;info5&quot;</span>)) &#123;<br>         System.out.println(<span class="hljs-string">&quot;Consumer01 接收到消息&quot;</span>+message+<span class="hljs-string">&quot;:此消息被拒绝&quot;</span>);<br>         channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>         System.out.println(<span class="hljs-string">&quot;Consumer01 接收到消息&quot;</span>+message);<br>         channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 开启手动应答</span><br>channel.basicConsume(normalQueue, <span class="hljs-literal">false</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>注意，要开启手动应答，也就是第12行代码第二个参数改为false;</p></blockquote><p>最后会发现，拒绝的那条消息，也就是上述代码中的&quot;info5&quot;进入到了死信队列，开启C2即可消费。</p><h1>7、延迟队列</h1><p>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。</p><h2 id="1、延迟队列使用场景">1、延迟队列使用场景</h2><ol><li>订单在十分钟之内未支付则自动取消</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。</li><li>用户注册成功后，如果三天内没有登陆则进行短信提醒。</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员。</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li></ol><p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；看起来似乎 使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？</p><p>如果 数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支 付的账单，确实也是一个可行的方案。</p><p>但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万 级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单 的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p><p><img src="/2022/11/11/rabbitmq/image-20221116165636746.png" alt></p><h2 id="2、RabbitMQ中的TTL">2、RabbitMQ中的TTL</h2><p>TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有 消息的最大存活时间，单位是毫秒。换句话说，如果一条消息设置了 TTL 属性或者进入了设置TTL 属性的队列，那么这条消息如果在TTL 设置的时间内没有被消费，则会成为&quot;死信&quot;。如果同时配置了队列的TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。</p><h3 id="1、消息设置TTL">1、消息设置TTL</h3><p><img src="/2022/11/11/rabbitmq/image-20221116170029495.png" alt></p><h3 id="2、队列设置TTL">2、队列设置TTL</h3><p><img src="/2022/11/11/rabbitmq/image-20221116170042720.png" alt></p><h3 id="3、区别">3、区别</h3><p>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队 列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者 之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；另外，还需 要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以 直接投递该消息到消费者，否则该消息将会被丢弃。</p><h2 id="3、整合SpringBoot">3、整合SpringBoot</h2><p>1、创建项目</p><p>2、导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!--RabbitMQ 依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--swagger--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--RabbitMQ 测试依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.amqp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-rabbit-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、修改配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">spring.rabbitmq.host=xx.xx.xx.xx</span><br><span class="hljs-string">spring.rabbitmq.port=5672</span><br><span class="hljs-string">spring.rabbitmq.username=admin</span><br><span class="hljs-string">spring.rabbitmq.password=123</span><br></code></pre></td></tr></table></figure><p>配置rabbitmq相关信息</p><p>4、添加Swagger配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;<br><span class="hljs-keyword">import</span> springfox.documentation.service.ApiInfo;<br><span class="hljs-keyword">import</span> springfox.documentation.service.Contact;<br><span class="hljs-keyword">import</span> springfox.documentation.spi.DocumentationType;<br><span class="hljs-keyword">import</span> springfox.documentation.spring.web.plugins.Docket;<br><span class="hljs-keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">webApiConfig</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>            .groupName(<span class="hljs-string">&quot;webApi&quot;</span>)<br>.apiInfo(webApiInfo())<br>.select()<br>            .build();<br>&#125;<br><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">webApiInfo</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>.title(<span class="hljs-string">&quot;rabbitmq 接口文档&quot;</span>)<br>.description(<span class="hljs-string">&quot;本文档描述了 rabbitmq 微服务接口定义&quot;</span>)<br>.version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>.contact(<span class="hljs-keyword">new</span> <span class="hljs-string">&quot;1551388580@qq.com&quot;</span>))<br>.build();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、队列TTL">4、队列TTL</h2><h3 id="1、架构图">1、架构图</h3><p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交 换机 Y，它们的类型都是direct，创建一个死信队列 QD，它们的绑定关系如下：</p><p><img src="/2022/11/11/rabbitmq/image-20221116170644518.png" alt></p><h3 id="2、配置类">2、配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TtlQueueConfig</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">X_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;X&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_A</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QA&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_B</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QB&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Y&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_LETTER_QUEUE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QD&quot;</span>;<br><span class="hljs-comment">// 声明 xExchange</span><br><span class="hljs-meta">@Bean(&quot;xExchange&quot;)</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">xExchange</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(X_EXCHANGE);<br>&#125;<br><span class="hljs-comment">// 声明 xExchange</span><br><span class="hljs-meta">@Bean(&quot;yExchange&quot;)</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">yExchange</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(Y_DEAD_LETTER_EXCHANGE);<br>&#125;<br><span class="hljs-comment">//声明队列 A ttl 为 10s 并绑定到对应的死信交换机</span><br>    <span class="hljs-meta">@Bean(&quot;queueA&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueA</span><span class="hljs-params">()</span>&#123;<br>Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">3</span>);<br><span class="hljs-comment">//声明当前队列绑定的死信交换机</span><br>args.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);<br><span class="hljs-comment">//声明当前队列的死信路由 key</span><br>args.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="hljs-string">&quot;YD&quot;</span>);<br><span class="hljs-comment">//声明队列的 TTL</span><br>args.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>, <span class="hljs-number">10000</span>);<br><span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(args).build();<br>&#125;<br><span class="hljs-comment">// 声明队列 A 绑定 X 交换机</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueaBindingX</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;<br><span class="hljs-keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="hljs-string">&quot;XA&quot;</span>);<br>&#125;<br><span class="hljs-comment">//声明队列 B ttl 为 40s 并绑定到对应的死信交换机</span><br><span class="hljs-meta">@Bean(&quot;queueB&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueB</span><span class="hljs-params">()</span>&#123;<br>Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">3</span>);<br><span class="hljs-comment">//声明当前队列绑定的死信交换机</span><br>args.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);<br><span class="hljs-comment">//声明当前队列的死信路由 key</span><br>args.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="hljs-string">&quot;YD&quot;</span>);<br><span class="hljs-comment">//声明队列的 TTL</span><br>args.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>, <span class="hljs-number">40000</span>);<br><span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(args).build();<br>&#125;<br><span class="hljs-comment">//声明队列 B 绑定 X 交换机</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queuebBindingX</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueB&quot;)</span> Queue queue1B,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;<br><span class="hljs-keyword">return</span> BindingBuilder.bind(queue1B).to(xExchange).with(<span class="hljs-string">&quot;XB&quot;</span>);<br>&#125;<br><span class="hljs-comment">//声明死信队列 QD</span><br><span class="hljs-meta">@Bean(&quot;queueD&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueD</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(DEAD_LETTER_QUEUE);<br>&#125;<br><span class="hljs-comment">//声明死信队列 QD 绑定关系</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">deadLetterBindingQAD</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span>&#123;<br><span class="hljs-keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="hljs-string">&quot;YD&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、生产者代码">3、生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RequestMapping(&quot;ttl&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendMsgController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><span class="hljs-meta">@GetMapping(&quot;sendMsg/&#123;message&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String message)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,发送一条信息给两个 TTL 队列:&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), message);<br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;XA&quot;</span>, <span class="hljs-string">&quot;消息来自 ttl 为 10S 的队列: &quot;</span>+message);<br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;XB&quot;</span>, <span class="hljs-string">&quot;消息来自 ttl 为 40S 的队列: &quot;</span>+message);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、消费者代码">4、消费者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLetterQueueConsumer</span> &#123;<br><span class="hljs-meta">@RabbitListener(queues = &quot;QD&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveD</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody());<br>log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,收到死信队列信息&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().toString(), msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发起一个请求：<a href="http://localhost:8080/ttl/sendMsg/%E5%98%BB%E5%98%BB%E5%98%BB">http://localhost:8080/ttl/sendMsg/嘻嘻嘻</a></p><p><img src="/2022/11/11/rabbitmq/image-20221116203557955.png" alt></p><p>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。</p><p>不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加TTL 为一个小时的队列，如果是预定会议室然 后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p><p>可以将之抽象出来，留下ttl时间。</p><h2 id="5、延时队列优化">5、延时队列优化</h2><h3 id="1、架构图-v2">1、架构图</h3><p><img src="/2022/11/11/rabbitmq/image-20221116203836634.png" alt></p><p>如图，新增一个队列QC，不设置TTL时间</p><h3 id="2、配置类-v2">2、配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgTtlQueueConfig</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Y&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_C</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QC&quot;</span>;<br><span class="hljs-comment">//声明队列 C 死信交换机</span><br><span class="hljs-meta">@Bean(&quot;queueC&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueB</span><span class="hljs-params">()</span>&#123;<br>Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">3</span>);<br><span class="hljs-comment">//声明当前队列绑定的死信交换机</span><br>args.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);<br><span class="hljs-comment">//声明当前队列的死信路由 key</span><br>args.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="hljs-string">&quot;YD&quot;</span>);<br><span class="hljs-comment">//没有声明 TTL 属性</span><br><span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(args).build();<br>&#125;<br><span class="hljs-comment">//声明队列 B 绑定 X 交换机</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queuecBindingX</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;<br><span class="hljs-keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="hljs-string">&quot;XC&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、生产者代码-v2">3、生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String message,<span class="hljs-meta">@PathVariable</span> String ttlTime)</span> &#123;<br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;XC&quot;</span>, message, correlationData -&gt;&#123;<br>        correlationData.getMessageProperties().setExpiration(ttlTime);<br><span class="hljs-keyword">return</span> correlationData;<br>&#125;);<br>log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,发送一条时长&#123;&#125;毫秒 TTL 信息给队列 C:&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),ttlTime, message);<br>&#125;<br></code></pre></td></tr></table></figure><p>发起请求：</p><p><a href="http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendExpirationMsg/你好</a> 1/20000</p><p><a href="http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendExpirationMsg/你好</a> 2/2000</p><p>结果看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消 息可能并不会按时“死亡“，因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。</p><p>也就是说，虽然第一个沉睡了20s，第二个沉睡了2s，但是仍然是先消费死信队列中的“你好 1”，再消费死信队列中的“你好 2”</p><h2 id="6、Rabbitmq-插件实现延迟队列">6、Rabbitmq 插件实现延迟队列</h2><p>上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的TTL 时间 及时死亡，就无法设计成一个通用的延时队列。</p><h3 id="1、安装延时插件队列">1、安装延时插件队列</h3><p>安装过程参考：<a href="https://blog.csdn.net/Dong_Zi8/article/details/116021223">Linux安装RabbitMQ+延迟插件</a></p><p><img src="/2022/11/11/rabbitmq/image-20221116204649783.png" alt></p><h3 id="2、架构图">2、架构图</h3><p>在这里新增了一个队列delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下:</p><p><img src="/2022/11/11/rabbitmq/image-20221116204723589.png" alt></p><h3 id="3、配置类">3、配置类</h3><p>在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制 消息传递后并 不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才 投递到目标队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayedQueueConfig</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.queue&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.exchange&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.routingkey&quot;</span>;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">delayedQueue</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(DELAYED_QUEUE_NAME);<br>&#125;<br><span class="hljs-comment">//自定义交换机 我们在这里定义的是一个延迟交换机</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> CustomExchange <span class="hljs-title function_">delayedExchange</span><span class="hljs-params">()</span> &#123; <br>        Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">//自定义交换机的类型</span><br>args.put(<span class="hljs-string">&quot;x-delayed-type&quot;</span>, <span class="hljs-string">&quot;direct&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomExchange</span>(DELAYED_EXCHANGE_NAME, <span class="hljs-string">&quot;x-delayed-message&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, args);<br>&#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">bindingDelayedQueue</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue queue,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange delayedExchange)</span> &#123;<br><span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、生产者代码">4、生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.exchange&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.routingkey&quot;</span>;<br><span class="hljs-meta">@GetMapping(&quot;sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String message,<span class="hljs-meta">@PathVariable</span> Integer delayTime)</span> &#123;<br>rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, message,<br>correlationData -&gt;&#123;correlationData.getMessageProperties().setDelay(delayTime);<br><span class="hljs-keyword">return</span> correlationData;<br>    &#125;);<br>log.info(<span class="hljs-string">&quot; 当前时间：&#123;&#125;, 发送一条延迟&#123;&#125;毫秒的信息给队列 delayed.queue:&#123;&#125;&quot;</span>, newDate(),delayTime, message);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、消费者代码">5、消费者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.queue&quot;</span>;<br><span class="hljs-meta">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveDelayedQueue</span><span class="hljs-params">(Message message)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span><br><span class="hljs-title class_">String</span>(message.getBody());<br>log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,收到延时队列的消息：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().toString(), msg);<br>&#125;<br></code></pre></td></tr></table></figure><p>发起请求：</p><p><a href="http://localhost:8080/ttl/sendDelayMsg/come">http://localhost:8080/ttl/sendDelayMsg/come</a> on baby1/20000</p><p><a href="http://localhost:8080/ttl/sendDelayMsg/come">http://localhost:8080/ttl/sendDelayMsg/come</a> on baby2/2000</p><p>结果为第二个消息先被消费掉，符合预期</p><h2 id="7、总结">7、总结</h2><p>延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正 确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。</p><p>当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景</p><h1>8、发布确认高级</h1><p>在生产环境中由于一些不明原因，导致 rabbitmq 重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。那么，如何才能进行 RabbitMQ 的消息可靠投递呢？ 特别是在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息该如何处理呢？</p><h2 id="1、SpringBoot发布确认">1、SpringBoot发布确认</h2><h3 id="1、确认机制方案">1、确认机制方案</h3><p><img src="/2022/11/11/rabbitmq/image-20221118160648725.png" alt></p><h3 id="2、架构图-v2">2、架构图</h3><p><img src="/2022/11/11/rabbitmq/image-20221118160735813.png" alt></p><h3 id="3、配置文件">3、配置文件</h3><p>注意要在配置文件中添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">spring.rabbitmq.publisher-confirm-type=correlated</span><br></code></pre></td></tr></table></figure><ul><li>NONE<br>禁用发布确认模式，是默认值</li><li>CORRELATED<br>发布消息成功到交换器后会触发回调方法</li><li>SIMPLE<br>有两种效果，其一效果和 CORRELATED 值一样会触发回调方法， 其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法 等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">spring.rabbitmq.host=xx.xx.xx.xx</span><br><span class="hljs-string">spring.rabbitmq.port=5672</span><br><span class="hljs-string">spring.rabbitmq.username=xxx</span><br><span class="hljs-string">spring.rabbitmq.password=xxx</span><br><span class="hljs-string">spring.rabbitmq.publisher-confirm-type=correlated</span><br></code></pre></td></tr></table></figure><h3 id="4、配置类">4、配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfirmConfig</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;confirm.exchange&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;confirm.queue&quot;</span>;<br><span class="hljs-comment">//声明业务 Exchange</span><br><span class="hljs-meta">@Bean(&quot;confirmExchange&quot;)</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">confirmExchange</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(CONFIRM_EXCHANGE_NAME);<br>&#125;<br><span class="hljs-comment">// 声明确认队列</span><br><span class="hljs-meta">@Bean(&quot;confirmQueue&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">confirmQueue</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();<br>&#125;<br><span class="hljs-comment">// 声明确认队列绑定关系</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBinding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span>&#123;<br><span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">&quot;key1&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、生产者">5、生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/confirm&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;confirm.exchange&quot;</span>;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> MyCallBack myCallBack;<br><span class="hljs-comment">//依赖注入 rabbitTemplate 之后再设置它的回调对象</span><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>rabbitTemplate.setConfirmCallback(myCallBack);<br>&#125;<br><span class="hljs-meta">@GetMapping(&quot;sendMessage/&#123;message&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String message)</span>&#123;<br>    <span class="hljs-comment">//指定消息 id 为 1</span><br>CorrelationData correlationData1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>String routingKey=<span class="hljs-string">&quot;key1&quot;</span>;<br>rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME,routingKey,message+routingKey,correlationData1);<br>CorrelationData correlationData2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>routingKey=<span class="hljs-string">&quot;key2&quot;</span>;<br>rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME,routingKey,message+routingKey,correlationData2);<br>log.info(<span class="hljs-string">&quot;发送消息内容:&#123;&#125;&quot;</span>,message);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、回调接口">6、回调接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RabbitTemplate</span>.ConfirmCallback &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 交换机不管是否收到消息的一个回调方法</span><br><span class="hljs-comment"> * CorrelationData</span><br><span class="hljs-comment">* 消息相关数据</span><br><span class="hljs-comment"> * ack</span><br><span class="hljs-comment">* 交换机是否收到消息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-type">boolean</span> ack, String cause)</span> &#123;<br>        String id=correlationData!=<span class="hljs-literal">null</span>?correlationData.getId():<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">if</span>(ack)&#123;<br>log.info(<span class="hljs-string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>,id);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>log.info(<span class="hljs-string">&quot;交换机还未收到 id 为:&#123;&#125;消息,由于原因:&#123;&#125;&quot;</span>,id,cause);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7、消费者">7、消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;confirm.queue&quot;</span>;<br><span class="hljs-meta">@RabbitListener(queues =CONFIRM_QUEUE_NAME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveMsg</span><span class="hljs-params">(Message message)</span>&#123; <br>    String msg=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody());<br>log.info(<span class="hljs-string">&quot;接受到队列 confirm.queue 消息:&#123;&#125;&quot;</span>,msg);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8、结果">8、结果</h3><p><img src="/2022/11/11/rabbitmq/image-20221118161441008.png" alt></p><p>可以看到，发送了两条消息，第一条消息的 RoutingKey 为 “key1”，第二条消息的 RoutingKey 为 “key2”，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为 第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条 消息被直接丢弃了。</p><h2 id="2、回退消息">2、回退消息</h2><h3 id="1、Mandatory-参数">1、Mandatory 参数</h3><p>**在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如 果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。**那么如何 让无法被路由的消息帮我想办法处理一下？通过设置 mandatory 参 数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</p><h3 id="2、生产者">2、生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageProducer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RabbitTemplate</span>.ConfirmCallback, RabbitTemplate.ReturnCallback&#123;<br>    <span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><span class="hljs-comment">//rabbitTemplate 注入之后就设置该值</span><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>rabbitTemplate.setConfirmCallback(<span class="hljs-built_in">this</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* true：</span><br><span class="hljs-comment">* 交换机无法将消息进行路由时，会将该消息返回给生产者</span><br><span class="hljs-comment">* false：</span><br><span class="hljs-comment">* 如果发现消息无法进行路由，则直接丢弃</span><br><span class="hljs-comment">*/</span><br>rabbitTemplate.setMandatory(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">//设置回退消息交给谁处理</span><br>rabbitTemplate.setReturnCallback(<span class="hljs-built_in">this</span>);<br>&#125;<br><span class="hljs-meta">@GetMapping(&quot;sendMessage&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String message)</span>&#123;<br><span class="hljs-comment">//让消息绑定一个 id 值</span><br><span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());<br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;confirm.exchange&quot;</span>,<span class="hljs-string">&quot;key1&quot;</span>,message+<span class="hljs-string">&quot;key1&quot;</span>,correlationData1);<br>log.info(<span class="hljs-string">&quot;发送消息 id 为:&#123;&#125;内容为&#123;&#125;&quot;</span>,correlationData1.getId(),message+<span class="hljs-string">&quot;key1&quot;</span>);<br><span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());<br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;confirm.exchange&quot;</span>,<span class="hljs-string">&quot;key2&quot;</span>,message+<span class="hljs-string">&quot;key2&quot;</span>,correlationData2);<br>log.info(<span class="hljs-string">&quot;发送消息 id 为:&#123;&#125;内容为&#123;&#125;&quot;</span>,correlationData2.getId(),message+<span class="hljs-string">&quot;key2&quot;</span>);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-type">boolean</span> ack, String cause)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> correlationData != <span class="hljs-literal">null</span> ? correlationData.getId() : <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">if</span> (ack) &#123;<br>log.info(<span class="hljs-string">&quot;交换机收到消息确认成功, id:&#123;&#125;&quot;</span>, id);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.error(<span class="hljs-string">&quot;消息 id:&#123;&#125;未成功投递到交换机,原因是:&#123;&#125;&quot;</span>, id, cause);<br>&#125;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnedMessage</span><span class="hljs-params">(Message message, <span class="hljs-type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;<br>log.info(<span class="hljs-string">&quot;消息:&#123;&#125;被服务器退回，退回原因:&#123;&#125;, 交换机是:&#123;&#125;, 路由 key:&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()),replyText, exchange, routingKey);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、回调接口">3、回调接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RabbitTemplate</span>.ConfirmCallback,RabbitTemplate.ReturnCallback &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 交换机不管是否收到消息的一个回调方法</span><br><span class="hljs-comment"> * CorrelationData</span><br><span class="hljs-comment">* 消息相关数据</span><br><span class="hljs-comment"> * ack</span><br><span class="hljs-comment">* 交换机是否收到消息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-type">boolean</span> ack, String cause)</span> &#123;<br>        String id=correlationData!=<span class="hljs-literal">null</span>?correlationData.getId():<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">if</span>(ack)&#123;<br>log.info(<span class="hljs-string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>,id);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>log.info(<span class="hljs-string">&quot;交换机还未收到 id 为:&#123;&#125;消息,由于原因:&#123;&#125;&quot;</span>,id,cause);<br>&#125;<br>&#125;<br><span class="hljs-comment">//当消息无法路由的时候的回调方法</span><br> <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnedMessage</span><span class="hljs-params">(Message message, <span class="hljs-type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;<br>log.error(<span class="hljs-string">&quot; 消 息 &#123;&#125;, 被 交 换 机 &#123;&#125; 退 回 ， 退 回 原 因 :&#123;&#125;, 路 由 key:&#123;&#125;&quot;</span>,<span class="hljs-keyword">new</span><br><span class="hljs-title class_">String</span>(message.getBody()),exchange,replyText,routingKey);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、结果">4、结果</h3><p><img src="/2022/11/11/rabbitmq/image-20221118162140632.png" alt></p><h2 id="3、备份交换机">3、备份交换机</h2><p>有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的 复杂性，该怎么做呢？</p><p>前面在设置死信队列的文章中提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。</p><p>备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就 是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备 份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定 的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进 入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。</p><h3 id="1、架构图-v3">1、架构图</h3><p><img src="/2022/11/11/rabbitmq/image-20221118162724651.png" alt></p><h3 id="2、修改配置类">2、修改配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfirmConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;confirm.exchange&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;confirm.queue&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">BACKUP_EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;backup.exchange&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">BACKUP_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;backup.queue&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">WARNING_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;warning.queue&quot;</span>;<br><span class="hljs-comment">// 声明确认队列</span><br> <span class="hljs-meta">@Bean(&quot;confirmQueue&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">confirmQueue</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();<br>&#125;<br><span class="hljs-comment">//声明确认队列绑定关系</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBinding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span>&#123;<br><span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">&quot;key1&quot;</span>);<br>&#125;<br><span class="hljs-comment">//声明备份 Exchange</span><br><span class="hljs-meta">@Bean(&quot;backupExchange&quot;)</span><br><span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title function_">backupExchange</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FanoutExchange</span>(BACKUP_EXCHANGE_NAME);<br>&#125;<br><span class="hljs-comment">//声明确认 Exchange 交换机的备份交换机</span><br> <span class="hljs-meta">@Bean(&quot;confirmExchange&quot;)</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">confirmExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ExchangeBuilder</span> <span class="hljs-variable">exchangeBuilder</span> <span class="hljs-operator">=</span> ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME).durable(<span class="hljs-literal">true</span>)<br><span class="hljs-comment">//设置该交换机的备份交换机</span><br> .withArgument(<span class="hljs-string">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE_NAME);<br><span class="hljs-keyword">return</span> (DirectExchange)exchangeBuilder.build();<br>&#125;<br><span class="hljs-comment">// 声明警告队列</span><br> <span class="hljs-meta">@Bean(&quot;warningQueue&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">warningQueue</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();<br>&#125;<br><span class="hljs-comment">// 声明报警队列绑定关系</span><br> <span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">warningBinding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue queue,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span>&#123;<br><span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(backupExchange);<br>&#125;<br><span class="hljs-comment">// 声明备份队列</span><br> <span class="hljs-meta">@Bean(&quot;backQueue&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">backQueue</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();<br>&#125;<br><span class="hljs-comment">// 声明备份队列绑定关系</span><br> <span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">backupBinding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;backQueue&quot;)</span> Queue queue,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span>&#123;<br><span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(backupExchange);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、报警消费者">3、报警消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WarningConsumer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">WARNING_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;warning.queue&quot;</span>;<br><span class="hljs-meta">@RabbitListener(queues = WARNING_QUEUE_NAME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveWarningMsg</span><span class="hljs-params">(Message message)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody());<br>log.error(<span class="hljs-string">&quot;报警发现不可路由消息：&#123;&#125;&quot;</span>, msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、结果-v2">4、结果</h3><p>注意重新启动项目的时候需要把原来的confirm.exchange 删除，因为我们修改了其绑定属性。</p><p><img src="/2022/11/11/rabbitmq/image-20221118163131576.png" alt></p><p>mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是备份交换机优先级高。</p><h1>9、幂等性、优先级队列、惰性队列</h1><h2 id="1、幂等性">1、幂等性</h2><p>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常， 此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱 了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误 立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等</p><p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但 实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p><p>怎么解决消息重复消费的问题呢？MQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消 息时用该 id 先判断该消息是否已消费过。</p><p>在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性， 这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。业界主流的幂等性有两种操作:</p><ol><li>唯一 ID+指纹码机制,利用数据库主键去重<br>指纹码:我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基 本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存 在数据库中,优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数 据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。</li><li>利用 redis 的原子性去实现<br>利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费</li></ol><h2 id="2、优先级队列">2、优先级队列</h2><p>为什么要有优先级队列，假如在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单,淘宝会及时将订单推送给我们，如 果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能，但是，tmall 商家对我们来说，肯定是要分大客户和小客户，比如像苹果，小米这样大商家一年起码能给我们创 造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经后端系统是使用 redis 来存 放的定时轮询，redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 RabbitMQ 进行改造和优化,如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。</p><blockquote><p>如何添加优先级队列</p></blockquote><p>1、声明队列</p><p>2、队列中代码添加优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>params.put(<span class="hljs-string">&quot;x-max-priority&quot;</span>, <span class="hljs-number">10</span>);<br>channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, params);<br></code></pre></td></tr></table></figure><p>3、消息中代码添加优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties().builder().priority(<span class="hljs-number">5</span>).build();<br></code></pre></td></tr></table></figure><p>4、发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());<br></code></pre></td></tr></table></figure><h2 id="3、惰性队列">3、惰性队列</h2><p>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消 费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持 更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致 使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p><p>默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中， 这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留 一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的 时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候。</p><blockquote><p>队列的两种模式</p></blockquote><p>队列具备两种模式：default 和 lazy。默认的为default 模式，在3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。 如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</p><p>在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。下面示 例中演示了一个惰性队列的声明细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br>args.put(<span class="hljs-string">&quot;x-queue-mode&quot;</span>, <span class="hljs-string">&quot;lazy&quot;</span>);<br>channel.queueDeclare(<span class="hljs-string">&quot;myqueue&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, args);<br></code></pre></td></tr></table></figure><blockquote><p>内存开销对比</p></blockquote><p><img src="/2022/11/11/rabbitmq/image-20221118171159028.png" alt></p><p>在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅 占用 1.5MB</p><h1>10、RabbitMQ集群</h1><h2 id="1、使用集群的原因">1、使用集群的原因</h2><p>如果 RabbitMQ 服务器遇到内存崩溃、机器掉电或者主板故障等情况，该怎么办？单台 RabbitMQ 服务器可以满足每秒 1000 条消息的吞吐量，那么如果应用需要 RabbitMQ 服务满足每秒 10 万条消息的吞吐量呢？购买昂贵的服务器来增强单机 RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是 解决实际问题的关键。</p><p>集群搭建可参考：<a href="https://cloud.tencent.com/developer/article/1923650">RabbitMQ集群搭建</a></p><h2 id="2、镜像队列">2、镜像队列</h2><p>如果 RabbitMQ 集群中只有一个 Broker 节点，那么该节点的失效将导致整体服务的临时性不可用，并 且也可能会导致消息的丢失。可以将所有消息都设置为持久化，并且对应队列的durable属性也设置为true，但 是这样仍然无法避免由于缓存导致的问题：因为消息在发送之后和被写入磁盘井执行刷盘动作之间存在一 个短暂却会产生问题的时间窗。通过 publisherconfirm 机制能够确保客户端知道哪些消息己经存入磁盘，尽 管如此，一般不希望遇到因单点故障导致的服务不可用。</p><p>引入镜像队列(Mirror Queue)的机制，可以将队列镜像到集群中的其他 Broker 节点之上，如果集群中 的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性。</p><h2 id="3、Haproxy-Keepalive-实现高可用负载均衡">3、Haproxy+Keepalive 实现高可用负载均衡</h2><h3 id="1、架构图-v4">1、架构图</h3><p><img src="/2022/11/11/rabbitmq/image-20221118191312087.png" alt></p><h3 id="2、实现">2、实现</h3><p>HAProxy 提供高可用性、负载均衡及基于TCPHTTP 应用的代理，支持虚拟主机，它是免费、快速并 且可靠的一种解决方案，包括 Twitter,Reddit,StackOverflow,GitHub 在内的多家知名互联网公司在使用。 HAProxy 实现了一种事件驱动、单一进程模型，此模型支持非常大的井发连接数。</p><p>扩展 nginx,lvs,haproxy 之间的区别: <a href="http://www.ha97.com/5646.html">http://www.ha97.com/5646.html</a></p><p>试想如果前面配置的 HAProxy 主机突然宕机或者网卡失效，那么虽然 RbbitMQ 集群没有任何故障但是 对于外界的客户端来说所有的连接都会被断开结果将是灾难性的为了确保负载均衡服务的可靠性同样显得 十分重要，这里就要引入 Keepalived 它能够通过自身健康检查、资源接管功能做高可用(双机热备)，实现 故障转移.</p><p>参考链接：<a href="http://www.yunweipai.com/40460.html#:~:text=%E9%80%9A%E8%BF%87%E6%9C%8D%E5%8A%A1%E4%BB%A3%E7%90%86%E5%B0%86%E6%B5%81%E9%87%8F%E7%94%B1%E5%89%8D%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%87%B3%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8A%82%E7%82%B9%E4%B8%8A%E3%80%82%201.3,Keepalived%E5%92%8CHAProxy%E7%BB%84%E5%90%88%20%E7%94%B1%E4%BA%8EHAProxy%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%B1Keepalived%E6%9D%A5%E4%B8%BAHAProxy%E6%8F%90%E4%BE%9B%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%8D%E5%8A%A1%EF%BC%8C%E8%80%8CHAProxy%E6%8F%90%E4%BE%9B%E5%9B%9B%E5%B1%82%E6%88%96%E4%B8%83%E5%B1%82%E9%AB%98%E6%80%A7%E8%83%BD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8F%8A%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%EF%BC%8C%E4%B8%A4%E8%80%85%E5%85%B1%E5%90%8C%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%8C%E7%BB%93%E6%9E%84%E5%A6%82%E5%9B%BE1%E6%89%80%E7%A4%BA%E3%80%82">用 Keepalived+HAProxy 实现高可用负载均衡的配置方法</a></p><h2 id="4、Federation-Exchange">4、Federation Exchange</h2><p>(broker 北京)，(broker 深圳)彼此之间相距甚远，网络延迟是一个不得不面对的问题。有一个在北京 的业务(Client 北京) 需要连接(broker 北京)，向其中的交换器 exchangeA 发送消息，此时的网络延迟很小， (Client 北京)可以迅速将消息发送至 exchangeA 中，就算在开启了 publisherconfirm 机制或者事务机制的情 况下，也可以迅速收到确认信息。此时又有个在深圳的业务(Client 深圳)需要向 exchangeA 发送消息， 那 么(Client 深圳) (broker 北京)之间有很大的网络延迟，(Client 深圳) 将发送消息至 exchangeA 会经历一定 的延迟，尤其是在开启了 publisherconfirm 机制或者事务机制的情况下，(Client 深圳) 会等待很长的延迟 时间来接收(broker 北京)的确认信息，进而必然造成这条发送线程的性能降低，甚至造成一定程度上的阻 塞。</p><p>将业务(Client 深圳)部署到北京的机房可以解决这个问题，但是如果(Client 深圳)调用的另些服务都部 署在深圳，那么又会引发新的时延问题，总不见得将所有业务全部部署在一个机房，那么容灾又何以实现？ 这里 使用 Federation 插件就可以很好地解决这个问题。</p><p><img src="/2022/11/11/rabbitmq/image-20221118191639111.png" alt></p><p><img src="/2022/11/11/rabbitmq/image-20221118192134598.png" alt></p><h2 id="5、Federation-Queue">5、Federation Queue</h2><p>联邦队列可以在多个 Broker 节点(或者集群)之间为单个队列提供均衡负载的功能。一个联邦队列可以 连接一个或者多个上游队列(upstream queue)，并从这些上游队列中获取消息以满足本地消费者消费消息 的需求。</p><p>参考链接：<a href="https://blog.csdn.net/qq_41157896/article/details/114646866">rabbitMQ插件Federation配置（数据同步）</a></p><h2 id="6、Shovel">6、Shovel</h2><p>Federation 具备的数据转发功能类似，Shovel 够可靠、持续地从一个 Broker 中的队列(作为源端，即 source)拉取数据并转发至另一个 Broker 中的交换器(作为目的端，即 destination)。作为源端的队列和作为 目的端的交换器可以同时位于同一个 Broker，也可以位于不同的 Broker 上。Shovel 可以翻译为&quot;铲子&quot;，是 一种比较形象的比喻，这个&quot;铲子&quot;可以将消息从一方&quot;铲子&quot;另一方。Shovel 行为就像优秀的客户端应用程 序能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理。</p><p><img src="/2022/11/11/rabbitmq/image-20221118192105876.png" alt></p><p>参考链接：<a href="https://cloud.tencent.com/developer/article/1469332">RabbitMQ Shovel</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-04-虚拟机栈</title>
      <link href="/2022/10/31/jvm-04-xu-ni-ji-zhan/"/>
      <url>/2022/10/31/jvm-04-xu-ni-ji-zhan/</url>
      
        <content type="html"><![CDATA[<h1>1、虚拟机栈概述</h1><h2 id="1、虚拟机栈的出现背景">1、虚拟机栈的出现背景</h2><ol><li>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。</li><li>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令</li></ol><h2 id="2、内存中的栈和堆">2、内存中的栈和堆</h2><ol><li>首先栈是运行时的单位，而堆是存储的单位。</li><li>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ol><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031170753668.png" alt></p><h2 id="3、虚拟机栈基本内容">3、虚拟机栈基本内容</h2><blockquote><p>Java虚拟机栈是什么？</p></blockquote><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<strong>对应着一次次的Java方法调用</strong>，栈是线程私有的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StackTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StackTest</span>();<br>        test.methodA();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>        methodB();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031171651921.png" alt></p><blockquote><p>虚拟机栈的生命周期</p></blockquote><p>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</p><blockquote><p>虚拟机栈的作用</p></blockquote><p>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。</p><p>局部变量，它是相比于成员变量来说的（或属性）</p><p>基本数据类型变量 VS 引用类型变量（类、数组、接口）</p><h2 id="4、虚拟机栈的特点">4、虚拟机栈的特点</h2><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li><li>JVM直接对Java栈的操作只有两个：<ul><li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li><li>执行结束后的<strong>出栈</strong>工作</li></ul></li><li>对于栈来说不存在垃圾回收问题<ul><li>栈不需要GC，但是可能存在OOM（异常）</li></ul></li></ul><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031171930120.png" alt></p><h2 id="5、虚拟机栈的异常">5、虚拟机栈的异常</h2><p>栈中可能出现哪些异常？</p><ul><li>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。<ul><li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong> 异常。（栈溢出）</li><li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。（内存溢出）</li></ul></li></ul><h2 id="6、设置栈内存大小">6、设置栈内存大小</h2><blockquote><p>官方文档：<a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a></p></blockquote><p>可以使用参数 <strong>-Xss</strong> 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><p>The following examples set the thread stack size to 1024 KB in different units:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xss1m<br>-Xss1024k<br>-Xss1048576<br></code></pre></td></tr></table></figure><h3 id="举例">举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackErrorTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(count);<br>        count++;<br>        main(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>没设置参数前的部分结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">11404</span><br><span class="hljs-number">11405</span><br><span class="hljs-number">11406</span><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.StackOverflowError<br>at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:<span class="hljs-number">691</span>)<br></code></pre></td></tr></table></figure><p>说明栈在11406这个深度溢出了</p><p>设置栈参数后，（可参考<a href="https://www.jianshu.com/p/909a906ec14b">Idea调节栈参数</a>）</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031181051063.png" alt></p><p>部分输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2474</span><br><span class="hljs-number">2475</span><br><span class="hljs-number">2476</span><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.StackOverflowError<br>at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:<span class="hljs-number">77</span>)<br></code></pre></td></tr></table></figure><h1>2、栈的存储单位</h1><h2 id="1、栈中存储什么">1、栈中存储什么</h2><ul><li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在</li><li>在这个线程上正在执行的<code>每个方法都各自对应一个栈帧</code>（Stack Frame）。</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ul><h2 id="2、栈运行原理">2、栈运行原理</h2><ul><li>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</li></ul><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031181732230.png" alt></p><ol><li><p><strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。栈是各自私有的。</p></li><li><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p></li><li><p>Java方法有两种返回函数的方式。</p><ul><li>一种是正常的函数返回，使用return指令。</li><li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。</li></ul><p>但不管使用哪种方式，都会导致栈帧被弹出。</p></li></ol><h2 id="3、栈帧的内部结构">3、栈帧的内部结构</h2><p>每个栈帧中存储着：</p><ul><li><code>局部变量表（Local Variables）</code></li><li><code>操作数栈（Operand Stack）（或表达式栈）</code></li><li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031183936694.png" alt></p><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031184012273.png" alt></p><h1>3、局部变量表</h1><h2 id="1、局部变量表">1、局部变量表</h2><ol><li>局部变量表也被称之为局部变量数组或本地变量表</li><li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。<ul><li>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</li><li>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li></ul></li><li>局部变量表中的变量只在当前方法调用中有效。<ul><li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li><li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul></li></ol><p>下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalVariablesTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LocalVariablesTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVariablesTest</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        test.test1();<br>    &#125;<br><br>    <span class="hljs-comment">//练习：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStatic</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">LocalVariablesTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVariablesTest</span>();<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(count);<br>        <span class="hljs-comment">//因为this变量不存在于当前方法的局部变量表中！！</span><br><span class="hljs-comment">//        System.out.println(this.count);</span><br>    &#125;<br><br>    <span class="hljs-comment">//关于Slot的使用的理解</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LocalVariablesTest</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.count = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;atguigu.com&quot;</span>;<br>        test2(date, name1);<br>        System.out.println(date + name1);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test2</span><span class="hljs-params">(Date dateP, String name2)</span> &#123;<br>        dateP = <span class="hljs-literal">null</span>;<br>        name2 = <span class="hljs-string">&quot;songhongkang&quot;</span>;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">weight</span> <span class="hljs-operator">=</span> <span class="hljs-number">130.5</span>;<span class="hljs-comment">//占据两个slot</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">gender</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span>;<br>        <span class="hljs-keyword">return</span> dateP + name2;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.count++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            b = a + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031190546496.png" alt></p><p>看完字节码后，可得结论：局部变量表所需的容量大小是在<code>编译期</code>确定下来的。</p><p>用jclasslib来看字节码，以main方法为例来讲解。</p><p>1、0-15 也就是有16行字节码</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031191240599.png" alt></p><p>2、方法异常信息表</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031191307715.png" alt></p><p>3、Misc</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031191327591.png" alt></p><p>4、行号表</p><p>Java代码的行号和字节码指令行号的对应关系</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031191415540.png" alt></p><p>5、注意：生效行数和剩余有效行数都是针对于字节码文件的行数</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221031191440509.png" alt></p><p>1、图中圈的东西表示该局部变量的作用域</p><p>2、Start PC==11表示在字节码的11行开始生效，也就是Java代码对应的第15行。而声明int num在java代码的是第14行，说明是从声明的下一行开始生效</p><p>3、Length== 5表示局部变量剩余有效行数，main方法字节码指令总共有16行，从11行开始生效，那么剩下就是16-11 ==5。</p><p>4、<code>Ljava/lang/String</code> 前面的L表示引用类型</p><h2 id="2、关于slot">2、关于slot</h2><ul><li>参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</li><li>局部变量表，<strong>最基本的存储单元是Slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li><li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型占用两个slot（1ong和double）。<ul><li>byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true</li><li>long和double则占据两个slot</li></ul></li><li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</li><li>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</li><li>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）</li></ul><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101155101775.png" alt></p><h2 id="3、slot代码示例">3、slot代码示例</h2><p><strong>this 存放在 index = 0 的位置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-built_in">this</span>.count++;<br>   &#125;<br></code></pre></td></tr></table></figure><p>局部变量表：this 存放在 index = 0 的位置</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101161423898.png" alt></p><p><strong>64位的类型（1ong和double）占用两个slot</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test2</span><span class="hljs-params">(Date dateP, String name2)</span> &#123;<br>      dateP = <span class="hljs-literal">null</span>;<br>      name2 = <span class="hljs-string">&quot;songhongkang&quot;</span>;<br>      <span class="hljs-type">double</span> <span class="hljs-variable">weight</span> <span class="hljs-operator">=</span> <span class="hljs-number">130.5</span>;<span class="hljs-comment">//占据两个slot</span><br>      <span class="hljs-type">char</span> <span class="hljs-variable">gender</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span>;<br>      <span class="hljs-keyword">return</span> dateP + name2;<br>  &#125;<br></code></pre></td></tr></table></figure><p>weight 为 double 类型，index 直接从 3 蹦到了 5</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101161537765.png" alt></p><h2 id="4、slot的重复使用">4、slot的重复使用</h2><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        b = a + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>局部变量c重用了局部变量b的slot位置</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101161714299.png" alt></p><h2 id="5、静态变量与局部变量的对比">5、静态变量与局部变量的对比</h2><p>java变量的分类：<br>1、按照数据类型分：① 基本数据类型  ② 引用数据类型<br>2、按照在类中声明的位置分：<br>2-1、成员变量：在使用前，都经历过默认初始化赋值<br>2-1-1、类变量: linking的prepare阶段：给类变量默认赋值<br>—&gt; initial阶段：给类变量显式赋值即静态代码块赋值<br>2-1-2、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值<br>2-2、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</p><ul><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li><li>我们知道成员变量有两次初始化的机会**，**第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li><li>和类变量初始化不同的是，<strong>局部变量表不存在系统初始化的过程</strong>，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li></ul><ol><li>在栈帧中，<code>与性能调优关系最为密切的部分就是前面提到的局部变量表</code>。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li><li><code>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</code></li></ol><h1>4、操作数栈</h1><h2 id="1、操作数栈">1、操作数栈</h2><ol><li><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</p></li><li><p>操作数栈，在方法执行过程中，<strong>根据字节码指令，往栈中写入数据或提取数据</strong>，即入栈（push）和 出栈（pop）</p><ul><li><p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。</p></li><li><p>比如：执行复制、交换、求和等操作</p></li></ul></li></ol><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101162841002.png" alt></p><h2 id="2、操作数栈作用">2、操作数栈作用</h2><ol><li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</li><li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。</li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</li><li>栈中的任何一个元素都是可以任意的Java数据类型<ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<strong>只不过操作数栈是用数组这个结构来实现的而已</strong></li><li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</li><li>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</li></ol><h1>5、代码追踪</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddOperation</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//byte、short、char、boolean：都以int型来保存</span><br>       <span class="hljs-type">byte</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j;<br><br>      <span class="hljs-comment">// int m = 800;</span><br><br>   &#125;<br></code></pre></td></tr></table></figure><p>字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> bipush <span class="hljs-number">15</span><br> <span class="hljs-number">2</span> istore_1<br> <span class="hljs-number">3</span> bipush <span class="hljs-number">8</span><br> <span class="hljs-number">5</span> istore_2<br> <span class="hljs-number">6</span> iload_1<br> <span class="hljs-number">7</span> iload_2<br> <span class="hljs-number">8</span> iadd<br> <span class="hljs-number">9</span> istore_3<br><span class="hljs-number">10</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101164637529.png" alt></p><p>1、执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101164809868.png" alt></p><p>2、执行完后，PC寄存器往下移，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置（istore_1），可以看到局部变量表的已经增加了一个元素。并且操作数栈为空了</p><blockquote><p>为什么局部变量表索引从 1 开始，是因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this</p></blockquote><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101164929145.png" alt></p><p>3、PC下移，指向下一行。操作数8也入栈，同时执行store操作，存入局部变量表中</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101165011427.png" alt></p><p>4、然后从局部变量表中，依次将数据放在操作数栈中，等待执行 add 操作</p><p>iload_1：取出局部变量表中索引为1的数据入操作数栈</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101165030381.png" alt></p><p>5、将操作数栈的两个元素相加，并存储在局部变量表3的位置</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101165049259.png" alt></p><p><strong>类型转换问题</strong></p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101170200451.png" alt></p><p>因为 8 可以存放在 byte 类型中，所以压入操作数栈的类型为 byte ，而不是 int ，所以执行的字节码指令为 bipush 8。但是存储在局部变量的时候，会转成 int 类型的变量：istore_4</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101170304921.png" alt></p><p>m改成800之后，byte存储不了，就成了short型，sipush 800</p><p><strong>如果被调用的方法带有返回值，返回值入操作数栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> m + n;<br>      <span class="hljs-keyword">return</span> k;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetSum</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">//获取上一个栈桢返回的结果，并保存在操作数栈中</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> getSum();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>getSum() 方法字节码指令：最后带着个 ireturn</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101170433423.png" alt></p><p>testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值()</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101170531591.png" alt></p><h1>6、栈顶缓存技术(可能未实现？)</h1><p><strong>栈顶缓存技术：Top Of Stack Cashing</strong></p><ol><li>前面提过，基于栈式架构的虚拟机所使用的<code>零地址指令</code>更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读/写次数多，效率不高。</li><li>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</strong></li><li>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</li></ol><h1>7、动态链接</h1><p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p><ul><li>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicLinkingTest</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;methodA()....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;methodB()....&quot;</span>);<br><br>        methodA();<br><br>        num++;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>对应的字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter05/com/atguigu/java1/DynamicLinkingTest.<span class="hljs-keyword">class</span><br>  <span class="hljs-title class_">Last</span> modified <span class="hljs-number">2020</span>-<span class="hljs-number">11</span>-<span class="hljs-number">10</span>; size <span class="hljs-number">712</span> bytes<br>  MD5 checksum e56913c945f897c7ee6c0a608629bca8<br>  Compiled from <span class="hljs-string">&quot;DynamicLinkingTest.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.atguigu.java1.DynamicLinkingTest<br>  minor version: <span class="hljs-number">0</span><br>  major version: <span class="hljs-number">52</span><br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">9.</span>#<span class="hljs-number">23</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = Fieldref           #<span class="hljs-number">8.</span>#<span class="hljs-number">24</span>         <span class="hljs-comment">// com/atguigu/java1/DynamicLinkingTest.num:I</span><br>   #<span class="hljs-number">3</span> = Fieldref           #<span class="hljs-number">25.</span>#<span class="hljs-number">26</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span><br>   #<span class="hljs-number">4</span> = String             #<span class="hljs-number">27</span>            <span class="hljs-comment">// methodA()....</span><br>   #<span class="hljs-number">5</span> = Methodref          #<span class="hljs-number">28.</span>#<span class="hljs-number">29</span>        <span class="hljs-comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>   #<span class="hljs-number">6</span> = String             #<span class="hljs-number">30</span>            <span class="hljs-comment">// methodB()....</span><br>   #<span class="hljs-number">7</span> = Methodref          #<span class="hljs-number">8.</span>#<span class="hljs-number">31</span>         <span class="hljs-comment">// com/atguigu/java1/DynamicLinkingTest.methodA:()V</span><br>   #<span class="hljs-number">8</span> = Class              #<span class="hljs-number">32</span>            <span class="hljs-comment">// com/atguigu/java1/DynamicLinkingTest</span><br>   #<span class="hljs-number">9</span> = Class              #<span class="hljs-number">33</span>            <span class="hljs-comment">// java/lang/Object</span><br>  #<span class="hljs-number">10</span> = Utf8               num<br>  #<span class="hljs-number">11</span> = Utf8               I<br>  #<span class="hljs-number">12</span> = Utf8               &lt;init&gt;<br>  #<span class="hljs-number">13</span> = Utf8               ()V<br>  #<span class="hljs-number">14</span> = Utf8               Code<br>  #<span class="hljs-number">15</span> = Utf8               LineNumberTable<br>  #<span class="hljs-number">16</span> = Utf8               LocalVariableTable<br>  #<span class="hljs-number">17</span> = Utf8               <span class="hljs-built_in">this</span><br>  #<span class="hljs-number">18</span> = Utf8               Lcom/atguigu/java1/DynamicLinkingTest;<br>  #<span class="hljs-number">19</span> = Utf8               methodA<br>  #<span class="hljs-number">20</span> = Utf8               methodB<br>  #<span class="hljs-number">21</span> = Utf8               SourceFile<br>  #<span class="hljs-number">22</span> = Utf8               DynamicLinkingTest.java<br>  #<span class="hljs-number">23</span> = NameAndType        #<span class="hljs-number">12</span>:#<span class="hljs-number">13</span>        <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  #<span class="hljs-number">24</span> = NameAndType        #<span class="hljs-number">10</span>:#<span class="hljs-number">11</span>        <span class="hljs-comment">// num:I</span><br>  #<span class="hljs-number">25</span> = Class              #<span class="hljs-number">34</span>            <span class="hljs-comment">// java/lang/System</span><br>  #<span class="hljs-number">26</span> = NameAndType        #<span class="hljs-number">35</span>:#<span class="hljs-number">36</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>  #<span class="hljs-number">27</span> = Utf8               <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>....<br>  #<span class="hljs-number">28</span> = Class              #<span class="hljs-number">37</span>            <span class="hljs-comment">// java/io/PrintStream</span><br>  #<span class="hljs-number">29</span> = NameAndType        #<span class="hljs-number">38</span>:#<span class="hljs-number">39</span>        <span class="hljs-comment">// println:(Ljava/lang/String;)V</span><br>  #<span class="hljs-number">30</span> = Utf8               <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>....<br>  #<span class="hljs-number">31</span> = NameAndType        #<span class="hljs-number">19</span>:#<span class="hljs-number">13</span>        <span class="hljs-comment">// methodA:()V</span><br>  #<span class="hljs-number">32</span> = Utf8               com/atguigu/java1/DynamicLinkingTest<br>  #<span class="hljs-number">33</span> = Utf8               java/lang/Object<br>  #<span class="hljs-number">34</span> = Utf8               java/lang/System<br>  #<span class="hljs-number">35</span> = Utf8               out<br>  #<span class="hljs-number">36</span> = Utf8               Ljava/io/PrintStream;<br>  #<span class="hljs-number">37</span> = Utf8               java/io/PrintStream<br>  #<span class="hljs-number">38</span> = Utf8               println<br>  #<span class="hljs-number">39</span> = Utf8               (Ljava/lang/String;)V<br>&#123;<br>  <span class="hljs-type">int</span> num;<br>    descriptor: I<br>    flags:<br><br>  <span class="hljs-keyword">public</span> com.atguigu.java1.DynamicLinkingTest();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: aload_0<br>         <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span><br>         <span class="hljs-number">7</span>: putfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field num:I</span><br>        <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">9</span>: <span class="hljs-number">4</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">11</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String methodA()....</span><br>         <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">12</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">13</span>: <span class="hljs-number">8</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// String methodB()....</span><br>         <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>         <span class="hljs-number">8</span>: aload_0<br>         <span class="hljs-number">9</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method methodA:()V</span><br>        <span class="hljs-number">12</span>: aload_0<br>        <span class="hljs-number">13</span>: dup<br>        <span class="hljs-number">14</span>: getfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field num:I</span><br>        <span class="hljs-number">17</span>: iconst_1<br>        <span class="hljs-number">18</span>: iadd<br>        <span class="hljs-number">19</span>: putfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field num:I</span><br>        <span class="hljs-number">22</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">16</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">18</span>: <span class="hljs-number">8</span><br>        line <span class="hljs-number">20</span>: <span class="hljs-number">12</span><br>        line <span class="hljs-number">21</span>: <span class="hljs-number">22</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">23</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;<br>&#125;<br>SourceFile: <span class="hljs-string">&quot;DynamicLinkingTest.java&quot;</span><br></code></pre></td></tr></table></figure><p>1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？</p><p>2、往上面翻，找到常量池的定义：<code>#7 = Methodref #8.#31</code></p><ul><li>先找 #8 ：<ul><li><code>#8 = Class #32</code> ：去找 #32</li><li><code>#32 = Utf8 com/atguigu/java1/DynamicLinkingTest</code></li><li>结论：通过 #8 我们找到了 <code>DynamicLinkingTest</code> 这个类</li></ul></li><li>再来找 #31：<ul><li><code>#31 = NameAndType #19:#13</code> ：去找 #19 和 #13</li><li><code>#19 = Utf8 methodA</code> ：方法名为 methodA</li><li><code>#13 = Utf8 ()V</code> ：方法没有形参，返回值为 void</li></ul></li></ul><p>3、结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用</p><p>4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等</p><p><img src="/2022/10/31/jvm-04-xu-ni-ji-zhan/image-20221101190630536.png" alt></p><p><strong>为什么要用常量池呢？</strong></p><ol><li>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</li><li>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-《程艾影》</title>
      <link href="/2022/10/28/c-cheng-ai-ying/"/>
      <url>/2022/10/28/c-cheng-ai-ying/</url>
      
        <content type="html"><![CDATA[<center>《程艾影》</center><p><img src="/2022/10/28/c-cheng-ai-ying/image-20221028201426573.png" alt></p><p>capo = 5</p><p>前奏-主歌-副歌-间歇-主歌-副歌-哼唱-副歌-主歌-尾奏</p><p><img src="/2022/10/28/c-cheng-ai-ying/image-20221028201251237.png" alt></p><p><img src="/2022/10/28/c-cheng-ai-ying/image-20221028201315318.png" alt></p><p><img src="/2022/10/28/c-cheng-ai-ying/image-20221028201340211.png" alt></p><blockquote><p>曲谱来源于小兵er</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 吉他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吉他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-《夜空中最亮的星》</title>
      <link href="/2022/10/28/c-ye-kong-zhong-zui-liang-de-xing/"/>
      <url>/2022/10/28/c-ye-kong-zhong-zui-liang-de-xing/</url>
      
        <content type="html"><![CDATA[<center>《夜空中最亮的星》</center><p>原调B | 选调A | capo = 2</p><p><img src="/2022/10/28/c-ye-kong-zhong-zui-liang-de-xing/image-20221028194640928.png" alt></p><p><img src="/2022/10/28/c-ye-kong-zhong-zui-liang-de-xing/image-20221028194753369.png" alt></p><blockquote><p>曲谱来源于趣谈音乐</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 吉他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吉他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-03-运行时数据区</title>
      <link href="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/"/>
      <url>/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/</url>
      
        <content type="html"><![CDATA[<h1>1、运行时数据区概述及线程</h1><h2 id="1、概述">1、概述</h2><p>运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027165103294.png" alt></p><p>当我们通过前面的：类的加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027165118280.png" alt></p><p>类比一下也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品。</p><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027165152827.png" alt></p><h2 id="2、运行时数据区结构">2、运行时数据区结构</h2><h3 id="1、运行时数据区和内存">1、运行时数据区和内存</h3><ol><li>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</li><li>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</li></ol><p>下图源于阿里巴巴手册jdk8</p><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027170903919.png" alt></p><h3 id="2、线程的内存空间">2、线程的内存空间</h3><ol><li>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区：其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</li><li>灰色的为单独线程私有的，红色的为多个线程共享的。即：<ul><li>线程独有：独立包括程序计数器、栈、本地方法栈</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul></li></ol><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027171302313.png" alt></p><h3 id="3、Runtime类">3、Runtime类</h3><p><strong>每个JVM只有一个Runtime实例</strong>。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境（运行时数据区）。</p><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027171346233.png" alt></p><h2 id="3、线程">3、线程</h2><h3 id="1、JVM线程">1、JVM线程</h3><ol><li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li><li>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射<ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li></ul></li><li>操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</li></ol><h3 id="2、JVM系统线程">2、JVM系统线程</h3><ul><li>如果使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[])</code>的main线程以及所有这个main线程自己创建的线程。</li><li>这些主要的后台系统线程在Hotspot JVM里主要是以下几个（了解）：</li></ul><ol><li><strong>虚拟机线程</strong>：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li><li><strong>周期任务线程</strong>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li><li><strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持</li><li><strong>编译线程</strong>：这种线程在运行时会将字节码编译成到本地代码</li><li><strong>信号调度线程</strong>：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li></ol><h1>2、程序计数器(PC寄存器)</h1><h2 id="1、PC寄存器介绍">1、PC寄存器介绍</h2><blockquote><p>官方文档网址：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p></blockquote><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027194012157.png" alt></p><ol><li>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，<strong>寄存器存储指令相关的现场信息</strong>。CPU只有把数据装载到寄存器才能够运行。</li><li>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<code>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</code>。</li><li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li><li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</li><li>它是<strong>程序控制流</strong>的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何OutofMemoryError（溢出）情况的区域。</li></ol><h2 id="2、PC寄存器的作用">2、PC寄存器的作用</h2><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。</p><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027194401567.png" alt></p><h2 id="3、例子">3、例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PCRegisterTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>        System.out.println(i);<br>        System.out.println(k);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看字节码</p><blockquote><p>看字节码的方法：<a href="https://blog.csdn.net/21aspnet/article/details/88351875">https://blog.csdn.net/21aspnet/article/details/88351875</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter04/com/atguigu/java/PCRegisterTest.<span class="hljs-keyword">class</span><br>  <span class="hljs-title class_">Last</span> modified <span class="hljs-number">2020</span>-<span class="hljs-number">11</span>-<span class="hljs-number">2</span>; size <span class="hljs-number">675</span> bytes<br>  MD5 checksum 53b3ef104479ec9e9b7ce5319e5881d3<br>  Compiled from <span class="hljs-string">&quot;PCRegisterTest.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.atguigu.java.PCRegisterTest<br>  minor version: <span class="hljs-number">0</span><br>  major version: <span class="hljs-number">52</span><br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">6.</span>#<span class="hljs-number">26</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = String             #<span class="hljs-number">27</span>            <span class="hljs-comment">// abc</span><br>   #<span class="hljs-number">3</span> = Fieldref           #<span class="hljs-number">28.</span>#<span class="hljs-number">29</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span><br>   #<span class="hljs-number">4</span> = Methodref          #<span class="hljs-number">30.</span>#<span class="hljs-number">31</span>        <span class="hljs-comment">// java/io/PrintStream.println:(I)V</span><br>   #<span class="hljs-number">5</span> = Class              #<span class="hljs-number">32</span>            <span class="hljs-comment">// com/atguigu/java/PCRegisterTest</span><br>   #<span class="hljs-number">6</span> = Class              #<span class="hljs-number">33</span>            <span class="hljs-comment">// java/lang/Object</span><br>   #<span class="hljs-number">7</span> = Utf8               &lt;init&gt;<br>   #<span class="hljs-number">8</span> = Utf8               ()V<br>   #<span class="hljs-number">9</span> = Utf8               Code<br>  #<span class="hljs-number">10</span> = Utf8               LineNumberTable<br>  #<span class="hljs-number">11</span> = Utf8               LocalVariableTable<br>  #<span class="hljs-number">12</span> = Utf8               <span class="hljs-built_in">this</span><br>  #<span class="hljs-number">13</span> = Utf8               Lcom/atguigu/java/PCRegisterTest;<br>  #<span class="hljs-number">14</span> = Utf8               main<br>  #<span class="hljs-number">15</span> = Utf8               ([Ljava/lang/String;)V<br>  #<span class="hljs-number">16</span> = Utf8               args<br>  #<span class="hljs-number">17</span> = Utf8               [Ljava/lang/String;<br>  #<span class="hljs-number">18</span> = Utf8               i<br>  #<span class="hljs-number">19</span> = Utf8               I<br>  #<span class="hljs-number">20</span> = Utf8               j<br>  #<span class="hljs-number">21</span> = Utf8               k<br>  #<span class="hljs-number">22</span> = Utf8               s<br>  #<span class="hljs-number">23</span> = Utf8               Ljava/lang/String;<br>  #<span class="hljs-number">24</span> = Utf8               SourceFile<br>  #<span class="hljs-number">25</span> = Utf8               PCRegisterTest.java<br>  #<span class="hljs-number">26</span> = NameAndType        #<span class="hljs-number">7</span>:#<span class="hljs-number">8</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  #<span class="hljs-number">27</span> = Utf8               abc<br>  #<span class="hljs-number">28</span> = Class              #<span class="hljs-number">34</span>            <span class="hljs-comment">// java/lang/System</span><br>  #<span class="hljs-number">29</span> = NameAndType        #<span class="hljs-number">35</span>:#<span class="hljs-number">36</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>  #<span class="hljs-number">30</span> = Class              #<span class="hljs-number">37</span>            <span class="hljs-comment">// java/io/PrintStream</span><br>  #<span class="hljs-number">31</span> = NameAndType        #<span class="hljs-number">38</span>:#<span class="hljs-number">39</span>        <span class="hljs-comment">// println:(I)V</span><br>  #<span class="hljs-number">32</span> = Utf8               com/atguigu/java/PCRegisterTest<br>  #<span class="hljs-number">33</span> = Utf8               java/lang/Object<br>  #<span class="hljs-number">34</span> = Utf8               java/lang/System<br>  #<span class="hljs-number">35</span> = Utf8               out<br>  #<span class="hljs-number">36</span> = Utf8               Ljava/io/PrintStream;<br>  #<span class="hljs-number">37</span> = Utf8               java/io/PrintStream<br>  #<span class="hljs-number">38</span> = Utf8               println<br>  #<span class="hljs-number">39</span> = Utf8               (I)V<br>&#123;<br>  <span class="hljs-keyword">public</span> com.atguigu.java.PCRegisterTest();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java/PCRegisterTest;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>         <span class="hljs-number">2</span>: istore_1<br>         <span class="hljs-number">3</span>: bipush        <span class="hljs-number">20</span><br>         <span class="hljs-number">5</span>: istore_2<br>         <span class="hljs-number">6</span>: iload_1<br>         <span class="hljs-number">7</span>: iload_2<br>         <span class="hljs-number">8</span>: iadd<br>         <span class="hljs-number">9</span>: istore_3<br>        <span class="hljs-number">10</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String abc</span><br>        <span class="hljs-number">12</span>: astore        <span class="hljs-number">4</span><br>        <span class="hljs-number">14</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>        <span class="hljs-number">17</span>: iload_1<br>        <span class="hljs-number">18</span>: invokevirtual #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(I)V</span><br>        <span class="hljs-number">21</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>        <span class="hljs-number">24</span>: iload_3<br>        <span class="hljs-number">25</span>: invokevirtual #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(I)V</span><br>        <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">10</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">11</span>: <span class="hljs-number">3</span><br>        line <span class="hljs-number">12</span>: <span class="hljs-number">6</span><br>        line <span class="hljs-number">14</span>: <span class="hljs-number">10</span><br>        line <span class="hljs-number">15</span>: <span class="hljs-number">14</span><br>        line <span class="hljs-number">16</span>: <span class="hljs-number">21</span><br>        line <span class="hljs-number">18</span>: <span class="hljs-number">28</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">29</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>            <span class="hljs-number">3</span>      <span class="hljs-number">26</span>     <span class="hljs-number">1</span>     i   I<br>            <span class="hljs-number">6</span>      <span class="hljs-number">23</span>     <span class="hljs-number">2</span>     j   I<br>           <span class="hljs-number">10</span>      <span class="hljs-number">19</span>     <span class="hljs-number">3</span>     k   I<br>           <span class="hljs-number">14</span>      <span class="hljs-number">15</span>     <span class="hljs-number">4</span>     s   Ljava/lang/String;<br>&#125;<br>SourceFile: <span class="hljs-string">&quot;PCRegisterTest.java&quot;</span><br></code></pre></td></tr></table></figure><p>左边的数字代表<strong>指令地址（指令偏移）</strong>，即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令</p><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027194950557.png" alt></p><h2 id="4、🔺两个注意点">4、🔺两个注意点</h2><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？<strong>或者问</strong>为什么使用 PC 寄存器来记录当前线程的执行地址呢？</strong></p><ol><li>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</li><li>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</li></ol><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027195119590.png" alt></p><p><strong>PC寄存器为什么被设定为私有的？</strong></p><ol><li>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li><li>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li><li>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</li></ol><blockquote><p>注意并行和并发，不是一个概念</p><p>并行：  串行</p><p>并发：  一个核，快速执行，看起来像并发</p></blockquote><h2 id="5、CPU时间片">5、CPU时间片</h2><ol><li>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</li><li>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</li><li>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，<strong>每个程序轮流执行</strong>。</li></ol><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221027195216420.png" alt></p><h1>3、本地方法接口</h1><h2 id="1、本地方法">1、本地方法</h2><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221031165301758.png" alt></p><ol><li>简单地讲，<strong>一个Native Method是一个Java调用非Java代码的接囗</strong>一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern 告知C++编译器去调用一个C的函数。</li><li>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</li><li>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</li><li>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</li></ol><h2 id="2、举例">2、举例</h2><p>标识符native可以与其它java标识符连用，但是abstract除外</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IHaveNatives</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Native1</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">Native2</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">float</span> <span class="hljs-title function_">Native3</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Native4</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ary)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、为什么有-Native-Method的存在？">3、为什么有 Native Method的存在？</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><h3 id="1、与java环境外交互">1、与java环境外交互</h3><p><strong>有时Java应用需要与Java外面的硬件环境交互，这是本地方法存在的主要原因</strong>。可以想想Java需要与一些<strong>底层系统</strong>，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><h3 id="2、与操作系统的交互">2、与操作系统的交互</h3><ol><li>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。</li><li>然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。</li><li><strong>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的</strong>。</li><li>还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li></ol><h3 id="3、Sun’s-Java">3、Sun’s Java</h3><ol><li>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。</li><li>例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li></ol><h3 id="4、本地方法的现状">4、本地方法的现状</h3><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等。</p><h1>4、本地方法栈</h1><ol><li><strong>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</li><li>本地方法栈，也是线程私有的。</li><li>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul></li><li>本地方法一般是使用C语言或C++语言实现的。</li><li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</li></ol><p><img src="/2022/10/27/jvm-03-yun-xing-shi-shu-ju-qu/image-20221031170046976.png" alt></p><p>说明：</p><ol><li>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。<ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存</li></ul></li><li>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</li><li>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>emoji</title>
      <link href="/2022/10/25/emoji/"/>
      <url>/2022/10/25/emoji/</url>
      
        <content type="html"><![CDATA[<p>People</p><table><thead><tr><th>:bowtie: <code>:bowtie:</code></th><th>😄 <code>:smile:</code></th><th>😆 <code>:laughing:</code></th></tr></thead><tbody><tr><td>😊 <code>:blush:</code></td><td>😃 <code>:smiley:</code></td><td>☺️ <code>:relaxed:</code></td></tr><tr><td>😏 <code>:smirk:</code></td><td>😍 <code>:heart_eyes:</code></td><td>😘 <code>:kissing_heart:</code></td></tr><tr><td>😚 <code>:kissing_closed_eyes:</code></td><td>😳 <code>:flushed:</code></td><td>😌 <code>:relieved:</code></td></tr><tr><td>😆 <code>:satisfied:</code></td><td>😁 <code>:grin:</code></td><td>😉 <code>:wink:</code></td></tr><tr><td>😜 <code>:stuck_out_tongue_winking_eye:</code></td><td>😝 <code>:stuck_out_tongue_closed_eyes:</code></td><td>😀 <code>:grinning:</code></td></tr><tr><td>😗 <code>:kissing:</code></td><td>😙 <code>:kissing_smiling_eyes:</code></td><td>😛 <code>:stuck_out_tongue:</code></td></tr><tr><td>😴 <code>:sleeping:</code></td><td>😟 <code>:worried:</code></td><td>😦 <code>:frowning:</code></td></tr><tr><td>😧 <code>:anguished:</code></td><td>😮 <code>:open_mouth:</code></td><td>😬 <code>:grimacing:</code></td></tr><tr><td>😕 <code>:confused:</code></td><td>😯 <code>:hushed:</code></td><td>😑 <code>:expressionless:</code></td></tr><tr><td>😒 <code>:unamused:</code></td><td>😅 <code>:sweat_smile:</code></td><td>😓 <code>:sweat:</code></td></tr><tr><td>😥 <code>:disappointed_relieved:</code></td><td>😩 <code>:weary:</code></td><td>😔 <code>:pensive:</code></td></tr><tr><td>😞 <code>:disappointed:</code></td><td>😖 <code>:confounded:</code></td><td>😨 <code>:fearful:</code></td></tr><tr><td>😰 <code>:cold_sweat:</code></td><td>😣 <code>:persevere:</code></td><td>😢 <code>:cry:</code></td></tr><tr><td>😭 <code>:sob:</code></td><td>😂 <code>:joy:</code></td><td>😲 <code>:astonished:</code></td></tr><tr><td>😱 <code>:scream:</code></td><td>:neckbeard: <code>:neckbeard:</code></td><td>😫 <code>:tired_face:</code></td></tr><tr><td>😠 <code>:angry:</code></td><td>😡 <code>:rage:</code></td><td>😤 <code>:triumph:</code></td></tr><tr><td>😪 <code>:sleepy:</code></td><td>😋 <code>:yum:</code></td><td>😷 <code>:mask:</code></td></tr><tr><td>😎 <code>:sunglasses:</code></td><td>😵 <code>:dizzy_face:</code></td><td>👿 <code>:imp:</code></td></tr><tr><td>😈 <code>:smiling_imp:</code></td><td>😐 <code>:neutral_face:</code></td><td>😶 <code>:no_mouth:</code></td></tr><tr><td>😇 <code>:innocent:</code></td><td>👽 <code>:alien:</code></td><td>💛 <code>:yellow_heart:</code></td></tr><tr><td>💙 <code>:blue_heart:</code></td><td>💜 <code>:purple_heart:</code></td><td>❤️ <code>:heart:</code></td></tr><tr><td>💚 <code>:green_heart:</code></td><td>💔 <code>:broken_heart:</code></td><td>💓 <code>:heartbeat:</code></td></tr><tr><td>💗 <code>:heartpulse:</code></td><td>💕 <code>:two_hearts:</code></td><td>💞 <code>:revolving_hearts:</code></td></tr><tr><td>💘 <code>:cupid:</code></td><td>💖 <code>:sparkling_heart:</code></td><td>✨ <code>:sparkles:</code></td></tr><tr><td>⭐ <code>:star:</code></td><td>🌟 <code>:star2:</code></td><td>💫 <code>:dizzy:</code></td></tr><tr><td>💥 <code>:boom:</code></td><td>💥 <code>:collision:</code></td><td>💢 <code>:anger:</code></td></tr><tr><td>❗ <code>:exclamation:</code></td><td>❓ <code>:question:</code></td><td>❕ <code>:grey_exclamation:</code></td></tr><tr><td>❔ <code>:grey_question:</code></td><td>💤 <code>:zzz:</code></td><td>💨 <code>:dash:</code></td></tr><tr><td>💦 <code>:sweat_drops:</code></td><td>🎶 <code>:notes:</code></td><td>🎵 <code>:musical_note:</code></td></tr><tr><td>🔥 <code>:fire:</code></td><td>💩 <code>:hankey:</code></td><td>💩 <code>:poop:</code></td></tr><tr><td>💩 <code>:shit:</code></td><td>👍 <code>:+1:</code></td><td>👍 <code>:thumbsup:</code></td></tr><tr><td>👎 <code>:-1:</code></td><td>👎 <code>:thumbsdown:</code></td><td>👌 <code>:ok_hand:</code></td></tr><tr><td>👊 <code>:punch:</code></td><td>👊 <code>:facepunch:</code></td><td>✊ <code>:fist:</code></td></tr><tr><td>✌️ <code>:v:</code></td><td>👋 <code>:wave:</code></td><td>✋ <code>:hand:</code></td></tr><tr><td>✋ <code>:raised_hand:</code></td><td>👐 <code>:open_hands:</code></td><td>☝️ <code>:point_up:</code></td></tr><tr><td>👇 <code>:point_down:</code></td><td>👈 <code>:point_left:</code></td><td>👉 <code>:point_right:</code></td></tr><tr><td>🙌 <code>:raised_hands:</code></td><td>🙏 <code>:pray:</code></td><td>👆 <code>:point_up_2:</code></td></tr><tr><td>👏 <code>:clap:</code></td><td>💪 <code>:muscle:</code></td><td>🤘 <code>:metal:</code></td></tr><tr><td>🖕 <code>:fu:</code></td><td>🚶 <code>:walking:</code></td><td>🏃 <code>:runner:</code></td></tr><tr><td>🏃 <code>:running:</code></td><td>👫 <code>:couple:</code></td><td>👪 <code>:family:</code></td></tr><tr><td>👬 <code>:two_men_holding_hands:</code></td><td>👭 <code>:two_women_holding_hands:</code></td><td>💃 <code>:dancer:</code></td></tr><tr><td>👯 <code>:dancers:</code></td><td>🙆‍♀️ <code>:ok_woman:</code></td><td>🙅 <code>:no_good:</code></td></tr><tr><td>💁 <code>:information_desk_person:</code></td><td>🙋 <code>:raising_hand:</code></td><td>👰‍♀️ <code>:bride_with_veil:</code></td></tr><tr><td>:person_with_pouting_face: <code>:person_with_pouting_face:</code></td><td>:person_frowning: <code>:person_frowning:</code></td><td>🙇 <code>:bow:</code></td></tr><tr><td>💏 <code>:couplekiss:</code></td><td>💑 <code>:couple_with_heart:</code></td><td>💆 <code>:massage:</code></td></tr><tr><td>💇 <code>:haircut:</code></td><td>💅 <code>:nail_care:</code></td><td>👦 <code>:boy:</code></td></tr><tr><td>👧 <code>:girl:</code></td><td>👩 <code>:woman:</code></td><td>👨 <code>:man:</code></td></tr><tr><td>👶 <code>:baby:</code></td><td>👵 <code>:older_woman:</code></td><td>👴 <code>:older_man:</code></td></tr><tr><td>:person_with_blond_hair: <code>:person_with_blond_hair:</code></td><td>👲 <code>:man_with_gua_pi_mao:</code></td><td>👳‍♂️ <code>:man_with_turban:</code></td></tr><tr><td>👷 <code>:construction_worker:</code></td><td>👮 <code>:cop:</code></td><td>👼 <code>:angel:</code></td></tr><tr><td>👸 <code>:princess:</code></td><td>😺 <code>:smiley_cat:</code></td><td>😸 <code>:smile_cat:</code></td></tr><tr><td>😻 <code>:heart_eyes_cat:</code></td><td>😽 <code>:kissing_cat:</code></td><td>😼 <code>:smirk_cat:</code></td></tr><tr><td>🙀 <code>:scream_cat:</code></td><td>😿 <code>:crying_cat_face:</code></td><td>😹 <code>:joy_cat:</code></td></tr><tr><td>😾 <code>:pouting_cat:</code></td><td>👹 <code>:japanese_ogre:</code></td><td>👺 <code>:japanese_goblin:</code></td></tr><tr><td>🙈 <code>:see_no_evil:</code></td><td>🙉 <code>:hear_no_evil:</code></td><td>🙊 <code>:speak_no_evil:</code></td></tr><tr><td>💂‍♂️ <code>:guardsman:</code></td><td>💀 <code>:skull:</code></td><td>🐾 <code>:feet:</code></td></tr><tr><td>👄 <code>:lips:</code></td><td>💋 <code>:kiss:</code></td><td>💧 <code>:droplet:</code></td></tr><tr><td>👂 <code>:ear:</code></td><td>👀 <code>:eyes:</code></td><td>👃 <code>:nose:</code></td></tr><tr><td>👅 <code>:tongue:</code></td><td>💌 <code>:love_letter:</code></td><td>👤 <code>:bust_in_silhouette:</code></td></tr><tr><td>👥 <code>:busts_in_silhouette:</code></td><td>💬 <code>:speech_balloon:</code></td><td>💭 <code>:thought_balloon:</code></td></tr><tr><td>:feelsgood: <code>:feelsgood:</code></td><td>:finnadie: <code>:finnadie:</code></td><td>:goberserk: <code>:goberserk:</code></td></tr><tr><td>:godmode: <code>:godmode:</code></td><td>:hurtrealbad: <code>:hurtrealbad:</code></td><td>:rage1: <code>:rage1:</code></td></tr><tr><td>:rage2: <code>:rage2:</code></td><td>:rage3: <code>:rage3:</code></td><td>:rage4: <code>:rage4:</code></td></tr><tr><td>:suspect: <code>:suspect:</code></td><td>:trollface: <code>:trollface:</code></td><td></td></tr></tbody></table><p>Nature</p><table><thead><tr><th>☀️ <code>:sunny:</code></th><th>☔ <code>:umbrella:</code></th><th>☁️ <code>:cloud:</code></th></tr></thead><tbody><tr><td>❄️ <code>:snowflake:</code></td><td>⛄ <code>:snowman:</code></td><td>⚡ <code>:zap:</code></td></tr><tr><td>🌀 <code>:cyclone:</code></td><td>🌁 <code>:foggy:</code></td><td>🌊 <code>:ocean:</code></td></tr><tr><td>🐱 <code>:cat:</code></td><td>🐶 <code>:dog:</code></td><td>🐭 <code>:mouse:</code></td></tr><tr><td>🐹 <code>:hamster:</code></td><td>🐰 <code>:rabbit:</code></td><td>🐺 <code>:wolf:</code></td></tr><tr><td>🐸 <code>:frog:</code></td><td>🐯 <code>:tiger:</code></td><td>🐨 <code>:koala:</code></td></tr><tr><td>🐻 <code>:bear:</code></td><td>🐷 <code>:pig:</code></td><td>🐽 <code>:pig_nose:</code></td></tr><tr><td>🐮 <code>:cow:</code></td><td>🐗 <code>:boar:</code></td><td>🐵 <code>:monkey_face:</code></td></tr><tr><td>🐒 <code>:monkey:</code></td><td>🐴 <code>:horse:</code></td><td>🐎 <code>:racehorse:</code></td></tr><tr><td>🐫 <code>:camel:</code></td><td>🐑 <code>:sheep:</code></td><td>🐘 <code>:elephant:</code></td></tr><tr><td>🐼 <code>:panda_face:</code></td><td>🐍 <code>:snake:</code></td><td>🐦 <code>:bird:</code></td></tr><tr><td>🐤 <code>:baby_chick:</code></td><td>🐥 <code>:hatched_chick:</code></td><td>🐣 <code>:hatching_chick:</code></td></tr><tr><td>🐔 <code>:chicken:</code></td><td>🐧 <code>:penguin:</code></td><td>🐢 <code>:turtle:</code></td></tr><tr><td>🐛 <code>:bug:</code></td><td>🐝 <code>:honeybee:</code></td><td>🐜 <code>:ant:</code></td></tr><tr><td>🪲 <code>:beetle:</code></td><td>🐌 <code>:snail:</code></td><td>🐙 <code>:octopus:</code></td></tr><tr><td>🐠 <code>:tropical_fish:</code></td><td>🐟 <code>:fish:</code></td><td>🐳 <code>:whale:</code></td></tr><tr><td>🐋 <code>:whale2:</code></td><td>🐬 <code>:dolphin:</code></td><td>🐄 <code>:cow2:</code></td></tr><tr><td>🐏 <code>:ram:</code></td><td>🐀 <code>:rat:</code></td><td>🐃 <code>:water_buffalo:</code></td></tr><tr><td>🐅 <code>:tiger2:</code></td><td>🐇 <code>:rabbit2:</code></td><td>🐉 <code>:dragon:</code></td></tr><tr><td>🐐 <code>:goat:</code></td><td>🐓 <code>:rooster:</code></td><td>🐕 <code>:dog2:</code></td></tr><tr><td>🐖 <code>:pig2:</code></td><td>🐁 <code>:mouse2:</code></td><td>🐂 <code>:ox:</code></td></tr><tr><td>🐲 <code>:dragon_face:</code></td><td>🐡 <code>:blowfish:</code></td><td>🐊 <code>:crocodile:</code></td></tr><tr><td>🐪 <code>:dromedary_camel:</code></td><td>🐆 <code>:leopard:</code></td><td>🐈 <code>:cat2:</code></td></tr><tr><td>🐩 <code>:poodle:</code></td><td>🐾 <code>:paw_prints:</code></td><td>💐 <code>:bouquet:</code></td></tr><tr><td>🌸 <code>:cherry_blossom:</code></td><td>🌷 <code>:tulip:</code></td><td>🍀 <code>:four_leaf_clover:</code></td></tr><tr><td>🌹 <code>:rose:</code></td><td>🌻 <code>:sunflower:</code></td><td>🌺 <code>:hibiscus:</code></td></tr><tr><td>🍁 <code>:maple_leaf:</code></td><td>🍃 <code>:leaves:</code></td><td>🍂 <code>:fallen_leaf:</code></td></tr><tr><td>🌿 <code>:herb:</code></td><td>🍄 <code>:mushroom:</code></td><td>🌵 <code>:cactus:</code></td></tr><tr><td>🌴 <code>:palm_tree:</code></td><td>🌲 <code>:evergreen_tree:</code></td><td>🌳 <code>:deciduous_tree:</code></td></tr><tr><td>🌰 <code>:chestnut:</code></td><td>🌱 <code>:seedling:</code></td><td>🌼 <code>:blossom:</code></td></tr><tr><td>🌾 <code>:ear_of_rice:</code></td><td>🐚 <code>:shell:</code></td><td>🌐 <code>:globe_with_meridians:</code></td></tr><tr><td>🌞 <code>:sun_with_face:</code></td><td>🌝 <code>:full_moon_with_face:</code></td><td>🌚 <code>:new_moon_with_face:</code></td></tr><tr><td>🌑 <code>:new_moon:</code></td><td>🌒 <code>:waxing_crescent_moon:</code></td><td>🌓 <code>:first_quarter_moon:</code></td></tr><tr><td>🌔 <code>:waxing_gibbous_moon:</code></td><td>🌕 <code>:full_moon:</code></td><td>🌖 <code>:waning_gibbous_moon:</code></td></tr><tr><td>🌗 <code>:last_quarter_moon:</code></td><td>🌘 <code>:waning_crescent_moon:</code></td><td>🌜 <code>:last_quarter_moon_with_face:</code></td></tr><tr><td>🌛 <code>:first_quarter_moon_with_face:</code></td><td>🌔 <code>:moon:</code></td><td>🌍 <code>:earth_africa:</code></td></tr><tr><td>🌎 <code>:earth_americas:</code></td><td>🌏 <code>:earth_asia:</code></td><td>🌋 <code>:volcano:</code></td></tr><tr><td>🌌 <code>:milky_way:</code></td><td>⛅ <code>:partly_sunny:</code></td><td>:octocat: <code>:octocat:</code></td></tr><tr><td>:squirrel: <code>:squirrel:</code></td><td></td><td></td></tr></tbody></table><p>Objects</p><table><thead><tr><th>🎍 <code>:bamboo:</code></th><th>💝 <code>:gift_heart:</code></th><th>🎎 <code>:dolls:</code></th></tr></thead><tbody><tr><td>🎒 <code>:school_satchel:</code></td><td>🎓 <code>:mortar_board:</code></td><td>🎏 <code>:flags:</code></td></tr><tr><td>🎆 <code>:fireworks:</code></td><td>🎇 <code>:sparkler:</code></td><td>🎐 <code>:wind_chime:</code></td></tr><tr><td>🎑 <code>:rice_scene:</code></td><td>🎃 <code>:jack_o_lantern:</code></td><td>👻 <code>:ghost:</code></td></tr><tr><td>🎅 <code>:santa:</code></td><td>🎄 <code>:christmas_tree:</code></td><td>🎁 <code>:gift:</code></td></tr><tr><td>🔔 <code>:bell:</code></td><td>🔕 <code>:no_bell:</code></td><td>🎋 <code>:tanabata_tree:</code></td></tr><tr><td>🎉 <code>:tada:</code></td><td>🎊 <code>:confetti_ball:</code></td><td>🎈 <code>:balloon:</code></td></tr><tr><td>🔮 <code>:crystal_ball:</code></td><td>💿 <code>:cd:</code></td><td>📀 <code>:dvd:</code></td></tr><tr><td>💾 <code>:floppy_disk:</code></td><td>📷 <code>:camera:</code></td><td>📹 <code>:video_camera:</code></td></tr><tr><td>🎥 <code>:movie_camera:</code></td><td>💻 <code>:computer:</code></td><td>📺 <code>:tv:</code></td></tr><tr><td>📱 <code>:iphone:</code></td><td>☎️ <code>:phone:</code></td><td>☎️ <code>:telephone:</code></td></tr><tr><td>📞 <code>:telephone_receiver:</code></td><td>📟 <code>:pager:</code></td><td>📠 <code>:fax:</code></td></tr><tr><td>💽 <code>:minidisc:</code></td><td>📼 <code>:vhs:</code></td><td>🔉 <code>:sound:</code></td></tr><tr><td>🔈 <code>:speaker:</code></td><td>🔇 <code>:mute:</code></td><td>📢 <code>:loudspeaker:</code></td></tr><tr><td>📣 <code>:mega:</code></td><td>⌛ <code>:hourglass:</code></td><td>⏳ <code>:hourglass_flowing_sand:</code></td></tr><tr><td>⏰ <code>:alarm_clock:</code></td><td>⌚ <code>:watch:</code></td><td>📻 <code>:radio:</code></td></tr><tr><td>📡 <code>:satellite:</code></td><td>➿ <code>:loop:</code></td><td>🔍 <code>:mag:</code></td></tr><tr><td>🔎 <code>:mag_right:</code></td><td>🔓 <code>:unlock:</code></td><td>🔒 <code>:lock:</code></td></tr><tr><td>🔏 <code>:lock_with_ink_pen:</code></td><td>🔐 <code>:closed_lock_with_key:</code></td><td>🔑 <code>:key:</code></td></tr><tr><td>💡 <code>:bulb:</code></td><td>🔦 <code>:flashlight:</code></td><td>🔆 <code>:high_brightness:</code></td></tr><tr><td>🔅 <code>:low_brightness:</code></td><td>🔌 <code>:electric_plug:</code></td><td>🔋 <code>:battery:</code></td></tr><tr><td>📲 <code>:calling:</code></td><td>📧 <code>:email:</code></td><td>📫 <code>:mailbox:</code></td></tr><tr><td>📮 <code>:postbox:</code></td><td>🛀 <code>:bath:</code></td><td>🛁 <code>:bathtub:</code></td></tr><tr><td>🚿 <code>:shower:</code></td><td>🚽 <code>:toilet:</code></td><td>🔧 <code>:wrench:</code></td></tr><tr><td>🔩 <code>:nut_and_bolt:</code></td><td>🔨 <code>:hammer:</code></td><td>💺 <code>:seat:</code></td></tr><tr><td>💰 <code>:moneybag:</code></td><td>💴 <code>:yen:</code></td><td>💵 <code>:dollar:</code></td></tr><tr><td>💷 <code>:pound:</code></td><td>💶 <code>:euro:</code></td><td>💳 <code>:credit_card:</code></td></tr><tr><td>💸 <code>:money_with_wings:</code></td><td>📧 <code>:e-mail:</code></td><td>📥 <code>:inbox_tray:</code></td></tr><tr><td>📤 <code>:outbox_tray:</code></td><td>✉️ <code>:envelope:</code></td><td>📨 <code>:incoming_envelope:</code></td></tr><tr><td>📯 <code>:postal_horn:</code></td><td>📪 <code>:mailbox_closed:</code></td><td>📬 <code>:mailbox_with_mail:</code></td></tr><tr><td>📭 <code>:mailbox_with_no_mail:</code></td><td>🚪 <code>:door:</code></td><td>🚬 <code>:smoking:</code></td></tr><tr><td>💣 <code>:bomb:</code></td><td>🔫 <code>:gun:</code></td><td>🔪 <code>:hocho:</code></td></tr><tr><td>💊 <code>:pill:</code></td><td>💉 <code>:syringe:</code></td><td>📄 <code>:page_facing_up:</code></td></tr><tr><td>📃 <code>:page_with_curl:</code></td><td>📑 <code>:bookmark_tabs:</code></td><td>📊 <code>:bar_chart:</code></td></tr><tr><td>📈 <code>:chart_with_upwards_trend:</code></td><td>📉 <code>:chart_with_downwards_trend:</code></td><td>📜 <code>:scroll:</code></td></tr><tr><td>📋 <code>:clipboard:</code></td><td>📆 <code>:calendar:</code></td><td>📅 <code>:date:</code></td></tr><tr><td>📇 <code>:card_index:</code></td><td>📁 <code>:file_folder:</code></td><td>📂 <code>:open_file_folder:</code></td></tr><tr><td>✂️ <code>:scissors:</code></td><td>📌 <code>:pushpin:</code></td><td>📎 <code>:paperclip:</code></td></tr><tr><td>✒️ <code>:black_nib:</code></td><td>✏️ <code>:pencil2:</code></td><td>📏 <code>:straight_ruler:</code></td></tr><tr><td>📐 <code>:triangular_ruler:</code></td><td>📕 <code>:closed_book:</code></td><td>📗 <code>:green_book:</code></td></tr><tr><td>📘 <code>:blue_book:</code></td><td>📙 <code>:orange_book:</code></td><td>📓 <code>:notebook:</code></td></tr><tr><td>📔 <code>:notebook_with_decorative_cover:</code></td><td>📒 <code>:ledger:</code></td><td>📚 <code>:books:</code></td></tr><tr><td>🔖 <code>:bookmark:</code></td><td>📛 <code>:name_badge:</code></td><td>🔬 <code>:microscope:</code></td></tr><tr><td>🔭 <code>:telescope:</code></td><td>📰 <code>:newspaper:</code></td><td>🏈 <code>:football:</code></td></tr><tr><td>🏀 <code>:basketball:</code></td><td>⚽ <code>:soccer:</code></td><td>⚾ <code>:baseball:</code></td></tr><tr><td>🎾 <code>:tennis:</code></td><td>🎱 <code>:8ball:</code></td><td>🏉 <code>:rugby_football:</code></td></tr><tr><td>🎳 <code>:bowling:</code></td><td>⛳ <code>:golf:</code></td><td>🚵 <code>:mountain_bicyclist:</code></td></tr><tr><td>🚴 <code>:bicyclist:</code></td><td>🏇 <code>:horse_racing:</code></td><td>🏂 <code>:snowboarder:</code></td></tr><tr><td>🏊 <code>:swimmer:</code></td><td>🏄 <code>:surfer:</code></td><td>🎿 <code>:ski:</code></td></tr><tr><td>♠️ <code>:spades:</code></td><td>♥️ <code>:hearts:</code></td><td>♣️ <code>:clubs:</code></td></tr><tr><td>♦️ <code>:diamonds:</code></td><td>💎 <code>:gem:</code></td><td>💍 <code>:ring:</code></td></tr><tr><td>🏆 <code>:trophy:</code></td><td>🎼 <code>:musical_score:</code></td><td>🎹 <code>:musical_keyboard:</code></td></tr><tr><td>🎻 <code>:violin:</code></td><td>👾 <code>:space_invader:</code></td><td>🎮 <code>:video_game:</code></td></tr><tr><td>🃏 <code>:black_joker:</code></td><td>🎴 <code>:flower_playing_cards:</code></td><td>🎲 <code>:game_die:</code></td></tr><tr><td>🎯 <code>:dart:</code></td><td>🀄 <code>:mahjong:</code></td><td>🎬 <code>:clapper:</code></td></tr><tr><td>📝 <code>:memo:</code></td><td>📝 <code>:pencil:</code></td><td>📖 <code>:book:</code></td></tr><tr><td>🎨 <code>:art:</code></td><td>🎤 <code>:microphone:</code></td><td>🎧 <code>:headphones:</code></td></tr><tr><td>🎺 <code>:trumpet:</code></td><td>🎷 <code>:saxophone:</code></td><td>🎸 <code>:guitar:</code></td></tr><tr><td>👞 <code>:shoe:</code></td><td>👡 <code>:sandal:</code></td><td>👠 <code>:high_heel:</code></td></tr><tr><td>💄 <code>:lipstick:</code></td><td>👢 <code>:boot:</code></td><td>👕 <code>:shirt:</code></td></tr><tr><td>👕 <code>:tshirt:</code></td><td>👔 <code>:necktie:</code></td><td>👚 <code>:womans_clothes:</code></td></tr><tr><td>👗 <code>:dress:</code></td><td>🎽 <code>:running_shirt_with_sash:</code></td><td>👖 <code>:jeans:</code></td></tr><tr><td>👘 <code>:kimono:</code></td><td>👙 <code>:bikini:</code></td><td>🎀 <code>:ribbon:</code></td></tr><tr><td>🎩 <code>:tophat:</code></td><td>👑 <code>:crown:</code></td><td>👒 <code>:womans_hat:</code></td></tr><tr><td>👞 <code>:mans_shoe:</code></td><td>🌂 <code>:closed_umbrella:</code></td><td>💼 <code>:briefcase:</code></td></tr><tr><td>👜 <code>:handbag:</code></td><td>👝 <code>:pouch:</code></td><td>👛 <code>:purse:</code></td></tr><tr><td>👓 <code>:eyeglasses:</code></td><td>🎣 <code>:fishing_pole_and_fish:</code></td><td>☕ <code>:coffee:</code></td></tr><tr><td>🍵 <code>:tea:</code></td><td>🍶 <code>:sake:</code></td><td>🍼 <code>:baby_bottle:</code></td></tr><tr><td>🍺 <code>:beer:</code></td><td>🍻 <code>:beers:</code></td><td>🍸 <code>:cocktail:</code></td></tr><tr><td>🍹 <code>:tropical_drink:</code></td><td>🍷 <code>:wine_glass:</code></td><td>🍴 <code>:fork_and_knife:</code></td></tr><tr><td>🍕 <code>:pizza:</code></td><td>🍔 <code>:hamburger:</code></td><td>🍟 <code>:fries:</code></td></tr><tr><td>🍗 <code>:poultry_leg:</code></td><td>🍖 <code>:meat_on_bone:</code></td><td>🍝 <code>:spaghetti:</code></td></tr><tr><td>🍛 <code>:curry:</code></td><td>🍤 <code>:fried_shrimp:</code></td><td>🍱 <code>:bento:</code></td></tr><tr><td>🍣 <code>:sushi:</code></td><td>🍥 <code>:fish_cake:</code></td><td>🍙 <code>:rice_ball:</code></td></tr><tr><td>🍘 <code>:rice_cracker:</code></td><td>🍚 <code>:rice:</code></td><td>🍜 <code>:ramen:</code></td></tr><tr><td>🍲 <code>:stew:</code></td><td>🍢 <code>:oden:</code></td><td>🍡 <code>:dango:</code></td></tr><tr><td>🥚 <code>:egg:</code></td><td>🍞 <code>:bread:</code></td><td>🍩 <code>:doughnut:</code></td></tr><tr><td>🍮 <code>:custard:</code></td><td>🍦 <code>:icecream:</code></td><td>🍨 <code>:ice_cream:</code></td></tr><tr><td>🍧 <code>:shaved_ice:</code></td><td>🎂 <code>:birthday:</code></td><td>🍰 <code>:cake:</code></td></tr><tr><td>🍪 <code>:cookie:</code></td><td>🍫 <code>:chocolate_bar:</code></td><td>🍬 <code>:candy:</code></td></tr><tr><td>🍭 <code>:lollipop:</code></td><td>🍯 <code>:honey_pot:</code></td><td>🍎 <code>:apple:</code></td></tr><tr><td>🍏 <code>:green_apple:</code></td><td>🍊 <code>:tangerine:</code></td><td>🍋 <code>:lemon:</code></td></tr><tr><td>🍒 <code>:cherries:</code></td><td>🍇 <code>:grapes:</code></td><td>🍉 <code>:watermelon:</code></td></tr><tr><td>🍓 <code>:strawberry:</code></td><td>🍑 <code>:peach:</code></td><td>🍈 <code>:melon:</code></td></tr><tr><td>🍌 <code>:banana:</code></td><td>🍐 <code>:pear:</code></td><td>🍍 <code>:pineapple:</code></td></tr><tr><td>🍠 <code>:sweet_potato:</code></td><td>🍆 <code>:eggplant:</code></td><td>🍅 <code>:tomato:</code></td></tr><tr><td>🌽 <code>:corn:</code></td><td></td><td></td></tr></tbody></table><p>Places</p><table><thead><tr><th>🏠 <code>:house:</code></th><th>🏡 <code>:house_with_garden:</code></th><th>🏫 <code>:school:</code></th></tr></thead><tbody><tr><td>🏢 <code>:office:</code></td><td>🏣 <code>:post_office:</code></td><td>🏥 <code>:hospital:</code></td></tr><tr><td>🏦 <code>:bank:</code></td><td>🏪 <code>:convenience_store:</code></td><td>🏩 <code>:love_hotel:</code></td></tr><tr><td>🏨 <code>:hotel:</code></td><td>💒 <code>:wedding:</code></td><td>⛪ <code>:church:</code></td></tr><tr><td>🏬 <code>:department_store:</code></td><td>🏤 <code>:european_post_office:</code></td><td>🌇 <code>:city_sunrise:</code></td></tr><tr><td>🌆 <code>:city_sunset:</code></td><td>🏯 <code>:japanese_castle:</code></td><td>🏰 <code>:european_castle:</code></td></tr><tr><td>⛺ <code>:tent:</code></td><td>🏭 <code>:factory:</code></td><td>🗼 <code>:tokyo_tower:</code></td></tr><tr><td>🗾 <code>:japan:</code></td><td>🗻 <code>:mount_fuji:</code></td><td>🌄 <code>:sunrise_over_mountains:</code></td></tr><tr><td>🌅 <code>:sunrise:</code></td><td>🌠 <code>:stars:</code></td><td>🗽 <code>:statue_of_liberty:</code></td></tr><tr><td>🌉 <code>:bridge_at_night:</code></td><td>🎠 <code>:carousel_horse:</code></td><td>🌈 <code>:rainbow:</code></td></tr><tr><td>🎡 <code>:ferris_wheel:</code></td><td>⛲ <code>:fountain:</code></td><td>🎢 <code>:roller_coaster:</code></td></tr><tr><td>🚢 <code>:ship:</code></td><td>🚤 <code>:speedboat:</code></td><td>⛵ <code>:boat:</code></td></tr><tr><td>⛵ <code>:sailboat:</code></td><td>🚣 <code>:rowboat:</code></td><td>⚓ <code>:anchor:</code></td></tr><tr><td>🚀 <code>:rocket:</code></td><td>✈️ <code>:airplane:</code></td><td>🚁 <code>:helicopter:</code></td></tr><tr><td>🚂 <code>:steam_locomotive:</code></td><td>🚊 <code>:tram:</code></td><td>🚞 <code>:mountain_railway:</code></td></tr><tr><td>🚲 <code>:bike:</code></td><td>🚡 <code>:aerial_tramway:</code></td><td>🚟 <code>:suspension_railway:</code></td></tr><tr><td>🚠 <code>:mountain_cableway:</code></td><td>🚜 <code>:tractor:</code></td><td>🚙 <code>:blue_car:</code></td></tr><tr><td>🚘 <code>:oncoming_automobile:</code></td><td>🚗 <code>:car:</code></td><td>🚗 <code>:red_car:</code></td></tr><tr><td>🚕 <code>:taxi:</code></td><td>🚖 <code>:oncoming_taxi:</code></td><td>🚛 <code>:articulated_lorry:</code></td></tr><tr><td>🚌 <code>:bus:</code></td><td>🚍 <code>:oncoming_bus:</code></td><td>🚨 <code>:rotating_light:</code></td></tr><tr><td>🚓 <code>:police_car:</code></td><td>🚔 <code>:oncoming_police_car:</code></td><td>🚒 <code>:fire_engine:</code></td></tr><tr><td>🚑 <code>:ambulance:</code></td><td>🚐 <code>:minibus:</code></td><td>🚚 <code>:truck:</code></td></tr><tr><td>🚋 <code>:train:</code></td><td>🚉 <code>:station:</code></td><td>🚆 <code>:train2:</code></td></tr><tr><td>🚅 <code>:bullettrain_front:</code></td><td>🚄 <code>:bullettrain_side:</code></td><td>🚈 <code>:light_rail:</code></td></tr><tr><td>🚝 <code>:monorail:</code></td><td>🚃 <code>:railway_car:</code></td><td>🚎 <code>:trolleybus:</code></td></tr><tr><td>🎫 <code>:ticket:</code></td><td>⛽ <code>:fuelpump:</code></td><td>🚦 <code>:vertical_traffic_light:</code></td></tr><tr><td>🚥 <code>:traffic_light:</code></td><td>⚠️ <code>:warning:</code></td><td>🚧 <code>:construction:</code></td></tr><tr><td>🔰 <code>:beginner:</code></td><td>🏧 <code>:atm:</code></td><td>🎰 <code>:slot_machine:</code></td></tr><tr><td>🚏 <code>:busstop:</code></td><td>💈 <code>:barber:</code></td><td>♨️ <code>:hotsprings:</code></td></tr><tr><td>🏁 <code>:checkered_flag:</code></td><td>🎌 <code>:crossed_flags:</code></td><td>🏮 <code>:izakaya_lantern:</code></td></tr><tr><td>🗿 <code>:moyai:</code></td><td>🎪 <code>:circus_tent:</code></td><td>🎭 <code>:performing_arts:</code></td></tr><tr><td>📍 <code>:round_pushpin:</code></td><td>🚩 <code>:triangular_flag_on_post:</code></td><td>🇯🇵 <code>:jp:</code></td></tr><tr><td>🇰🇷 <code>:kr:</code></td><td>🇨🇳 <code>:cn:</code></td><td>🇺🇸 <code>:us:</code></td></tr><tr><td>🇫🇷 <code>:fr:</code></td><td>🇪🇸 <code>:es:</code></td><td>🇮🇹 <code>:it:</code></td></tr><tr><td>🇷🇺 <code>:ru:</code></td><td>🇬🇧 <code>:gb:</code></td><td>🇬🇧 <code>:uk:</code></td></tr><tr><td>🇩🇪 <code>:de:</code></td><td></td><td></td></tr></tbody></table><p>Symbols</p><table><thead><tr><th>1️⃣ <code>:one:</code></th><th>2️⃣ <code>:two:</code></th><th>3️⃣ <code>:three:</code></th></tr></thead><tbody><tr><td>4️⃣ <code>:four:</code></td><td>5️⃣ <code>:five:</code></td><td>6️⃣ <code>:six:</code></td></tr><tr><td>7️⃣ <code>:seven:</code></td><td>8️⃣ <code>:eight:</code></td><td>9️⃣ <code>:nine:</code></td></tr><tr><td>🔟 <code>:keycap_ten:</code></td><td>🔢 <code>:1234:</code></td><td>0️⃣ <code>:zero:</code></td></tr><tr><td>#️⃣ <code>:hash:</code></td><td>🔣 <code>:symbols:</code></td><td>◀️ <code>:arrow_backward:</code></td></tr><tr><td>⬇️ <code>:arrow_down:</code></td><td>▶️ <code>:arrow_forward:</code></td><td>⬅️ <code>:arrow_left:</code></td></tr><tr><td>🔠 <code>:capital_abcd:</code></td><td>🔡 <code>:abcd:</code></td><td>🔤 <code>:abc:</code></td></tr><tr><td>↙️ <code>:arrow_lower_left:</code></td><td>↘️ <code>:arrow_lower_right:</code></td><td>➡️ <code>:arrow_right:</code></td></tr><tr><td>⬆️ <code>:arrow_up:</code></td><td>↖️ <code>:arrow_upper_left:</code></td><td>↗️ <code>:arrow_upper_right:</code></td></tr><tr><td>⏬ <code>:arrow_double_down:</code></td><td>⏫ <code>:arrow_double_up:</code></td><td>🔽 <code>:arrow_down_small:</code></td></tr><tr><td>⤵️ <code>:arrow_heading_down:</code></td><td>⤴️ <code>:arrow_heading_up:</code></td><td>↩️ <code>:leftwards_arrow_with_hook:</code></td></tr><tr><td>↪️ <code>:arrow_right_hook:</code></td><td>↔️ <code>:left_right_arrow:</code></td><td>↕️ <code>:arrow_up_down:</code></td></tr><tr><td>🔼 <code>:arrow_up_small:</code></td><td>🔃 <code>:arrows_clockwise:</code></td><td>🔄 <code>:arrows_counterclockwise:</code></td></tr><tr><td>⏪ <code>:rewind:</code></td><td>⏩ <code>:fast_forward:</code></td><td>ℹ️ <code>:information_source:</code></td></tr><tr><td>🆗 <code>:ok:</code></td><td>🔀 <code>:twisted_rightwards_arrows:</code></td><td>🔁 <code>:repeat:</code></td></tr><tr><td>🔂 <code>:repeat_one:</code></td><td>🆕 <code>:new:</code></td><td>🔝 <code>:top:</code></td></tr><tr><td>🆙 <code>:up:</code></td><td>🆒 <code>:cool:</code></td><td>🆓 <code>:free:</code></td></tr><tr><td>🆖 <code>:ng:</code></td><td>🎦 <code>:cinema:</code></td><td>🈁 <code>:koko:</code></td></tr><tr><td>📶 <code>:signal_strength:</code></td><td>:u5272: <code>:u5272:</code></td><td>:u5408: <code>:u5408:</code></td></tr><tr><td>:u55b6: <code>:u55b6:</code></td><td>:u6307: <code>:u6307:</code></td><td>:u6708: <code>:u6708:</code></td></tr><tr><td>:u6709: <code>:u6709:</code></td><td>🈵 <code>:u6e80:</code></td><td>:u7121: <code>:u7121:</code></td></tr><tr><td>:u7533: <code>:u7533:</code></td><td>:u7a7a: <code>:u7a7a:</code></td><td>:u7981: <code>:u7981:</code></td></tr><tr><td>🈂️ <code>:sa:</code></td><td>🚻 <code>:restroom:</code></td><td>🚹 <code>:mens:</code></td></tr><tr><td>🚺 <code>:womens:</code></td><td>🚼 <code>:baby_symbol:</code></td><td>🚭 <code>:no_smoking:</code></td></tr><tr><td>🅿️ <code>:parking:</code></td><td>♿ <code>:wheelchair:</code></td><td>🚇 <code>:metro:</code></td></tr><tr><td>🛄 <code>:baggage_claim:</code></td><td>🉑 <code>:accept:</code></td><td>🚾 <code>:wc:</code></td></tr><tr><td>🚰 <code>:potable_water:</code></td><td>🚮 <code>:put_litter_in_its_place:</code></td><td>㊙️ <code>:secret:</code></td></tr><tr><td>㊗️ <code>:congratulations:</code></td><td>Ⓜ️ <code>:m:</code></td><td>🛂 <code>:passport_control:</code></td></tr><tr><td>🛅 <code>:left_luggage:</code></td><td>🛃 <code>:customs:</code></td><td>🉐 <code>:ideograph_advantage:</code></td></tr><tr><td>🆑 <code>:cl:</code></td><td>🆘 <code>:sos:</code></td><td>🆔 <code>:id:</code></td></tr><tr><td>🚫 <code>:no_entry_sign:</code></td><td>🔞 <code>:underage:</code></td><td>📵 <code>:no_mobile_phones:</code></td></tr><tr><td>🚯 <code>:do_not_litter:</code></td><td>🚱 <code>:non-potable_water:</code></td><td>🚳 <code>:no_bicycles:</code></td></tr><tr><td>🚷 <code>:no_pedestrians:</code></td><td>🚸 <code>:children_crossing:</code></td><td>⛔ <code>:no_entry:</code></td></tr><tr><td>✳️ <code>:eight_spoked_asterisk:</code></td><td>✴️ <code>:eight_pointed_black_star:</code></td><td>💟 <code>:heart_decoration:</code></td></tr><tr><td>🆚 <code>:vs:</code></td><td>📳 <code>:vibration_mode:</code></td><td>📴 <code>:mobile_phone_off:</code></td></tr><tr><td>💹 <code>:chart:</code></td><td>💱 <code>:currency_exchange:</code></td><td>♈ <code>:aries:</code></td></tr><tr><td>♉ <code>:taurus:</code></td><td>♊ <code>:gemini:</code></td><td>♋ <code>:cancer:</code></td></tr><tr><td>♌ <code>:leo:</code></td><td>♍ <code>:virgo:</code></td><td>♎ <code>:libra:</code></td></tr><tr><td>♏ <code>:scorpius:</code></td><td>♐ <code>:sagittarius:</code></td><td>♑ <code>:capricorn:</code></td></tr><tr><td>♒ <code>:aquarius:</code></td><td>♓ <code>:pisces:</code></td><td>⛎ <code>:ophiuchus:</code></td></tr><tr><td>🔯 <code>:six_pointed_star:</code></td><td>❎ <code>:negative_squared_cross_mark:</code></td><td>🅰️ <code>:a:</code></td></tr><tr><td>🅱️ <code>:b:</code></td><td>🆎 <code>:ab:</code></td><td>🅾️ <code>:o2:</code></td></tr><tr><td>💠 <code>:diamond_shape_with_a_dot_inside:</code></td><td>♻️ <code>:recycle:</code></td><td>🔚 <code>:end:</code></td></tr><tr><td>🔛 <code>:on:</code></td><td>🔜 <code>:soon:</code></td><td>🕐 <code>:clock1:</code></td></tr><tr><td>🕜 <code>:clock130:</code></td><td>🕙 <code>:clock10:</code></td><td>🕥 <code>:clock1030:</code></td></tr><tr><td>🕚 <code>:clock11:</code></td><td>🕦 <code>:clock1130:</code></td><td>🕛 <code>:clock12:</code></td></tr><tr><td>🕧 <code>:clock1230:</code></td><td>🕑 <code>:clock2:</code></td><td>🕝 <code>:clock230:</code></td></tr><tr><td>🕒 <code>:clock3:</code></td><td>🕞 <code>:clock330:</code></td><td>🕓 <code>:clock4:</code></td></tr><tr><td>🕟 <code>:clock430:</code></td><td>🕔 <code>:clock5:</code></td><td>🕠 <code>:clock530:</code></td></tr><tr><td>🕕 <code>:clock6:</code></td><td>🕡 <code>:clock630:</code></td><td>🕖 <code>:clock7:</code></td></tr><tr><td>🕢 <code>:clock730:</code></td><td>🕗 <code>:clock8:</code></td><td>🕣 <code>:clock830:</code></td></tr><tr><td>🕘 <code>:clock9:</code></td><td>🕤 <code>:clock930:</code></td><td>💲 <code>:heavy_dollar_sign:</code></td></tr><tr><td>©️ <code>:copyright:</code></td><td>®️ <code>:registered:</code></td><td>™️ <code>:tm:</code></td></tr><tr><td>❌ <code>:x:</code></td><td>❗ <code>:heavy_exclamation_mark:</code></td><td>‼️ <code>:bangbang:</code></td></tr><tr><td>⁉️ <code>:interrobang:</code></td><td>⭕ <code>:o:</code></td><td>✖️ <code>:heavy_multiplication_x:</code></td></tr><tr><td>➕ <code>:heavy_plus_sign:</code></td><td>➖ <code>:heavy_minus_sign:</code></td><td>➗ <code>:heavy_division_sign:</code></td></tr><tr><td>💮 <code>:white_flower:</code></td><td>💯 <code>:100:</code></td><td>✔️ <code>:heavy_check_mark:</code></td></tr><tr><td>☑️ <code>:ballot_box_with_check:</code></td><td>🔘 <code>:radio_button:</code></td><td>🔗 <code>:link:</code></td></tr><tr><td>➰ <code>:curly_loop:</code></td><td>〰️ <code>:wavy_dash:</code></td><td>〽️ <code>:part_alternation_mark:</code></td></tr><tr><td>🔱 <code>:trident:</code></td><td>:black_square: <code>:black_square:</code></td><td>:white_square: <code>:white_square:</code></td></tr><tr><td>✅ <code>:white_check_mark:</code></td><td>🔲 <code>:black_square_button:</code></td><td>🔳 <code>:white_square_button:</code></td></tr><tr><td>⚫ <code>:black_circle:</code></td><td>⚪ <code>:white_circle:</code></td><td>🔴 <code>:red_circle:</code></td></tr><tr><td>🔵 <code>:large_blue_circle:</code></td><td>🔷 <code>:large_blue_diamond:</code></td><td>🔶 <code>:large_orange_diamond:</code></td></tr><tr><td>🔹 <code>:small_blue_diamond:</code></td><td>🔸 <code>:small_orange_diamond:</code></td><td>🔺 <code>:small_red_triangle:</code></td></tr><tr><td>🔻 <code>:small_red_triangle_down:</code></td><td>:shipit: <code>:shipit:</code></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emoji </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-02-类加载子系统</title>
      <link href="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/"/>
      <url>/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="1、类加载子系统">1、类加载子系统</h2><h3 id="1、内存结构概述">1、内存结构概述</h3><h4 id="1、简图">1、简图</h4><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024163558872.png" alt></p><h4 id="2、详细图">2、详细图</h4><p>英文版</p><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024164417433.png" alt></p><p>中文版</p><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024164544639.png" alt></p><h3 id="2、类加载器子系统">2、类加载器子系统</h3><h4 id="1、类加载器子系统的作用">1、类加载器子系统的作用</h4><ol><li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</li><li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine（执行引擎）决定。<br>（比如：别人给你介绍对象，能不能成另说。其中ClassLoader只负责别人介绍对象，能不能成全看你）</li><li><strong>加载的类信息存放于一块称为方法区的内存空间</strong>。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li></ol><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024164911148.png" alt></p><h4 id="2、类加载器ClassLoader角色">2、类加载器ClassLoader角色</h4><ol><li>class file（在下图中就是Car.class文件）存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li><li>class file加载到JVM中，被称为DNA元数据模板（在下图中就是内存中的Car Class），放在方法区。</li><li>在.class文件–&gt;JVM–&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li></ol><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024165223695.png" alt></p><h3 id="3、类加载过程">3、类加载过程</h3><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024165836131.png" alt="类加载过程"></p><h4 id="1、Demo">1、Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloLoader</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;谢谢ClassLoader加载我....&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;你的大恩大德，我下辈子再报！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>加载过程如下：</p><ol><li>执行 main() 方法（静态方法）就需要先加载main方法所在类 HelloLoader</li><li>加载成功，则进行链接、初始化等操作。完成后调用 HelloLoader 类中的静态方法 main</li><li>加载失败则抛出异常</li></ol><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024170014984.png" alt="类加载过程示意图"></p><h4 id="2、加载（Loading）">2、加载（Loading）</h4><p>加载：</p><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li><code>在内存中生成一个代表这个类的java.lang.Class对象</code>，作为方法区这个类的各种数据的访问入口</li></ol><p><code>生成大的class实例是在加载阶段实现的</code></p><p>加载 .class 文件的方式：</p><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用</li><li>从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul><h4 id="3、链接（Linking）">3、链接（Linking）</h4><p>链接又包括三个过程：验证 -&gt; 准备 -&gt; 解析</p><h5 id="1、验证-Verify">1、验证(Verify)</h5><ol><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ol><p>使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE （java），如果出现不合法的字节码文件，那么将会验证不通过。</p><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024171040995.png" alt=".class文件"></p><h5 id="2、准备-Prepare">2、准备(Prepare)</h5><ol><li>为类变量（static变量）分配内存并且设置该类变量的默认初始值，即零值</li><li><code>这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化</code></li><li>注意：<code>这里不会为实例变量分配初始化</code>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</li></ol><blockquote><p>举例</p></blockquote><p>代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloApp</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//prepare：a = 0 ---&gt; initial : a = 1</span><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、解析-Resolve">3、解析(Resolve)</h5><ol><li>将常量池内的<code>符号引用</code>转换为直接引用的过程</li><li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</li></ol><blockquote><p>符号引用：反编译 class 文件后可以查看符号引用，下面带# 的就是符号引用</p></blockquote><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024182616267.png" alt="查看符号引用"></p><h4 id="4、初始化（Initialization）">4、初始化（Initialization）</h4><p>类的初始化时机：</p><ol><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（比如：Class.forName(“com.atguigu.Test”)）</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ol><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即<code>不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）</code></p><h4 id="5、clinit">5、clinit()</h4><ol><li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</li><li>此方法不需定义，是javac编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和静态代码块中的语句合并而来。也就是说，<code>当我们代码中包含static变量的时候，就会有clinit方法</code></li><li><code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</li><li><code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）</li><li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li><li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</li></ol><blockquote><p>IDEA 中安装 JClassLib Bytecode viewer 插件，可以很方便的看字节码。<a href="https://blog.csdn.net/qq_42326620/article/details/122768642">IDEA安装JClass插件</a></p></blockquote><h5 id="1、有static变量">1、有static变量</h5><p>查看下面这个代码的字节码，可以发现有一个<code>&lt;clinit&gt;()</code>方法。</p><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024185101090.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassInitTest</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>   <span class="hljs-keyword">static</span>&#123;<br>       num = <span class="hljs-number">2</span>;<br>       number = <span class="hljs-number">20</span>;<br>       System.out.println(num);<br>       <span class="hljs-comment">//System.out.println(number);//报错：非法的前向引用。</span><br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 1、linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span><br><span class="hljs-comment">    * 2、这里因为静态代码块出现在声明变量语句前面，所以之前被准备阶段为0的number变量会</span><br><span class="hljs-comment">    * 首先被初始化为20，再接着被初始化成10（这也是面试时常考的问题哦）</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(ClassInitTest.num);<span class="hljs-comment">//2</span><br>        System.out.println(ClassInitTest.number);<span class="hljs-comment">//10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&lt;clint字节码&gt;：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> iconst_1<br> <span class="hljs-number">1</span> putstatic #<span class="hljs-number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;<br> <span class="hljs-number">4</span> iconst_2<br> <span class="hljs-number">5</span> putstatic #<span class="hljs-number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;<br> <span class="hljs-number">8</span> bipush <span class="hljs-number">20</span> <span class="hljs-comment">//先赋20</span><br><span class="hljs-number">10</span> putstatic #<span class="hljs-number">5</span> &lt;com/atguigu/java/ClassInitTest.number&gt;<br><span class="hljs-number">13</span> getstatic #<span class="hljs-number">2</span> &lt;java/lang/System.out&gt;<br><span class="hljs-number">16</span> getstatic #<span class="hljs-number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;<br><span class="hljs-number">19</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<br><span class="hljs-number">22</span> bipush <span class="hljs-number">10</span><span class="hljs-comment">//再赋10</span><br><span class="hljs-number">24</span> putstatic #<span class="hljs-number">5</span> &lt;com/atguigu/java/ClassInitTest.number&gt;<br><span class="hljs-number">27</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><blockquote><p>当我们代码中包含static变量的时候，就会有clinit方法</p></blockquote><h5 id="2、无-static-变量">2、无 static 变量</h5><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024185305810.png" alt></p><p>没有clinit是因为没有static变量</p><h5 id="3、构造器">3、构造器</h5><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024185513790.png" alt></p><p>构造器对应的是右边的init()</p><p>在构造器中：</p><ul><li>先将类变量 a 赋值为 10</li><li>再将局部变量赋值为 20</li></ul><h5 id="4、拥有父类的类">4、拥有父类的类</h5><p>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</p><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024185655011.png" alt></p><p>如上代码，加载流程如下：</p><ul><li>首先，执行 main() 方法需要加载 ClinitTest1 类</li><li>获取 Son.B 静态变量，需要加载 Son 类</li><li>Son 类的父类是 Father 类，所以需要先执行 Father 类的加载，再执行 Son 类的加载</li></ul><h5 id="5、同步加锁问题">5、同步加锁问题</h5><p>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadThreadTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;开始&quot;</span>);<br>            <span class="hljs-type">DeadThread</span> <span class="hljs-variable">dead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadThread</span>();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r,<span class="hljs-string">&quot;线程1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r,<span class="hljs-string">&quot;线程2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadThread</span>&#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;初始化当前类&quot;</span>);<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">线程<span class="hljs-number">2</span>开始<br>线程<span class="hljs-number">1</span>开始<br>线程<span class="hljs-number">2</span>初始化当前类<br><br><span class="hljs-regexp">//</span>然后程序卡死了<br></code></pre></td></tr></table></figure><p>程序卡死，分析原因：</p><ul><li>两个线程同时去加载 DeadThread 类，而 DeadThread 类中静态代码块中有一处死循环</li><li>先加载 DeadThread 类的线程抢到了同步锁，然后在类的静态代码块中执行死循环，而另一个线程在等待同步锁的释放</li><li>所以无论哪个线程先执行 DeadThread 类的加载，另外一个类也不会继续执行。（一个类只会被加载一次）</li></ul><h3 id="4、类加载器分类">4、类加载器分类</h3><h4 id="1、概述">1、概述</h4><ol><li>JVM严格来讲支持两种类型的类加载器 。分别为<code>引导类加载器（Bootstrap ClassLoader）</code>和<code>自定义类加载器（User-Defined ClassLoader）</code></li><li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></li><li>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示</li></ol><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024191612814.png" alt></p><p>Optional四者之间的关系是包含关系。不是上层下层，也不是子父类的 继承关系。</p><p><strong>ExtClassLoader</strong></p><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024191738052.png" alt></p><p><strong>AppClassLoader</strong></p><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221024191755771.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//获取系统类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">systemClassLoader</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();<br>        System.out.println(systemClassLoader); <span class="hljs-comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><br>        <span class="hljs-comment">//获取其上层：扩展类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">extClassLoader</span> <span class="hljs-operator">=</span> systemClassLoader.getParent();<br>        System.out.println(extClassLoader);<span class="hljs-comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span><br><br>        <span class="hljs-comment">//获取其上层：获取不到引导类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">bootstrapClassLoader</span> <span class="hljs-operator">=</span> extClassLoader.getParent();<br>        System.out.println(bootstrapClassLoader);<span class="hljs-comment">//null</span><br><br>        <span class="hljs-comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ClassLoaderTest.class.getClassLoader();<br>        System.out.println(classLoader);<span class="hljs-comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><br>        <span class="hljs-comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> String.class.getClassLoader();<br>        System.out.println(classLoader1);<span class="hljs-comment">//null</span><br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>我们尝试获取引导类加载器，获取到的值为 null ，这并不代表引导类加载器不存在，<strong>因为引导类加载器右 C/C++ 语言，我们获取不到</strong></li><li>两次获取系统类加载器的值都相同：sun.misc.Launcher$AppClassLoader@18b4aac2 ，这说明<strong>系统类加载器是全局唯一的</strong></li></ul><h4 id="2、虚拟机自带的加载器">2、虚拟机自带的加载器</h4><h5 id="1、启动类加载器">1、启动类加载器</h5><p>启动类加载器（引导类加载器，Bootstrap ClassLoader）</p><ol><li>这个类加载使用<code>C/C++</code>语言实现的，嵌套在JVM内部</li><li>它用来加载Java的核心库<code>（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容）</code>，用于提供JVM自身需要的类</li><li>并不继承自java.lang.ClassLoader，没有父加载器</li><li>加载扩展类和应用程序类加载器，并作为他们的父类加载器</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为<code>java、javax、sun</code>等开头的类</li></ol><h5 id="2、扩展类加载器">2、扩展类加载器</h5><p>扩展类加载器（Extension ClassLoader）</p><ol><li><code>Java语言编写</code>，由sun.misc.Launcher$ExtClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为<code>启动类加载器</code></li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li></ol><h5 id="3、系统类加载器">3、系统类加载器</h5><p>应用程序类加载器（也称为系统类加载器，AppClassLoader）</p><ol><li>Java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为<code>扩展类加载器</code></li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader.getSystemclassLoader()方法可以获取到该类加载器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;**********启动类加载器**************&quot;</span>);<br>        <span class="hljs-comment">//获取BootstrapClassLoader能够加载的api的路径</span><br>        URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();<br>        <span class="hljs-keyword">for</span> (URL element : urLs) &#123;<br>            System.out.println(element.toExternalForm());<br>        &#125;<br>        <span class="hljs-comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Provider.class.getClassLoader();<br>        System.out.println(classLoader);<br><br>        System.out.println(<span class="hljs-string">&quot;***********扩展类加载器*************&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">extDirs</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;java.ext.dirs&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String path : extDirs.split(<span class="hljs-string">&quot;;&quot;</span>)) &#123;<br>            System.out.println(path);<br>        &#125;<br><br>        <span class="hljs-comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> CurveDB.class.getClassLoader();<br>        System.out.println(classLoader1);<span class="hljs-comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">**********启动类加载器**************<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/resources.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/rt.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/sunrsasign.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/jsse.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/jce.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/charsets.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/jfr.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/classes<br><span class="hljs-literal">null</span><br>***********扩展类加载器*************<br>C:\Program Files\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>\jre\lib\ext<br>C:\Windows\Sun\Java\lib\ext<br>sun.misc.Launcher$ExtClassLoader@29453f44<br></code></pre></td></tr></table></figure><h4 id="3、用户自定义类加载器">3、用户自定义类加载器</h4><h5 id="1、何时需要自定义类加载器？">1、何时需要自定义类加载器？</h5><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那为什么还需要自定义类加载器？</p><ul><li>隔离加载类（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间价之间是隔离的）</li><li>修改类加载的方式</li><li>扩展加载源（还可以考虑从数据库中加载类，路由器等等不同的地方）</li><li>防止源码泄漏（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密）</li></ul><h5 id="2、如何自定义类加载器？">2、如何自定义类加载器？</h5><ol><li>开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findclass()方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以<code>直接继承URIClassLoader类</code>，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">byte</span>[] result = getClassFromCustomPath(name);<br>            <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNotFoundException</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//defineClass和findClass搭配使用</span><br>                <span class="hljs-keyword">return</span> defineClass(name, result, <span class="hljs-number">0</span>, result.length);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>(name);<br>    &#125;<br><span class="hljs-comment">//自定义流的获取方式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] getClassFromCustomPath(String name) &#123;<br>        <span class="hljs-comment">//从自定义路径中加载指定类:细节略</span><br>        <span class="hljs-comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CustomClassLoader</span> <span class="hljs-variable">customClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomClassLoader</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-literal">true</span>, customClassLoader);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>            System.out.println(obj.getClass().getClassLoader());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、ClassLoader">4、ClassLoader</h4><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221025162137614.png" alt></p><p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221025162203691.png" alt></p><blockquote><p>获取ClassLoader途径</p></blockquote><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221025162252275.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.</span><br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>).getClassLoader();<br>            System.out.println(classLoader);<br>            <span class="hljs-comment">//2.</span><br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();<br>            System.out.println(classLoader1);<br><br>            <span class="hljs-comment">//3.</span><br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader2</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader().getParent();<br>            System.out.println(classLoader2);<br><br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">null<br>sun.misc.Launcher<span class="hljs-variable">$AppClassLoader</span>@<span class="hljs-number">18</span>b4aac2<br>sun.misc.Launcher<span class="hljs-variable">$ExtClassLoader</span>@<span class="hljs-number">1540</span>e19d<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="5、🔺双亲委派机制">5、🔺双亲委派机制</h3><h4 id="1、双亲委派机制原理">1、双亲委派机制原理</h4><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式</p><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li><li>父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</li></ol><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221025163844593.png" alt></p><blockquote><p>举个通俗的例子：小孩有一个苹果，问妈妈说吃不吃，妈妈一看奶奶还在，就问奶奶吃不吃苹果；奶奶一看苹果有点硬，咬不动于是说不吃，给了妈妈，妈妈一看说苹果有点酸，又给了小孩，小孩说我正好喜欢吃又酸又硬的，于是小孩吃了。</p></blockquote><p>有点像 职责链模式</p><h4 id="2、双亲委派机制代码演示">2、双亲委派机制代码演示</h4><h5 id="1、Demo1">1、Demo1</h5><p>1、自己建立一个 java.lang.String 类，写上 static 代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是自定义的String类的静态代码块&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在另外的程序中加载 String 类，看看加载的 String 类是 JDK 自带的 String 类，还是我们自己编写的 String 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        java.lang.<span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.String();<br>        System.out.println(<span class="hljs-string">&quot;hello,atguigu.com&quot;</span>);<br><br>        <span class="hljs-type">StringTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringTest</span>();<br>        System.out.println(test.getClass().getClassLoader());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hello,atguigu<span class="hljs-selector-class">.com</span><br>sun<span class="hljs-selector-class">.misc</span>.Launcher<span class="hljs-variable">$AppClassLoader</span>@<span class="hljs-number">18</span>b4aac2<br></code></pre></td></tr></table></figure><p>程序并没有输出我们静态代码块中的内容，说明仍然加载的是 JDK 自带的 String 类。</p><p>把刚刚的类改一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是自定义的String类的静态代码块&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//错误: 在类 java.lang.String 中找不到 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello,String&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221025164730203.png" alt></p><p>由于双亲委派机制一直找父类，所以最后找到了Bootstrap ClassLoader，Bootstrap ClassLoader找到的是 JDK 自带的 String 类，在那个String类中并没有 main() 方法，所以就报了上面的错误。</p><h5 id="2、Demo2">2、Demo2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShkStart</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.SecurityException: Prohibited <span class="hljs-keyword">package</span> name: java.lang<br>at java.lang.ClassLoader.preDefineClass(ClassLoader.java:<span class="hljs-number">662</span>)<br>at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="hljs-number">761</span>)<br>at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:<span class="hljs-number">142</span>)<br>at java.net.URLClassLoader.defineClass(URLClassLoader.java:<span class="hljs-number">467</span>)<br>at java.net.URLClassLoader.access$<span class="hljs-number">100</span>(URLClassLoader.java:<span class="hljs-number">73</span>)<br>at java.net.URLClassLoader$<span class="hljs-number">1.</span>run(URLClassLoader.java:<span class="hljs-number">368</span>)<br>at java.net.URLClassLoader$<span class="hljs-number">1.</span>run(URLClassLoader.java:<span class="hljs-number">362</span>)<br>at java.security.AccessController.doPrivileged(Native Method)<br>at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="hljs-number">361</span>)<br>at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="hljs-number">424</span>)<br>at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="hljs-number">335</span>)<br>at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="hljs-number">357</span>)<br>at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:<span class="hljs-number">495</span>)<br>Error: A JNI error has occurred, please check your installation and <span class="hljs-keyword">try</span> again<br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> <br>Process finished with exit code <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>即使类名没有重复，也禁止使用java.lang这种包名。这是一种保护机制</p><h5 id="3、Demo3">3、Demo3</h5><p>当我们加载jdbc.jar 用于实现数据库连接的时候</p><ol><li>我们现在程序中需要用到SPI接口，而SPI接口属于rt.jar包中Java核心api</li><li>然后使用双清委派机制，引导类加载器把rt.jar包加载进来，而rt.jar包中的SPI存在一些接口，接口我们就需要具体的实现类了</li><li>具体的实现类就涉及到了某些第三方的jar包了，比如我们加载SPI的实现类jdbc.jar包【首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的】</li><li>第三方的jar包中的类属于系统类加载器来加载</li><li>从这里面就可以看到SPI核心接口由引导类加载器来加载，SPI具体实现类由系统类加载器来加载</li></ol><p><img src="/2022/10/24/jvm-02-lei-jia-zai-zi-xi-tong/image-20221025164859134.png" alt></p><h4 id="3、双亲委派机制的优势">3、双亲委派机制的优势</h4><ol><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改<ul><li>自定义类：自定义java.lang.String 没有被加载。</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ol><h3 id="6、沙箱安全机制">6、沙箱安全机制</h3><p>自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p><p>简单来说，就是保证引导类加载器负责加载的核心包不会被恶意篡改</p><h3 id="7、如何判断两个class对象是否相同？">7、如何判断两个class对象是否相同？</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ol><li>类的完整类名必须一致，包括包名</li><li><strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong></li></ol><p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要<code>加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</code></p><h3 id="8、对类加载器的引用">8、对类加载器的引用</h3><ol><li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li><li><code>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</code></li><li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-01-JVM与Java体系结构</title>
      <link href="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/"/>
      <url>/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JVM系列参考了<a href="https://www.bilibili.com/video/BV1PJ411n7xZ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4397d58737f806d687218418438c3de3">尚硅谷的JVM视频教程</a>，以及<a href="https://imlql.cn/categories/JVM/">风祁的时光录的个人博客</a></p></blockquote><p>是否遇到过这些问题？</p><ol><li>运行着的线上系统突然卡死，系统无法访问，甚至直接OOM！</li><li>想解决线上JVM GC问题，但却无从下手。</li><li>新项目上线，对各种JVM参数设置一脸茫然，直接默认吧然后就JJ了。</li><li>每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼。</li></ol><h2 id="1、Java及JVM简介">1、Java及JVM简介</h2><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021162119621.png" alt></p><p>如果我们把核心类库的API比做数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。</p><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021162207599.png" alt></p><p>计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言。</p><p>So，架构师每天都在思考什么？</p><ol><li>应该如何让我的系统更快？</li><li>如何避免系统出现瓶颈？</li></ol><h3 id="1、推荐书目">1、推荐书目</h3><p><strong>官方文档</strong></p><p><strong>英文文档规范</strong>：<a href="https://docs.oracle.com/javase/specs/index.html">https://docs.oracle.com/javase/specs/index.html</a></p><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021162737446.png" alt></p><p><strong>中文书籍：</strong></p><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021162826232.png" alt></p><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021162848622.png" alt></p><h3 id="2、Java-VS-C">2、Java VS C++</h3><ol><li>垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。</li><li>C++语言需要程序员自己来分配内存和回收内存，对于高手来说可能更加舒服，但是对于普通开发者，如果技术实力不够，很容易造成内存泄漏。而Java全部交给JVM进行内存分配和回收，这也是一种趋势，减少程序员的工作量。</li></ol><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021162556628.png" alt></p><h3 id="3、Java生态圈">3、Java生态圈</h3><p>Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p><ol><li>作为一个平台，Java虚拟机扮演着举足轻重的作用<ul><li>Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分</li></ul></li><li>作为一种文化，Java几乎成为了“开源”的代名词。<ul><li>第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。</li><li>就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。</li></ul></li><li>作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。</li></ol><blockquote><p>Java-跨平台的语言</p></blockquote><p>下面这张图就很形象</p><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021163236035.png" alt></p><blockquote><p>JVM-跨语言的平台</p></blockquote><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021163440775.png" alt></p><ul><li>随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现<code>在Java虚拟机平台上运行非Java语言编写的程序</code>。</li><li>Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它<code>只关心“字节码”文件</code>。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</li><li>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：<code>jvm字节码</code>。</li><li>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</li><li>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——<code>Class文件</code>格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</li></ul><blockquote><p>多语言混合编程</p></blockquote><ol><li>Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</li><li>试想一下，在一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。</li><li>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如DaVinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。</li></ol><blockquote><h4 id="Open-JDK和Oracle-JDK">Open JDK和Oracle JDK</h4></blockquote><p>在JDK11之前，Oracle JDK中还会存在一些Open JDK中没有的，闭源的功能。但在JDK11中，我们可以认为Open JDK和Oracle JDK代码实质上已经达到完全一致的程度了。</p><blockquote><p>Java代码执行流程</p></blockquote><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021165300594.png" alt></p><h3 id="4、虚拟机">4、虚拟机</h3><h4 id="1、虚拟机概念">1、虚拟机概念</h4><ul><li><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款<code>软件</code>，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p><ul><li><p>大名鼎鼎的Virtual Box，VMware就属于系统虚拟机，它们完全是对物理计算机硬件的仿真(模拟)，提供了一个可运行完整操作系统的软件平台。</p></li><li><p>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</p></li></ul></li><li><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p></li></ul><h4 id="2、Java虚拟机">2、Java虚拟机</h4><ol><li>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</li><li>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</li><li><strong>Java技术的核心就是Java虚拟机</strong>（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</li></ol><p><strong>作用：</strong></p><p>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p><p><strong>特点：</strong></p><ol><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收功能</li></ol><h3 id="5、JVM位置及整体架构">5、JVM位置及整体架构</h3><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021164330033.png" alt></p><p>JVM是运行在操作系统之上的，它与硬件没有直接的交互</p><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021164401275.png" alt></p><ol><li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</li><li>它采用解释器与即时编译器并存的架构。</li><li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。</li></ol><blockquote><p>下面这张图要会画</p></blockquote><p><img src="/2022/10/21/jvm-01-jvm-yu-java-ti-xi-jie-gou/image-20221021164535409.png" alt></p><h3 id="6、JVM的架构模型">6、JVM的架构模型</h3><p>Java编译器输入的指令流基本上是一种<strong>基于栈的指令集架构</strong>，另外一种指令集架构则是<strong>基于寄存器的指令集架构</strong>。</p><blockquote><p>HotSpot是基于栈的指令集架构</p></blockquote><p>具体来说：这两种架构之间的区别：</p><h4 id="1、基于栈的指令集架构">1、基于栈的指令集架构</h4><p>基于栈式架构的特点：</p><ol><li>设计和实现更简单，适用于资源受限的系统；</li><li>避开了寄存器的分配难题：使用零地址指令方式分配</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</li><li>不需要硬件支持，可移植性更好，更好实现跨平台</li></ol><h4 id="2、基于寄存器的指令级架构">2、基于寄存器的指令级架构</h4><p>基于寄存器架构的特点：</p><ol><li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li><li>指令集架构则完全依赖硬件，与硬件的耦合度高，可移植性差</li><li><code>性能优秀和执行更高效</code></li><li><code>花费更少的指令去完成一项操作</code></li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</li></ol><h4 id="3、举例">3、举例</h4><p>执行2+3这种逻辑操作</p><ul><li><p>基于栈的计算流程（以Java虚拟机为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">iconst_2 <span class="hljs-comment">//常量2入栈</span><br>istore_1<br>iconst_3 <span class="hljs-comment">// 常量3入栈</span><br>istore_2<br>iload_1<br>iload_2<br>iadd <span class="hljs-comment">//常量2/3出栈，执行相加</span><br>istore_0 <span class="hljs-comment">// 结果5入栈</span><br></code></pre></td></tr></table></figure></li><li><p>而基于寄存器的计算流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">mov eax,<span class="hljs-number">2</span> <span class="hljs-comment">//将eax寄存器的值设为1</span><br>add eax,<span class="hljs-number">3</span> <span class="hljs-comment">//使eax寄存器的值加3</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="4、JVM架构总结">4、JVM架构总结</h4><ol><li><strong>由于跨平台性的设计，Java的指令都是根据栈来设计的</strong>。不同平台CPU架构不同，所以不能设计为基于寄存器的。<code>栈的优点</code>：跨平台，指令集小，编译器容易实现，<code>缺点</code>是性能比寄存器差一些。</li><li>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpot VM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</li></ol><p>因为基于栈的架构跨平台性好、指令集小，虽然相对于基于寄存器的架构来说，基于栈的架构编译得到的指令更多，执行性能也不如基于寄存器的架构好，但考虑到其跨平台性与移植性，我们还是选用栈的架构</p><h3 id="7、JVM的生命周期">7、JVM的生命周期</h3><h4 id="1、虚拟机的启动">1、虚拟机的启动</h4><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><h4 id="2、虚拟机的执行">2、虚拟机的执行</h4><ol><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序</li><li>程序开始执行时他才运行，程序结束时他就停止</li><li><code>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</code></li></ol><h4 id="3、虚拟机的退出">3、虚拟机的退出</h4><p><code>有如下的几种情况：</code></p><ol><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统用现错误而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或System类的exit()方法，或Runtime类的halt()方法，并且Java安全管理器也允许这次exit()或halt()操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</li></ol><h3 id="8、常见JVM类型">8、常见JVM类型</h3><h4 id="1、Sun-Classic-VM">1、Sun Classic VM</h4><ol><li>早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是<code>世界上第一款商用Java虚拟机</code>，JDK1.4时完全被淘汰。</li><li>这款虚拟机内部只提供解释器，没有即时编译器，因此效率比较低。【即时编译器会把热点代码的本地机器指令缓存起来，那么以后使用热点代码的时候，效率就比较高】</li><li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作，解释器和编译器不能配合工作。<ul><li>我们将字节码指令翻译成机器指令也是需要花时间的，如果只使用JIT，就需要把所有字节码指令都翻译成机器指令，就会导致翻译时间过长，也就是说在程序刚启动的时候，等待时间会很长。</li><li>而解释器就是走到哪，解释到哪。</li></ul></li><li>现在Hotspot内置了此虚拟机。</li></ol><h4 id="2、HotSpot-VM（重点）">2、HotSpot VM（重点）</h4><ol><li><p>HotSpot历史</p><ul><li>最初由一家名为“Longview Technologies”的小公司设计</li><li>1997年，此公司被Sun收购；2009年，Sun公司被甲骨文收购。</li><li>JDK1.3时，HotSpot VM成为默认虚拟机</li></ul></li><li><p>目前</p><p><code>Hotspot占有绝对的市场地位，称霸武林</code></p><ul><li>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</li><li>Sun/oracle JDK和openJDK的默认虚拟机</li></ul></li><li><p>从服务器、桌面到移动端、嵌入式都有应用。</p></li><li><p>名称中的HotSpot指的就是它的<code>热点代码探测技术</code>。</p><ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li><li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li></ul></li></ol><h4 id="3、JRockit（商用三大虚拟机之一）">3、JRockit（商用三大虚拟机之一）</h4><ol><li>专注于服务器端应用：它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</li><li>大量的行业基准测试显示，<code>JRockit JVM是世界上最快的JVM</code>：使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</li><li>优势：全面的Java运行时解决方案组合<ul><li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</li><li>Mission Control服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li></ul></li><li>2008年，JRockit被Oracle收购。</li><li>Oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</li><li>高斯林：目前就职于谷歌，研究人工智能和水下机器人</li></ol><h4 id="4、IBM的J9（商用三大虚拟机之一）">4、IBM的J9（商用三大虚拟机之一）</h4><ol><li>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</li><li>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。</li><li>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。</li><li>2017年左右，IBM发布了开源J9VM，命名为openJ9，交给Eclipse基金会管理，也称为Eclipse OpenJ9</li><li>OpenJDK -&gt; 是JDK开源了，包括了虚拟机</li></ol><h4 id="5、Graal-VM（未来虚拟机）">5、Graal VM（未来虚拟机）</h4><ol><li>2018年4月，Oracle Labs公开了GraalvM，号称 “<strong>Run Programs Faster Anywhere</strong>”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。</li><li>GraalVM在HotSpot VM基础上增强而成的**跨语言全栈虚拟机，可以作为“任何语言”**的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</li><li>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</li><li>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</li><li><code>如果说HotSpot有一天真的被取代，Graalvm希望最大</code>。但是Java的软件生态没有丝毫变化。</li></ol><h4 id="6、其他虚拟机">6、其他虚拟机</h4><ol><li><p>Exact VM</p></li><li><p>KVM和CDC/CLDC Hotspot</p></li><li><p>Azul VM</p></li><li><p>Liquid VM</p></li><li><p>Apache Marmony</p></li><li><p>Micorsoft JVM</p></li><li><p>Taobao JVM</p><ol><li><code>基于OpenJDK开发了自己的定制版本AlibabaJDK</code>，简称AJDK。是整个阿里Java体系的基石。</li><li>基于OpenJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。<ul><li>创新的GCIH（GCinvisible heap）技术实现了off-heap，即<code>将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的</code>。</li><li>GCIH中的<code>对象还能够在多个Java虚拟机进程中实现共享</code></li><li>使用crc32指令实现JvM intrinsic降低JNI的调用开销</li><li>PMU hardware的Java profiling tool和诊断协助功能</li><li>针对大数据场景的ZenGC</li></ul></li><li>taobao vm应用在阿里产品上性能高，<code>硬件严重依赖intel的cpu，损失了兼容性，但提高了性能</code></li></ol><p>目前已经在淘宝、天猫上线，把Oracle官方JvM版本全部替换了。</p></li><li><p>Dalvik VM</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Z-《流行的云》</title>
      <link href="/2022/10/20/z-liu-xing-de-yun/"/>
      <url>/2022/10/20/z-liu-xing-de-yun/</url>
      
        <content type="html"><![CDATA[<p>特殊调弦</p><p><img src="/2022/10/20/z-liu-xing-de-yun/image-20221020103152306.png"></p><p><img src="/2022/10/20/z-liu-xing-de-yun/image-20221020103212498.png"></p><blockquote><p>曲谱来源 元子弹吉他</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 吉他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吉他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/2022/10/19/git-chang-yong-ming-ling/"/>
      <url>/2022/10/19/git-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="1、创建版本库"><a href="#1、创建版本库" class="headerlink" title="1、创建版本库"></a>1、创建版本库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> &lt;url&gt; <span class="hljs-comment">#克隆远程版本</span><br><br>$ git init <span class="hljs-comment">#初始化本地版本库</span><br><br>$ git config --global user.name 用户名 <span class="hljs-comment">#设置用户名</span><br><br>$ git config --global user.email 邮箱 <span class="hljs-comment">#设置邮箱</span><br></code></pre></td></tr></table></figure><h2 id="2、修改和提交代码"><a href="#2、修改和提交代码" class="headerlink" title="2、修改和提交代码"></a>2、修改和提交代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status <span class="hljs-comment">#查看状态</span><br><br>$ git diff <span class="hljs-comment">#查看便变更内容</span><br><br>$ git add . <span class="hljs-comment">#跟踪所有改动的文件</span><br><br>$ git add &lt;file&gt; <span class="hljs-comment">#跟踪指定的文件</span><br><br>$ git <span class="hljs-built_in">mv</span> &lt;old&gt; &lt;new&gt; <span class="hljs-comment">#文件改名</span><br><br>$ git <span class="hljs-built_in">rm</span> &lt;file&gt; <span class="hljs-comment">#删除文件</span><br><br>$ git <span class="hljs-built_in">rm</span> --cached file <span class="hljs-comment">#停止跟踪文件但不删除</span><br><br>$ git commit -m <span class="hljs-string">&quot;commit message&quot;</span> <span class="hljs-comment">#提交所有更新过的文件</span><br><br>$ git commit -- amend <span class="hljs-comment">#修改最后一次提交</span><br></code></pre></td></tr></table></figure><h2 id="3、查看历史提交"><a href="#3、查看历史提交" class="headerlink" title="3、查看历史提交"></a>3、查看历史提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git long <span class="hljs-comment">#查看提交历史</span><br><br>$ git <span class="hljs-built_in">log</span> -p &lt;file&gt; <span class="hljs-comment">#查看指定文件的提交历史</span><br><br>$ git blame &lt;file&gt; <span class="hljs-comment">#以列表方式查看指定文件的提交历史</span><br></code></pre></td></tr></table></figure><h2 id="4、撤销"><a href="#4、撤销" class="headerlink" title="4、撤销"></a>4、撤销</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reset --hard HEAD <span class="hljs-comment">#撤销工作目录中所有未提交文件的修改内容</span><br><br>$ git checkout  HEAD file <span class="hljs-comment">#撤销指定的未提交文件的修改内容</span><br><br>$ git revert &lt;commit&gt; <span class="hljs-comment">#撤销指定的提交</span><br></code></pre></td></tr></table></figure><h2 id="5、分支、标签"><a href="#5、分支、标签" class="headerlink" title="5、分支、标签"></a>5、分支、标签</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch <span class="hljs-comment">#显示所有本地分支</span><br><br>$ git checkout &lt;branch/tag&gt; <span class="hljs-comment">#切换到指定分支或标签</span><br><br>$ git branch &lt;new-branch&gt; <span class="hljs-comment">#创建新的分支</span><br><br>$ git branch -d &lt;branch&gt; <span class="hljs-comment"># 删除本地分支</span><br><br>$ git tag <span class="hljs-comment">#列出所有本地标签</span><br><br>$ git tag &lt;tagname&gt; <span class="hljs-comment">#基于最新提交创建标签</span><br><br>$ git tag -d &lt;tagname&gt; <span class="hljs-comment">#删除标签</span><br></code></pre></td></tr></table></figure><h2 id="6、合并与衍合"><a href="#6、合并与衍合" class="headerlink" title="6、合并与衍合"></a>6、合并与衍合</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git merge &lt;branch&gt; <span class="hljs-comment">#合并指定分支到当前分支</span><br><br>$ git rebase &lt;branch&gt; <span class="hljs-comment">#衍合指定分支到当前分支</span><br></code></pre></td></tr></table></figure><h2 id="7、远程操作"><a href="#7、远程操作" class="headerlink" title="7、远程操作"></a>7、远程操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote -v <span class="hljs-comment">#查看远程版本信息</span><br><br>$ git remote show &lt;remote&gt; <span class="hljs-comment"># 查看指定远程版本库的信息</span><br><br>$ git remote add &lt;remote&gt; url <span class="hljs-comment">#添加远程版本库</span><br><br>$ git fetch &lt;remote&gt; <span class="hljs-comment">#从远程获取代码</span><br><br>$ git pull &lt;remote&gt; &lt;branch&gt; <span class="hljs-comment">#下载代码及快速合并</span><br><br>$ git push &lt;remote&gt; &lt;branch&gt; <span class="hljs-comment">#上传代码及快速合并</span><br><br>$ git push &lt;remote&gt; :&lt;branch/tag-name&gt; <span class="hljs-comment">#删除远程分支或标签</span><br><br>$ git push --tags <span class="hljs-comment">#上传所有标签</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-行为型-备忘录-访问者</title>
      <link href="/2022/10/19/10-xing-wei-xing-bei-wang-lu-fang-wen-zhe/"/>
      <url>/2022/10/19/10-xing-wei-xing-bei-wang-lu-fang-wen-zhe/</url>
      
        <content type="html"><![CDATA[<h1 id="一、备忘录模式"><a href="#一、备忘录模式" class="headerlink" title="一、备忘录模式"></a>一、备忘录模式</h1><p>备忘录模式定义：备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。当你需要让对象返回之前的状态时,就使用备忘录模式。备忘录模式有两个目标:储存系统关键对象的重要状态；维护关键对象的封装。</p><h2 id="1、结构与实现"><a href="#1、结构与实现" class="headerlink" title="1、结构与实现"></a>1、结构与实现</h2><h3 id="1、备忘录模式结构"><a href="#1、备忘录模式结构" class="headerlink" title="1、备忘录模式结构"></a>1、备忘录模式结构</h3><p>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</p><p>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</p><p>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</p><p>备忘录有两个等效的接口：</p><ul><li><strong>窄接口</strong>：管理者(Caretaker)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(narror Interface)，这个窄接口只允许他把备忘录对象传给其他的对象。</li><li><strong>宽接口</strong>：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wide Interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。</li></ul><h3 id="2、备忘录模式代码实现"><a href="#2、备忘录模式代码实现" class="headerlink" title="2、备忘录模式代码实现"></a>2、备忘录模式代码实现</h3><p>Demo案例-打Boss</p><p>游戏中的某个场景，一游戏角色有生命力、攻击力、防御力等数据，在打Boss前和后一定会不一样的，我们允许玩家如果感觉与Boss决斗的效果不理想可以让游戏恢复到决斗之前的状态。</p><p>要实现上述案例，有两种方式：</p><ul><li>“白箱”备忘录模式</li><li>“黑箱”备忘录模式</li></ul><h4 id="1、白箱备忘录模式"><a href="#1、白箱备忘录模式" class="headerlink" title="1、白箱备忘录模式"></a>1、白箱备忘录模式</h4><p>备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开</p><p>关系类图：</p><p><img src="/2022/10/19/10-xing-wei-xing-bei-wang-lu-fang-wen-zhe/image-20221020110410991.png"></p><h5 id="1、GameRole"><a href="#1、GameRole" class="headerlink" title="1、GameRole"></a>1、GameRole</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GameRole</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> vit;<span class="hljs-comment">//生命力</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> atk;<span class="hljs-comment">//攻击力</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> def;<span class="hljs-comment">//防御力</span><br><br>    <span class="hljs-comment">//初始化状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.vit = <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">this</span>.atk = <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">this</span>.def = <span class="hljs-number">100</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//战斗</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fight</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.vit = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.atk = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.def = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//保存角色状态</span><br>    <span class="hljs-keyword">public</span> RoleStateMemento <span class="hljs-title function_">saveState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoleStateMemento</span>(vit, atk, def);<br>    &#125;<br><br>    <span class="hljs-comment">//恢复角色状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverState</span><span class="hljs-params">(RoleStateMemento roleStateMemento)</span> &#123;<br>        <span class="hljs-built_in">this</span>.vit = roleStateMemento.getVit();<br>        <span class="hljs-built_in">this</span>.atk = roleStateMemento.getAtk();<br>        <span class="hljs-built_in">this</span>.def = roleStateMemento.getDef();<br>    &#125;<br><br>    <span class="hljs-comment">//展示状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stateDisplay</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;角色生命力&quot;</span> + vit);<br>        System.out.println(<span class="hljs-string">&quot;角色攻击力&quot;</span> + atk);<br>        System.out.println(<span class="hljs-string">&quot;角色防御力&quot;</span> + def);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getVit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> vit;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVit</span><span class="hljs-params">(<span class="hljs-type">int</span> vit)</span> &#123;<br>        <span class="hljs-built_in">this</span>.vit = vit;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAtk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> atk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAtk</span><span class="hljs-params">(<span class="hljs-type">int</span> atk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.atk = atk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDef</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> def;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDef</span><span class="hljs-params">(<span class="hljs-type">int</span> def)</span> &#123;<br>        <span class="hljs-built_in">this</span>.def = def;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、RoleStateMemento"><a href="#2、RoleStateMemento" class="headerlink" title="2、RoleStateMemento"></a>2、RoleStateMemento</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleStateMemento</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> vit;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> atk;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> def;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RoleStateMemento</span><span class="hljs-params">(<span class="hljs-type">int</span> vit, <span class="hljs-type">int</span> atk, <span class="hljs-type">int</span> def)</span> &#123;<br>        <span class="hljs-built_in">this</span>.vit = vit;<br>        <span class="hljs-built_in">this</span>.atk = atk;<br>        <span class="hljs-built_in">this</span>.def = def;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getVit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> vit;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVit</span><span class="hljs-params">(<span class="hljs-type">int</span> vit)</span> &#123;<br>        <span class="hljs-built_in">this</span>.vit = vit;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAtk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> atk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAtk</span><span class="hljs-params">(<span class="hljs-type">int</span> atk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.atk = atk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDef</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> def;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDef</span><span class="hljs-params">(<span class="hljs-type">int</span> def)</span> &#123;<br>        <span class="hljs-built_in">this</span>.def = def;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、RoleStateCaretaker"><a href="#3、RoleStateCaretaker" class="headerlink" title="3、RoleStateCaretaker"></a>3、RoleStateCaretaker</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleStateCaretaker</span> &#123;<br>    <span class="hljs-keyword">private</span> RoleStateMemento roleStateMemento;<br><br>    <span class="hljs-keyword">public</span> RoleStateMemento <span class="hljs-title function_">getRoleStateMemento</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> roleStateMemento;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRoleStateMemento</span><span class="hljs-params">(RoleStateMemento roleStateMemento)</span> &#123;<br>        <span class="hljs-built_in">this</span>.roleStateMemento = roleStateMemento;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4、Client"><a href="#4、Client" class="headerlink" title="4、Client"></a>4、Client</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;--------------大战Boss前------------------------&quot;</span>);<br>        <span class="hljs-comment">//大战Boss前</span><br>        <span class="hljs-type">GameRole</span> <span class="hljs-variable">gameRole</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GameRole</span>();<br>        gameRole.initState();<br>        gameRole.stateDisplay();<br><br>        <span class="hljs-comment">//保存进度</span><br>        <span class="hljs-type">RoleStateCaretaker</span> <span class="hljs-variable">roleStateCaretaker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoleStateCaretaker</span>();<br>        roleStateCaretaker.setRoleStateMemento(gameRole.saveState());<br><br>        System.out.println(<span class="hljs-string">&quot;--------------大战Boss后------------------------&quot;</span>);<br>        <span class="hljs-comment">//大战Boss 损耗严重</span><br>        gameRole.fight();<br>        gameRole.stateDisplay();<br><br>        System.out.println(<span class="hljs-string">&quot;--------------满血复活------------------------&quot;</span>);<br>        gameRole.recoverState(roleStateCaretaker.getRoleStateMemento());<br>        gameRole.stateDisplay();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5、结果"><a href="#5、结果" class="headerlink" title="5、结果"></a>5、结果</h5><p><img src="/2022/10/19/10-xing-wei-xing-bei-wang-lu-fang-wen-zhe/image-20221020105645535.png"></p><h4 id="2、黑箱备忘录模式"><a href="#2、黑箱备忘录模式" class="headerlink" title="2、黑箱备忘录模式"></a>2、黑箱备忘录模式</h4><p>将 <code>RoleStateMemento</code> 设为 <code>GameRole</code> 的内部类，从而将 <code>RoleStateMemento</code> 对象封装在 <code>GameRole</code> 里面；在外面提供一个标识接口 <code>Memento</code> 给 <code>RoleStateCaretaker</code> 及其他对象使用。这样 <code>GameRole</code> 类看到的是 <code>RoleStateMemento</code> 所有的接口，而<code>RoleStateCaretaker</code> 及其他对象看到的仅仅是标识接口 <code>Memento</code> 所暴露出来的接口，从而维护了封装型。类图如下：</p><p><img src="/2022/10/19/10-xing-wei-xing-bei-wang-lu-fang-wen-zhe/image-20221020111221487.png"></p><h5 id="1、GameRole-1"><a href="#1、GameRole-1" class="headerlink" title="1、GameRole"></a>1、GameRole</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GameRole</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> vit;<span class="hljs-comment">//生命力</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> atk;<span class="hljs-comment">//攻击力</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> def;<span class="hljs-comment">//防御力</span><br><br>    <span class="hljs-comment">//初始化状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.vit = <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">this</span>.atk = <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">this</span>.def = <span class="hljs-number">100</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//战斗</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fight</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.vit = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.atk = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.def = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//保存角色状态</span><br>    <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">saveState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoleStateMemento</span>(vit, atk, def);<br>    &#125;<br><br>    <span class="hljs-comment">//恢复角色状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverState</span><span class="hljs-params">(Memento memento)</span> &#123;<br>        <span class="hljs-type">RoleStateMemento</span> <span class="hljs-variable">roleStateMemento</span> <span class="hljs-operator">=</span> (RoleStateMemento) memento;<br>        <span class="hljs-built_in">this</span>.vit = roleStateMemento.getVit();<br>        <span class="hljs-built_in">this</span>.atk = roleStateMemento.getAtk();<br>        <span class="hljs-built_in">this</span>.def = roleStateMemento.getDef();<br>    &#125;<br><br>    <span class="hljs-comment">//展示状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stateDisplay</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;角色生命力&quot;</span> + vit);<br>        System.out.println(<span class="hljs-string">&quot;角色攻击力&quot;</span> + atk);<br>        System.out.println(<span class="hljs-string">&quot;角色防御力&quot;</span> + def);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getVit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> vit;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVit</span><span class="hljs-params">(<span class="hljs-type">int</span> vit)</span> &#123;<br>        <span class="hljs-built_in">this</span>.vit = vit;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAtk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> atk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAtk</span><span class="hljs-params">(<span class="hljs-type">int</span> atk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.atk = atk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDef</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> def;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDef</span><span class="hljs-params">(<span class="hljs-type">int</span> def)</span> &#123;<br>        <span class="hljs-built_in">this</span>.def = def;<br>    &#125;<br><br>    <span class="hljs-comment">//在内部定义备忘录内部类 RoleStateMemento（该内部类设置为私有的）</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleStateMemento</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Memento</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> vit;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> atk;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> def;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">RoleStateMemento</span><span class="hljs-params">(<span class="hljs-type">int</span> vit, <span class="hljs-type">int</span> atk, <span class="hljs-type">int</span> def)</span> &#123;<br>            <span class="hljs-built_in">this</span>.vit = vit;<br>            <span class="hljs-built_in">this</span>.atk = atk;<br>            <span class="hljs-built_in">this</span>.def = def;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getVit</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> vit;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVit</span><span class="hljs-params">(<span class="hljs-type">int</span> vit)</span> &#123;<br>            <span class="hljs-built_in">this</span>.vit = vit;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAtk</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> atk;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAtk</span><span class="hljs-params">(<span class="hljs-type">int</span> atk)</span> &#123;<br>            <span class="hljs-built_in">this</span>.atk = atk;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDef</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> def;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDef</span><span class="hljs-params">(<span class="hljs-type">int</span> def)</span> &#123;<br>            <span class="hljs-built_in">this</span>.def = def;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、Memento"><a href="#2、Memento" class="headerlink" title="2、Memento"></a>2、Memento</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Memento</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、RoleStateCaretaker-1"><a href="#3、RoleStateCaretaker-1" class="headerlink" title="3、RoleStateCaretaker"></a>3、RoleStateCaretaker</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleStateCaretaker</span> &#123;<br>    <span class="hljs-keyword">private</span> Memento memento;<br><br>    <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">getMemento</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> memento;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMemento</span><span class="hljs-params">(Memento memento)</span> &#123;<br>        <span class="hljs-built_in">this</span>.memento = memento;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4、Client-1"><a href="#4、Client-1" class="headerlink" title="4、Client"></a>4、Client</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;--------------大战Boss前------------------------&quot;</span>);<br>        <span class="hljs-comment">//大战Boss前</span><br>        <span class="hljs-type">GameRole</span> <span class="hljs-variable">gameRole</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GameRole</span>();<br>        gameRole.initState();<br>        gameRole.stateDisplay();<br><br>        <span class="hljs-comment">//保存进度</span><br>        <span class="hljs-type">RoleStateCaretaker</span> <span class="hljs-variable">roleStateCaretaker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoleStateCaretaker</span>();<br>        roleStateCaretaker.setMemento(gameRole.saveState());<br><br>        System.out.println(<span class="hljs-string">&quot;--------------大战Boss后------------------------&quot;</span>);<br>        <span class="hljs-comment">//大战Boss 损耗严重</span><br>        gameRole.fight();<br>        gameRole.stateDisplay();<br><br>        System.out.println(<span class="hljs-string">&quot;--------------满血复活------------------------&quot;</span>);<br>        gameRole.recoverState(roleStateCaretaker.getMemento());<br>        gameRole.stateDisplay();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5、结果-1"><a href="#5、结果-1" class="headerlink" title="5、结果"></a>5、结果</h5><p><img src="/2022/10/19/10-xing-wei-xing-bei-wang-lu-fang-wen-zhe/image-20221020111438140.png"></p><h2 id="2、优缺点"><a href="#2、优缺点" class="headerlink" title="2、优缺点"></a>2、优缺点</h2><p><strong>优点：</strong></p><ul><li>它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。</li><li>备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。</li></ul><p><strong>缺点：</strong></p><ul><li>资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源。</li></ul><h2 id="3、应用场景"><a href="#3、应用场景" class="headerlink" title="3、应用场景"></a>3、应用场景</h2><ul><li>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</li><li>需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，idea等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</li></ul><p>参考：<a href="https://juejin.cn/post/6975288482927214605">设计模式学习21-备忘录模式</a></p><h1 id="二、访问者模式"><a href="#二、访问者模式" class="headerlink" title="二、访问者模式"></a>二、访问者模式</h1><p>定义：访问者（Visitor）模式的定义：<strong>将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。</strong>它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</p><h2 id="1、结构与实现-1"><a href="#1、结构与实现-1" class="headerlink" title="1、结构与实现"></a>1、结构与实现</h2><h3 id="1、访问者模式结构"><a href="#1、访问者模式结构" class="headerlink" title="1、访问者模式结构"></a>1、访问者模式结构</h3><p>抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。</p><p>具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</p><p>抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。</p><p>具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。</p><p>对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</p><h3 id="2、访问者模式代码实现"><a href="#2、访问者模式代码实现" class="headerlink" title="2、访问者模式代码实现"></a>2、访问者模式代码实现</h3><p>一个Demo案例-喂养宠物</p><p>现在养宠物的人特别多，就以这个为例，当然宠物还分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食。</p><p>以上五个结构分别对应如下:</p><ul><li>访问者角色：给宠物喂食的人</li><li>具体访问者角色：主人、其他人</li><li>抽象元素角色：动物抽象类</li><li>具体元素角色：宠物狗、宠物猫</li><li>结构对象角色：主人家</li></ul><h4 id="1、Person"><a href="#1、Person" class="headerlink" title="1、Person"></a>1、Person</h4><p><em>抽象访问者接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">//喂宠物狗</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">feed</span><span class="hljs-params">(Dog dog)</span>;<br><br>    <span class="hljs-comment">//喂宠物猫</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">feed</span><span class="hljs-params">(Cat cat)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、Owner"><a href="#2、Owner" class="headerlink" title="2、Owner"></a>2、Owner</h4><p><em>具体访问者角色 主人类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Owner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">feed</span><span class="hljs-params">(Dog dog)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;主人喂食宠物狗...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">feed</span><span class="hljs-params">(Cat cat)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;主人喂食宠物猫...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、Someone"><a href="#3、Someone" class="headerlink" title="3、Someone"></a>3、Someone</h4><p><em>具体访问者角色 其他人类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Someone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">feed</span><span class="hljs-params">(Dog dog)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;其他人喂食宠物狗...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">feed</span><span class="hljs-params">(Cat cat)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;其他人喂食宠物猫...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、Animal"><a href="#4、Animal" class="headerlink" title="4、Animal"></a>4、Animal</h4><p><em>定义动物接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Person person)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、Dog"><a href="#5、Dog" class="headerlink" title="5、Dog"></a>5、Dog</h4><p><em>实现Animal接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Person person)</span> &#123;<br>        person.feed(<span class="hljs-built_in">this</span>);<br>        System.out.println(<span class="hljs-string">&quot;真香~，汪汪汪！！！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、Cat"><a href="#6、Cat" class="headerlink" title="6、Cat"></a>6、Cat</h4><p><em>实现Animal接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Person person)</span> &#123;<br>        person.feed(<span class="hljs-built_in">this</span>);<br>        System.out.println(<span class="hljs-string">&quot;真香~，喵喵喵！！！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7、Home"><a href="#7、Home" class="headerlink" title="7、Home"></a>7、Home</h4><p><em>定义对象结构  主人的家</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Home</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Animal&gt; nodeList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Animal&gt;();<br><br>    <span class="hljs-comment">//添加方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Animal animal)</span> &#123;<br>        nodeList.add(animal);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aciton</span><span class="hljs-params">(Person person)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Animal node : nodeList) &#123;<br>            node.accept(person);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8、Client"><a href="#8、Client" class="headerlink" title="8、Client"></a>8、Client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Home</span> <span class="hljs-variable">home</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Home</span>();<br>        home.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br>        home.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>());<br><br>        <span class="hljs-type">Owner</span> <span class="hljs-variable">owner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Owner</span>();<br>        home.aciton(owner);<br>        System.out.println(<span class="hljs-string">&quot;===========================&quot;</span>);<br>        <span class="hljs-type">Someone</span> <span class="hljs-variable">someone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Someone</span>();<br>        home.aciton(someone);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9、结果"><a href="#9、结果" class="headerlink" title="9、结果"></a>9、结果</h4><p><img src="/2022/10/19/10-xing-wei-xing-bei-wang-lu-fang-wen-zhe/image-20221020113116173.png"></p><h2 id="2、优缺点-1"><a href="#2、优缺点-1" class="headerlink" title="2、优缺点"></a>2、优缺点</h2><p><strong>优点：</strong></p><ul><li>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li><li>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li><li>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li><li>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li></ul><p><strong>缺点：</strong></p><ul><li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</li><li>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</li><li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</li></ul><p>参考：<a href="https://juejin.cn/post/6974984329654960165">设计模式学习17-访问者模式</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 备忘录 </tag>
            
            <tag> 访问者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09-行为型-命令-解释器-中介</title>
      <link href="/2022/10/19/09-xing-wei-xing-ming-ling-jie-shi-qi-zhong-jie/"/>
      <url>/2022/10/19/09-xing-wei-xing-ming-ling-jie-shi-qi-zhong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="一、命令模式"><a href="#一、命令模式" class="headerlink" title="一、命令模式"></a>一、命令模式</h1><p>命令模式(Command Pattern)：将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。</p><p>命令模式通俗点来讲，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。</p><p>关系图如下：</p><p><img src="/2022/10/19/09-xing-wei-xing-ming-ling-jie-shi-qi-zhong-jie/image-20221019183821026.png"></p><ul><li><strong>Command</strong>  一个具体命令的抽象接口。</li><li><strong>ConcreteCommand</strong>  就是其具体的一个实现，你可以有多个<code>Command</code>接口的实现。具体命令本身并不实现具体的业务命令， 而是会将调用委派给一个业务逻辑对象去执行。</li><li><strong>Receiver</strong>  作为具体命令的最终接收者。几乎任何对象都可以作为接收者，命令的细节由<strong>Receiver</strong>来实现。</li><li><strong>Invoker</strong>  携带命令执行 <code>action</code>请求。它不负责创建命令对象，它通常会通过构造函数从客户端处获得预先生成的命令。</li><li><strong>Client</strong>  发起具体的命令交给<strong>Invoker</strong>去执行。</li></ul><p>看实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exe</span><span class="hljs-params">()</span>;  <br>&#125;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> Receiver receiver;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCommand</span><span class="hljs-params">(Receiver receiver)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.receiver = receiver;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exe</span><span class="hljs-params">()</span> &#123;  <br>        receiver.action();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">action</span><span class="hljs-params">()</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;command received!&quot;</span>);  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span> &#123;  <br>      <br>    <span class="hljs-keyword">private</span> Command command;  <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Invoker</span><span class="hljs-params">(Command command)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.command = command;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">action</span><span class="hljs-params">()</span>&#123;  <br>        command.exe();  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Receiver</span> <span class="hljs-variable">receiver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Receiver</span>();  <br>        <span class="hljs-type">Command</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCommand</span>(receiver);  <br>        <span class="hljs-type">Invoker</span> <span class="hljs-variable">invoker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Invoker</span>(cmd);  <br>        invoker.action();  <br>    &#125;  <br>&#125;  <br><br></code></pre></td></tr></table></figure><p>命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开，熟悉Struts的同学应该知道，Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！</p><p>命令模式应用非常普遍，我们常见的断路器组件<strong>Hystrix</strong>，还有<strong>Java</strong>多线程中的线程池<code>ThreadPoolExecutor</code>都用到了命令模式。</p><p><strong>优点：</strong></p><ul><li>降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。</li><li>新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。</li><li>可以比较容易地设计一个命令队列或宏命令（组合命令）。</li><li>为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案。</li></ul><p><strong>缺点：</strong></p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。</li></ul><h1 id="二、解释器模式"><a href="#二、解释器模式" class="headerlink" title="二、解释器模式"></a>二、解释器模式</h1><p>解释器模式是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。</p><p>进行加减运算，怎么实现？第一想法是使用工具类，提供对应的加法和减法的工具方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用于两个整数相加</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">//用于两个整数相加</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b + c;<br>&#125;<br><br><span class="hljs-comment">//用于n个整数相加</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Integer ... arr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Integer i : arr) &#123;<br>        sum += i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的形式比较单一、有限，如果形式变化非常多，这就不符合要求，因为加法和减法运算，两个运算符与数值可以有无限种组合方式。比如 1+2+3+4+5、1+2+3-4等等。</p><p>现在需要一种翻译识别机器，能够解析由数字以及 + - 符号构成的合法的运算序列。如果把运算符和数字都看作节点的话，能够逐个节点的进行读取解析运算，这就是解释器模式的思维。</p><p>类图：</p><p><img src="/2022/10/19/09-xing-wei-xing-ming-ling-jie-shi-qi-zhong-jie/image-20221019184910429.png"></p><p>解释器的主要角色：</p><ul><li>抽象解释器(AbstractExpression/Expression)：声明一个所有具体表达式都要实现的抽象接口（或者抽象类），接口中主要是一个interpret()方法，称为解释操作。具体解释任务由它的各个实现类来完成，具体的解释器分别由终结符解释器TerminalExpression和非终结符解释器NonterminalExpression完成。</li><li>终结符表达式(TerminalExpression)：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。终结符一半是文法中的运算单元，比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。</li><li>非终结符表达式(NonterminalExpression)：文法中的每条规则对应于一个非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，+就是非终结符，解析+的解释器就是一个非终结符表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。</li><li>环境角色(Context)：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。</li></ul><h2 id="1、Demo案例-计算加减乘除算法"><a href="#1、Demo案例-计算加减乘除算法" class="headerlink" title="1、Demo案例-计算加减乘除算法"></a>1、Demo案例-计算加减乘除算法</h2><p>简单的一个解释器计算加减乘除算法</p><h3 id="1、AbstractExpression"><a href="#1、AbstractExpression" class="headerlink" title="1、AbstractExpression"></a>1、AbstractExpression</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象解释器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpreter</span><span class="hljs-params">(Context context)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、Add"><a href="#2、Add" class="headerlink" title="2、Add"></a>2、Add</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非终结表达式：加法</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Add</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractExpression left;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractExpression right;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpreter</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> left.interpreter(context) + right.interpreter(context);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、Subtract"><a href="#3、Subtract" class="headerlink" title="3、Subtract"></a>3、Subtract</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非终结表达式：减法</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subtract</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractExpression left;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractExpression right;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpreter</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> left.interpreter(context) - right.interpreter(context);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、Multiply"><a href="#4、Multiply" class="headerlink" title="4、Multiply"></a>4、Multiply</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非终结表达式：乘法</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Multiply</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractExpression left;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractExpression right;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpreter</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> left.interpreter(context) * right.interpreter(context);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、Division"><a href="#5、Division" class="headerlink" title="5、Division"></a>5、Division</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非终结表达式：除法</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Division</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractExpression left;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractExpression right;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpreter</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.right.interpreter(context);<br>        <span class="hljs-keyword">if</span> (right != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> left.interpreter(context) / right;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、Variable"><a href="#6、Variable" class="headerlink" title="6、Variable"></a>6、Variable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//终结表达式：变量</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Variable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String key;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interpreter</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> context.getValue(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7、Context"><a href="#7、Context" class="headerlink" title="7、Context"></a>7、Context</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//环境上下文</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Integer&gt; valueMap = Maps.newHashMap();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addValue</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String key, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> value)</span> &#123;<br>        valueMap.put(key, Integer.valueOf(value));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String key)</span> &#123;<br>        <span class="hljs-keyword">return</span> valueMap.get(key).intValue();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8、Application"><a href="#8、Application" class="headerlink" title="8、Application"></a>8、Application</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>();<br>        context.addValue(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">6</span>);<br>        context.addValue(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">9</span>);<br>        context.addValue(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">Variable</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Variable</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">Variable</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Variable</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-type">Variable</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Variable</span>(<span class="hljs-string">&quot;c&quot;</span>);<br><br>        <span class="hljs-type">AbstractExpression</span> <span class="hljs-variable">multiplyValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Multiply</span>(a, b);<br>        <span class="hljs-type">AbstractExpression</span> <span class="hljs-variable">subtractValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subtract</span>(a, b);<br>        <span class="hljs-type">AbstractExpression</span> <span class="hljs-variable">addValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Add</span>(subtractValue, c);<br>        <span class="hljs-type">AbstractExpression</span> <span class="hljs-variable">divisionValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Division</span>(multiplyValue, addValue);<br><br>        log.info(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, context.getValueMap());<br>        log.info(<span class="hljs-string">&quot;(a*b)/(a-b+c) = &#123;&#125;&quot;</span>, divisionValue.interpreter(context));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9、结果"><a href="#9、结果" class="headerlink" title="9、结果"></a>9、结果</h3><p><img src="/2022/10/19/09-xing-wei-xing-ming-ling-jie-shi-qi-zhong-jie/image-20221019205702816.png"></p><h2 id="2、解释器模式使用场景"><a href="#2、解释器模式使用场景" class="headerlink" title="2、解释器模式使用场景"></a>2、解释器模式使用场景</h2><ul><li>当语言的文法较为简单，且执行效率不是关键问题时。</li><li>当问题重复出现，且可以用一种简单的语言来进行表达时。</li><li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候。</li></ul><h2 id="3、在jdk中的应用"><a href="#3、在jdk中的应用" class="headerlink" title="3、在jdk中的应用"></a>3、在jdk中的应用</h2><p>这个模式通常定义了一个语言的语法，然后解析相应语法的语句。</p><ol><li>java.util.Pattern</li><li>java.text.Normalizer</li><li>java.text.Format</li></ol><h1 id="三、中介模式"><a href="#三、中介模式" class="headerlink" title="三、中介模式"></a>三、中介模式</h1><p>中介者模式(Mediator Pattern)：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</p><p>下面的图可以更好的理解中介模式。</p><p><img src="/2022/10/19/09-xing-wei-xing-ming-ling-jie-shi-qi-zhong-jie/image-20221019212125724.png"></p><h2 id="1、Demo案例-租房问题"><a href="#1、Demo案例-租房问题" class="headerlink" title="1、Demo案例-租房问题"></a>1、Demo案例-租房问题</h2><p>现在租房基本都是通过房屋中介，房主将房屋托管给房屋中介，而租房者从房屋中介获取房屋信息。房屋中介充当租房者与房屋所有者之间的中介者</p><p>类图如下：</p><p><img src="/2022/10/19/09-xing-wei-xing-ming-ling-jie-shi-qi-zhong-jie/image-20221019213747108.png"></p><h3 id="1、Mediator"><a href="#1、Mediator" class="headerlink" title="1、Mediator"></a>1、Mediator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> &#123;<br>    <span class="hljs-comment">//声明一个联络方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">constact</span><span class="hljs-params">(String message, Person person)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、Person"><a href="#2、Person" class="headerlink" title="2、Person"></a>2、Person</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">protected</span> Mediator mediator;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, Mediator mediator)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.mediator = mediator;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、HouseOwner"><a href="#3、HouseOwner" class="headerlink" title="3、HouseOwner"></a>3、HouseOwner</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HouseOwner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HouseOwner</span><span class="hljs-params">(String name, Mediator mediator)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, mediator);<br>    &#125;<br><br>    <span class="hljs-comment">//与中介者联系</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">constact</span><span class="hljs-params">(String message)</span>&#123;<br>        mediator.constact(message,<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//获取信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getMessage</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;房主&quot;</span>+name+<span class="hljs-string">&quot;获取的信息:&quot;</span>+message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、Tenant"><a href="#4、Tenant" class="headerlink" title="4、Tenant"></a>4、Tenant</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tenant</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tenant</span><span class="hljs-params">(String name, Mediator mediator)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, mediator);<br>    &#125;<br><br>    <span class="hljs-comment">//与中介者联系</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">constact</span><span class="hljs-params">(String message)</span>&#123;<br>        mediator.constact(message,<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//获取信息</span><br>    <span class="hljs-comment">//获取信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getMessage</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;租房者&quot;</span>+name+<span class="hljs-string">&quot;获取的信息:&quot;</span>+message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、MediatorStructure"><a href="#5、MediatorStructure" class="headerlink" title="5、MediatorStructure"></a>5、MediatorStructure</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MediatorStructure</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mediator</span> &#123;<br><br>    <span class="hljs-comment">//中介结构必须知道所有房主和租房者的信息</span><br>    <span class="hljs-keyword">private</span> HouseOwner houseOwner;<br>    <span class="hljs-keyword">private</span> Tenant tenant;<br><br>    <span class="hljs-keyword">public</span> HouseOwner <span class="hljs-title function_">getHouseOwner</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> houseOwner;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHouseOwner</span><span class="hljs-params">(HouseOwner houseOwner)</span> &#123;<br>        <span class="hljs-built_in">this</span>.houseOwner = houseOwner;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Tenant <span class="hljs-title function_">getTenant</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> tenant;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTenant</span><span class="hljs-params">(Tenant tenant)</span> &#123;<br>        <span class="hljs-built_in">this</span>.tenant = tenant;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">constact</span><span class="hljs-params">(String message, Person person)</span> &#123;<br>        <span class="hljs-keyword">if</span> (person == houseOwner) &#123;<br>            <span class="hljs-comment">//如果是房主，则租房者获得信息</span><br>            tenant.getMessage(message);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//反之是房主获得信息</span><br>            houseOwner.getMessage(message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、Client"><a href="#6、Client" class="headerlink" title="6、Client"></a>6、Client</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//房主 租房者 中介机构</span><br>        <span class="hljs-type">MediatorStructure</span> <span class="hljs-variable">mediator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MediatorStructure</span>();<br><br>        <span class="hljs-comment">//房主和租房者只需要知道中介机构即可</span><br>        <span class="hljs-type">HouseOwner</span> <span class="hljs-variable">houseOwner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HouseOwner</span>(<span class="hljs-string">&quot;张三&quot;</span>, mediator);<br>        <span class="hljs-type">Tenant</span> <span class="hljs-variable">tenant</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tenant</span>(<span class="hljs-string">&quot;李四&quot;</span>, mediator);<br><br>        <span class="hljs-comment">//中介机构需要知道房主和租房者</span><br>        mediator.setHouseOwner(houseOwner);<br>        mediator.setTenant(tenant);<br><br>        tenant.constact(<span class="hljs-string">&quot;需要租一间房子&quot;</span>);<br>        houseOwner.constact(<span class="hljs-string">&quot;我有一间房子，你要租吗？？？&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7、结果"><a href="#7、结果" class="headerlink" title="7、结果"></a>7、结果</h3><p><img src="/2022/10/19/09-xing-wei-xing-ming-ling-jie-shi-qi-zhong-jie/image-20221019212554026.png"></p><h2 id="2、优缺点"><a href="#2、优缺点" class="headerlink" title="2、优缺点"></a>2、优缺点</h2><p><strong>优点：</strong></p><ul><li>中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星型结构。</li><li>中介者模式可将各同事对象解耦。中介者有利于各同事之间的松耦合，我们可以独立的改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则”。</li><li>可以减少子类生成，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使各个同事类可被重用，无须对同事类进行扩展。</li></ul><p><strong>缺点：</strong></p><ul><li>在具体中介者类中包含了大量同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li></ul><h2 id="3、应用场景"><a href="#3、应用场景" class="headerlink" title="3、应用场景"></a>3、应用场景</h2><ul><li>当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时。</li><li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li></ul><blockquote><p>参考：<a href="https://juejin.cn/post/6974984853402058760#heading-5">中介者模式</a>、<a href="https://juejin.cn/post/6844903795017646094#heading-38">学习并理解23种设计模式</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 命令 </tag>
            
            <tag> 解释器 </tag>
            
            <tag> 中介 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nohup什么东西？</title>
      <link href="/2022/10/18/nohup-shi-me-dong-xi/"/>
      <url>/2022/10/18/nohup-shi-me-dong-xi/</url>
      
        <content type="html"><![CDATA[<p>所以nohup是什么东西？</p><p><code>nohup</code>是英语 no hangup 的缩写，是不挂断的意思，也就是指程序不退出，用在系统后台不挂断地运行命令，退出终端不会影响程序的运行。</p><p>在工作中，我们可能经常要在服务器上跑程序，有可能要跑的程序耗时很长，需要运行一段时间，我们希望即使关闭终端，程序不受影响，继续运行。在Linux中的<code>nohup</code>命令可以达到这种效果。</p><h2 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> 命令 参数<br><span class="hljs-built_in">nohup</span> 选项<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">--<span class="hljs-built_in">help</span>     <span class="hljs-comment"># 显示此帮助信息并退出</span><br>--version  <span class="hljs-comment"># 显示版本信息并退出</span><br></code></pre></td></tr></table></figure><h2 id="Demo案例"><a href="#Demo案例" class="headerlink" title="Demo案例"></a>Demo案例</h2><p>准备一个test.py程序，功能是每隔2秒会输出”hello nohup!”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time <br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello nohup!&quot;</span>)<br>    time.sleep(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>然后使用<code>nohup python3 test.py</code>运行。</p><p>使用nohup命令时，程序的输出会默认重定向到一个nohup.out文件下。若是想要输出到指定的文件，则可以另外指定输出文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> python3 test.py &gt; out.txt<br></code></pre></td></tr></table></figure><p>但是现在还做不到让程序在后台运行，如果想要让程序在后台运行的话，可以加上 &amp; </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> python3 test.py &gt; out.txt &amp; <br></code></pre></td></tr></table></figure><p>此时关掉终端再重新打开，使用ps命令查看一下进程，发现程序还在运行。</p><p>这里如果想要把标准错误和标准输出都重定向到指定的out.txt文件中，可以使用<code>2&gt;&amp;1</code>符号，<code>2&gt;&amp;1</code>符号的意思是将将标准错误 2 重定向到标准输出 &amp;1。</p><ul><li>0 stdin (standard input，标准输入)</li><li>1 stdout (standard output，标准输出)</li><li>2 stderr (standard error，标准错误输出)</li></ul><p>具体详情见：<a href>2&gt;&amp;1到底是什么意思？</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> python3 test.py &gt; out.txt 2&gt;&amp;1 &amp; <br></code></pre></td></tr></table></figure><p><code>nohup</code>命令结合<code>&amp;</code>符号可以使进程在后台运行，即使关闭了终端依然不受影响。</p><p>那么如何结束进程呢？</p><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>执行一个<code>kill</code>命令时，实际上是发送了一个信号给系统，让它去结束掉一些不正常的应用进程。 可以使用<code>kill -l</code>命令看到所有信号的列表：</p><p><img src="/2022/10/18/nohup-shi-me-dong-xi/image-20221018215614795.png"></p><p>下面是一些常用信号的含义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">(1)SIGHUP 终端线路挂断，终止进程<br>(2)SIGINT 中断进程（同 Ctrl + C）<br>(3)SIGQUIT 退出进程（同 Ctrl + \）<br>(15)SIGTERM 终止进程<br>(9)SIGKILL 强制终止进程<br>(18)SIGCONT 继续（与SIGSTOP相反， <span class="hljs-built_in">fg</span>/bg命令）<br>(19)SIGSTOP 暂停（同 Ctrl + Z）<br></code></pre></td></tr></table></figure><p>常用到的有15 和 9</p><p>(15)SIGTERM：也就是执行<code>kill -15 pid</code>命令，这里”-15”即代表SIGTERM信号。<br> 注意：SIGTERM是默认选项，也就是说执行<code>kill pid</code>和<code>kill -15 pid</code>是等价的。<br> 执行此指令时操作系统会发送一个SIGTERM信号给对应的程序，当程序接收到该信号后，可以用一段时间来正常关闭，一般会先保存进度并释放资源，然后再停止，也就是不一定会立即停止进程，比如程序正在等待IO，可能就不会立马停止运行。也就是说，(15)SIGTERM信号不是强制停止，是可以被忽略的。</p><p>(9)SIGKILL：也就是执行<code>kill -9 pid</code>命令，这里”-9”即代表SIGKILL信号。<br> 是必杀信号，此信号强制进程立即停止运行。程序不能忽略此信号，而未保存的进度将会丢失，从而可能会影响服务的再次启动，此命令应该慎用。</p><p>kill语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> 信号或选项 pid<br></code></pre></td></tr></table></figure><p>默认信号（当没有指定的时候）是SIGTERM。当它不起作用时，可以使用<code>kill -9 pid</code>命令来强制kill掉一个进程。</p><p>应用的pid可以使用以下的命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef<br>ps -aux<br></code></pre></td></tr></table></figure><p>二者都可以查看到pid</p><p><img src="/2022/10/18/nohup-shi-me-dong-xi/image-20221018215918762.png"></p><p>比如想要kill掉PID为108的进程，只需要执行<code>kill -9 108</code>即可。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> nohup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-数据库</title>
      <link href="/2022/10/17/springboot-shu-ju-ku/"/>
      <url>/2022/10/17/springboot-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="一、spring-boot-集成-Jdbc-Template"><a href="#一、spring-boot-集成-Jdbc-Template" class="headerlink" title="一、spring-boot 集成 Jdbc Template"></a>一、spring-boot 集成 Jdbc Template</h2><p>整体结构：</p><p><img src="/2022/10/17/springboot-shu-ju-ku/image-20221017184658161.png" alt="整体结构"></p><h3 id="1、导入依赖"><a href="#1、导入依赖" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、application-yml"><a href="#2、application-yml" class="headerlink" title="2、application.yml"></a>2、application.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/demo</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/spring-boot-demo?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;serverTimezone=GMT%2B8</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span><br>    <span class="hljs-attr">initialization-mode:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">continue-on-error:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">schema:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;classpath:db/schema.sql&quot;</span><br>    <span class="hljs-attr">data:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;classpath:db/data.sql&quot;</span><br>    <span class="hljs-attr">hikari:</span><br>      <span class="hljs-attr">minimum-idle:</span> <span class="hljs-number">5</span><br>      <span class="hljs-attr">connection-test-query:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">DUAL</span><br>      <span class="hljs-attr">maximum-pool-size:</span> <span class="hljs-number">20</span><br>      <span class="hljs-attr">auto-commit:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">idle-timeout:</span> <span class="hljs-number">30000</span><br>      <span class="hljs-attr">pool-name:</span> <span class="hljs-string">SpringBootDemoHikariCP</span><br>      <span class="hljs-attr">max-lifetime:</span> <span class="hljs-number">60000</span><br>      <span class="hljs-attr">connection-timeout:</span> <span class="hljs-number">30000</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.xkcoding:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h3 id="3、实体类User"><a href="#3、实体类User" class="headerlink" title="3、实体类User"></a>3、实体类User</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Table(name = &quot;orm_user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主键</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Pk</span><br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加密后的密码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加密使用的盐</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String salt;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 邮箱</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String email;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 手机号码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Column(name = &quot;phone_number&quot;)</span><br>    <span class="hljs-keyword">private</span> String phoneNumber;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 状态，-1：逻辑删除，0：禁用，1：启用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer status;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Column(name = &quot;create_time&quot;)</span><br>    <span class="hljs-keyword">private</span> Date createTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上次登录时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Column(name = &quot;last_login_time&quot;)</span><br>    <span class="hljs-keyword">private</span> Date lastLoginTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上次更新时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Column(name = &quot;last_update_time&quot;)</span><br>    <span class="hljs-keyword">private</span> Date lastUpdateTime;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、UserDao继承BaseDao"><a href="#4、UserDao继承BaseDao" class="headerlink" title="4、UserDao继承BaseDao"></a>4、UserDao继承BaseDao</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseDao</span>&lt;User, Long&gt; &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserDao</span><span class="hljs-params">(JdbcTemplate jdbcTemplate)</span> &#123;<br>        <span class="hljs-built_in">super</span>(jdbcTemplate);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 操作影响行数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">insert</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.insert(user, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据主键删除用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 操作影响行数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">delete</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.deleteById(id);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id   主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 操作影响行数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">update</span><span class="hljs-params">(User user, Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.updateById(user, id, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据主键获取用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> id对应的用户</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">selectById</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.findOneById(id);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据查询条件获取用户列表</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户查询条件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">selectUserList</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.findByExample(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、UserServiceImpl实现IUserService接口"><a href="#5、UserServiceImpl实现IUserService接口" class="headerlink" title="5、UserServiceImpl实现IUserService接口"></a>5、UserServiceImpl实现IUserService接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceImpl</span><span class="hljs-params">(UserDao userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户实体</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 保存成功 &#123;<span class="hljs-doctag">@code</span> true&#125; 保存失败 &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">save</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rawPass</span> <span class="hljs-operator">=</span> user.getPassword();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">salt</span> <span class="hljs-operator">=</span> IdUtil.simpleUUID();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> SecureUtil.md5(rawPass + Const.SALT_PREFIX + salt);<br>        user.setPassword(pass);<br>        user.setSalt(salt);<br>        <span class="hljs-keyword">return</span> userDao.insert(user) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 删除成功 &#123;<span class="hljs-doctag">@code</span> true&#125; 删除失败 &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">delete</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> userDao.delete(id) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户实体</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id   主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 更新成功 &#123;<span class="hljs-doctag">@code</span> true&#125; 更新失败 &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">update</span><span class="hljs-params">(User user, Long id)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">exist</span> <span class="hljs-operator">=</span> getUser(id);<br>        <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(user.getPassword())) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rawPass</span> <span class="hljs-operator">=</span> user.getPassword();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">salt</span> <span class="hljs-operator">=</span> IdUtil.simpleUUID();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> SecureUtil.md5(rawPass + Const.SALT_PREFIX + salt);<br>            user.setPassword(pass);<br>            user.setSalt(salt);<br>        &#125;<br>        BeanUtil.copyProperties(user, exist, CopyOptions.create().setIgnoreNullValue(<span class="hljs-literal">true</span>));<br>        exist.setLastUpdateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTime</span>());<br>        <span class="hljs-keyword">return</span> userDao.update(exist, id) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取单个用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 单个用户对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> userDao.findOneById(id);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取用户列表</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户实体</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUser</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> userDao.findByExample(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、结果"><a href="#6、结果" class="headerlink" title="6、结果"></a>6、结果</h3><p><img src="/2022/10/17/springboot-shu-ju-ku/image-20221017184607196.png"></p><h2 id="二、spring-boot-集成原生mybatis"><a href="#二、spring-boot-集成原生mybatis" class="headerlink" title="二、spring-boot 集成原生mybatis"></a>二、spring-boot 集成原生mybatis</h2><p>spring-boot 集成原生mybatis，使用 <a href="https://github.com/mybatis/spring-boot-starter">mybatis-spring-boot-starter</a> 集成</p><h3 id="1、导入依赖-1"><a href="#1、导入依赖-1" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、主启动类"><a href="#2、主启动类" class="headerlink" title="2、主启动类"></a>2、主启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(basePackages = &#123;&quot;com.xkcoding.orm.mybatis.mapper&quot;&#125;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootDemoOrmMybatisApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SpringBootDemoOrmMybatisApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>记得加 @MapperScan 注解</p><h3 id="3、application-yml"><a href="#3、application-yml" class="headerlink" title="3、application.yml"></a>3、application.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/spring-boot-demo?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;serverTimezone=GMT%2B8</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span><br>    <span class="hljs-attr">initialization-mode:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">continue-on-error:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">schema:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;classpath:db/schema.sql&quot;</span><br>    <span class="hljs-attr">data:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;classpath:db/data.sql&quot;</span><br>    <span class="hljs-attr">hikari:</span><br>      <span class="hljs-attr">minimum-idle:</span> <span class="hljs-number">5</span><br>      <span class="hljs-attr">connection-test-query:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">DUAL</span><br>      <span class="hljs-attr">maximum-pool-size:</span> <span class="hljs-number">20</span><br>      <span class="hljs-attr">auto-commit:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">idle-timeout:</span> <span class="hljs-number">30000</span><br>      <span class="hljs-attr">pool-name:</span> <span class="hljs-string">SpringBootDemoHikariCP</span><br>      <span class="hljs-attr">max-lifetime:</span> <span class="hljs-number">60000</span><br>      <span class="hljs-attr">connection-timeout:</span> <span class="hljs-number">30000</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.xkcoding:</span> <span class="hljs-string">debug</span><br>    <span class="hljs-attr">com.xkcoding.orm.mybatis.mapper:</span> <span class="hljs-string">trace</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-comment"># 下划线转驼峰</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mappers/*.xml</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.xkcoding.orm.mybatis.entity</span><br></code></pre></td></tr></table></figure><h3 id="4、UserMapper接口"><a href="#4、UserMapper接口" class="headerlink" title="4、UserMapper接口"></a>4、UserMapper接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询所有用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Select(&quot;SELECT * FROM orm_user&quot;)</span><br>    List&lt;User&gt; <span class="hljs-title function_">selectAllUser</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id查询用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 当前id的用户，不存在则是 &#123;<span class="hljs-doctag">@code</span> null&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Select(&quot;SELECT * FROM orm_user WHERE id = #&#123;id&#125;&quot;)</span><br>    User <span class="hljs-title function_">selectUserById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Long id)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功 - &#123;<span class="hljs-doctag">@code</span> 1&#125; 失败 - &#123;<span class="hljs-doctag">@code</span> 0&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;user&quot;)</span> User user)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 主键id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功 - &#123;<span class="hljs-doctag">@code</span> 1&#125; 失败 - &#123;<span class="hljs-doctag">@code</span> 0&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Long id)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、UserMapper-xml"><a href="#5、UserMapper-xml" class="headerlink" title="5、UserMapper.xml"></a>5、UserMapper.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.xkcoding.orm.mybatis.mapper.UserMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;saveUser&quot;</span>&gt;</span><br>        INSERT INTO `orm_user` (`name`,<br>                                `password`,<br>                                `salt`,<br>                                `email`,<br>                                `phone_number`,<br>                                `status`,<br>                                `create_time`,<br>                                `last_login_time`,<br>                                `last_update_time`)<br>        VALUES (#&#123;user.name&#125;,<br>                #&#123;user.password&#125;,<br>                #&#123;user.salt&#125;,<br>                #&#123;user.email&#125;,<br>                #&#123;user.phoneNumber&#125;,<br>                #&#123;user.status&#125;,<br>                #&#123;user.createTime&#125;,<br>                #&#123;user.lastLoginTime&#125;,<br>                #&#123;user.lastUpdateTime&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span>&gt;</span><br>        DELETE<br>        FROM `orm_user`<br>        WHERE `id` = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserMapperTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SpringBootDemoOrmMybatisApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectAllUser</span><span class="hljs-params">()</span> &#123;<br>        List&lt;User&gt; userList = userMapper.selectAllUser();<br>        Assert.assertTrue(CollUtil.isNotEmpty(userList));<br>        log.debug(<span class="hljs-string">&quot;【userList】= &#123;&#125;&quot;</span>, userList);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectUserById</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.selectUserById(<span class="hljs-number">1L</span>);<br>        Assert.assertNotNull(user);<br>        log.debug(<span class="hljs-string">&quot;【user】= &#123;&#125;&quot;</span>, user);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">salt</span> <span class="hljs-operator">=</span> IdUtil.fastSimpleUUID();<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> User.builder().name(<span class="hljs-string">&quot;testSave3&quot;</span>).password(SecureUtil.md5(<span class="hljs-string">&quot;123456&quot;</span> + salt)).salt(salt).email(<span class="hljs-string">&quot;testSave3@xkcoding.com&quot;</span>).phoneNumber(<span class="hljs-string">&quot;17300000003&quot;</span>).status(<span class="hljs-number">1</span>).lastLoginTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTime</span>()).createTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTime</span>()).lastUpdateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTime</span>()).build();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> userMapper.saveUser(user);<br>        Assert.assertEquals(<span class="hljs-number">1</span>, i);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> userMapper.deleteById(<span class="hljs-number">1L</span>);<br>        Assert.assertEquals(<span class="hljs-number">1</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7、参考"><a href="#7、参考" class="headerlink" title="7、参考"></a>7、参考</h3><ul><li>Mybatis官方文档：<a href="http://www.mybatis.org/mybatis-3/zh/index.html">http://www.mybatis.org/mybatis-3/zh/index.html</a></li><li>Mybatis官方脚手架文档：<a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></li><li>Mybatis整合Spring Boot官方demo：<a href="https://github.com/mybatis/spring-boot-starter/tree/master/mybatis-spring-boot-samples">https://github.com/mybatis/spring-boot-starter/tree/master/mybatis-spring-boot-samples</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-配置文件以及日志</title>
      <link href="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/"/>
      <url>/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、多个配置文件的读取"><a href="#一、多个配置文件的读取" class="headerlink" title="一、多个配置文件的读取"></a>一、多个配置文件的读取</h2><p>现在有多个配置文件，运行时要读取其中一个配置文件，怎么选择？</p><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221014172131119.png"></p><p>多个配置文件的读取，在设置好property类后，可以在application中选择要读取的对象，如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/demo</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><p>当要读取 application-dev 时，只需将第七行代码改为dev，当要读取application-prod时，只需将第七行代码改为prod。</p><p>如下是设置为dev的运行结果：</p><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221014172456012.png"></p><h2 id="二、spring-boot-集成-spring-boot-starter-actuator"><a href="#二、spring-boot-集成-spring-boot-starter-actuator" class="headerlink" title="二、spring-boot 集成 spring-boot-starter-actuator"></a>二、spring-boot 集成 spring-boot-starter-actuator</h2><p>actuator用于监控 spring-boot 的启动和运行状态</p><h3 id="1、pom文件"><a href="#1、pom文件" class="headerlink" title="1、pom文件"></a>1、pom文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、application-yml"><a href="#2、application-yml" class="headerlink" title="2、application.yml"></a>2、application.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/demo</span><br><span class="hljs-comment"># 若要访问端点信息，需要配置用户名和密码</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">security:</span><br>    <span class="hljs-attr">user:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">zhaibiao</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>      <br><span class="hljs-attr">management:</span><br>  <span class="hljs-comment"># 端点信息接口使用的端口，为了和主系统接口使用的端口进行分离</span><br>  <span class="hljs-attr">server:</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8090</span><br>    <span class="hljs-attr">servlet:</span><br>      <span class="hljs-attr">context-path:</span> <span class="hljs-string">/sys</span><br>  <span class="hljs-comment"># 端点健康情况，默认值&quot;never&quot;，设置为&quot;always&quot;可以显示硬盘使用情况和线程情况</span><br>  <span class="hljs-attr">endpoint:</span><br>    <span class="hljs-attr">health:</span><br>      <span class="hljs-attr">show-details:</span> <span class="hljs-string">always</span><br>  <span class="hljs-comment"># 设置端点暴露的哪些内容，默认[&quot;health&quot;,&quot;info&quot;]，设置&quot;*&quot;代表暴露所有可访问的端点</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3、端点暴露地址"><a href="#3、端点暴露地址" class="headerlink" title="3、端点暴露地址"></a>3、端点暴露地址</h3><ol><li>打开浏览器，访问：<a href="http://localhost:8090/sys/actuator/mappings">http://localhost:8090/sys/actuator/mappings</a> ，输入用户名(zhaibiao)密码(123456)即可看到所有的mapping信息</li><li>访问：<a href="http://localhost:8090/sys/actuator/beans">http://localhost:8090/sys/actuator/beans</a> ，输入用户名(zhaibiao)密码(123456)即可看到所有 Spring 管理的Bean</li></ol><ul><li>actuator文档：<a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#production-ready">https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#production-ready</a></li></ul><h3 id="4、结果"><a href="#4、结果" class="headerlink" title="4、结果"></a>4、结果</h3><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221017161554284.png" alt="beans"></p><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221017161608902.png" alt="mappings"></p><h2 id="三、spring-boot集成admin"><a href="#三、spring-boot集成admin" class="headerlink" title="三、spring-boot集成admin"></a>三、spring-boot集成admin</h2><h3 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h3><h4 id="1、导入依赖"><a href="#1、导入依赖" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h4><p>服务端配置文件不需要太多配置，端口号即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8000</span><br></code></pre></td></tr></table></figure><h4 id="3、主启动类"><a href="#3、主启动类" class="headerlink" title="3、主启动类"></a>3、主启动类</h4><p>必须要在主启动类上加 <code>@EnableAdminServer</code> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAdminServer</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootDemoAdminServerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SpringBootDemoAdminServerApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h3><h4 id="1、导入依赖-1"><a href="#1、导入依赖-1" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2、配置文件-1"><a href="#2、配置文件-1" class="headerlink" title="2、配置文件"></a>2、配置文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/demo</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-comment"># Spring Boot Admin展示的客户端项目名，不设置，会使用自动生成的随机id</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">spring-boot-demo-admin-client</span><br>  <span class="hljs-attr">boot:</span><br>    <span class="hljs-attr">admin:</span><br>      <span class="hljs-attr">client:</span><br>        <span class="hljs-comment"># Spring Boot Admin 服务端地址</span><br>        <span class="hljs-attr">url:</span> <span class="hljs-string">&quot;http://localhost:8000/&quot;</span><br>        <span class="hljs-attr">instance:</span><br>          <span class="hljs-attr">metadata:</span><br>            <span class="hljs-comment"># 客户端端点信息的安全认证信息</span><br>            <span class="hljs-attr">user.name:</span> <span class="hljs-string">$&#123;spring.security.user.name&#125;</span><br>            <span class="hljs-attr">user.password:</span> <span class="hljs-string">$&#123;spring.security.user.password&#125;</span><br>  <span class="hljs-attr">security:</span><br>    <span class="hljs-attr">user:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">zhaibiao</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoint:</span><br>    <span class="hljs-attr">health:</span><br>      <span class="hljs-comment"># 端点健康情况，默认值&quot;never&quot;，设置为&quot;always&quot;可以显示硬盘使用情况和线程情况</span><br>      <span class="hljs-attr">show-details:</span> <span class="hljs-string">always</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-comment"># 设置端点暴露的哪些内容，默认[&quot;health&quot;,&quot;info&quot;]，设置&quot;*&quot;代表暴露所有可访问的端点</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span><br></code></pre></td></tr></table></figure><h4 id="3、控制类（用来测试）"><a href="#3、控制类（用来测试）" class="headerlink" title="3、控制类（用来测试）"></a>3、控制类（用来测试）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IndexController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(value = &#123;&quot;&quot;, &quot;/&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This is a Spring Boot Admin Client.&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、结果"><a href="#3、结果" class="headerlink" title="3、结果"></a>3、结果</h3><p>运行步骤：</p><ol><li>先启动server服务端，启动管控台服务端程序</li><li>再启动client客户端，注册到服务端</li><li>观察服务端里，客户端程序的运行状态等信息</li></ol><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221017163939849.png" alt="server"></p><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221017164045955.png" alt="client"></p><h2 id="四、spring-boot集成logback"><a href="#四、spring-boot集成logback" class="headerlink" title="四、spring-boot集成logback"></a>四、spring-boot集成logback</h2><p>演示如何使用 logback 记录程序运行过程中的日志，以及如何配置 logback，可以同时生成控制台日志和文件日志记录，文件日志以日期和大小进行拆分生成。</p><h3 id="1、导入依赖-2"><a href="#1、导入依赖-2" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>demo-logback<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、配置文件-2"><a href="#2、配置文件-2" class="headerlink" title="2、配置文件"></a>2、配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/demo</span><br></code></pre></td></tr></table></figure><p>配置端口</p><h3 id="3、logback-spring-xml"><a href="#3、logback-spring-xml" class="headerlink" title="3、logback-spring.xml"></a>3、logback-spring.xml</h3><p>在resources下建立logback-spring.xml用于配置logback</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_ERROR_PATTERN&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;FILE_LOG_PATTERN:-%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125; $&#123;LOG_LEVEL_PATTERN:-%5p&#125; $&#123;PID:- &#125; --- [%t] %-40.40logger&#123;39&#125; %file:%line: %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>INFO<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_INFO&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--如果只是想要 Info 级别的日志，只是过滤 info 还是会输出 Error 日志，因为 Error 的级别高， 所以我们使用下面的策略，可以避免输出 Error 的日志--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--过滤 Error--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>ERROR<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--匹配到就禁止--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--没有匹配到就允许--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。--&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;File&gt;logs/info.demo-logback.log&lt;/File&gt;--&gt;</span><br>  <span class="hljs-comment">&lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>logs/demo-logback/info.created_on_%d&#123;yyyy-MM-dd&#125;.part_%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--只保留最近90天的日志--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>90<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志--&gt;</span><br>   <span class="hljs-comment">&lt;!--&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- maxFileSize:这是活动文件的大小，默认值是10MB,本篇设置为1KB，只是为了演示 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>2MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;--&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;maxFileSize&gt;1KB&lt;/maxFileSize&gt;--&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;/triggeringPolicy&gt;--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处设置字符集 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_ERROR&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--如果只是想要 Error 级别的日志，那么需要过滤一下，默认是 info 级别的，ThresholdFilter--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>Error<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。--&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;File&gt;logs/error.demo-logback.log&lt;/File&gt;--&gt;</span><br>  <span class="hljs-comment">&lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>logs/demo-logback/error.created_on_%d&#123;yyyy-MM-dd&#125;.part_%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--只保留最近90天的日志--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>90<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- maxFileSize:这是活动文件的大小，默认值是10MB,本篇设置为1KB，只是为了演示 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>2MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_ERROR_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处设置字符集 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE_INFO&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE_ERROR&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4、主启动类进行测试"><a href="#4、主启动类进行测试" class="headerlink" title="4、主启动类进行测试"></a>4、主启动类进行测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootDemoLogbackApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(SpringBootDemoLogbackApplication.class, args);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> context.getBeanDefinitionNames().length;<br>        log.trace(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);<br>        log.debug(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);<br>        log.info(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);<br>        log.warn(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);<br>        log.error(<span class="hljs-string">&quot;Spring boot启动初始化了 &#123;&#125; 个 Bean&quot;</span>, length);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//int j = 1 / i;</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;【SpringBootDemoLogbackApplication】启动异常：&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、结果"><a href="#5、结果" class="headerlink" title="5、结果"></a>5、结果</h3><p>报错日志如下：</p><p><img src="/2022/10/14/springboot-pei-zhi-wen-jian-yi-ji-ri-zhi/image-20221017170557025.png" alt="Error"></p><blockquote><p>TODO</p></blockquote><h2 id="五、spring-boot-使用-AOP-切面的方式记录-web-请求日志"><a href="#五、spring-boot-使用-AOP-切面的方式记录-web-请求日志" class="headerlink" title="五、spring-boot 使用 AOP 切面的方式记录 web 请求日志"></a>五、spring-boot 使用 AOP 切面的方式记录 web 请求日志</h2><h2 id="六、spring-boot-统一异常处理"><a href="#六、spring-boot-统一异常处理" class="headerlink" title="六、spring-boot 统一异常处理"></a>六、spring-boot 统一异常处理</h2>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 配置文件 </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v2-哈希表</title>
      <link href="/2022/10/13/v2-ha-xi-biao/"/>
      <url>/2022/10/13/v2-ha-xi-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="一、理论基础"><a href="#一、理论基础" class="headerlink" title="一、理论基础"></a>一、理论基础</h1><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p><p>哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。</p><p>哈希表能解决什么问题呢？一般哈希表是用来判断一个元素是否出现在元素里。</p><p>例如要查询一个名字是否在这所学校里，要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。</p><h2 id="1、哈希函数"><a href="#1、哈希函数" class="headerlink" title="1、哈希函数"></a>1、哈希函数</h2><p>哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。</p><p>哈希函数通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p><p>但是若是哈希表不够大，而hashCode得到的数值又大于哈希表的长度呢？一般都是用取模来解决这个问题。</p><p>那么问题又来了，若是有很多同学通过hashCode得到的数值都相等呢？这个现象就叫哈希碰撞</p><h2 id="2、哈希碰撞"><a href="#2、哈希碰撞" class="headerlink" title="2、哈希碰撞"></a>2、哈希碰撞</h2><p>如下，小李和小王都映射到索引下标1的位置，产生哈希碰撞。</p><p><img src="/2022/10/13/v2-ha-xi-biao/image-20221013103434324.png"></p><p>解决办法有两个</p><h3 id="1、拉链法"><a href="#1、拉链法" class="headerlink" title="1、拉链法"></a>1、拉链法</h3><p>拉链法简而言之就是产生碰撞时，让发生冲突的元素都储存在链表中。</p><p><img src="/2022/10/13/v2-ha-xi-biao/image-20221013103638804.png"></p><h3 id="2、线性探测法"><a href="#2、线性探测法" class="headerlink" title="2、线性探测法"></a>2、线性探测法</h3><p>线性探测法是当产生冲突时，往下顺延至没有数据的那一位，如下图。</p><p><img src="/2022/10/13/v2-ha-xi-biao/image-20221013103733434.png"></p><p>所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。</p><h2 id="3、常见哈希结构"><a href="#3、常见哈希结构" class="headerlink" title="3、常见哈希结构"></a>3、常见哈希结构</h2><ul><li>数组</li><li>set</li><li>map</li></ul><h2 id="4、常用方法"><a href="#4、常用方法" class="headerlink" title="4、常用方法"></a>4、常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 是否包含关键字</span><br>map.containsKey(keys);<br><span class="hljs-comment">// 添加关键字和值</span><br>map.put(keys, value);<br><span class="hljs-comment">// 获取所有键的值</span><br>map.values();<br><br><span class="hljs-comment">// 字符串转字符数组</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;string&quot;</span>;<br><span class="hljs-type">char</span>[] ch = str.toCharArray();<br><span class="hljs-comment">// 字符数组转字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">keys</span> <span class="hljs-operator">=</span> String.valueOf(ch);<br></code></pre></td></tr></table></figure><h1 id="二、经典题"><a href="#二、经典题" class="headerlink" title="二、经典题"></a>二、经典题</h1><h2 id="1、数组中只出现一次的两个数字"><a href="#1、数组中只出现一次的两个数字" class="headerlink" title="1、数组中只出现一次的两个数字"></a>1、数组中只出现一次的两个数字</h2><p>牛客原题链接：<a href="https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8?tpId=295&tqId=745&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=/exam/oj"><strong>BM52</strong> <strong>数组中只出现一次的两个数字</strong></a></p><h3 id="1、方法一：哈希表"><a href="#1、方法一：哈希表" class="headerlink" title="1、方法一：哈希表"></a>1、方法一：哈希表</h3><p>看到题目，很容易想到用一个哈希表来记录每个数出现的次数，并得到只出现一次的数字</p><p>具体思路如下：</p><p>1、创建一个哈希表</p><p>2、当数组元素没有在哈希表中成为key的时候，put进哈希表，当已存在的时候，则remove掉。</p><p>3、最后哈希表中剩下的key就是只出现一次的数字</p><p>4、遍历key然后返回结果</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] FindNumsAppearOnce (<span class="hljs-type">int</span>[] array) &#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-comment">// 用于返回结果</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 创建一个哈希表</span><br>        HashMap&lt;Integer,Object&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++)&#123;<br>            <span class="hljs-comment">// 如果已经被当作key了，那就直接remove掉</span><br>            <span class="hljs-keyword">if</span>(set.containsKey(array[i]))&#123;<br>                set.remove(array[i],<span class="hljs-literal">null</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 否则就添加进去</span><br>                set.put(array[i],<span class="hljs-literal">null</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 最后拿出来放进返回结果的数组中进行返回</span><br>        <span class="hljs-keyword">for</span>(Integer num:set.keySet())&#123;<br>            res[i++] = num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>当然，时间复杂度和空间复杂度都是O(n)，但是这道题要求是空间复杂度为O(1)，So?</p><h3 id="2、方法二：双指针法"><a href="#2、方法二：双指针法" class="headerlink" title="2、方法二：双指针法"></a>2、方法二：双指针法</h3><p>双指针法的前提是要数组有序，可以用Arrays.sort来对数组进行排序。定义两个指针，若是后一个元素和当前元素不等，说明什么？<code>说明前一个元素只出现了一次</code>。这句话有歧义，可能有人会说我从 1, 1, 2中的第二个位置的1和2进行比较，就说明不了1只出现了一次。这个问题如何解决？很好办，只需要从0开始遍历即可，若是出现后一个元素和当前元素相等，就直接将指针后移两位。这样就解决问题了。</p><p>具体思路如下：</p><ol><li>对原始数组进行排序</li><li>遍历数组，若是 i + 1 等于数组的长度 或者 下一个元素不等于当前元素，就将  i 存入返回数组中，并后移一位；否则后移两位</li></ol><blockquote><p>注意，若是 i + 1 等于数组的长度，说明此时i已经是最后一个元素，直接放入返回数组中即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] FindNumsAppearOnce (<span class="hljs-type">int</span>[] array) &#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-comment">//   双指针法</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        Arrays.sort(array);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">two</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> == array.length || array[i + <span class="hljs-number">1</span>] != array[i]) &#123;<br>                res[two] = array[i];<br>                two++;<br>            &#125;   <br>            <span class="hljs-keyword">else</span><br>                i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3、方法三：位运算"><a href="#3、方法三：位运算" class="headerlink" title="3、方法三：位运算"></a>3、<code>方法三：位运算</code></h3><p>先来了解一下什么叫异或运算</p><p>异或运算是基于二进制的位运算，采用符号XOR或者^来表示，运算规则是就与二进制，如果是同值取0、异值取1。</p><p><code>异或运算的性质</code>：</p><ol><li>交换律 可以任意交换运算因子，结果不变。</li><li>结合律 （a^b）^c=a^(a^c)</li><li>对于任何数x，都有x^x=0,x^0=x,同自己求异或运算为0，同0求异或运算结果为自己</li><li>自反性，A^B^B=A^0=A。这个性质可以用来求哪一个数为一个</li></ol><p>这道题运用的就是第四个性质，自反性</p><blockquote><p>举个例子：</p><p>4 ⊕ 4 = 0，将4化为二进制为 0100</p><p>所以 0100</p><p>异或 0100</p><p>得到 0000</p><p>4 ⊕ 4 ⊕ 5 = 5</p><p>则 0100</p><p> 0100</p><p> 0101</p><p>得到 0101</p><p>我们可以看到上面的运算过程，因为4=4，两者相等异或结果为0。所以0异或任意数都等于任意数。</p></blockquote><p>所以，当只有一个出现了一次的数字的时候，则只需要将全部数进行异或运算，运算结果就剩下了那个只出现一次的数字了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] singleNumber(<span class="hljs-type">int</span>[] nums) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)  <span class="hljs-comment">// 1. 遍历 nums 执行异或运算</span><br>        x ^= num;<br>    <span class="hljs-keyword">return</span> x;            <span class="hljs-comment">// 2. 返回出现一次的数字 x</span><br>&#125;<br></code></pre></td></tr></table></figure><p>问题来了：上述的思想是多个数中找到只出现一次的数字，但是本题是找两个，比如输入 1,4,1,6。最后剩下4⊕6。怎么办？</p><p>那就进行分组嘛，分成两个组。</p><p>但是分组的依据是什么呢？先来看看按奇数偶数分，按奇数偶数分不难实现，只需要将其 &amp;1 即可，原理是奇数的最低位一定是1，偶数的最低位一定是0。但是也不能保证只出现一次的数字正好是一奇一偶，或许人家是两个奇数两个偶数呢？所以按奇数偶数的分法不可行。</p><p>确定分组依据之前，先看一个小例子，比如要区分0100和0110，也就是4和6，怎么区分呢？可以从最低位刚开始不同的位置区分，0100⊕0110 = 0010，那么可以用0010来区分。异或运算<code>正好</code>用的上。</p><p>那么问题就变的很简单，具体思路如下：</p><ol><li>先将全部数进行异或运算，得出最终结果</li><li>找到可以充当分组的数</li><li>分组，同时求出出现一次的数字</li><li>进行非降序排列</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] FindNumsAppearOnce (<span class="hljs-type">int</span>[] array) &#123;<br>        <span class="hljs-comment">// write code here</span><br>    <br>        <span class="hljs-comment">// 先将全部数进行异或运算，得出最终结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : array) &#123;<br>            temp ^= num;<br>        &#125;<br>    <br>        <span class="hljs-comment">// 找到那个可以充当分组去进行与运算的数</span><br>        <span class="hljs-comment">// 从最低位开始找起</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mask</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> ((tmp &amp; mask) == <span class="hljs-number">0</span>) &#123;<br>            mask &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br>    <br>        <span class="hljs-comment">// 进行分组，分成两组，转换为两组 求出现一次的数字 去求</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : array) &#123;<br>            <span class="hljs-keyword">if</span> ((num &amp; mask) == <span class="hljs-number">0</span>) &#123;<br>                a ^= num;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                b ^= num;<br>            &#125;<br>        &#125;<br>    <br>        <span class="hljs-comment">// 因为题目要求小的数放前面，所以这一做个判断</span><br>        <span class="hljs-keyword">if</span> (a &gt; b) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a;<br>            a = b;<br>            b = c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;a, b&#125;;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>第14行的 &lt;&lt; 符号，左移运算符。效果：通过从右侧推入零并让最左边的位脱落来向左移动。比如9 &lt;&lt; 1 等同于 1001 &lt;&lt; 1 ，结果就是0010，换做十进制也就是2</p></blockquote><p>上述的第30到32行的代码，也可以用异或来实现a和b数值的交换。<code>这也是异或性质的运用。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">a = a ^ b    <span class="hljs-comment">// a = a ^ b</span><br>b = a ^ b    <span class="hljs-comment">// b = a ^ b ^ b ,  ==&gt; b = a</span><br>a = a ^ b    <span class="hljs-comment">// a = a ^ b ^ a ,  ==&gt; a = b</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08-行为型-状态-迭代器</title>
      <link href="/2022/10/12/08-xing-wei-xing-zhuang-tai-die-dai-qi/"/>
      <url>/2022/10/12/08-xing-wei-xing-zhuang-tai-die-dai-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="一、状态模式"><a href="#一、状态模式" class="headerlink" title="一、状态模式"></a>一、状态模式</h1><p>状态模式（State Pattern）：它主要用来解决对象在多种状态转换时，需要对外 输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换。</p><p>当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了 其类。</p><h2 id="1、Demo案例-抽奖活动问题"><a href="#1、Demo案例-抽奖活动问题" class="headerlink" title="1、Demo案例-抽奖活动问题"></a>1、Demo案例-抽奖活动问题</h2><blockquote><p>需求</p></blockquote><ol><li>假如每参加一次这个活动要 扣除用户50积分，中奖概率 是10%  </li><li>奖品数量固定，抽完就不能 抽奖 </li><li>活动有四个状态: 可以抽奖、 不能抽奖、发放奖品和奖品 领完 </li><li>活动的四个状态转换关系图 </li></ol><p><img src="/2022/10/12/08-xing-wei-xing-zhuang-tai-die-dai-qi/image-20221012210047466.png"></p><p>状态模式解决该问题类图：</p><p><img src="/2022/10/12/08-xing-wei-xing-zhuang-tai-die-dai-qi/image-20221012211016481.png"></p><h3 id="1、State"><a href="#1、State" class="headerlink" title="1、State"></a>1、State</h3><p>状态抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span> &#123;<br>   <br>   <span class="hljs-comment">// 扣除积分 - 50</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductMoney</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 是否抽中奖品</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">raffle</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 发放奖品</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispensePrize</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、NoRaffleState"><a href="#2、NoRaffleState" class="headerlink" title="2、NoRaffleState"></a>2、NoRaffleState</h3><p>不能抽奖状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoRaffleState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">State</span> &#123;<br><br>    <span class="hljs-comment">// 初始化时传入活动引用，扣除积分后改变其状态</span><br>    RaffleActivity activity;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NoRaffleState</span><span class="hljs-params">(RaffleActivity activity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.activity = activity;<br>    &#125;<br><br>    <span class="hljs-comment">// 当前状态可以扣积分 , 扣除后，将状态设置成可以抽奖状态</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductMoney</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;扣除50积分成功，您可以抽奖了&quot;</span>);<br>        activity.setState(activity.getCanRaffleState());<br>    &#125;<br><br>    <span class="hljs-comment">// 当前状态不能抽奖</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">raffle</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;扣了积分才能抽奖喔！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 当前状态不能发奖品</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispensePrize</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;不能发放奖品&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、DispenseState"><a href="#3、DispenseState" class="headerlink" title="3、DispenseState"></a>3、DispenseState</h3><p>发放奖品的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DispenseState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">State</span> &#123;<br><br>    <span class="hljs-comment">// 初始化时传入活动引用，发放奖品后改变其状态</span><br>    RaffleActivity activity;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DispenseState</span><span class="hljs-params">(RaffleActivity activity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.activity = activity;<br>    &#125;<br>    <br>    <span class="hljs-comment">//</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductMoney</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;不能扣除积分&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">raffle</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;不能抽奖&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//发放奖品</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispensePrize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(activity.getCount() &gt; <span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;恭喜中奖了&quot;</span>);<br>            <span class="hljs-comment">// 改变状态为不能抽奖</span><br>            activity.setState(activity.getNoRafflleState());<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;很遗憾，奖品发送完了&quot;</span>);<br>            <span class="hljs-comment">// 改变状态为奖品发送完毕, 后面我们就不可以抽奖</span><br>            activity.setState(activity.getDispensOutState());<br>            <span class="hljs-comment">//System.out.println(&quot;抽奖活动结束&quot;);</span><br>            <span class="hljs-comment">//System.exit(0);</span><br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、DispenseOutState"><a href="#4、DispenseOutState" class="headerlink" title="4、DispenseOutState"></a>4、DispenseOutState</h3><p>奖品发放完毕状态</p><p>当我们activity 改变成 DispenseOutState， 抽奖活动结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DispenseOutState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">State</span> &#123;<br><br>   <span class="hljs-comment">// 初始化时传入活动引用</span><br>    RaffleActivity activity;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DispenseOutState</span><span class="hljs-params">(RaffleActivity activity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.activity = activity;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductMoney</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;奖品发送完了，请下次再参加&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">raffle</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;奖品发送完了，请下次再参加&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispensePrize</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;奖品发送完了，请下次再参加&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、CanRaffleState"><a href="#5、CanRaffleState" class="headerlink" title="5、CanRaffleState"></a>5、CanRaffleState</h3><p>可以抽奖的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CanRaffleState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">State</span> &#123;<br><br>    RaffleActivity activity;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CanRaffleState</span><span class="hljs-params">(RaffleActivity activity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.activity = activity;<br>    &#125;<br><br>    <span class="hljs-comment">//已经扣除了积分，不能再扣</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductMoney</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;已经扣取过了积分&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//可以抽奖, 抽完奖后，根据实际情况，改成新的状态</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">raffle</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;正在抽奖，请稍等！&quot;</span>);<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// 10%中奖机会</span><br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 改变活动状态为发放奖品 context</span><br>            activity.setState(activity.getDispenseState());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;很遗憾没有抽中奖品！&quot;</span>);<br>            <span class="hljs-comment">// 改变状态为不能抽奖</span><br>            activity.setState(activity.getNoRafflleState());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 不能发放奖品</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispensePrize</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;没中奖，不能发放奖品&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、RaffleActivity"><a href="#6、RaffleActivity" class="headerlink" title="6、RaffleActivity"></a>6、RaffleActivity</h3><p>抽奖活动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RaffleActivity</span> &#123;<br><br>   <span class="hljs-comment">// state 表示活动当前的状态，是变化</span><br>    <span class="hljs-type">State</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 奖品数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 四个属性，表示四种状态</span><br>    <span class="hljs-type">State</span> <span class="hljs-variable">noRafflleState</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoRaffleState</span>(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-type">State</span> <span class="hljs-variable">canRaffleState</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanRaffleState</span>(<span class="hljs-built_in">this</span>);<br>    <br>    <span class="hljs-type">State</span> <span class="hljs-variable">dispenseState</span> <span class="hljs-operator">=</span>   <span class="hljs-keyword">new</span> <span class="hljs-title class_">DispenseState</span>(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-type">State</span> <span class="hljs-variable">dispensOutState</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DispenseOutState</span>(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-comment">//构造器</span><br>    <span class="hljs-comment">//1. 初始化当前的状态为 noRafflleState（即不能抽奖的状态）</span><br>    <span class="hljs-comment">//2. 初始化奖品的数量 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RaffleActivity</span><span class="hljs-params">( <span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = getNoRafflleState();<br>        <span class="hljs-built_in">this</span>.count = count;<br>    &#125;<br><br>    <span class="hljs-comment">//扣分, 调用当前状态的 deductMoney</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debuctMoney</span><span class="hljs-params">()</span>&#123;<br>        state.deductMoney();<br>    &#125;<br><br>    <span class="hljs-comment">//抽奖 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">raffle</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-comment">// 如果当前的状态是抽奖成功</span><br>        <span class="hljs-keyword">if</span>(state.raffle())&#123;<br>           <span class="hljs-comment">//领取奖品</span><br>            state.dispensePrize();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(State state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = state;<br>    &#125;<br><br>    <span class="hljs-comment">//这里请大家注意，每领取一次奖品，count--</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">curCount</span> <span class="hljs-operator">=</span> count; <br>       count--;<br>        <span class="hljs-keyword">return</span> curCount;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCount</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-built_in">this</span>.count = count;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getNoRafflleState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> noRafflleState;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNoRafflleState</span><span class="hljs-params">(State noRafflleState)</span> &#123;<br>        <span class="hljs-built_in">this</span>.noRafflleState = noRafflleState;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getCanRaffleState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> canRaffleState;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCanRaffleState</span><span class="hljs-params">(State canRaffleState)</span> &#123;<br>        <span class="hljs-built_in">this</span>.canRaffleState = canRaffleState;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getDispenseState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> dispenseState;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDispenseState</span><span class="hljs-params">(State dispenseState)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dispenseState = dispenseState;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getDispensOutState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> dispensOutState;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDispensOutState</span><span class="hljs-params">(State dispensOutState)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dispensOutState = dispensOutState;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7、ClientTest"><a href="#7、ClientTest" class="headerlink" title="7、ClientTest"></a>7、ClientTest</h3><p>主函数测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientTest</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-comment">// 创建活动对象，奖品有1个奖品</span><br>        <span class="hljs-type">RaffleActivity</span> <span class="hljs-variable">activity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RaffleActivity</span>(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 我们连续抽30次奖</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;--------第&quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;次抽奖----------&quot;</span>);<br>            <span class="hljs-comment">// 参加抽奖，第一步点击扣除积分</span><br>            activity.debuctMoney();<br><br>            <span class="hljs-comment">// 第二步抽奖</span><br>            activity.raffle();<br>        &#125;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、状态模式原理"><a href="#2、状态模式原理" class="headerlink" title="2、状态模式原理"></a>2、状态模式原理</h2><p>类图如下：</p><p><img src="/2022/10/12/08-xing-wei-xing-zhuang-tai-die-dai-qi/image-20221012210214155.png"></p><blockquote><p>说明</p></blockquote><ol><li>Context 类为环境角色, 用于维护State实例,这个实例定义当前状态 </li><li>State 是抽象状态角色,定义一个接口封装与Context 的一个特点接口相关行为 </li><li>ConcreteState 具体的状态角色，每个子类实现一个与Context 的一个状态相关行为</li></ol><h2 id="3、状态模式应用"><a href="#3、状态模式应用" class="headerlink" title="3、状态模式应用"></a>3、状态模式应用</h2><p>状态模式在实际项目-借贷平台中的应用</p><ol><li>借贷平台的订单，有审核-发布-抢单 等等 步骤，随着操作的不同，会改变订单的 状态, 项目中的这个模块实现就会使用到状态模式 </li><li>通常通过if/else判断订单的状态，从而实现不同的逻辑，伪代码如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(审核)&#123;<br><span class="hljs-comment">//审核逻辑</span><br>&#125;elseif(发布)&#123;<br><span class="hljs-comment">//发布逻辑</span><br>&#125;elseif(接单)&#123;<br><span class="hljs-comment">//接单逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p>问题分析：</p><p>这类代码难以应对变化，在添加一种状态时，我们需要手动 添加if/else，在添加一种功能时，要对所有的状态进行判断。 因此代码会变得越来越臃肿，并且一旦没有处理某个状态， 便会发生极其严重的BUG，难以维护。此时就需要使用状态模式</p><h2 id="4、状态模式注意事项"><a href="#4、状态模式注意事项" class="headerlink" title="4、状态模式注意事项"></a>4、状态模式注意事项</h2><ol><li>代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中 </li><li>方便维护。将容易产生问题的if-else语句删除了，如果把每个状态的行为都放到一 个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多if-else语句， 而且容易出错 </li><li>符合“开闭原则”。容易增删状态 </li><li>会产生很多类。每个状态都要一个对应的类，当状态过多时会产生很多类，加大维 护难度 </li><li>应用场景：当一个事件或者对象有很多种状态，状态之间会相互转换，对不同的状 态要求有不同的行为的时候，可以考虑使用状态模式</li></ol><h1 id="二、迭代器模式"><a href="#二、迭代器模式" class="headerlink" title="二、迭代器模式"></a>二、迭代器模式</h1><h2 id="1、迭代器模式的原理和实现"><a href="#1、迭代器模式的原理和实现" class="headerlink" title="1、迭代器模式的原理和实现"></a>1、迭代器模式的原理和实现</h2><p>迭代器模式，也叫游标模式。迭代器模式用来遍历集合对象。这里说的“集合对象”也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。</p><p>迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及<strong>容器和容器迭代器</strong>部分两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。</p><p>通过一个例子来具体讲，如何实现一个迭代器。</p><p>大部分编程语言都提供了遍历容器的迭代器类，我们在平时开发中，直接拿来用即可，几乎不大可能从零编写一个迭代器。不过，这里为了讲解迭代器的实现原理，我们假设某个新的编程语言的基础类库中，还没有提供线性容器对应的迭代器，需要我们从零开始开发。</p><p>线性数据结构包括数组和链表，在大部分编程语言中都有对应的类来封装这两种数据结构，在开发中直接拿来用就可以了。假设在这种新的编程语言中，这两个数据结构分别对应 ArrayList 和 LinkedList 两个类。除此之外，我们从两个类中抽象出公共的接口，定义为 List 接口，以方便开发者基于接口而非实现编程，编写的代码能在两种数据存储结构之间灵活切换。</p><p>现在针对 ArrayList 和 LinkedList 两个线性容器，设计实现对应的迭代器。定义一个迭代器接口 Iterator，以及针对两种容器的具体的迭代器实现类 ArrayIterator 和 ListIterator。</p><p>先来看下 Iterator 接口的定义。具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 接口定义方式一</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>  E <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 接口定义方式二</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>  E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Iterator 接口有两种定义方式。在第一种定义中，next() 函数用来将游标后移一位元素，currentItem() 函数用来返回当前游标指向的元素。在第二种定义中，返回当前元素与后移一位这两个操作，要放到同一个函数 next() 中完成。第一种定义方式更加灵活一些，比如我们可以多次调用 currentItem() 查询当前元素，而不移动游标。所以，在接下来的实现中，我们选择第一种接口定义方式。</p><p>再来看下 ArrayIterator 的代码实现，具体如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayIterator</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor;<br>  <span class="hljs-keyword">private</span> ArrayList&lt;E&gt; arrayList;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayIterator</span><span class="hljs-params">(ArrayList&lt;E&gt; arrayList)</span> &#123;<br>    <span class="hljs-built_in">this</span>.cursor = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">this</span>.arrayList = arrayList;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> cursor != arrayList.size(); <span class="hljs-comment">// 注意这里，cursor在指向最后一个元素的时候，hasNext()仍旧返回true。</span><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    cursor++;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> E <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (cursor &gt;= arrayList.size()) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> arrayList.get(cursor);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    ArrayList&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    names.add(<span class="hljs-string">&quot;lql&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;dl&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;tql&quot;</span>);<br><br>    Iterator&lt;String&gt; iterator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIterator</span>(names);<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>      System.out.println(iterator.currentItem());<br>      iterator.next();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码实现中，需要将待遍历的容器对象，通过构造函数传递给迭代器类。实际上，为了封装迭代器的创建细节，我们可以在容器中定义一个 iterator() 方法，来创建对应的迭代器。为了能实现基于接口而非实现编程，我们还需要将这个方法定义在 List 接口中。具体的代码实现和使用示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>  Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>  <span class="hljs-comment">// ...省略其他接口函数...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIterator</span>(<span class="hljs-built_in">this</span>);<br>  &#125;<br>  <span class="hljs-comment">// ...省略其他代码</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    names.add(<span class="hljs-string">&quot;lql&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;dl&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;tql&quot;</span>);<br><br>    Iterator&lt;String&gt; iterator = names.iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>      System.out.println(iterator.currentItem());<br>      iterator.next();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 LinkedIterator，它的代码结构跟 ArrayIterator 完全相同。结合刚刚的例子，来总结一下迭代器的设计思路。总结下来就三句话：迭代器中需要定义 hasNext()、currentItem()、next() 三个最基本的方法。待遍历的容器对象通过依赖注入传递到迭代器类中。容器通过 iterator() 方法来创建迭代器。</p><h2 id="2、迭代器模式的优势"><a href="#2、迭代器模式的优势" class="headerlink" title="2、迭代器模式的优势"></a>2、迭代器模式的优势</h2><p>一般来讲，遍历集合数据有三种方法：for 循环、foreach 循环、iterator 迭代器。对于这三种方式，我拿 Java 语言来举例说明一下。具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    names.add(<span class="hljs-string">&quot;lql&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;dl&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;tql&quot;</span>);<br><br>    <span class="hljs-comment">// 第一种遍历方式：for循环</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; names.size(); i++) &#123;<br>      System.out.print(names.get(i) + <span class="hljs-string">&quot;,&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 第二种遍历方式：foreach循环</span><br>    <span class="hljs-keyword">for</span> (String name : names) &#123;<br>      System.out.print(name + <span class="hljs-string">&quot;,&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 第三种遍历方式：迭代器遍历</span><br>    Iterator&lt;String&gt; iterator = names.iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>      System.out.print(iterator.next() + <span class="hljs-string">&quot;,&quot;</span>); <span class="hljs-comment">// Java中的迭代器接口是第二种定义方式，next()既移动游标又返回数据</span><br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>实际上，foreach 循环只是一个语法糖而已，底层是基于迭代器来实现的。也就是说，上面代码中的第二种遍历方式（foreach 循环代码）的底层实现，就是第三种遍历方式（迭代器遍历代码）。这两种遍历方式可以看作同一种遍历方式，也就是迭代器遍历方式。</p><p>从上面的代码来看，for 循环遍历方式比起迭代器遍历方式，代码看起来更加简洁。那为什么还要用迭代器来遍历容器呢？为什么还要给容器设计对应的迭代器呢？原因有以下三个。</p><ol><li>首先，对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用 for 循环来遍历就足够了。但是，对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比如，树有前中后序、按层遍历，图有深度优先、广度优先遍历等等。如果由客户端代码来实现这些遍历算法，势必增加开发成本，而且容易写错。如果将这部分遍历的逻辑写到容器类中，也会导致容器类代码的复杂性。前面也多次提到，应对复杂性的方法就是拆分。我们可以将遍历操作拆分到迭代器类中。比如，针对图的遍历，我们就可以定义 DFSIterator、BFSIterator 两个迭代器类，让它们分别来实现深度优先遍历和广度优先遍历。</li><li>其次，将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这样，我们就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响。</li><li>最后，容器和迭代器都提供了抽象的接口，方便我们在开发的时候，基于接口而非具体的实现编程。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成从后往前遍历链表，客户端代码只需要将迭代器类从 LinkedIterator 切换为 ReversedLinkedIterator 即可，其他代码都不需要修改。除此之外，添加新的遍历算法，我们只需要扩展新的迭代器类，也更符合开闭原则。</li></ol><p>迭代器模式主要作用是解耦容器代码和遍历代码。</p><h2 id="3、在遍历的同时增删集合元素会发生什么？"><a href="#3、在遍历的同时增删集合元素会发生什么？" class="headerlink" title="3、在遍历的同时增删集合元素会发生什么？"></a>3、在遍历的同时增删集合元素会发生什么？</h2><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为<strong>结果不可预期行为</strong>或者<strong>未决行为</strong>，也就是说，运行结果到底是对还是错，要视情况而定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>  E <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayIterator</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor;<br>  <span class="hljs-keyword">private</span> ArrayList&lt;E&gt; arrayList;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayIterator</span><span class="hljs-params">(ArrayList&lt;E&gt; arrayList)</span> &#123;<br>    <span class="hljs-built_in">this</span>.cursor = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">this</span>.arrayList = arrayList;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> cursor &lt; arrayList.size();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    cursor++;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> E <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (cursor &gt;= arrayList.size()) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> arrayList.get(cursor);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>  Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIterator</span>(<span class="hljs-built_in">this</span>);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;c&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;d&quot;</span>);<br><br>    Iterator&lt;String&gt; iterator = names.iterator();<br>    iterator.next();<br>    names.remove(<span class="hljs-string">&quot;a&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>我们知道，ArrayList 底层对应的是数组这种数据结构，在执行完第 55 行代码的时候，数组中存储的是 a、b、c、d 四个元素，迭代器的游标 cursor 指向元素 a。当执行完第 58行代码的时候，游标指向元素 b，到这里都没有问题。</li><li>为了保持数组存储数据的连续性，数组的删除操作会涉及元素的搬移。当执行到第 59行代码的时候，我们从数组中将元素 a 删除掉，b、c、d 三个元素会依次往前搬移一位，这就会导致游标本来指向元素 b，现在变成了指向元素 c。原本在执行完第 58 行代码之后，我们还可以遍历到 b、c、d 三个元素，但在执行完第 59 行代码之后，我们只能遍历到 c、d 两个元素，b 遍历不到了。</li></ol><ol><li>不过，如果第 59 行代码删除的不是游标前面的元素（元素 a）以及游标所在位置的元素（元素 b），而是游标后面的元素（元素 c 和 d），这样就不会存在任何问题了，不会存在某个元素遍历不到的情况了。</li><li>所以，我们前面说，在遍历的过程中删除集合元素，结果是不可预期的，有时候没问题（删除元素 c 或 d），有时候就有问题（删除元素 a 或 b），这个要视情况而定（到底删除的是哪个位置的元素），就是这个意思。</li><li>在遍历的过程中删除集合元素，有可能会导致某个元素遍历不到，那在遍历的过程中添加集合元素，会发生什么情况呢？还是结合刚刚那个例子来讲解，我们将上面的代码稍微改造一下，把删除元素改为添加元素。具体的代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;c&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;d&quot;</span>);<br><br>    Iterator&lt;String&gt; iterator = names.iterator();<br>    iterator.next();<br>    names.add(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;x&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>在执行完第 10 行代码之后，数组中包含 a、b、c、d 四个元素，游标指向 b 这个元素，已经跳过了元素 a。在执行完第 11 行代码之后，我们将 x 插入到下标为 0 的位置，a、b、c、d 四个元素依次往后移动一位。这个时候，游标又重新指向了元素 a。元素 a 被游标重复指向两次，也就是说，元素 a 存在被重复遍历的情况。</li><li>跟删除情况类似，如果我们在游标的后面添加元素，就不会存在任何问题。所以，在遍历的同时添加集合元素也是一种不可预期行为。</li></ol><h2 id="4、如何应对遍历时改变集合导致的未决行为？"><a href="#4、如何应对遍历时改变集合导致的未决行为？" class="headerlink" title="4、如何应对遍历时改变集合导致的未决行为？"></a>4、如何应对遍历时改变集合导致的未决行为？</h2><ol><li>当通过迭代器来遍历集合的时候，增加、删除集合元素会导致不可预期的遍历结果。实际上，“不可预期”比直接出错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难 debug 的 bug 就是这么产生的。那如何才能避免出现这种不可预期的运行结果呢？</li><li>有两种比较干脆利索的解决方案：一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。</li><li>实际上，第一种解决方案比较难实现，我们要确定遍历开始和结束的时间点。遍历开始的时间节点我们很容易获得。我们可以把创建迭代器的时间点作为遍历开始的时间点。但是，遍历结束的时间点该如何来确定呢？</li><li>在实际的软件开发中，每次使用迭代器来遍历元素，并不一定非要把所有元素都遍历一遍。</li><li>我们可以在迭代器类中定义一个新的接口 finishIteration()，主动告知容器迭代器使用完了，你可以增删元素了，可行吗？但是，这就要求程序员在使用完迭代器之后要主动调用这个函数，也增加了开发成本，还很容易漏掉。</li></ol><ol><li>实际上，第二种解决方法更加合理。Java 语言就是采用的这种解决方案，增删元素之后，让遍历报错。</li><li>怎么确定在遍历时候，集合有没有增删元素呢？我们在 ArrayList 中定义一个成员变量 modCount，记录集合被修改的次数，集合每调用一次增加或删除元素的函数，就会给 modCount 加 1。当通过调用集合上的 iterator() 函数来创建迭代器的时候，我们把 modCount 值传递给迭代器的 expectedModCount 成员变量，之后每次调用迭代器上的 hasNext()、next()、currentItem() 函数，我们都会检查集合上的 modCount 是否等于 expectedModCount，也就是看，在创建完迭代器之后，modCount 是否改变过。</li><li>如果两个值不相同，那就说明集合存储的元素已经改变了，要么增加了元素，要么删除了元素，之前创建的迭代器已经不能正确运行了，再继续使用就会产生不可预期的结果，所以我们选择 fail-fast 解决方式，抛出运行时异常，结束掉程序，让程序员尽快修复这个因为不正确使用迭代器而产生的 bug。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor;<br>  <span class="hljs-keyword">private</span> ArrayList arrayList;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> expectedModCount;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayIterator</span><span class="hljs-params">(ArrayList arrayList)</span> &#123;<br>    <span class="hljs-built_in">this</span>.cursor = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">this</span>.arrayList = arrayList;<br>    <span class="hljs-built_in">this</span>.expectedModCount = arrayList.modCount;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>    checkForComodification();<br>    <span class="hljs-keyword">return</span> cursor &lt; arrayList.size();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    checkForComodification();<br>    cursor++;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span> &#123;<br>    checkForComodification();<br>    <span class="hljs-keyword">return</span> arrayList.get(cursor);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (arrayList.modCount != expectedModCount) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 代码示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;c&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;d&quot;</span>);<br><br>    Iterator&lt;String&gt; iterator = names.iterator();<br>    iterator.next();<br>    names.remove(<span class="hljs-string">&quot;a&quot;</span>);<br>    iterator.next(); <span class="hljs-comment">// 抛出ConcurrentModificationException异常</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、如何在遍历的同时安全的删除集合元素？"><a href="#5、如何在遍历的同时安全的删除集合元素？" class="headerlink" title="5、如何在遍历的同时安全的删除集合元素？"></a>5、如何在遍历的同时安全的删除集合元素？</h2><ol><li>像 Java 语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个 remove() 方法，能够在遍历集合的同时，安全地删除集合中的元素。不过，需要说明的是，它并没有提供添加元素的方法。毕竟迭代器的主要作用是遍历，添加元素放到迭代器里本身就不合适。</li><li>Java 迭代器中提供的 remove() 方法还是比较鸡肋的，作用有限。它只能删除游标指向的前一个元素，而且一个 next() 函数之后，只能跟着最多一个 remove() 操作，多次调用 remove() 操作会报错。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    names.add(<span class="hljs-string">&quot;a&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;b&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;c&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;d&quot;</span>);<br><br>    Iterator&lt;String&gt; iterator = names.iterator();<br>    iterator.next();<br>    iterator.remove();<br>    iterator.remove(); <span class="hljs-comment">// 报错，抛出IllegalStateException异常</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么通过迭代器就能安全的删除集合中的元素呢？来看下 remove() 函数是如何实现的，代码如下所示。在 Java 实现中，迭代器类是容器类的内部类，并且 next() 函数不仅将游标后移一位，还会返回当前的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; &#123;<br>  <span class="hljs-keyword">transient</span> Object[] elementData;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>  <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Itr</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-type">int</span> cursor; <span class="hljs-comment">// index of next element to return</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br><br>    Itr() &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> cursor != size;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>      checkForComodification();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>      <span class="hljs-keyword">if</span> (i &gt;= size) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>      Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>      <span class="hljs-keyword">if</span> (i &gt;= elementData.length) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>      cursor = i + <span class="hljs-number">1</span>;<br><br>      <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>      checkForComodification();<br><br>      <span class="hljs-keyword">try</span> &#123;<br>        ArrayList.<span class="hljs-built_in">this</span>.remove(lastRet);<br>        cursor = lastRet;<br>        lastRet = -<span class="hljs-number">1</span>;<br>        expectedModCount = modCount;<br>      &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码实现中，迭代器类新增了一个 lastRet 成员变量，用来记录游标指向的前一个元素。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的游标和 lastRet 值，来保证不会因为删除元素而导致某个元素遍历不到。如果通过容器来删除元素，并且希望更新迭代器中的游标值来保证遍历不出错，我们就要维护这个容器都创建了哪些迭代器，每个迭代器是否还在使用等信息，代码实现就变得比较复杂了。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 状态 </tag>
            
            <tag> 迭代器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07-行为型-策略-职责链</title>
      <link href="/2022/10/11/07-xing-wei-xing-ce-lue-zhi-ze-lian/"/>
      <url>/2022/10/11/07-xing-wei-xing-ce-lue-zhi-ze-lian/</url>
      
        <content type="html"><![CDATA[<h1 id="一、策略模式【常用】"><a href="#一、策略模式【常用】" class="headerlink" title="一、策略模式【常用】"></a>一、策略模式【常用】</h1><h2 id="1、Demo案例-鸭子问题"><a href="#1、Demo案例-鸭子问题" class="headerlink" title="1、Demo案例-鸭子问题"></a>1、Demo案例-鸭子问题</h2><p>编写鸭子项目，具体要求如下: </p><ol><li>有各种鸭子(比如 野鸭、北京鸭、水鸭等， 鸭子有各种行为，比如 叫、飞行等) </li><li>显示鸭子的信息</li></ol><h3 id="1、传统方式解决鸭子问题代码实现"><a href="#1、传统方式解决鸭子问题代码实现" class="headerlink" title="1、传统方式解决鸭子问题代码实现"></a>1、传统方式解决鸭子问题代码实现</h3><h4 id="1、Duck"><a href="#1、Duck" class="headerlink" title="1、Duck"></a>1、Duck</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Duck</span><span class="hljs-params">()</span> &#123;<br>   <br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span>;<span class="hljs-comment">//显示鸭子信息</span><br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;鸭子嘎嘎叫~~&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;鸭子会游泳~~&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;鸭子会飞翔~~~&quot;</span>);<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、PekingDuck"><a href="#2、PekingDuck" class="headerlink" title="2、PekingDuck"></a>2、PekingDuck</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PekingDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Duck</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot;~~北京鸭~~~&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-comment">//因为北京鸭不能飞翔，因此需要重写fly</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot;北京鸭不能飞翔&quot;</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、ToyDuck"><a href="#3、ToyDuck" class="headerlink" title="3、ToyDuck"></a>3、ToyDuck</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToyDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Duck</span>&#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot;玩具鸭&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-comment">//需要重写父类的所有方法</span><br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;玩具鸭不能叫~~&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;玩具鸭不会游泳~~&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;玩具鸭不会飞翔~~~&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、WildDuck"><a href="#4、WildDuck" class="headerlink" title="4、WildDuck"></a>4、WildDuck</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WildDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Duck</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; 这是野鸭 &quot;</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、问题"><a href="#5、问题" class="headerlink" title="5、问题"></a>5、问题</h4><p>那么问题来了</p><ol><li>其它鸭子，都继承了Duck类，所以fly让所有子类都会飞了，这是不正确的 </li><li>上面说的1 的问题，其实是继承带来的问题：对类的局部改动，尤其超类的局部改 动，会影响其他部分。会有溢出效应</li><li>为了改进1问题，我们可以通过覆盖fly 方法来解决 =&gt; 覆盖解决</li><li>问题又来了，如果我们有一个玩具鸭子ToyDuck, 这样就需要ToyDuck去覆盖Duck 的所有实现的方法</li></ol><p>解决思路 ==策略模式== </p><h3 id="2、策略模式解决鸭子问题代码实现"><a href="#2、策略模式解决鸭子问题代码实现" class="headerlink" title="2、策略模式解决鸭子问题代码实现"></a>2、策略模式解决鸭子问题代码实现</h3><p>思路分析：</p><p>分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体 设定行为对象。原则就是：分离变化部分，封装接口，基于接口编程各种功能。此模 式让行为的变化独立于算法的使用者</p><h4 id="1、FlyBehavior"><a href="#1、FlyBehavior" class="headerlink" title="1、FlyBehavior"></a>1、FlyBehavior</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FlyBehavior</span> &#123;<br>   <br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 子类具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、GoodFlyBehavior"><a href="#2、GoodFlyBehavior" class="headerlink" title="2、GoodFlyBehavior"></a>2、GoodFlyBehavior</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodFlyBehavior</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FlyBehavior</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; 飞翔技术高超 ~~~&quot;</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、BadFlyBehavior"><a href="#3、BadFlyBehavior" class="headerlink" title="3、BadFlyBehavior"></a>3、BadFlyBehavior</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BadFlyBehavior</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FlyBehavior</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; 飞翔技术一般 &quot;</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、NoFlyBehavior"><a href="#4、NoFlyBehavior" class="headerlink" title="4、NoFlyBehavior"></a>4、NoFlyBehavior</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoFlyBehavior</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FlyBehavior</span>&#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; 不会飞翔  &quot;</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、QuackBehavior"><a href="#5、QuackBehavior" class="headerlink" title="5、QuackBehavior"></a>5、QuackBehavior</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">QuackBehavior</span> &#123;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span>;<span class="hljs-comment">//子类实现</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、Duck"><a href="#6、Duck" class="headerlink" title="6、Duck"></a>6、Duck</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span> &#123;<br><br>   <span class="hljs-comment">//属性, 策略接口</span><br>   FlyBehavior flyBehavior;<br>   <span class="hljs-comment">//其它属性&lt;-&gt;策略接口</span><br>   QuackBehavior quackBehavior;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Duck</span><span class="hljs-params">()</span> &#123;<br>   <br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span>;<span class="hljs-comment">//显示鸭子信息</span><br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;鸭子嘎嘎叫~~&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;鸭子会游泳~~&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//改进</span><br>      <span class="hljs-keyword">if</span>(flyBehavior != <span class="hljs-literal">null</span>) &#123;<br>         flyBehavior.fly();<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFlyBehavior</span><span class="hljs-params">(FlyBehavior flyBehavior)</span> &#123;<br>      <span class="hljs-built_in">this</span>.flyBehavior = flyBehavior;<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setQuackBehavior</span><span class="hljs-params">(QuackBehavior quackBehavior)</span> &#123;<br>      <span class="hljs-built_in">this</span>.quackBehavior = quackBehavior;<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7、PekingDuck"><a href="#7、PekingDuck" class="headerlink" title="7、PekingDuck"></a>7、PekingDuck</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PekingDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Duck</span> &#123;<br><br>   <span class="hljs-comment">//假如北京鸭可以飞翔，但是飞翔技术一般</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">PekingDuck</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>      flyBehavior = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadFlyBehavior</span>();<br>      <br>   &#125;<br>   <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot;~~北京鸭~~~&quot;</span>);<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8、ToyDuck"><a href="#8、ToyDuck" class="headerlink" title="8、ToyDuck"></a>8、ToyDuck</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToyDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Duck</span>&#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ToyDuck</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>      flyBehavior = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoFlyBehavior</span>();<br>   &#125;<br>   <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot;玩具鸭&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-comment">//需要重写父类的所有方法</span><br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;玩具鸭不能叫~~&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;玩具鸭不会游泳~~&quot;</span>);<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9、WildDuck"><a href="#9、WildDuck" class="headerlink" title="9、WildDuck"></a>9、WildDuck</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WildDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Duck</span> &#123;<br>   <br>   <span class="hljs-comment">//构造器，传入FlyBehavor 的对象</span><br>   <span class="hljs-keyword">public</span>  <span class="hljs-title function_">WildDuck</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>      flyBehavior = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GoodFlyBehavior</span>();<br>   &#125;<br>   <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; 这是野鸭 &quot;</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10、Client"><a href="#10、Client" class="headerlink" title="10、Client"></a>10、Client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-type">WildDuck</span> <span class="hljs-variable">wildDuck</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WildDuck</span>();<br>      wildDuck.fly();<span class="hljs-comment">//</span><br>      <br>      <span class="hljs-type">ToyDuck</span> <span class="hljs-variable">toyDuck</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ToyDuck</span>();<br>      toyDuck.fly();<br>      <br>      <span class="hljs-type">PekingDuck</span> <span class="hljs-variable">pekingDuck</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PekingDuck</span>();<br>      pekingDuck.fly();<br>      <br>      <span class="hljs-comment">//动态改变某个对象的行为, 北京鸭 不能飞</span><br>      pekingDuck.setFlyBehavior(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NoFlyBehavior</span>());<br>      System.out.println(<span class="hljs-string">&quot;北京鸭的实际飞翔能力&quot;</span>);<br>      pekingDuck.fly();<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2022/10/11/07-xing-wei-xing-ce-lue-zhi-ze-lian/image-20221012163252938.png"></p><h2 id="2、策略模式工作原理"><a href="#2、策略模式工作原理" class="headerlink" title="2、策略模式工作原理"></a>2、策略模式工作原理</h2><ol><li>策略模式（Strategy Pattern）中，定义算法族，分别封装起来，让他们之间可以 互相替换，此模式让算法的变化独立于使用算法的客户 </li><li>这算法体现了几个设计原则，第一、把变化的代码从不变的代码中分离出来； 第二、针对接口编程而不是具体类（定义了策略接口）；第三、多用组合/聚合， 少用继承（客户通过组合方式使用策略）</li></ol><p>类图如下：</p><p><img src="/2022/10/11/07-xing-wei-xing-ce-lue-zhi-ze-lian/image-20221012162105114.png"></p><p>从上图可以看到，客户context 有成员变量strategy或者其他的策略接口 ,至于需要使用到哪个策略，我们可以在构造器中指定。</p><h2 id="3、策略模式在JDK-Arrays-应用"><a href="#3、策略模式在JDK-Arrays-应用" class="headerlink" title="3、策略模式在JDK-Arrays 应用"></a>3、策略模式在JDK-Arrays 应用</h2><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] data = &#123; <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span> &#125;;<br><br>        <span class="hljs-comment">// 说明</span><br>        <span class="hljs-comment">// 1. 实现了 Comparator 接口（策略接口） , 匿名类对象 new Comparator&lt;Integer&gt;()&#123;..&#125;</span><br>        <span class="hljs-comment">// 2. 对象 new Comparator&lt;Integer&gt;()&#123;..&#125; 就是实现了策略接口的对象</span><br>        <span class="hljs-comment">// 3. public int compare(Integer o1, Integer o2)&#123;&#125; 指定具体的处理方式</span><br>        Comparator&lt;Integer&gt; comparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>                <span class="hljs-keyword">if</span> (o1 &gt; o2) &#123;<br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;;<br>        &#125;;<br><br>        <span class="hljs-comment">// 说明</span><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">       * public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;</span><br><span class="hljs-comment">              if (c == null) &#123;</span><br><span class="hljs-comment">                  sort(a); //默认方法</span><br><span class="hljs-comment">              &#125; else &#123;</span><br><span class="hljs-comment">                  if (LegacyMergeSort.userRequested)</span><br><span class="hljs-comment">                      legacyMergeSort(a, c); //使用策略对象c</span><br><span class="hljs-comment">                  else</span><br><span class="hljs-comment">                     // 使用策略对象c</span><br><span class="hljs-comment">                      TimSort.sort(a, 0, a.length, c, null, 0, 0);</span><br><span class="hljs-comment">              &#125;</span><br><span class="hljs-comment">          &#125;</span><br><span class="hljs-comment">       */</span><br>        <span class="hljs-comment">// 方式1</span><br>        Arrays.sort(data, comparator);<br><br>        System.out.println(Arrays.toString(data)); <span class="hljs-comment">// ????????</span><br><br><br>        <span class="hljs-comment">//方式2- lambda 表达式</span><br>        Integer[] data2 = &#123; <span class="hljs-number">19</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">14</span>, <span class="hljs-number">13</span> &#125;;<br><br>        Arrays.sort(data2, (var1, var2) -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(var1.compareTo(var2) &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;);<br><br>        System.out.println(<span class="hljs-string">&quot;data2=&quot;</span> + Arrays.toString(data2));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>上述用两种方式实现策略模式，方式1是以Comparator为接口，实现compare方法来完成具体实现</li><li>方式2是直接在lambda处指定策略</li></ol><h2 id="4、注意事项"><a href="#4、注意事项" class="headerlink" title="4、注意事项"></a>4、注意事项</h2><ol><li>策略模式的关键是：分析项目中变化部分与不变部分 </li><li>策略模式的核心思想是：多用组合/聚合 少用继承；用行为类组合，而不是行为的 继承。更有弹性 </li><li>体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只 要添加一种策略（或者行为）即可，避免了使用多重转移语句（if..else if..else） </li><li>提供了可以替换继承关系的办法： 策略模式将算法封装在独立的Strategy类中使得 你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展 </li><li>需要注意的是：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大</li></ol><h1 id="二、职责链模式"><a href="#二、职责链模式" class="headerlink" title="二、职责链模式"></a>二、职责链模式</h1><p>模板模式、策略模式，职责链模式。这三种模式具有相同的作用：复用和扩展，在实际的项目开发中比较常用，特别是框架开发中，我们可以利用它们来提供框架的扩展点，能够让框架的使用者在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p><h2 id="1、Demo案例-学校采购"><a href="#1、Demo案例-学校采购" class="headerlink" title="1、Demo案例-学校采购"></a>1、Demo案例-学校采购</h2><blockquote><p>需求</p></blockquote><p>采购员采购教学器材</p><ol><li>如果金额小于等于 5000, 由教学主任审批 （0&lt;=x&lt;=5000）</li><li>如果金额小于等于 10000, 由院长审批 (5000&lt;x&lt;=10000)</li><li>如果金额小于等于 30000, 由副校长审批 (10000&lt;x&lt;=30000)</li><li>如果金额超过 30000 以上，有校长审批 ( 30000&lt;x)</li></ol><h3 id="1、传统方式解决方案"><a href="#1、传统方式解决方案" class="headerlink" title="1、传统方式解决方案"></a>1、传统方式解决方案</h3><ol><li>传统方式是：接收到一个采购请求后，根据采购金额来调用对应的 Approver (审批人)完成审批。</li><li>传统方式的问题分析 : 客户端这里会使用到 分支判断(比如 switch) 来对不同的采购请求处理， 这样就存在如下问题 (1) 如果各个级别的人员审批金额发生变化，在客户端的也需要变化 (2) 客户端必须明确的知道有多少个审批级别和访问</li><li>这样对一个采购请求进行处理 和 Approver (审批人) 就存在强耦合关系，不利于代码的扩展和维护</li></ol><h3 id="2、职责链模式方案代码"><a href="#2、职责链模式方案代码" class="headerlink" title="2、职责链模式方案代码"></a>2、职责链模式方案代码</h3><h4 id="1、Approver【抽象类】"><a href="#1、Approver【抽象类】" class="headerlink" title="1、Approver【抽象类】"></a>1、Approver【抽象类】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Approver</span> &#123;<br><br>  Approver approver; <span class="hljs-comment">// 下一个处理者</span><br>  String name; <span class="hljs-comment">// 名字</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Approver</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br><br>  <span class="hljs-comment">// 下一个处理者</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApprover</span><span class="hljs-params">(Approver approver)</span> &#123;<br>    <span class="hljs-built_in">this</span>.approver = approver;<br>  &#125;<br><br>  <span class="hljs-comment">// 处理审批请求的方法，得到一个请求, 处理是子类完成，因此该方法做成抽象</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest purchaseRequest)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、PurchaseRequest"><a href="#2、PurchaseRequest" class="headerlink" title="2、PurchaseRequest"></a>2、PurchaseRequest</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 请求类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseRequest</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 请求类型</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// 请求金额</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 构造器</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">PurchaseRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> type, <span class="hljs-type">float</span> price, <span class="hljs-type">int</span> id)</span> &#123;<br>    <span class="hljs-built_in">this</span>.type = type;<br>    <span class="hljs-built_in">this</span>.price = price;<br>    <span class="hljs-built_in">this</span>.id = id;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> type;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> price;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> id;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、DepartmentApprover"><a href="#3、DepartmentApprover" class="headerlink" title="3、DepartmentApprover"></a>3、DepartmentApprover</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 教学主任</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DepartmentApprover</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Approver</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DepartmentApprover</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>    <span class="hljs-built_in">super</span>(name);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest purchaseRequest)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-keyword">if</span> (purchaseRequest.getPrice() &lt;= <span class="hljs-number">5000</span>) &#123;<br>      System.out.println(<span class="hljs-string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="hljs-string">&quot; 被 &quot;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; 处理&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      approver.processRequest(purchaseRequest);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、CollegeApprover"><a href="#4、CollegeApprover" class="headerlink" title="4、CollegeApprover"></a>4、CollegeApprover</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 院长</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollegeApprover</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Approver</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">CollegeApprover</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>    <span class="hljs-built_in">super</span>(name);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest purchaseRequest)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-keyword">if</span> (purchaseRequest.getPrice() &gt; <span class="hljs-number">5000</span> &amp;&amp; purchaseRequest.getPrice() &lt;= <span class="hljs-number">10000</span>) &#123;<br>      System.out.println(<span class="hljs-string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="hljs-string">&quot; 被 &quot;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; 处理&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      approver.processRequest(purchaseRequest);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、ViceSchoolMasterApprover"><a href="#5、ViceSchoolMasterApprover" class="headerlink" title="5、ViceSchoolMasterApprover"></a>5、ViceSchoolMasterApprover</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 副校长</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViceSchoolMasterApprover</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Approver</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ViceSchoolMasterApprover</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>    <span class="hljs-built_in">super</span>(name);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest purchaseRequest)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-keyword">if</span> (purchaseRequest.getPrice() &gt; <span class="hljs-number">10000</span> &amp;&amp; purchaseRequest.getPrice() &lt;= <span class="hljs-number">30000</span>) &#123;<br>      System.out.println(<span class="hljs-string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="hljs-string">&quot; 被 &quot;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; 处理&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      approver.processRequest(purchaseRequest);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、SchoolMasterApprover"><a href="#6、SchoolMasterApprover" class="headerlink" title="6、SchoolMasterApprover"></a>6、SchoolMasterApprover</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 校长</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SchoolMasterApprover</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Approver</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">SchoolMasterApprover</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>    <span class="hljs-built_in">super</span>(name);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(PurchaseRequest purchaseRequest)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-keyword">if</span> (purchaseRequest.getPrice() &gt; <span class="hljs-number">30000</span>) &#123;<br>      System.out.println(<span class="hljs-string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="hljs-string">&quot; 被 &quot;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; 处理&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      approver.processRequest(purchaseRequest);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7、Client"><a href="#7、Client" class="headerlink" title="7、Client"></a>7、Client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-comment">// 创建一个请求</span><br>    <span class="hljs-type">PurchaseRequest</span> <span class="hljs-variable">purchaseRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PurchaseRequest</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4000</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 创建相关的审批人</span><br>    <span class="hljs-type">DepartmentApprover</span> <span class="hljs-variable">departmentApprover</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DepartmentApprover</span>(<span class="hljs-string">&quot;张主任&quot;</span>);<br>    <span class="hljs-type">CollegeApprover</span> <span class="hljs-variable">collegeApprover</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CollegeApprover</span>(<span class="hljs-string">&quot;李院长&quot;</span>);<br>    <span class="hljs-type">ViceSchoolMasterApprover</span> <span class="hljs-variable">viceSchoolMasterApprover</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViceSchoolMasterApprover</span>(<span class="hljs-string">&quot;王副校&quot;</span>);<br>    <span class="hljs-type">SchoolMasterApprover</span> <span class="hljs-variable">schoolMasterApprover</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SchoolMasterApprover</span>(<span class="hljs-string">&quot;B校长&quot;</span>);<br><br>    <span class="hljs-comment">// 需要将各个审批级别的下一个设置好 (处理人构成环形: )</span><br>    departmentApprover.setApprover(collegeApprover);<br>    collegeApprover.setApprover(viceSchoolMasterApprover);<br>    viceSchoolMasterApprover.setApprover(schoolMasterApprover);<br>    schoolMasterApprover.setApprover(departmentApprover);<br><br>    departmentApprover.processRequest(purchaseRequest);<br>    viceSchoolMasterApprover.processRequest(purchaseRequest);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、职责链模式工作原理"><a href="#2、职责链模式工作原理" class="headerlink" title="2、职责链模式工作原理"></a>2、职责链模式工作原理</h2><ol><li>职责链模式（Chain of Responsibility Pattern）,  又叫 责任链模式，为请求创建了一个接收者 对象的链(简单示意图)。这种模式对请求的 发送者和接收者进行解耦。 </li><li>职责链模式通常每个接收者都包含对另一个接 收者的引用。如果一个对象不能处理该请求， 那么它会把相同的请求传给下一个接收者，依 此类推。 </li></ol><p>职责链模式（Chain Of Responsibility）， 使多个对象都有机会处理请求，从而避 免请求的发送者和接收者之间的耦合关 系。将这个对象连成一条链，并沿着这 条链传递该请求，直到有一个对象处理 它为止。</p><p>通俗来讲，就是在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p><blockquote><p>职责链模式最常用来开发框架的过滤器和拦截器</p></blockquote><h2 id="3、Servlet-Filter"><a href="#3、Servlet-Filter" class="headerlink" title="3、Servlet Filter"></a>3、Servlet Filter</h2><p>Servlet Filter 是 Java Servlet 规范中定义的组件，翻译成中文就是过滤器，它可以实现对 HTTP 请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等。因为它是 Servlet 规范的一部分，所以，只要是支持 Servlet 的 Web 容器（比如，Tomcat、Jetty 等），都支持过滤器功能。</p><p><img src="/2022/10/11/07-xing-wei-xing-ce-lue-zhi-ze-lian/image-20221012180753720.png"></p><p>在实际项目中 Servlet Filter的使用 。一个简单的示例代码，如下所示。添加一个过滤器，只需要定义一个实现 javax.servlet.Filter 接口的过滤器类，并且将它配置在 web.xml 配置文件中。Web 容器启动的时候，会读取 web.xml 中的配置，创建过滤器对象。当有请求到来的时候，会先经过过滤器，然后才由 Servlet 来处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>    <span class="hljs-comment">// 在创建Filter时自动调用，</span><br>    <span class="hljs-comment">// 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）</span><br><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span><br>      <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    System.out.println(<span class="hljs-string">&quot;拦截客户端发送来的请求.&quot;</span>);<br>    chain.doFilter(request, response);<br>    System.out.println(<span class="hljs-string">&quot;拦截发送给客户端的响应.&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 在销毁Filter时自动调用</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">// 在web.xml配置文件中如下配置：<br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>logFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.zb.cd.LogFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>logFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>从刚刚的示例代码中可以发现，添加过滤器非常方便，不需要修改任何代码，定义一个实现 javax.servlet.Filter 的类，再改改配置就搞定了，完全符合开闭原则。那 Servlet Filter 是如何做到如此好的扩展性的呢？它利用的就是职责链模式。</li><li>职责链模式的实现包含处理器接口（IHandler）或抽象类（Handler），以及处理器链（HandlerChain）。对应到 Servlet Filter，javax.servlet.Filter 就是处理器接口，FilterChain 就是处理器链。接下来重点来看 FilterChain 是如何实现的。</li><li>不过，Servlet 只是一个规范，并不包含具体的实现，所以，Servlet 中的 FilterChain 只是一个接口定义。具体的实现类由遵从 Servlet 规范的 Web 容器来提供，比如，ApplicationFilterChain 类就是 Tomcat 提供的 FilterChain 的实现类，源码如下所示。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationFilterChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FilterChain</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前执行到了哪个filter</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n; <span class="hljs-comment">// filter的个数</span><br>  <span class="hljs-keyword">private</span> ApplicationFilterConfig[] filters;<br>  <span class="hljs-keyword">private</span> Servlet servlet;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> &#123;<br>    <span class="hljs-keyword">if</span> (pos &lt; n) &#123;<br>      <span class="hljs-type">ApplicationFilterConfig</span> <span class="hljs-variable">filterConfig</span> <span class="hljs-operator">=</span> filters[pos++];<br>      <span class="hljs-type">Filter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> filterConfig.getFilter();<br>      filter.doFilter(request, response, <span class="hljs-built_in">this</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// filter都处理完毕后，执行servlet</span><br>      servlet.service(request, response);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFilter</span><span class="hljs-params">(ApplicationFilterConfig filterConfig)</span> &#123;<br>    <span class="hljs-keyword">for</span> (ApplicationFilterConfig filter : filters) <span class="hljs-keyword">if</span> (filter == filterConfig) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (n == filters.length) &#123; <span class="hljs-comment">// 扩容</span><br>      ApplicationFilterConfig[] newFilters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationFilterConfig</span>[n + INCREMENT];<br>      System.arraycopy(filters, <span class="hljs-number">0</span>, newFilters, <span class="hljs-number">0</span>, n);<br>      filters = newFilters;<br>    &#125;<br>    filters[n++] = filterConfig;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ApplicationFilterChain 中的 doFilter() 函数的代码实现比较有技巧，实际上是一个递归调用。可以用每个 Filter（比如 LogFilter）的 doFilter() 的代码实现，直接替换 ApplicationFilterChain 的第 12 行代码，可以看出是递归调用。如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span>  &#123;<br>    <span class="hljs-keyword">if</span> (pos &lt; n) &#123;<br>        <span class="hljs-type">ApplicationFilterConfig</span> <span class="hljs-variable">filterConfig</span> <span class="hljs-operator">=</span> filters[pos++];<br>        <span class="hljs-type">Filter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> filterConfig.getFilter();<br>        <span class="hljs-comment">//filter.doFilter(request, response, this);</span><br>        <span class="hljs-comment">//把filter.doFilter的代码实现展开替换到这里</span><br>        System.out.println(<span class="hljs-string">&quot;拦截客户端发送来的请求.&quot;</span>);<br>        chain.doFilter(request, response); <span class="hljs-comment">// chain就是this</span><br>        System.out.println(<span class="hljs-string">&quot;拦截发送给客户端的响应.&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// filter都处理完毕后，执行servlet</span><br>        servlet.service(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样实现主要是为了在一个 doFilter() 方法中，支持双向拦截，既能拦截客户端发送来的请求，也能拦截发送给客户端的响应。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 策略 </tag>
            
            <tag> 职责链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-《安河桥》</title>
      <link href="/2022/10/09/c-an-he-qiao/"/>
      <url>/2022/10/09/c-an-he-qiao/</url>
      
        <content type="html"><![CDATA[<center>《安河桥》</center><p>原调G | 选调G </p><p><img src="/2022/10/09/c-an-he-qiao/image-20221009170248015.png"></p><p><img src="/2022/10/09/c-an-he-qiao/image-20221009170322004.png"></p><p><img src="/2022/10/09/c-an-he-qiao/image-20221009170357665.png"></p><p><img src="/2022/10/09/c-an-he-qiao/image-20221009170417935.png"></p><p><img src="/2022/10/09/c-an-he-qiao/image-20221009170440876.png"></p><blockquote><p>曲谱来源大树音乐屋</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 吉他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吉他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-《成都》</title>
      <link href="/2022/10/09/c-cheng-du/"/>
      <url>/2022/10/09/c-cheng-du/</url>
      
        <content type="html"><![CDATA[<center>《成都》<center><p>原调D | 选调C | capo = 3</p><p><img src="/2022/10/09/c-cheng-du/image-20221009165319957.png" alt></p><p><img src="/2022/10/09/c-cheng-du/image-20221009165406564.png" alt></p><blockquote><p>曲谱来源于趣谈音乐</p></blockquote></center></center>]]></content>
      
      
      <categories>
          
          <category> 吉他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吉他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v2-数组</title>
      <link href="/2022/10/08/v2-shu-zu/"/>
      <url>/2022/10/08/v2-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1>一、理论基础</h1><p>定义：<strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p><p>需要注意两点：</p><ul><li>数组下标从0开始</li><li>数组内存空间的地址是连续的</li></ul><p>针对二维数组在内存空间的地址是否连续，不同的编程语言的内存管理不同。在C++中二维数组是连续分布的。但在java中二维数组不是连续分布的。</p><p>java中的二维数组可能是如下排列方式：</p><p><img src="/2022/10/08/v2-shu-zu/image-20221008165054951.png" alt></p><p>基本方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;    <span class="hljs-comment">// 长度</span><br>nums[i];  <span class="hljs-comment">// 取值</span><br></code></pre></td></tr></table></figure><h1>二、经典题目（力扣、牛客</h1><h2 id="1、704-二分查找">1、704.二分查找</h2><p>二分查找的前提条件是数组有序，同时还要保证数组无重复元素，因为若是有重复元素，二分查找返回来的索引可能不是唯一的。二分查找需要注意的地方是边界问题，一旦确定好边界，都要按这个规则来，一会是左闭右闭一会是左闭右开，当然绕！</p><p>所以若是看到数组有序且无重复，可以联想二分查找</p><p>二分查找两种写法：</p><ul><li>左闭右闭即[left, right]</li><li>左闭右开即[left, right)</li></ul><h3 id="1、左闭右闭">1、左闭右闭</h3><p>定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right]</strong> 。</p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，同样if (nums[middle] &lt; target) left要赋值为 middle + 1。因为是左闭右闭，所以middle一定已经判断过了，直接跳过即可</li></ul><h3 id="2、左闭右开">2、左闭右开</h3><p>定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right）</strong> 。</p><ul><li>while (left &lt;= right) 要使用 &lt; ，因为left == right是没有有意义的，所以不能使用&lt;=，要使用&lt;</li><li>if (nums[middle] &gt; target) right 要赋值为 middle， if (nums[middle] &lt; target) left要赋值为 middle + 1。</li></ul><p>二者选一个即可，我个人倾向于左闭右闭</p><h3 id="3、相关题目推荐">3、相关题目推荐</h3><ul><li><a href="https://programmercarl.com/0035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html">35.搜索插入位置(opens new window)</a></li><li><a href="https://programmercarl.com/0034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.html">34.在排序数组中查找元素的第一个和最后一个位置(opens new window)</a></li><li>69.x 的平方根</li><li>367.有效的完全平方数</li></ul><h2 id="2、27-移除元素">2、27.移除元素</h2><p>题目要求不能使用额外的数组空间，意味着只能原地操作</p><p>两种方法</p><h3 id="1、暴力法">1、暴力法</h3><p>for循环两次，碰到目标值，就将后面的各个元素往前移动一位</p><p>当然时间复杂度比较高，O(n*2)</p><h3 id="2、双指针法">2、双指针法</h3><p>维持两个指针，一个快一个慢，for循环一次，若不为目标值，将fast所在位置的元素赋值给slow所在位置的元素，同时往后进一位</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (fast = <span class="hljs-number">0</span>; fast &lt; nums.length; fast++) &#123;<br>   <span class="hljs-keyword">if</span>(nums[fast] != val) &#123;<br>       nums[slow++] = nums[fast];<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、相关题目推荐-v2">3、相关题目推荐</h3><ul><li>26.删除排序数组中的重复项</li><li>283.移动零</li><li>844.比较含退格的字符串</li><li>977.有序数组的平方</li></ul><h2 id="3、209-长度最小的子数组">3、209.长度最小的子数组</h2><p>三种方法</p><h3 id="1、暴力法-v2">1、暴力法</h3><p>两层for循环，每遍历一个，就向后相加找到大于target的索引并记录，同时保留一个res来记录最小值</p><p>当然时间复杂度是比较高的，O(n*2)</p><h3 id="2、滑动窗口">2、滑动窗口</h3><p>定义两个指针start和end，并记录sum，若是sum &lt; target，就将end往后++；若是sum &gt;= target，就将start++，并对sum和size做相应操作</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (end &lt; nums.length) &#123;<br>     sum += nums[end];<br>     <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>     min = Math.min(min, end - start + <span class="hljs-number">1</span>);<br>        sum -= nums[start];<br>        start++;<br>     &#125;<br>     end++;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、相关题目推荐-v3">3、相关题目推荐</h3><ul><li><a href="https://leetcode.cn/problems/fruit-into-baskets/">904.水果成篮(opens new window)</a></li><li>==<a href="https://leetcode.cn/problems/minimum-window-substring/">76.最小覆盖子串</a>==【经典】</li></ul><h3 id="4、滑动窗口总结">4、滑动窗口总结</h3><p>滑动窗口有最小滑动窗口模板和最大滑动窗口模板，具体要求看题目要求</p><p>最小滑动窗口模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (j &lt; len)&#123;<br>    判断[i, j]是否满足条件<br>    <span class="hljs-keyword">while</span> (满足条件)&#123;<br>        不断更新结果(注意在<span class="hljs-keyword">while</span>内更新！)<br>        i += <span class="hljs-number">1</span> （最大程度的压缩i，使得滑窗尽可能的小）<br>    &#125;<br>    j += <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (end &lt; nums.length) &#123;<br>     sum += nums[end];<br>     <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>     min = Math.min(min, end - start + <span class="hljs-number">1</span>);<br>        sum -= nums[start];<br>        start++;<br>     &#125;<br>     end++;<br>&#125;<br></code></pre></td></tr></table></figure><p>代表题目为209</p><p>最大滑动窗口模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (j &lt; len)&#123;<br>    判断[i, j]是否满足条件<br>    <span class="hljs-keyword">while</span> (不满足条件)&#123;<br>        i += <span class="hljs-number">1</span> （最大程度的压缩i，使得滑窗尽可能的小）<br>    &#125;<br>    不断更新结果(注意在<span class="hljs-keyword">while</span>内更新！)<br>    j += <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (right &lt; fruits.length) &#123;<br>    map.put(fruits[right], map.getOrDefault(fruits[right], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (map.size() &gt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-comment">// count为水果最大数目，当map大小超过2时，滑窗需前移left;</span><br>       map.put(fruits[left], map.get(fruits[left]) - <span class="hljs-number">1</span>);<br>       <span class="hljs-keyword">if</span> (map.get(fruits[left]) == <span class="hljs-number">0</span>) &#123;<br>            map.remove(fruits[left]);<br>       &#125;<br>       left++;<br>    &#125;<br>    count = Math.max(count, right - left + <span class="hljs-number">1</span>);<br>    right++;<br>&#125;<br></code></pre></td></tr></table></figure><p>代表题目为904</p><h2 id="4、59-螺旋矩阵II">4、59.螺旋矩阵II</h2><p>正确解决二分法是坚持循环不变量原则，这道题也是一样，要么一直左闭右开，要么一直左闭右闭。</p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由此可见，需要定义的变量有：</p><ol><li>返回的数组</li><li>循环次数，每一环为一次，定义这个的目的是控制边界，因为有的时候需要赋值n-1次，有的时候需要赋值n-2次，这个时候就要用到循环次数</li><li>定义起始变量start，每循环一圈就令start++</li><li>定义全局变量i, j</li></ol><h3 id="相关题目推荐">相关题目推荐</h3><ul><li>54.螺旋矩阵</li><li>剑指Offer 29.顺时针打印矩阵</li></ul><h2 id="5、二位数组中的查找（牛客">5、二位数组中的查找（牛客</h2><p>题目链接：<a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=295&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=%2Fexam%2Foj">二位数组中的查找</a></p><h3 id="1、方法一">1、方法一</h3><p>直接二维循环暴力，不多赘述</p><h3 id="2、方法二">2、方法二</h3><p>可以发现，只有当前行有一个元素大于目标值，那么该元素后面的和下面的就不用看了，也肯定大于元素。相当于暴力法的剪枝操作。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span> [][] array)</span> &#123;<br>    <span class="hljs-comment">// 剪枝    </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>                <span class="hljs-keyword">if</span> (array[i][j] == target)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (array[i][j] &gt; target &amp;&amp; col == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (array[i][j] &gt; target) &#123;<br>                    col = j;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3、方法三">3、方法三</h3><p>首先看四个角，左上与右下必定为最小值与最大值，而左下与右上就有规律了：<strong>左下元素大于它上方的元素，小于它右方的元素，右上元素与之相反</strong>。既然左下角元素有这么一种规律，相当于将要查找的部分分成了一个大区间和小区间，每次与左下角元素比较，我们就知道目标值应该在哪部分中，于是可以利用分治思维来做。</p><p>首先以左下角为起点，若是它小于目标元素，则往右移动去找大的，若是他大于目标元素，则往上移动去找小的。若是移动到了矩阵边界也没找到，说明矩阵中不存在目标值。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span> [][] array)</span> &#123;<br>        <span class="hljs-comment">//优先判断特殊</span><br>        <span class="hljs-keyword">if</span>(array.length == <span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> array.length;<br>        <span class="hljs-keyword">if</span>(array[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">//从最左下角的元素开始往左或往上</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; m; )&#123;<br>            <span class="hljs-comment">//元素较大，往上走</span><br>            <span class="hljs-keyword">if</span>(array[i][j] &gt; target)  <br>                i--;<br>            <span class="hljs-comment">//元素较小，往右走</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(array[i][j] &lt; target)<br>                j++;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记</title>
      <link href="/2022/09/27/du-shu-bi-ji/"/>
      <url>/2022/09/27/du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="cf0279ad49910541a41438567238882f062868c64d59367d913b7c1bd3b3089e">8f1cbd128789af83855b0654c56affebf269f8ebeab30c7a77e0ad4ee53534abf8127398457cf86c0a224b90ebb981babd3b9be897d78041891daa3f617b8cab38db2f0c759631a4f9efd0d4ab8245ba4a7bbc95f81300c612cd4b417dd90c18c2f1d33e07c6f22142c1f6c0339b43fac635fd6003dc5c96eac2d9c9154950d88ec5127277c234aba901eae0d89636e089f1ea5aad9bb29276f48a4cbd272f9348bc04b52e4c0934df487d08c5d4bbdbc18609161b31bc9b5d227f82f63e6cad564fecd7f44940232104f77c4f87776b435c4d888461eff3c179bb40b2eceb43c359cfa9d316b5f35959cf71140812f656dd0e34e0abdefbae6c8e935303136616c7bcd3f3ae4557753a25aecf793c7851a10d84c1ad923e035a9166126ce6165a746b2af10cc1084861baff6548cfeab4679837e4572ea4be1cbabf72bf4423a3e0e2f5f19d29f9f10282ea04fc5694262a051b1ccfcbd7c0ed58a1b6c0db1d0559bd7cd6c4f219bf2efc3c09d0bc46fe60da3d1199441223587e1e62639384b09630b4d285cf38e5a8c73084ecf0a26246e998e8c90219bfa1fd52525aa73fcde9de5a09c565a3c57e1aa69a13fbd0809424f4e7d367a7373d34976d33b59022effc1b3ca633a6f323756622e56d7bcaa5e0cf088c4ff41b9967ce307568439244dc2845f74dd570960e0c183b117f00ff2c7494c6d922e41e1d15168eee6bc62a6b4fbf200b272144858da49b4752fd88524c6a1a6c89504280af5a2608594867f353c620568e5d0e2e902f989049f34c8b308738e3cbd3d6b339b7c095ae55db010b474c5d16d22cf782254c722bc3b199e07d0a758b79ab381b1311d01b1c769da858b98da8301e0f23b47e04fc2d5090b18e9554f683b7310a547ec15c94951d2570e0d12d6f177a808bde9925a23e47e450d44f7f0f781c2689aa7a480d06b2357e8ea2b95a01c07adda1860efaaeb0aace985527a0a9fa712af992b9dcd912c78169bf9e7018f129a1b2cecf2fecb165f486160922f35688c82eed9cdb34bc10eb2fcd7a756493a0f844d6fd08f9d4014758426820e23847f383b966cde71a04f0f6b87f14a5b8a0fca77557a306e7481979709f5c5c225f0f084bbef65f70be04c0fde7dfbfb1dfc6f14cf44aaf2b5b95c4122686c8065a6977ed355f8f4e648a05cb0ea6dc0643bdc2fc1d2de57dfd4089d7f32a8dd76766df60ee4cfd88e24721f11292f5b1f502f1a72f0497ef36f3c1ac4cb3ee17083248d8c8ca998608701ac0dd8139425e1a9b6f99cf9c3eeac2a06aed83b38a20f73b84b0090a2b8a36c99272737f93885174ab1e87cefdb9a3f2fdffa933e4c795e2adf3903c845ecda24f99e75be87e7b8bf4dbf5ac1226e097ded11ddf7a8f63de1c5e822228fc9b84ed261c449983b82e175c2c5b096d54929dc1c189c73eacd8af898780bd5cca8258fc2cc5abc5b9b369af006f9504e54c82ff73a5298e247417397c5d1c4664a066f1fce2f9801dd32139557941437d8acb596bf3dfd58345e92e9813efdfab7600a35f7013502f6d2cb14539ebe1b0f151ad3920b0917d463a10aceb17a3ff3b8b922f00a09c05d72a5a7a0880e82eaf523458a6d474a2c6e98d0c0c6340f1c9a2c7486af0b97237050ceb7e40c73d0346d79b96ddb3374b14528c391905fd3b7c22b6b58c9f17e7f28404686744d8e9753cf06aca1ca3fcee9142110970d9d602147d4c50501572bbb66203231abffa86dd7d8909e60c3b003addd350272effe4d90625dc7a8d091e8e4ab7c44461419a80cd87dbed723b88a5c4d0d45fef83449c00c943e997f780c3917cd142083e4d7f58f96b78fd4a61b0d666904e9b9e9ed6f9ed65fb799df4820eabc22406f397d783884f0cd8dce42f4ced411fe1f77619708683fbb8672c2d234aa0d81942324cbd0f234622d6776050a137a57025533f1ed330048344113378de2d209a607d61496caf353f958d267f5db13126d8b812ad3139b8a3cafa05ab29488aa907e9f6e8349d9c57cb045aff4d0aaaf20dcd916ff7ffae8cd6a13249c0594c0240e8b170138c56e7536a9ca0becfef3bf9b70fcaa703d9b10359f3d43375a9d419c113fe8cdaebbde1a9930ef2fc0f24b4527ecaa49a1110cd6091463132fbd2abbc880408369060d5c8c69d39a56f98aa26bfef8fd40247b44041b3e57b33afde1865b83360076e6b00b21b5f0722e1b63b5f6a0addc0e2a53bd4ac6161f0fb705dad36ffde6a9ae1e0faabd85586a5b8ee765e473245ad86c1b4edcf809fc70ec8f77a7204c4090fc9048f34d67c8160b1c95c17d2da5af81581cc237b8a760d8e4d048149f3e942fc67ee7cc854a37636bf1b6e04523f3833a492d2849f705e946de1cecf99ad61ad87df6ee1951b63311f031bdc223d2355091ed4ee9ae9d49e0c95fd307a798d749a4fa6c7205411f649e9e6a90282208cfd4e6fcca058a73cee157ab2c60a020ead4bf2550f2e310d2035a303771a7aea9b44af1880659f53c21ed3cd4def1024817f273e980268c34df8ce0c671ce28f25197f907c9076561ae8c7fb3280e2ae4253456cc5cfbf323f72bf400eea4c5d3e0c1a27caea441977e1d347713987c87770b563749621f376713c26500fc16b0aadd86ac88abdf359bc873ea7f8f03a129d71d9963d1d7de394a4671fbf5adb179a2f211a2bca9e66c138e008ff6e80c793ba8e5fcc8624e932865d3f8decf3aadc682ec981171f9938cb177bcb8a3746438d78003b054298fbad9e79e8be90159351cccd96c2aa103e568440863da5b732619bd417bac1ab5ccf81ffca59856b1e144059b40b0ae30b4122202b9cd0763909af9672073cb99034a86ff84a5839f773b41c59ad4565f8eeb645ca911efaf0d0beacd4dab3b7e396b0c5171a4332d002f7e910590fef6c8fe879e7fd83b641ae32aa27adc73d02d4ae3a16ef4bcb376c6171cc76004458e940d02828a37663cf4e34309f52aba8ee30cc624b6d38fd487727a9cd642a9c16314fe91dd48c5d4566c9baf6a3d8ff1db8ae4acc89b2a3aba5bb82bb8526c3687b49ce564769ac0e3d509283f067f036593a4d3370add7239e3fd5e5b3c601b92df1e46a5f9339377b955ed9e58b52aedcf248fbfc2f6c88a5945a721cc2d70d67252e7d70571b66539f811b93c6b8e74e447dad4e63a3fa76c9de17685b5f58539ef6f315632ecff98740d3344f5654f8ae841a294f34b2b80c766d670749d8e31b89814b78801113b14efa0f9f24c669dcb2c93692c00f77ce56b94759adcf4ca3b852ad9033875439288c99a723c0f9b032a554cefbfbbfa63405cdad9b10917dc28dfde6dcb61f344e857caebf1c166145755d0d7429bd3419a801dadc4b4884b7fbed226a76001a2548cdbe63e73c0986e4a74c28ff6e6964e71368c965dc2ef9dd91af4e4f2a4f3f7fcba28eac94c3ac7d851f7bb1255ee28835697e0a6632626ea3f4d27100054d3bb197534fcc0f2dbe868d79f2d7c7a77d5d92e56938ba17fd8d09cfde0f66177a261b61e7d6cac0fbf160f0092f24c1f22702476fa895f2490442717a6d747ee38cb742634a9e527dc128a5bda7e91d2ee0d3fe69c0d4ab0141bf57ccf551cb91b9cce369040a765717b650d3a6f43eceb072e82561f9b8962aa2b71d21fe61882e63371bd56cfa5f52620f673c8c34552e2636b5c4811a81d2d4c246c036b8a988a2dd73f97df70b5bc2e2ff06cac391d69196a40710e30f9f010d5cc6503d6f0b2d81eea1f9f43c0573b601badeb71b421235ff2c4380fd969cf0f2315275fe50185c2f482d149c7170c8bea3f21a12f161a9ce93608c6a76154e9b73ccc10c03e24ed43cdb5f632351be8cbee7cf5e14b2cdeb28ceeb2da842ed0531e42a97bb6997e0430a3fc4a1a74f3b343e4b2e8534e5e277294b95429d21d9df258858af26e6ce94378a7c0e368a52d6d2f3674698da6cac9b3635b3dafbf40895845142c102ce09cbb726722ea63526c143c37e47456d2825b3e6bd1364656104f42ef5509a103bec2f4acb093371c81caf74b23f386914fc7f59b8ccc3da8fe332f0aad11411b8354309a437b1213f2fe52e53d435f209875d80dd36d46f0e7d64cd5b9cb30bc731da8306a951ab82c489aaca1a36c857bb4ca2ae20fbfd942d374184c0cea3d89d9c49635c2b8b36adcd9c680f099434fbf3df68bcb2af7b1bec6754c503b8bc9ce006353f8b686bad96048dabde4fa9edfb3f7b7feb5458e9ce71861a507ca7a90365c55a2bd5becda4bc37d905c3dbd9061ef0a244e1de7eae13f5714b3096b94105754ae5226cee6a9538ee4e0e4fb512df5289f8da7265a1e46f140595fde6155c904ca3928103a51a943d74a796b952ccc03319f2b8aafa65eb9cd2d9a13f8e57f21e47f9b4226bfc0938491b69630bbd43a01c846d46cc8735335c25895c3baf4a1d6ea760870a39277cb9710ef04e5279c1d149f592a0858844f8900ca34b838188c460381db0374f162f075eb370537ca3391d33e4dcbdac0e7d645e94cc9050438290c40966634117393d85031f95e338edbc3e27273b1e0a65e253d0db09b355b838b389d927b240fa3b7861443b3fe416b78c8848d6d84f63e915ba793704d7ec9e1f872594c74ebaae65aa5d6f0496</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06-行为型-观察者-模板</title>
      <link href="/2022/09/27/06-xing-wei-xing-guan-cha-zhe-mo-ban/"/>
      <url>/2022/09/27/06-xing-wei-xing-guan-cha-zhe-mo-ban/</url>
      
        <content type="html"><![CDATA[<h1 id="一、观察者模式【常用】"><a href="#一、观察者模式【常用】" class="headerlink" title="一、观察者模式【常用】"></a>一、观察者模式【常用】</h1><ol><li>23种设计模式分为创建型、结构型、行为型。创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合或组装”问题，那行为型设计模式主要解决的就是“类或对象之间的交互”问题。</li><li>行为型设计模式比较多，有 11 个，几乎占了 23 种经典设计模式的一半。它们分别是：观察者模式、模板模式、策略模式、职责链模式、状态模式、迭代器模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</li><li>根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</li></ol><h2 id="1、Demo案例-天气预报"><a href="#1、Demo案例-天气预报" class="headerlink" title="1、Demo案例-天气预报"></a>1、Demo案例-天气预报</h2><ol><li>气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去(比如发布到自己的网站或第三方)。</li><li>需要<strong>设计开放型</strong> <strong>API</strong>，便于<strong>其他第三方也能接入气象站获取数据</strong>。</li><li>提供温度、气压和湿度的接口</li><li>测量数据更新时，要能实时的通知给第三方</li></ol><h3 id="1、方案一"><a href="#1、方案一" class="headerlink" title="1、方案一"></a>1、方案一</h3><p><img src="/2022/09/27/06-xing-wei-xing-guan-cha-zhe-mo-ban/image-20220930151033041.png" alt="传统设计方案"></p><h4 id="1、WeatherData"><a href="#1、WeatherData" class="headerlink" title="1、WeatherData"></a>1、WeatherData</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 类是核心</span><br><span class="hljs-comment"> * 1. 包含最新的天气情况信息 </span><br><span class="hljs-comment"> * 2. 含有 CurrentConditions 对象</span><br><span class="hljs-comment"> * 3. 当数据有更新时，就主动的调用   CurrentConditions对象update方法(含 display), 这样他们（接入方）就看到最新的信息</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeatherData</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> temperatrue;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> pressure;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> humidity;<br>   <span class="hljs-keyword">private</span> CurrentConditions currentConditions;<br>   <span class="hljs-comment">//加入新的第三方</span><br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">WeatherData</span><span class="hljs-params">(CurrentConditions currentConditions)</span> &#123;<br>      <span class="hljs-built_in">this</span>.currentConditions = currentConditions;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getTemperature</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> temperatrue;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getPressure</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> pressure;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getHumidity</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> humidity;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dataChange</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//调用 接入方的 update</span><br>      currentConditions.update(getTemperature(), getPressure(), getHumidity());<br>   &#125;<br><br>   <span class="hljs-comment">//当数据有更新时，就调用 setData</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> pressure, <span class="hljs-type">float</span> humidity)</span> &#123;<br>      <span class="hljs-built_in">this</span>.temperatrue = temperature;<br>      <span class="hljs-built_in">this</span>.pressure = pressure;<br>      <span class="hljs-built_in">this</span>.humidity = humidity;<br>      <span class="hljs-comment">//调用dataChange， 将最新的信息 推送给 接入方 currentConditions</span><br>      dataChange();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、CurrentConditions"><a href="#2、CurrentConditions" class="headerlink" title="2、CurrentConditions"></a>2、CurrentConditions</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 显示当前天气情况（可以理解成是气象站自己的网站）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CurrentConditions</span> &#123;<br>   <span class="hljs-comment">// 温度，气压，湿度</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> temperature;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> pressure;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> humidity;<br><br>   <span class="hljs-comment">//更新 天气情况，是由 WeatherData 来调用，我使用推送模式</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> pressure, <span class="hljs-type">float</span> humidity)</span> &#123;<br>      <span class="hljs-built_in">this</span>.temperature = temperature;<br>      <span class="hljs-built_in">this</span>.pressure = pressure;<br>      <span class="hljs-built_in">this</span>.humidity = humidity;<br>      display();<br>   &#125;<br><br>   <span class="hljs-comment">//显示</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;***Today mTemperature: &quot;</span> + temperature + <span class="hljs-string">&quot;***&quot;</span>);<br>      System.out.println(<span class="hljs-string">&quot;***Today mPressure: &quot;</span> + pressure + <span class="hljs-string">&quot;***&quot;</span>);<br>      System.out.println(<span class="hljs-string">&quot;***Today mHumidity: &quot;</span> + humidity + <span class="hljs-string">&quot;***&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、Client"><a href="#3、Client" class="headerlink" title="3、Client"></a>3、Client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 创建接入方 currentConditions</span><br>    <span class="hljs-type">CurrentConditions</span> <span class="hljs-variable">currentConditions</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CurrentConditions</span>();<br>    <span class="hljs-comment">// 创建 WeatherData 并将 接入方 currentConditions 传递到 WeatherData中</span><br>    <span class="hljs-type">WeatherData</span> <span class="hljs-variable">weatherData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeatherData</span>(currentConditions);<br><br>    <span class="hljs-comment">// 更新天气情况</span><br>    weatherData.setData(<span class="hljs-number">30</span>, <span class="hljs-number">150</span>, <span class="hljs-number">40</span>);<br><br>    <span class="hljs-comment">// 天气情况变化</span><br>    System.out.println(<span class="hljs-string">&quot;============天气情况变化=============&quot;</span>);<br>    weatherData.setData(<span class="hljs-number">40</span>, <span class="hljs-number">160</span>, <span class="hljs-number">20</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、问题分析"><a href="#4、问题分析" class="headerlink" title="4、问题分析"></a>4、问题分析</h4><ol><li>其他第三方接入气象站获取数据的问题，无法在运行时动态的添加第三方 (新浪网站)</li><li>违反 ocp 原则，当加入第三方时，需要修改WeatherData代码，不利于维护。</li></ol><h3 id="2、观察者模式方案"><a href="#2、观察者模式方案" class="headerlink" title="2、观察者模式方案"></a>2、观察者模式方案</h3><h4 id="1、Subject【接口】"><a href="#1、Subject【接口】" class="headerlink" title="1、Subject【接口】"></a>1、Subject【接口】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口, 让WeatherData 来实现 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer o)</span>;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer o)</span>;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、Observer【接口】"><a href="#2、Observer【接口】" class="headerlink" title="2、Observer【接口】"></a>2、Observer【接口】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//观察者接口，有观察者来实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> pressure, <span class="hljs-type">float</span> humidity)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、WeatherData"><a href="#3、WeatherData" class="headerlink" title="3、WeatherData"></a>3、WeatherData</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeatherData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> temperatrue;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> pressure;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> humidity;<br>   <span class="hljs-comment">//观察者集合</span><br>   <span class="hljs-keyword">private</span> ArrayList&lt;Observer&gt; observers;<br>   <br>   <span class="hljs-comment">//加入新的第三方</span><br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">WeatherData</span><span class="hljs-params">()</span> &#123;<br>      observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Observer&gt;();<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getTemperature</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> temperatrue;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getPressure</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> pressure;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getHumidity</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> humidity;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dataChange</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//调用 接入方的 update</span><br>      <br>      notifyObservers();<br>   &#125;<br><br>   <span class="hljs-comment">//当数据有更新时，就调用 setData</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> pressure, <span class="hljs-type">float</span> humidity)</span> &#123;<br>      <span class="hljs-built_in">this</span>.temperatrue = temperature;<br>      <span class="hljs-built_in">this</span>.pressure = pressure;<br>      <span class="hljs-built_in">this</span>.humidity = humidity;<br>      <span class="hljs-comment">//调用dataChange， 将最新的信息 推送给 接入方 currentConditions</span><br>      dataChange();<br>   &#125;<br><br>   <span class="hljs-comment">//注册一个观察者</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer o)</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      observers.add(o);<br>   &#125;<br><br>   <span class="hljs-comment">//移除一个观察者</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer o)</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-keyword">if</span>(observers.contains(o)) &#123;<br>         observers.remove(o);<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-comment">//遍历所有的观察者，并通知</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; observers.size(); i++) &#123;<br>         observers.get(i).update(<span class="hljs-built_in">this</span>.temperatrue, <span class="hljs-built_in">this</span>.pressure, <span class="hljs-built_in">this</span>.humidity);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、CurrentConditions"><a href="#4、CurrentConditions" class="headerlink" title="4、CurrentConditions"></a>4、CurrentConditions</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CurrentConditions</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br><br>   <span class="hljs-comment">// 温度，气压，湿度</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> temperature;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> pressure;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> humidity;<br><br>   <span class="hljs-comment">// 更新 天气情况，是由 WeatherData 来调用，我使用推送模式</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> pressure, <span class="hljs-type">float</span> humidity)</span> &#123;<br>      <span class="hljs-built_in">this</span>.temperature = temperature;<br>      <span class="hljs-built_in">this</span>.pressure = pressure;<br>      <span class="hljs-built_in">this</span>.humidity = humidity;<br>      display();<br>   &#125;<br><br>   <span class="hljs-comment">// 显示</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;***Today mTemperature: &quot;</span> + temperature + <span class="hljs-string">&quot;***&quot;</span>);<br>      System.out.println(<span class="hljs-string">&quot;***Today mPressure: &quot;</span> + pressure + <span class="hljs-string">&quot;***&quot;</span>);<br>      System.out.println(<span class="hljs-string">&quot;***Today mHumidity: &quot;</span> + humidity + <span class="hljs-string">&quot;***&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、BaiduSite"><a href="#5、BaiduSite" class="headerlink" title="5、BaiduSite"></a>5、BaiduSite</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaiduSite</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br><br>  <span class="hljs-comment">// 温度，气压，湿度</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> temperature;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> pressure;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> humidity;<br><br>  <span class="hljs-comment">// 更新 天气情况，是由 WeatherData 来调用，我使用推送模式</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> pressure, <span class="hljs-type">float</span> humidity)</span> &#123;<br>    <span class="hljs-built_in">this</span>.temperature = temperature;<br>    <span class="hljs-built_in">this</span>.pressure = pressure;<br>    <span class="hljs-built_in">this</span>.humidity = humidity;<br>    display();<br>  &#125;<br><br>  <span class="hljs-comment">// 显示</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;===百度网站====&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;***百度网站 气温 : &quot;</span> + temperature + <span class="hljs-string">&quot;***&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;***百度网站 气压: &quot;</span> + pressure + <span class="hljs-string">&quot;***&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;***百度网站 湿度: &quot;</span> + humidity + <span class="hljs-string">&quot;***&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、Client"><a href="#6、Client" class="headerlink" title="6、Client"></a>6、Client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-comment">// 创建一个WeatherData</span><br>    <span class="hljs-type">WeatherData</span> <span class="hljs-variable">weatherData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeatherData</span>();<br><br>    <span class="hljs-comment">// 创建观察者</span><br>    <span class="hljs-type">CurrentConditions</span> <span class="hljs-variable">currentConditions</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CurrentConditions</span>();<br>    <span class="hljs-type">BaiduSite</span> <span class="hljs-variable">baiduSite</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaiduSite</span>();<br><br>    <span class="hljs-comment">// 注册到weatherData</span><br>    weatherData.registerObserver(currentConditions);<br>    weatherData.registerObserver(baiduSite);<br><br>    <span class="hljs-comment">// 测试</span><br>    System.out.println(<span class="hljs-string">&quot;通知各个注册的观察者, 看看信息&quot;</span>);<br>    weatherData.setData(<span class="hljs-number">10f</span>, <span class="hljs-number">100f</span>, <span class="hljs-number">30.3f</span>);<br><br>    weatherData.removeObserver(currentConditions);<br>    <span class="hljs-comment">// 测试</span><br>    System.out.println();<br>    System.out.println(<span class="hljs-string">&quot;通知各个注册的观察者, 看看信息&quot;</span>);<br>    weatherData.setData(<span class="hljs-number">10f</span>, <span class="hljs-number">100f</span>, <span class="hljs-number">30.3f</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、原理及应用场景剖析"><a href="#2、原理及应用场景剖析" class="headerlink" title="2、原理及应用场景剖析"></a>2、原理及应用场景剖析</h2><p><strong>观察者模式</strong>也被称为<strong>发布订阅模式</strong>。</p><p>在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p><ol><li>一般情况下，被依赖的对象叫作<strong>被观察者</strong>（Observable），依赖的对象叫作<strong>观察者</strong>（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。</li><li>实际上，观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式。现在先来看其中最经典的一种实现方式。这也是在讲到这种模式的时候，很多书籍或资料给出的最常见的实现方式。具体的代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer observer)</span>;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer observer)</span>;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">(Message message)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Message message)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>  <span class="hljs-keyword">private</span> List&lt;Observer&gt; observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Observer&gt;();<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer observer)</span> &#123;<br>    observers.add(observer);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer observer)</span> &#123;<br>    observers.remove(observer);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">(Message message)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Observer observer : observers) &#123;<br>      observer.update(message);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserverOne</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Message message)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span><br>    System.out.println(<span class="hljs-string">&quot;ConcreteObserverOne is notified.&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserverTwo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Message message)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span><br>    System.out.println(<span class="hljs-string">&quot;ConcreteObserverTwo is notified.&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ConcreteSubject</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteSubject</span>();<br>    subject.registerObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserverOne</span>());<br>    subject.registerObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserverTwo</span>());<br>    subject.notifyObservers(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原理和代码都比较容易理解，但是这种设计模式能解决什么问题？</p><p>假设我们在开发一个 P2P 投资理财系统，用户注册成功之后，我们会给用户发放投资体验金。代码实现大致是下面这个样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>  <span class="hljs-keyword">private</span> UserService userService; <span class="hljs-comment">// 依赖注入</span><br>  <span class="hljs-keyword">private</span> PromotionService promotionService; <span class="hljs-comment">// 依赖注入</span><br><br>  <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-comment">// 省略输入参数的校验代码</span><br>    <span class="hljs-comment">// 省略userService.register()异常的try-catch代码</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> userService.register(telephone, password);<br>    promotionService.issueNewUserExperienceCash(userId);<br>    <span class="hljs-keyword">return</span> userId;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>虽然注册接口做了两件事情，注册和发放体验金，违反单一职责原则，但是，如果没有扩展和修改的需求，现在的代码实现是可以接受的。如果非得用观察者模式，就需要引入更多的类和更加复杂的代码结构，反倒是一种过度设计。</li><li>相反，如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠券，并且还要给用户发送一封“欢迎注册成功”的站内信。这种情况下，我们就需要频繁地修改 register() 函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操作越来越多，那 register() 函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维护性。</li><li>这个时候，观察者模式就能派上用场了。利用观察者模式，对上面的代码进行了重构。重构之后的代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RegObserver</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRegSuccess</span><span class="hljs-params">(<span class="hljs-type">long</span> userId)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegPromotionObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RegObserver</span> &#123;<br>  <span class="hljs-keyword">private</span> PromotionService promotionService; <span class="hljs-comment">// 依赖注入</span><br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRegSuccess</span><span class="hljs-params">(<span class="hljs-type">long</span> userId)</span> &#123;<br>    promotionService.issueNewUserExperienceCash(userId);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegNotificationObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RegObserver</span> &#123;<br>  <span class="hljs-keyword">private</span> NotificationService notificationService;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRegSuccess</span><span class="hljs-params">(<span class="hljs-type">long</span> userId)</span> &#123;<br>    notificationService.sendInboxMessage(userId, <span class="hljs-string">&quot;Welcome...&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>  <span class="hljs-keyword">private</span> UserService userService; <span class="hljs-comment">// 依赖注入</span><br>  <span class="hljs-keyword">private</span> List&lt;RegObserver&gt; regObservers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  <span class="hljs-comment">// 一次性设置好，之后也不可能动态的修改</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRegObservers</span><span class="hljs-params">(List&lt;RegObserver&gt; observers)</span> &#123;<br>    regObservers.addAll(observers);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-comment">// 省略输入参数的校验代码</span><br>    <span class="hljs-comment">// 省略userService.register()异常的try-catch代码</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> userService.register(telephone, password);<br><br>    <span class="hljs-keyword">for</span> (RegObserver observer : regObservers) &#123;<br>      observer.handleRegSuccess(userId);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> userId;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>当我们需要添加新的观察者的时候，比如，用户注册成功之后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，UserController 类的 register() 函数完全不需要修改，只需要再添加一个实现了 RegObserver 接口的类，并且通过 setRegObservers() 函数将它注册到 UserController 类中即可。</li><li>前面我们已经学习了很多设计模式，不知道你有没有发现，实际上，<strong>设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。</strong>借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚松耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。</li></ol><h2 id="3、基于不同应用场景的不同实现方式"><a href="#3、基于不同应用场景的不同实现方式" class="headerlink" title="3、基于不同应用场景的不同实现方式"></a>3、基于不同应用场景的不同实现方式</h2><ol><li>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。</li><li>观察者模式有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</li><li>之前讲到的实现方式，从刚刚的分类方式上来看，它是一种同步阻塞的实现方式。观察者和被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码。对照上面讲到的用户注册的例子，register() 函数依次调用执行每个观察者的 handleRegSuccess() 函数，等到都执行完成之后，才会返回结果给客户端。</li><li>如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间尽可能短，那我们可以将同步阻塞的实现方式改为异步非阻塞的实现方式，以此来减少响应时间。具体来讲，当 userService.register() 函数执行完成之后，我们启动一个新的线程来执行观察者的 handleRegSuccess() 函数，这样 userController.register() 函数就不需要等到所有的 handleRegSuccess() 函数都执行完成之后才返回结果给客户端。userController.register() 函数从执行 3 个 SQL 语句才返回，减少到只需要执行 1 个 SQL 语句就返回，响应时间粗略来讲减少为原来的 1/3。</li><li>那如何实现一个异步非阻塞的观察者模式呢？简单一点的做法是，在每个 handleRegSuccess() 函数中，创建一个新的线程执行代码。不过，我们还有更加优雅的实现方式，那就是基于 EventBus 来实现。它可以复用在任何需要异步非阻塞观察者模式的应用场景中。</li><li>刚刚讲到的两个场景，不管是同步阻塞实现方式还是异步非阻塞实现方式，都是进程内的实现方式。如果用户注册成功之后，我们需要发送用户信息给大数据征信系统，而大数据征信系统是一个独立的系统，跟它之间的交互是跨不同进程的，那如何实现一个跨进程的观察者模式呢？</li><li>如果大数据征信系统提供了发送用户注册信息的 RPC 接口，我们仍然可以沿用之前的实现思路，在 handleRegSuccess() 函数中调用 RPC 接口来发送数据。但是，我们还有更加优雅、更加常用的一种实现方式，那就是基于消息队列（Message Queue，比如 ActiveMQ）来实现。</li><li>当然，这种实现方式也有弊端，那就是需要引入一个新的系统（消息队列），增加了维护成本。不过，它的好处也非常明显。在原来的实现方式中，观察者需要注册到被观察者中，被观察者需要依次遍历观察者来发送消息。而基于消息队列的实现方式，被观察者和观察者解耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。</li></ol><p>关于EventBus可以看这篇博客   </p><p><a href="https://imlql.cn/post/dd09051e.html">https://imlql.cn/post/dd09051e.html</a></p><h1 id="二、模板模式【常用】"><a href="#二、模板模式【常用】" class="headerlink" title="二、模板模式【常用】"></a>二、模板模式【常用】</h1><p>模板模式两大作用：复用和扩展</p><h2 id="1、Demo案例-豆浆制作"><a href="#1、Demo案例-豆浆制作" class="headerlink" title="1、Demo案例-豆浆制作"></a>1、Demo案例-豆浆制作</h2><p>编写制作豆浆的程序，说明如下: </p><ol><li>制作豆浆的流程 选材—&gt;添加配料—&gt;浸泡—&gt;放到豆浆机打碎 </li><li>通过添加不同的配料，可以制作出不同口味的豆浆 </li><li>选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的 </li><li>请使用 模板方法模式 完成 </li></ol><h3 id="1、SoyaMilk【抽象类】"><a href="#1、SoyaMilk【抽象类】" class="headerlink" title="1、SoyaMilk【抽象类】"></a>1、SoyaMilk【抽象类】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象类，表示豆浆</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SoyaMilk</span> &#123;<br><br>   <span class="hljs-comment">//模板方法, make , 模板方法可以做成final , 不让子类去覆盖.</span><br>   <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">make</span><span class="hljs-params">()</span> &#123;<br>      <br>      select(); <br>      <span class="hljs-keyword">if</span>(customerWantCondiments()) &#123;<br>         addCondiments();<br>      &#125;<br>      soak();<br>      beat();<br>      <br>   &#125;<br>   <br>   <span class="hljs-comment">//选材料</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;第一步：选择好的新鲜黄豆  &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-comment">//添加不同的配料， 抽象方法, 子类具体实现</span><br>   <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span>;<br>   <br>   <span class="hljs-comment">//浸泡</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">soak</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;第三步， 黄豆和配料开始浸泡， 需要3小时 &quot;</span>);<br>   &#125;<br>    <br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">beat</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;第四步：黄豆和配料放到豆浆机去打碎  &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-comment">//钩子方法，决定是否需要添加配料</span><br>   <span class="hljs-type">boolean</span> <span class="hljs-title function_">customerWantCondiments</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、RedBeanSoyaMilk"><a href="#2、RedBeanSoyaMilk" class="headerlink" title="2、RedBeanSoyaMilk"></a>2、RedBeanSoyaMilk</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedBeanSoyaMilk</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SoyaMilk</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    System.out.println(<span class="hljs-string">&quot; 加入上好的红豆 &quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、PureSoyaMilk"><a href="#3、PureSoyaMilk" class="headerlink" title="3、PureSoyaMilk"></a>3、PureSoyaMilk</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 纯豆浆</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PureSoyaMilk</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SoyaMilk</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-comment">// 空实现</span><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">customerWantCondiments</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、PeanutSoyaMilk"><a href="#4、PeanutSoyaMilk" class="headerlink" title="4、PeanutSoyaMilk"></a>4、PeanutSoyaMilk</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PeanutSoyaMilk</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SoyaMilk</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCondiments</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    System.out.println(<span class="hljs-string">&quot; 加入上好的花生 &quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、Client"><a href="#5、Client" class="headerlink" title="5、Client"></a>5、Client</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;----制作红豆豆浆----&quot;</span>);<br>    <span class="hljs-type">SoyaMilk</span> <span class="hljs-variable">redBeanSoyaMilk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedBeanSoyaMilk</span>();<br>    redBeanSoyaMilk.make();<br><br>    System.out.println(<span class="hljs-string">&quot;----制作花生豆浆----&quot;</span>);<br>    <span class="hljs-type">SoyaMilk</span> <span class="hljs-variable">peanutSoyaMilk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PeanutSoyaMilk</span>();<br>    peanutSoyaMilk.make();<br><br>    System.out.println(<span class="hljs-string">&quot;----制作纯豆浆----&quot;</span>);<br>    <span class="hljs-type">SoyaMilk</span> <span class="hljs-variable">pureSoyaMilk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PureSoyaMilk</span>();<br>    pureSoyaMilk.make();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、原理及应用"><a href="#2、原理及应用" class="headerlink" title="2、原理及应用"></a>2、原理及应用</h2><p>模板方法模式（Template Method Pattern），又叫模板模式(Template Pattern)，z 在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法 实现，但调用将以抽象类中定义的方式进行。</p><p>简单说，模板方法模式 定义一个操作中的算法的骨架，而将一些步骤延迟到子 类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定 步骤</p><p>原理很简单，代码实现就更加简单，我写了一个示例代码，如下所示。templateMethod() 函数定义为 final，是为了避免子类重写它。method1() 和 method2() 定义为 abstract，是为了强迫子类去实现。不过，这些都不是必须的，在实际的项目开发中，模板模式的代码实现比较灵活，待会儿讲到应用场景的时候，我们会有具体的体现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">templateMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...</span><br>        method1();<br>        <span class="hljs-comment">//...</span><br>        method2();<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">AbstractClass</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> ConcreteClass1();<br>demo.templateMethod();<br></code></pre></td></tr></table></figure><h2 id="3、模板作用一：复用"><a href="#3、模板作用一：复用" class="headerlink" title="3、模板作用一：复用"></a>3、模板作用一：复用</h2><p>模板模式把一个算法中不变的流程抽象到父类的模板方法 templateMethod() 中，将可变的部分 method1()、method2() 留给子类 ContreteClass1 和 ContreteClass2 来实现。所有的子类都可以复用父类中模板方法定义的流程代码。</p><h3 id="1、Java-InputStream"><a href="#1、Java-InputStream" class="headerlink" title="1、Java InputStream"></a>1、Java InputStream</h3><ol><li>Java IO 类库中，有很多类的设计用到了模板模式，比如 InputStream、OutputStream、Reader、Writer。拿 InputStream 来举例说明一下。</li><li> InputStream 部分相关代码如下。在代码中，read() 函数是一个模板方法，定义了读取数据的整个流程，并且暴露了一个可以由子类来定制的抽象方法。不过这个方法也被命名为了 read()，只是参数跟模板方法不同。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStream</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Closeable</span> &#123;<br>    <span class="hljs-comment">//...省略其他代码...</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (off &lt; <span class="hljs-number">0</span> || len &lt; <span class="hljs-number">0</span> || len &gt; b.length - off) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> read();<br>        <span class="hljs-keyword">if</span> (c == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        b[off] = (<span class="hljs-type">byte</span>) c;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (; i &lt; len; i++) &#123;<br>                c = read();<br>                <span class="hljs-keyword">if</span> (c == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                b[off + i] = (<span class="hljs-type">byte</span>) c;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ee) &#123;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteArrayInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-comment">//...省略其他代码...</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (pos &lt; count) ? (buf[pos++] &amp; <span class="hljs-number">0xff</span>) : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、Java-AbstractList"><a href="#2、Java-AbstractList" class="headerlink" title="2、Java AbstractList"></a>2、Java AbstractList</h3><p>在 Java AbstractList 类中，addAll() 函数可以看作模板方法，add() 是子类需要重写的方法，尽管没有声明为 abstract 的，但函数实现直接抛出了 UnsupportedOperationException 异常。前提是，如果子类不重写是不能使用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index,Collection&lt;?extends E&gt; c)</span>&#123;<br>        rangeCheckForAdd(index);<br>        <span class="hljs-type">boolean</span> modified=<span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span>(E e:c)&#123;<br>            add(index++,e);<br>            modified=<span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> modified;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index,E element)</span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、模板作用二：扩展"><a href="#4、模板作用二：扩展" class="headerlink" title="4、模板作用二：扩展"></a>4、模板作用二：扩展</h2><p>这里所说的扩展，并不是指代码的扩展性，而是指框架的扩展性，有点类似我们之前讲到的控制反转。基于这个作用，模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化框架的功能。我们通过 Junit TestCase、Java Servlet 两个例子来解释一下。</p><h3 id="1、Java-Servlet"><a href="#1、Java-Servlet" class="headerlink" title="1、Java Servlet"></a>1、Java Servlet</h3><p>对于 Java Web 项目开发来说，常用的开发框架是 SpringMVC。利用它，我们只需要关注业务代码的编写，底层的原理几乎不会涉及。但是，如果我们抛开这些高级框架来开发 Web 项目，必然会用到 Servlet。实际上，使用比较底层的 Servlet 来开发 Web 项目也不难。我们只需要定义一个继承 HttpServlet 的类，并且重写其中的 doGet() 或 doPost() 方法，来分别处理 get 和 post 请求。具体的代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">this</span>.doPost(req, resp);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp.getWriter().write(<span class="hljs-string">&quot;Hello World.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外，我们还需要在配置文件 web.xml 中做如下配置。Tomcat、Jetty 等 Servlet 容器在启动的时候，会自动加载这个配置文件中的 URL 和 Servlet 之间的映射关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.zb.cd.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当我们在浏览器中输入网址（比如，<a href="http://127.0.0.1:8080/hello">http://127.0.0.1:8080/hello</a> ）的时候，Servlet 容器会接收到相应的请求，并且根据 URL 和 Servlet 之间的映射关系，找到相应的 Servlet（HelloServlet），然后执行它的 service() 方法。service() 方法定义在父类 HttpServlet 中，它会调用 doGet() 或 doPost() 方法，然后输出数据（“Hello world”）到网页。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest req, ServletResponse res)</span><br>      <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    HttpServletRequest request;<br>    HttpServletResponse response;<br>    <span class="hljs-keyword">if</span> (!(req <span class="hljs-keyword">instanceof</span> HttpServletRequest &amp;&amp; res <span class="hljs-keyword">instanceof</span> HttpServletResponse)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletException</span>(<span class="hljs-string">&quot;non-HTTP request or response&quot;</span>);<br>    &#125;<br>    request = (HttpServletRequest) req;<br>    response = (HttpServletResponse) res;<br>    service(request, response);<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>      <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> req.getMethod();<br>    <span class="hljs-keyword">if</span> (method.equals(METHOD_GET)) &#123;<br>      <span class="hljs-type">long</span> <span class="hljs-variable">lastModified</span> <span class="hljs-operator">=</span> getLastModified(req);<br>      <span class="hljs-keyword">if</span> (lastModified == -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// servlet doesn&#x27;t support if-modified-since, no reason</span><br>        <span class="hljs-comment">// to go through further expensive logic</span><br>        doGet(req, resp);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ifModifiedSince</span> <span class="hljs-operator">=</span> req.getDateHeader(HEADER_IFMODSINCE);<br>        <span class="hljs-keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;<br>          <span class="hljs-comment">// If the servlet mod time is later, call doGet()</span><br>          <span class="hljs-comment">// Round down to the nearest second for a proper compare</span><br>          <span class="hljs-comment">// A ifModifiedSince of -1 will always be less</span><br>          maybeSetLastModified(resp, lastModified);<br>          doGet(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_HEAD)) &#123;<br>      <span class="hljs-type">long</span> <span class="hljs-variable">lastModified</span> <span class="hljs-operator">=</span> getLastModified(req);<br>      maybeSetLastModified(resp, lastModified);<br>      doHead(req, resp);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_POST)) &#123;<br>      doPost(req, resp);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_PUT)) &#123;<br>      doPut(req, resp);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_DELETE)) &#123;<br>      doDelete(req, resp);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;<br>      doOptions(req, resp);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(METHOD_TRACE)) &#123;<br>      doTrace(req, resp);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">errMsg</span> <span class="hljs-operator">=</span> lStrings.getString(<span class="hljs-string">&quot;http.method_not_implemented&quot;</span>);<br>      Object[] errArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">1</span>];<br>      errArgs[<span class="hljs-number">0</span>] = method;<br>      errMsg = MessageFormat.format(errMsg, errArgs);<br>      resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>从上面的代码中我们可以看出，HttpServlet 的 service() 方法就是一个模板方法，它实现了整个 HTTP 请求的执行流程，doGet()、doPost() 是模板中可以由子类来定制的部分。实际上，这就相当于 Servlet 框架提供了一个扩展点（doGet()、doPost() 方法），让框架用户在不用修改 Servlet 框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。</p><h3 id="2、JUnit-TestCase"><a href="#2、JUnit-TestCase" class="headerlink" title="2、JUnit TestCase"></a>2、JUnit TestCase</h3><ol><li>跟 Java Servlet 类似，JUnit 框架也通过模板模式提供了一些功能扩展点（setUp()、tearDown() 等），让框架用户可以在这些扩展点上扩展功能。</li><li>在使用 JUnit 测试框架来编写单元测试的时候，我们编写的测试类都要继承框架提供的 TestCase 类。在 TestCase 类中，runBare() 函数是模板方法，它定义了执行测试用例的整体流程：先执行 setUp() 做些准备工作，然后执行 runTest() 运行真正的测试代码，最后执行 tearDown() 做扫尾工作。</li><li>TestCase 类的具体代码如下所示。尽管 setUp()、tearDown() 并不是抽象函数，还提供了默认的实现，不强制子类去重新实现，但这部分也是可以在子类中定制的，所以也符合模板模式的定义。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Assert</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Test</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runBare</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-type">Throwable</span> <span class="hljs-variable">exception</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    setUp();<br>    <span class="hljs-keyword">try</span> &#123;<br>      runTest();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable running) &#123;<br>      exception = running;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        tearDown();<br>      &#125; <span class="hljs-keyword">catch</span> (Throwable tearingDown) &#123;<br>        <span class="hljs-keyword">if</span> (exception == <span class="hljs-literal">null</span>) exception = tearingDown;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> exception;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * * Sets up the fixture, for example, open a network connection.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * &lt;p&gt;* This method is called before a test is executed.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;&#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * * Tears down the fixture, for example, close a network connection.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * &lt;p&gt;* This method is called after a test is executed.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【回调】</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 观察者 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-结构型-门面-组合-享元</title>
      <link href="/2022/09/27/05-jie-gou-xing-men-mian-zu-he-xiang-yuan/"/>
      <url>/2022/09/27/05-jie-gou-xing-men-mian-zu-he-xiang-yuan/</url>
      
        <content type="html"><![CDATA[<h1 id="一、门面模式（外观模式）【不常用】"><a href="#一、门面模式（外观模式）【不常用】" class="headerlink" title="一、门面模式（外观模式）【不常用】"></a>一、门面模式（外观模式）【不常用】</h1><ol><li>门面模式原理和实现都特别简单，应用场景也比较明确，主要在接口设计方面使用。</li><li>为了保证接口的可复用性（或者叫通用性），我们需要将接口尽量设计得细粒度一点，职责单一一点。但是，如果接口的粒度过小，在接口的使用者开发一个业务功能时，就会导致需要调用 n 多细粒度的接口才能完成。调用者肯定会抱怨接口不好用。</li><li>相反，如果接口粒度设计得太大，一个接口返回 n 多数据，要做 n 多事情，就会导致接口不够通用、可复用性不好。接口不可复用，那针对不同的调用者的业务需求，我们就需要开发不同的接口来满足，这就会导致系统的接口无限膨胀。</li><li>那如何来解决接口的可复用性（通用性）和易用性之间的矛盾呢？</li></ol><h2 id="1、门面模式的原理与实现"><a href="#1、门面模式的原理与实现" class="headerlink" title="1、门面模式的原理与实现"></a>1、门面模式的原理与实现</h2><p>门面模式，也叫外观模式，英文全称是 Facade Design Pattern。在 GoF 的《设计模式》一书中，门面模式是这样定义的：</p><blockquote><p>Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use</p></blockquote><ol><li>翻译成中文就是：门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</li><li>假设有一个系统 A，提供了 a、b、c、d 四个接口。系统 B 完成某个业务功能，需要调用 A 系统的 a、b、d 接口。利用门面模式，我们提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用。</li><li>但是为什么不让系统 B 直接调用 a、b、d ，还要提供一个包裹 a、b、d 的接口 x 呢？</li><li>假设我们刚刚提到的系统 A 是一个后端服务器，系统 B 是 App 客户端。App 客户端通过后端服务器提供的接口来获取数据。我们知道，App 和服务器之间是通过移动网络通信的，网络通信耗时比较多，为了提高 App 的响应速度，我们要尽量减少 App 与服务器之间的网络通信次数。</li><li>假设，完成某个业务功能（比如显示某个页面信息）需要“依次”调用 a、b、d 三个接口，因自身业务的特点，不支持并发调用这三个接口。</li><li>如果我们现在发现 App 客户端的响应速度比较慢，排查之后发现，是因为过多的接口调用过多的网络通信。针对这种情况，我们就可以利用门面模式，让后端服务器提供一个包裹 a、b、d 三个接口调用的接口 x。App 客户端调用一次接口 x，来获取到所有想要的数据，将网络通信的次数从 3 次减少到 1 次，也就提高了 App 的响应速度。</li><li>这里举的例子只是应用门面模式的其中一个意图，也就是解决性能问题。实际上，不同的应用场景下，使用门面模式的意图也不同。</li></ol><h2 id="2、Demo案例-影院管理"><a href="#2、Demo案例-影院管理" class="headerlink" title="2、Demo案例-影院管理"></a>2、Demo案例-影院管理</h2><ul><li>组建一个家庭影院：</li><li>DVD 播放器、投影仪、自动屏幕、环绕立体声、爆米花机,要求完成使用家庭影院的功能，其过程为：</li><li>直接用遥控器：统筹各设备开关<ul><li>开爆米花机</li><li>放下屏幕</li><li>开投影仪</li><li>开音响</li><li>开 DVD，选 dvd</li><li>去拿爆米花</li><li>调暗灯光</li><li>播放</li><li>观影结束后，关闭各种设备</li></ul></li></ul><h3 id="1、传统方案"><a href="#1、传统方案" class="headerlink" title="1、传统方案"></a>1、传统方案</h3><p><img src="/2022/09/27/05-jie-gou-xing-men-mian-zu-he-xiang-yuan/image-20220927173050295.png"></p><ol><li>在 ClientTest 的 main 方法中，创建各个子系统的对象，并直接去调用子系统(对象)相关方法，会造成调用过程 混乱，没有清晰的过程 不利于在 ClientTest 中，去维护对子系统的操作</li><li>解决思路：<strong>定义一个高层接口</strong>，给<strong>子系统中的一组接口提供一个一致的界面</strong>(比如在高层接口提供四个方法 ready, play, pause, end )，用来访问子系统中的一群接口</li><li>也就是说 就是通过定义一个一致的接口(界面类)，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发 生调用，而无需关心这个子系统的内部细节 =&gt; <strong>外观模式</strong></li><li>外观类(Facade): 为调用端提供统一的调用接口, 外观类知道哪些子系统负责处理请求,从而将调用端的请求代 理给适当子系统对象</li><li>调用者(Client): 外观接口的调用者</li><li>子系统的集合：指模块或者子系统，处理 Facade 对象指派的任务，他是功能的实际提供者</li></ol><h3 id="2、门面模式代码"><a href="#2、门面模式代码" class="headerlink" title="2、门面模式代码"></a>2、门面模式代码</h3><h4 id="1、TheaterLight"><a href="#1、TheaterLight" class="headerlink" title="1、TheaterLight"></a>1、TheaterLight</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TheaterLight</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">TheaterLight</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TheaterLight</span>();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TheaterLight <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot; TheaterLight on &quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot; TheaterLight off &quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dim</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot; TheaterLight dim.. &quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bright</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot; TheaterLight bright.. &quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、Stereo"><a href="#2、Stereo" class="headerlink" title="2、Stereo"></a>2、Stereo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stereo</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Stereo</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stereo</span>();<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Stereo <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; Stereo on &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; Screen off &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">up</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; Screen up.. &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、Screen"><a href="#3、Screen" class="headerlink" title="3、Screen"></a>3、Screen</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Screen</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Screen</span>();<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Screen <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">up</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; Screen up &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; Screen down &quot;</span>);<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、Projector"><a href="#4、Projector" class="headerlink" title="4、Projector"></a>4、Projector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Projector</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Projector</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Projector</span>();<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Projector <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; Projector on &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; Projector ff &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">focus</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; Projector is Projector  &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、Popcorn"><a href="#5、Popcorn" class="headerlink" title="5、Popcorn"></a>5、Popcorn</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Popcorn</span> &#123;<br>   <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Popcorn</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Popcorn</span>();<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Popcorn <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; popcorn on &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; popcorn ff &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; popcorn is poping  &quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、DVDPlayer"><a href="#6、DVDPlayer" class="headerlink" title="6、DVDPlayer"></a>6、DVDPlayer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DVDPlayer</span> &#123;<br>   <br>   <span class="hljs-comment">//使用单例模式, 使用饿汉式</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">DVDPlayer</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DVDPlayer</span>();<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DVDPlayer <span class="hljs-title function_">getInstanc</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; dvd on &quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; dvd off &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; dvd is playing &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-comment">//....</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pause</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; dvd pause ..&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7、HomeTheaterFacade"><a href="#7、HomeTheaterFacade" class="headerlink" title="7、HomeTheaterFacade"></a>7、HomeTheaterFacade</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeTheaterFacade</span> &#123;<br><br>  <span class="hljs-comment">// 定义各个子系统对象</span><br>  <span class="hljs-keyword">private</span> TheaterLight theaterLight;<br>  <span class="hljs-keyword">private</span> Popcorn popcorn;<br>  <span class="hljs-keyword">private</span> Stereo stereo;<br>  <span class="hljs-keyword">private</span> Projector projector;<br>  <span class="hljs-keyword">private</span> Screen screen;<br>  <span class="hljs-keyword">private</span> DVDPlayer dVDPlayer;<br><br>  <span class="hljs-comment">// 构造器</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">HomeTheaterFacade</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-built_in">this</span>.theaterLight = TheaterLight.getInstance();<br>    <span class="hljs-built_in">this</span>.popcorn = Popcorn.getInstance();<br>    <span class="hljs-built_in">this</span>.stereo = Stereo.getInstance();<br>    <span class="hljs-built_in">this</span>.projector = Projector.getInstance();<br>    <span class="hljs-built_in">this</span>.screen = Screen.getInstance();<br>    <span class="hljs-built_in">this</span>.dVDPlayer = DVDPlayer.getInstanc();<br>  &#125;<br><br>  <span class="hljs-comment">// 操作分成 4 步</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ready</span><span class="hljs-params">()</span> &#123;<br>    popcorn.on();<br>    popcorn.pop();<br>    screen.down();<br>    projector.on();<br>    stereo.on();<br>    dVDPlayer.on();<br>    theaterLight.dim();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;<br>    dVDPlayer.play();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pause</span><span class="hljs-params">()</span> &#123;<br>    dVDPlayer.pause();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span> &#123;<br>    popcorn.off();<br>    theaterLight.bright();<br>    screen.up();<br>    projector.off();<br>    stereo.off();<br>    dVDPlayer.off();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、门面模式的应用场景举例"><a href="#3、门面模式的应用场景举例" class="headerlink" title="3、门面模式的应用场景举例"></a>3、门面模式的应用场景举例</h3><ol><li>在 GoF 给出的定义中提到，“门面模式让子系统更加易用”，实际上，它除了解决易用性问题之外，还能解决其他很多方面的问题。</li><li>除此之外，门面模式定义中的“子系统（subsystem）”也可以有多种理解方式。它既可以是一个完整的系统，也可以是更细粒度的类或者模块。</li></ol><h4 id="1、解决易用性问题"><a href="#1、解决易用性问题" class="headerlink" title="1、解决易用性问题"></a>1、解决易用性问题</h4><ol><li>门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如，Linux 系统调用函数就可以看作一种“门面”。它是 Linux 操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。再比如，Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。</li><li>设计原则、思想、模式很多都是相通的，是同一个道理不同角度的表述。实际上，从隐藏实现复杂性，提供更易用接口这个意图来看，门面模式有点类似之前讲到的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要的接口。除此之外，门面模式还有点类似之前提到封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节。</li></ol><h4 id="2、解决性能问题"><a href="#2、解决性能问题" class="headerlink" title="2、解决性能问题"></a>2、解决性能问题</h4><ol><li>关于利用门面模式解决性能问题这一点，刚刚已经讲过了。我们通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度。我们来讨论一下这样一个问题：从代码实现的角度来看，该如何组织门面接口和非门面接口？</li><li>如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普通接口来用即可。如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。</li></ol><h4 id="3、解决分布式事务问题"><a href="#3、解决分布式事务问题" class="headerlink" title="3、解决分布式事务问题"></a>3、解决分布式事务问题</h4><ol><li>关于利用门面模式来解决分布式事务问题，我们通过一个例子来解释一下。</li><li>在一个金融系统中，有两个业务领域模型，用户和钱包。这两个业务领域模型都对外暴露了一系列接口，比如用户的增删改查接口、钱包的增删改查接口。假设有这样一个业务场景：在用户注册的时候，我们不仅会创建用户（在数据库 User 表中），还会给用户创建一个钱包（在数据库的 Wallet 表中）。</li><li>对于这样一个简单的业务需求，我们可以通过依次调用用户的创建接口和钱包的创建接口来完成。但是，用户注册需要<code>支持事务</code>，也就是说，创建用户和钱包的两个操作，要么都成功，要么都失败，不能一个成功、一个失败。</li><li>要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。</li></ol><h1 id="二、组合模式【不常用】"><a href="#二、组合模式【不常用】" class="headerlink" title="二、组合模式【不常用】"></a>二、组合模式【不常用】</h1><ol><li>组合模式跟之前提到的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里的“组合模式”，主要是用来处理树形结构数据。这里的“数据”，可以简单理解为一组对象集合。</li><li>正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。</li></ol><h2 id="1、组合模式的原理与实现"><a href="#1、组合模式的原理与实现" class="headerlink" title="1、组合模式的原理与实现"></a>1、组合模式的原理与实现</h2><ol><li>在 GoF 的《设计模式》一书中，组合模式是这样定义的：</li></ol><blockquote><p>Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.</p></blockquote><ol><li><p>翻译成中文就是：将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。</p></li><li><p>假设有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：</p><ul><li><p>动态地添加、删除某个目录下的子目录或文件；</p></li><li><p>统计指定目录下的文件个数；</p></li><li><p>统计指定目录下的文件总大小。</p></li></ul></li><li><p>在下面的代码实现中，把文件和目录统一用 FileSystemNode 类来表示，并且通过 isFile 属性来区分。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br>  <span class="hljs-keyword">private</span> String path;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isFile;<br>  <span class="hljs-keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileSystemNode</span><span class="hljs-params">(String path, <span class="hljs-type">boolean</span> isFile)</span> &#123;<br>    <span class="hljs-built_in">this</span>.path = path;<br>    <span class="hljs-built_in">this</span>.isFile = isFile;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> path;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>    subNodes.add(fileOrDir);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> subNodes.size();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; i &lt; size; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (i &lt; size) &#123;<br>      subNodes.remove(i);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>想要补全其中的 countNumOfFiles() 和 countSizeOfFiles() 这两个函数，并不是件难事，实际上这就是树上的递归遍历算法。对于文件，我们直接返回文件的个数（返回 1）或大小。对于目录，我们遍历目录中每个子目录或者文件，递归计算它们的个数或大小，然后求和，就是这个目录下的文件个数和文件大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (isFile) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numOfFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>        numOfFiles += fileOrDir.countNumOfFiles();<br>    &#125;<br>    <span class="hljs-keyword">return</span> numOfFiles;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (isFile) &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path);<br>        <span class="hljs-keyword">if</span> (!file.exists()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> file.length();<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">sizeofFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>         sizeofFiles += fileOrDir.countSizeOfFiles();<br>    &#125;<br>    <span class="hljs-keyword">return</span> sizeofFiles;<br>&#125;<br></code></pre></td></tr></table></figure><p>单纯从功能实现角度来说，上面的代码没有问题，已经实现了我们想要的功能。但是，如果我们开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模（文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对业务的认知）的角度来说，最好对文件和目录进行区分设计，定义为 File 和 Directory 两个类。</p><p>按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br>  <span class="hljs-keyword">protected</span> String path;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileSystemNode</span><span class="hljs-params">(String path)</span> &#123;<br>    <span class="hljs-built_in">this</span>.path = path;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span>;<br>  <br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> path;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(String path)</span> &#123;<br>    <span class="hljs-built_in">super</span>(path);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span> &#123;<br>    java.io.<span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.File(path);<br>    <span class="hljs-keyword">if</span> (!file.exists()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> file.length();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Directory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FileSystemNode</span> &#123;<br><br>  <span class="hljs-keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Directory</span><span class="hljs-params">(String path)</span> &#123;<br>    <span class="hljs-built_in">super</span>(path);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumOfFiles</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numOfFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>      numOfFiles += fileOrDir.countNumOfFiles();<br>    &#125;<br>    <span class="hljs-keyword">return</span> numOfFiles;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSizeOfFiles</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">sizeofFiles</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;<br>      sizeofFiles += fileOrDir.countSizeOfFiles();<br>    &#125;<br>    <span class="hljs-keyword">return</span> sizeofFiles;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>    subNodes.add(fileOrDir);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeSubNode</span><span class="hljs-params">(FileSystemNode fileOrDir)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> subNodes.size();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; i &lt; size; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (i &lt; size) &#123;<br>      subNodes.remove(i);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>文件和目录类都设计好了，我们来看，如何用它们来表示一个文件系统中的目录树结构。具体的代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * /</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;/wz/</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;/wz/a.txt</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;/wz/b.txt</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;/wz/movies/</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;/wz/movies/c.avi</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;/xzg/</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;/xzg/docs/</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;/xzg/docs/d.txt</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">Directory</span> <span class="hljs-variable">fileSystemTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/&quot;</span>);<br>    <span class="hljs-type">Directory</span> <span class="hljs-variable">node_wz</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/wz/&quot;</span>);<br>    <span class="hljs-type">Directory</span> <span class="hljs-variable">node_xzg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/xzg/&quot;</span>);<br>    fileSystemTree.addSubNode(node_wz);<br>    fileSystemTree.addSubNode(node_xzg);<br><br>    <br>    <span class="hljs-type">File</span> <span class="hljs-variable">node_wz_a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/wz/a.txt&quot;</span>);<br>    <span class="hljs-type">File</span> <span class="hljs-variable">node_wz_b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/wz/b.txt&quot;</span>);<br>    <span class="hljs-type">Directory</span> <span class="hljs-variable">node_wz_movies</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/wz/movies/&quot;</span>);<br>    node_wz.addSubNode(node_wz_a);<br>    node_wz.addSubNode(node_wz_b);<br>    node_wz.addSubNode(node_wz_movies);<br><br>    <br>    <span class="hljs-type">File</span> <span class="hljs-variable">node_wz_movies_c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/wz/movies/c.avi&quot;</span>);<br>    node_wz_movies.addSubNode(node_wz_movies_c);<br><br>    <br>    <span class="hljs-type">Directory</span> <span class="hljs-variable">node_xzg_docs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;/xzg/docs/&quot;</span>);<br>    node_xzg.addSubNode(node_xzg_docs);<br><br>    <br>    <span class="hljs-type">File</span> <span class="hljs-variable">node_xzg_docs_d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/xzg/docs/d.txt&quot;</span>);<br>    node_xzg_docs.addSubNode(node_xzg_docs_d);<br><br>    <br>    System.out.println(<span class="hljs-string">&quot;/ files num:&quot;</span> + fileSystemTree.countNumOfFiles());<br>    System.out.println(<span class="hljs-string">&quot;/wz/ files num:&quot;</span> + node_wz.countNumOfFiles());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>对照着这个例子，再重新看一下组合模式的定义：“将一组对象（文件和目录）组织成树形结构，以表示一种‘部分 - 整体’的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）。”</li><li>实际上，刚才的这种组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。</li></ol><h2 id="2、组合模式的应用场景举例"><a href="#2、组合模式的应用场景举例" class="headerlink" title="2、组合模式的应用场景举例"></a>2、组合模式的应用场景举例</h2><ol><li>刚刚提到了文件系统的例子，对于组合模式，再举一个例子。在实际的项目中，遇到类似的可以表示成树形结构的业务场景，只要“照葫芦画瓢”去设计就可以了。</li><li>假设我们在开发一个 OA 系统（办公自动化系统）。公司的组织结构包含部门和员工两种数据类型。其中，部门又可以包含子部门和员工。在数据库中的表结构如下所示：</li></ol><p><img src="/2022/09/27/05-jie-gou-xing-men-mian-zu-he-xiang-yuan/image-20220927191655637.png"></p><ol><li>我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。</li><li>部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这个应用场景可以使用组合模式来设计和实现。</li><li>这个例子的代码结构跟上一个例子的很相似，代码实现贴在下面。其中，HumanResource 是部门类（Department）和员工类（Employee）抽象出来的父类，为的是能统一薪资的处理逻辑。Demo 中的代码负责从数据库中读取数据并在内存中构建组织架构图。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">abstract</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">HumanResource</span>  &#123;<br>  <span class="hljs-keyword">protected</span>  <span class="hljs-type">long</span> id;<br>  <span class="hljs-keyword">protected</span>  <span class="hljs-type">double</span> salary;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-title function_">HumanResource</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span>  &#123;<br>    <span class="hljs-built_in">this</span>.id = id;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-type">long</span>  <span class="hljs-title function_">getId</span><span class="hljs-params">()</span>  &#123;<br>    <span class="hljs-keyword">return</span> id;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">abstract</span>  <span class="hljs-type">double</span>  <span class="hljs-title function_">calculateSalary</span><span class="hljs-params">()</span>;<br><br>&#125;<br><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Employee</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">HumanResource</span>  &#123;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-title function_">Employee</span><span class="hljs-params">(<span class="hljs-type">long</span> id, <span class="hljs-type">double</span> salary)</span>  &#123;<br>    <span class="hljs-built_in">super</span>(id);<br>    <span class="hljs-built_in">this</span>.salary = salary;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-type">double</span>  <span class="hljs-title function_">calculateSalary</span><span class="hljs-params">()</span>  &#123;<br>    <span class="hljs-keyword">return</span> salary;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Department</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">HumanResource</span>  &#123;<br>  <span class="hljs-keyword">private</span> List&lt;HumanResource&gt; subNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-title function_">Department</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span>  &#123;<br>    <span class="hljs-built_in">super</span>(id);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-type">double</span>  <span class="hljs-title function_">calculateSalary</span><span class="hljs-params">()</span>  &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">totalSalary</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (HumanResource hr : subNodes) &#123;<br>      totalSalary += hr.calculateSalary();<br>    &#125;<br>    <span class="hljs-built_in">this</span>.salary = totalSalary;<br>    <span class="hljs-keyword">return</span> totalSalary;<br><br>  &#125;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">addSubNode</span><span class="hljs-params">(HumanResource hr)</span>  &#123;<br>    subNodes.add(hr);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 构建组织架构的代码</span><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Demo</span>  &#123;<br>  <span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span>  <span class="hljs-type">long</span> ORGANIZATION\_ROOT\_ID = <span class="hljs-number">1001</span>;<br>  <span class="hljs-keyword">private</span> DepartmentRepo departmentRepo; <span class="hljs-comment">// 依赖注入</span><br>  <span class="hljs-keyword">private</span> EmployeeRepo employeeRepo; <span class="hljs-comment">// 依赖注入</span><br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">buildOrganization</span><span class="hljs-params">()</span>  &#123;<br>    <span class="hljs-type">Department</span> <span class="hljs-variable">rootDepartment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Department</span>(ORGANIZATION\_ROOT\_ID);<br>    buildOrganization(rootDepartment);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">buildOrganization</span><span class="hljs-params">(Department department)</span>  &#123;<br>    List&lt;Long&gt; subDepartmentIds = departmentRepo.getSubDepartmentIds(department.getId());<br>    <span class="hljs-keyword">for</span> (Long subDepartmentId : subDepartmentIds) &#123;<br>      <span class="hljs-type">Department</span> <span class="hljs-variable">subDepartment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Department</span>(subDepartmentId);<br>      department.addSubNode(subDepartment);<br>      buildOrganization(subDepartment);<br>    &#125;<br><br>    List&lt;Long&gt; employeeIds = employeeRepo.getDepartmentEmployeeIds(department.getId());<br>    <span class="hljs-keyword">for</span> (Long employeeId : employeeIds) &#123;<br>      <span class="hljs-type">double</span> <span class="hljs-variable">salary</span> <span class="hljs-operator">=</span> employeeRepo.getEmployeeSalary(employeeId);<br>      department.addSubNode(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(employeeId, salary));<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再拿组合模式的定义跟这个例子对照一下：“将一组对象（员工和部门）组织成树形结构，以表示一种‘部分 - 整体’的层次结构（部门与子部门的嵌套结构）。组合模式让客户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。”</p><h1 id="三、享元模式【不常用】"><a href="#三、享元模式【不常用】" class="headerlink" title="三、享元模式【不常用】"></a>三、享元模式【不常用】</h1><p>跟其他所有的设计模式类似，享元模式的原理和实现也非常简单。</p><h2 id="1、享元模式原理与实现"><a href="#1、享元模式原理与实现" class="headerlink" title="1、享元模式原理与实现"></a>1、享元模式原理与实现</h2><ol><li>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是<code>享元对象是不可变对象</code>。</li><li>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。</li><li>这里我稍微解释一下，定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象<code>不能暴露任何 set() 等修改内部状态的方法</code>。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。</li><li>接下来，通过一个简单的例子解释一下享元模式。</li><li>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。具体的代码如下所示。其中，ChessPiece 类表示棋子，ChessBoard 类表示一个棋局，里面保存了象棋中 30 个棋子的信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPiece</span> &#123; <span class="hljs-comment">// 棋子</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>  <span class="hljs-keyword">private</span> String text;<br>  <span class="hljs-keyword">private</span> Color color;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionX;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionY;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessPiece</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String text, Color color, <span class="hljs-type">int</span> positionX, <span class="hljs-type">int</span> positionY)</span> &#123;<br>    <span class="hljs-built_in">this</span>.id = id;<br>    <span class="hljs-built_in">this</span>.text = text;<br>    <span class="hljs-built_in">this</span>.color = color;<br>    <span class="hljs-built_in">this</span>.positionX = positionX;<br>    <span class="hljs-built_in">this</span>.positionY = positionX;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    RED,<br>    BLACK<br>  &#125;<br><br>  <span class="hljs-comment">// ...省略其他属性和getter/setter方法...</span><br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessBoard</span> &#123; <span class="hljs-comment">// 棋局</span><br>  <span class="hljs-keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessBoard</span><span class="hljs-params">()</span> &#123;<br>    init();<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    chessPieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPiece</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;車&quot;</span>, ChessPiece.Color.BLACK, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>    chessPieces.put(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPiece</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;馬&quot;</span>, ChessPiece.Color.BLACK, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>));<br>    <span class="hljs-comment">// ...省略摆放其他棋子的代码...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">int</span> chessPieceId, <span class="hljs-type">int</span> toPositionX, <span class="hljs-type">int</span> toPositionY)</span> &#123;<br>    <span class="hljs-comment">// ...省略...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个 ChessBoard 棋局对象。因为游戏大厅中有成千上万的房间（实际上，百万人同时在线的游戏大厅也有很多），那保存这么多棋局对象就会消耗大量的内存。有没有什么办法来节省内存呢？</p><p>这个时候，享元模式就可以派上用场了。像刚刚的实现方式，在内存中会有大量的相似对象。这些相似对象的 id、text、color 都是相同的，唯独 positionX、positionY 不同。实际上，我们可以将棋子的 id、text、color 属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 享元类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPieceUnit</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>  <span class="hljs-keyword">private</span> String text;<br>  <span class="hljs-keyword">private</span> Color color;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessPieceUnit</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String text, Color color)</span> &#123;<br>    <span class="hljs-built_in">this</span>.id = id;<br>    <span class="hljs-built_in">this</span>.text = text;<br>    <span class="hljs-built_in">this</span>.color = color;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    RED,<br>    BLACK<br>  &#125;<br>  <span class="hljs-comment">// ...省略其他属性和getter方法...</span><br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPieceUnitFactory</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Integer, ChessPieceUnit&gt; pieces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">static</span> &#123;<br>    pieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPieceUnit</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;車&quot;</span>, ChessPieceUnit.Color.BLACK));<br>    pieces.put(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPieceUnit</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;馬&quot;</span>, ChessPieceUnit.Color.BLACK));<br>    <span class="hljs-comment">// ...省略摆放其他棋子的代码...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ChessPieceUnit <span class="hljs-title function_">getChessPiece</span><span class="hljs-params">(<span class="hljs-type">int</span> chessPieceId)</span> &#123;<br>    <span class="hljs-keyword">return</span> pieces.get(chessPieceId);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessPiece</span> &#123;<br>  <span class="hljs-keyword">private</span> ChessPieceUnit chessPieceUnit;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionX;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> positionY;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessPiece</span><span class="hljs-params">(ChessPieceUnit unit, <span class="hljs-type">int</span> positionX, <span class="hljs-type">int</span> positionY)</span> &#123;<br>    <span class="hljs-built_in">this</span>.chessPieceUnit = unit;<br>    <span class="hljs-built_in">this</span>.positionX = positionX;<br>    <span class="hljs-built_in">this</span>.positionY = positionY;<br>  &#125;<br><br>  <span class="hljs-comment">// 省略getter、setter方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessBoard</span> &#123;<br>  <span class="hljs-keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChessBoard</span><span class="hljs-params">()</span> &#123;<br>    init();<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    chessPieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPiece</span>(ChessPieceUnitFactory.getChessPiece(<span class="hljs-number">1</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>    chessPieces.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChessPiece</span>(ChessPieceUnitFactory.getChessPiece(<span class="hljs-number">2</span>), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-comment">// ...省略摆放其他棋子的代码...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">int</span> chessPieceId, <span class="hljs-type">int</span> toPositionX, <span class="hljs-type">int</span> toPositionY)</span> &#123;<br>    <span class="hljs-comment">// ...省略...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>在上面的代码实现中，利用工厂类来缓存 ChessPieceUnit 信息（也就是 id、text、color）。通过工厂类获取到的 ChessPieceUnit 就是享元。所有的 ChessBoard 对象共享这 30 个 ChessPieceUnit 对象（因为象棋中只有 30 个棋子）。在使用享元模式之前，记录 1 万个棋局，我们要创建 30 万（30*1 万）个棋子的 ChessPieceUnit 对象。利用享元模式，我们只需要创建 30 个享元对象供所有棋局共享使用即可，大大节省了内存。</li><li>那享元模式的原理讲完了，我们来总结一下它的代码结构。实际上，它的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 来缓存已经创建过的享元对象，来达到复用的目的。</li></ol><h2 id="2、享元模式在文本编辑器中的应用"><a href="#2、享元模式在文本编辑器中的应用" class="headerlink" title="2、享元模式在文本编辑器中的应用"></a>2、享元模式在文本编辑器中的应用</h2><ol><li>弄懂了享元模式的原理和实现之后，再来看另外一个例子，如何利用享元模式来优化文本编辑器的内存占用？</li><li>可以把这里提到的文本编辑器想象成 Office 的 Word。不过，为了简化需求背景，我们假设这个文本编辑器只实现了文字编辑功能，不包含图片、表格等复杂的编辑功能。对于简化之后的文本编辑器，我们要在内存中表示一个文本文件，只需要记录文字和格式两部分信息就可以了，其中，格式又包括文字的字体、大小、颜色等信息。</li><li>尽管在实际的文档编写中，我们一般都是按照文本类型（标题、正文……）来设置文字的格式，标题是一种格式，正文是另一种格式等等。但是，从理论上讲，我们可以给文本文件中的每个文字都设置不同的格式。为了实现如此灵活的格式设置，并且代码实现又不过于太复杂，我们把每个文字都当作一个独立的对象来看待，并且在其中包含它的格式信息。具体的代码示例如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Character</span> &#123; <span class="hljs-comment">// 文字</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> c;<br><br>  <span class="hljs-keyword">private</span> Font font;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> colorRGB;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Character</span><span class="hljs-params">(<span class="hljs-type">char</span> c, Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>    <span class="hljs-built_in">this</span>.c = c;<br>    <span class="hljs-built_in">this</span>.font = font;<br>    <span class="hljs-built_in">this</span>.size = size;<br>    <span class="hljs-built_in">this</span>.colorRGB = colorRGB;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Editor</span> &#123;<br>  <span class="hljs-keyword">private</span> List&lt;Character&gt; chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendCharacter</span><span class="hljs-params">(<span class="hljs-type">char</span> c, Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>    <span class="hljs-type">Character</span> <span class="hljs-variable">character</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Character</span>(c, font, size, colorRGB);<br>    chars.add(character);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>在文本编辑器中，我们每敲一个文字，都会调用 Editor 类中的 appendCharacter() 方法，创建一个新的 Character 对象，保存到 chars 数组中。如果一个文本文件中，有上万、十几万、几十万的文字，那我们就要在内存中存储这么多 Character 对象。那有没有办法可以节省一点内存呢？</li><li>实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设置成不同的格式。所以，对于字体格式，我们可以将它设计成享元，让不同的文字共享使用。按照这个设计思路，我们对上面的代码进行重构。重构后的代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterStyle</span> &#123;<br>  <span class="hljs-keyword">private</span> Font font;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> colorRGB;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">CharacterStyle</span><span class="hljs-params">(Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>    <span class="hljs-built_in">this</span>.font = font;<br>    <span class="hljs-built_in">this</span>.size = size;<br>    <span class="hljs-built_in">this</span>.colorRGB = colorRGB;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-type">CharacterStyle</span> <span class="hljs-variable">otherStyle</span> <span class="hljs-operator">=</span> (CharacterStyle) o;<br>    <span class="hljs-keyword">return</span> font.equals(otherStyle.font)<br>        &amp;&amp; size == otherStyle.size<br>        &amp;&amp; colorRGB == otherStyle.colorRGB;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterStyleFactory</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;CharacterStyle&gt; styles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CharacterStyle <span class="hljs-title function_">getStyle</span><span class="hljs-params">(Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>    <span class="hljs-type">CharacterStyle</span> <span class="hljs-variable">newStyle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CharacterStyle</span>(font, size, colorRGB);<br>    <span class="hljs-keyword">for</span> (CharacterStyle style : styles) &#123;<br>      <span class="hljs-keyword">if</span> (style.equals(newStyle)) &#123;<br>        <span class="hljs-keyword">return</span> style;<br>      &#125;<br>    &#125;<br>    styles.add(newStyle);<br>    <span class="hljs-keyword">return</span> newStyle;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Character</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> c;<br>  <span class="hljs-keyword">private</span> CharacterStyle style;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Character</span><span class="hljs-params">(<span class="hljs-type">char</span> c, CharacterStyle style)</span> &#123;<br>    <span class="hljs-built_in">this</span>.c = c;<br>    <span class="hljs-built_in">this</span>.style = style;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Editor</span> &#123;<br>  <span class="hljs-keyword">private</span> List&lt;Character&gt; chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendCharacter</span><span class="hljs-params">(<span class="hljs-type">char</span> c, Font font, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> colorRGB)</span> &#123;<br>    <span class="hljs-type">Character</span> <span class="hljs-variable">character</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Character</span>(c, CharacterStyleFactory.getStyle(font, size, colorRGB));<br>    chars.add(character);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、享元模式-vs-单例、缓存、对象池"><a href="#3、享元模式-vs-单例、缓存、对象池" class="headerlink" title="3、享元模式 vs 单例、缓存、对象池"></a>3、享元模式 vs 单例、缓存、对象池</h2><p>在上面的讲解中，多次提到“共享”“缓存”“复用”这些字眼，那它跟单例、缓存、对象池这些概念有什么区别呢？我们来简单对比一下。</p><h3 id="1、享元模式跟单例的区别"><a href="#1、享元模式跟单例的区别" class="headerlink" title="1、享元模式跟单例的区别"></a>1、享元模式跟单例的区别</h3><ol><li>在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例。</li><li>我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用享元模式是为了<code>对象复用，节省内存</code>，而应用多例模式是为了<code>限制对象的个数</code>。</li></ol><h3 id="2、享元模式跟缓存的区别"><a href="#2、享元模式跟缓存的区别" class="headerlink" title="2、享元模式跟缓存的区别"></a>2、享元模式跟缓存的区别</h3><p>在享元模式的实现中，我们通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际上是“存储”的意思，跟我们平时所说的“数据库缓存”“CPU 缓存”“MemCache 缓存”是两回事。我们平时所讲的缓存，主要是为了提高访问效率，而非复用。</p><h3 id="3、享元模式跟对象池的区别"><a href="#3、享元模式跟对象池的区别" class="headerlink" title="3、享元模式跟对象池的区别"></a>3、享元模式跟对象池的区别</h3><ol><li>对象池、连接池（比如数据库连接池）、线程池等也是为了复用，那它们跟享元模式有什么区别呢？</li><li>像 C++ 这样的编程语言，内存的管理是由程序员负责的。为了避免频繁地进行对象创建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉。</li><li>虽然对象池、连接池、线程池、享元模式都是为了复用，但是，如果我们再细致地抠一抠“复用”这个字眼的话，对象池、连接池、线程池等池化技术中的“复用”和享元模式中的“复用”实际上是不同的概念。</li><li>池化技术中的“复用”可以理解为“重复使用”，主要目的是<code>节省时间</code>（比如从数据库池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是<code>节省空间</code>。</li></ol><h2 id="4、享元模式在Java-Integer、String中的应用"><a href="#4、享元模式在Java-Integer、String中的应用" class="headerlink" title="4、享元模式在Java Integer、String中的应用"></a>4、享元模式在Java Integer、String中的应用</h2><p>先来看一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">56</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">56</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">129</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">129</span>;<br>System.out.println(i1 == i2);<br>System.out.println(i3 == i4);<br></code></pre></td></tr></table></figure><ol><li>Java提供了自动拆箱与装箱机制，比如int的装箱就是Integer.valueOf(); 拆箱就是i.intValue();</li><li>前 4 行赋值语句都会触发自动装箱操作，也就是会创建 Integer 对象并且赋值给 i1、i2、i3、i4 这四个变量。根据刚刚的讲解，i1、i2 尽管存储的数值相同，都是 56，但是指向不同的 Integer 对象，所以通过”==”来判定是否相同的时候，会返回 false。同理，i3 i4 判定语句也会返回 false。</li><li>不过，上面的分析还是不对，答案并非是两个 false，而是一个 true，一个 false。看到这里，可能会比较纳闷了。实际上，这正是因为 Integer 用到了享元模式来复用对象，才导致了这样的运行结果。当我们通过自动装箱，也就是调用 valueOf() 来创建 Integer 对象的时候，如果要创建的 Integer 对象的值在 -128 到 127 之间，会从 IntegerCache 类中直接返回，否则才调用 new 方法创建。看代码更加清晰一些，Integer 类的 valueOf() 函数的具体代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>       <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>           <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>   &#125;<br></code></pre></td></tr></table></figure><p>实际上，这里的 IntegerCache 相当于，我们上面讲的生成享元对象的工厂类，只不过名字不叫 xxxFactory 而已。我们来看它的具体代码实现。这个类是 Integer 的内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerCache</span> &#123;<br>       <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> -<span class="hljs-number">128</span>;<br>       <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> high;<br>       <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br><br>       <span class="hljs-keyword">static</span> &#123;<br>           <span class="hljs-comment">// high value may be configured by property</span><br>           <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">integerCacheHighPropValue</span> <span class="hljs-operator">=</span><br>               VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>           <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-keyword">try</span> &#123;<br>                   <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> parseInt(integerCacheHighPropValue);<br>                   i = Math.max(i, <span class="hljs-number">127</span>);<br>                   <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                   h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>               &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                   <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>               &#125;<br>           &#125;<br>           high = h;<br><br>           cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[(high - low) + <span class="hljs-number">1</span>];<br>           <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> low;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>               cache[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(j++);<br><br>           <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>           <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">private</span> <span class="hljs-title function_">IntegerCache</span><span class="hljs-params">()</span> &#123;&#125;<br>   &#125;<br></code></pre></td></tr></table></figure><ol><li>为什么 IntegerCache 只缓存 -128 到 127 之间的整型值呢？</li><li>在 IntegerCache 的代码实现中，当这个类被加载的时候，缓存的享元对象会被集中一次性创建好。毕竟整型值太多了，我们不可能在 IntegerCache 类中预先创建好所有的整型值，这样既占用太多内存，也使得加载 IntegerCache 类的时间过长。所以，我们只能选择缓存对于大部分应用来说最常用的整型值，也就是一个字节的大小（-128 到 127 之间的数据）。</li><li>实际上，JDK 也提供了方法来让我们可以自定义缓存的最大值，有下面两种方式。如果通过分析应用的 JVM 内存占用情况，发现 -128 到 255 之间的数据占用的内存比较多，就可以用如下方式，将缓存的最大值从 127 调整到 255。不过，这里注意一下，JDK 并没有提供设置最小值的方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一：</span><br>-Djava.lang.Integer.IntegerCache.high=<span class="hljs-number">255</span><br><span class="hljs-comment">//方法二：</span><br>-XX:AutoBoxCacheMax=<span class="hljs-number">255</span><br></code></pre></td></tr></table></figure><ol><li>现在，让我们再回到最开始的问题，因为 56 处于 -128 和 127 之间，i1 和 i2 会指向相同的享元对象，所以 i1 == i2 返回 true。而 129 大于 127，并不会被缓存，每次都会创建一个全新的对象，也就是说，i3 和 i4 指向不同的 Integer 对象，所以 i3 == i4 返回 false。</li></ol><p>实际上，除了 Integer 类型之外，其他包装器类型，比如 Long、Short、Byte 等，也都利用了享元模式来缓存 -128 到 127 之间的数据。</p><p>在我们平时的开发中，对于下面这样三种创建整型对象的方式，我们优先使用后两种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>);<br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>第一种创建方式并不会使用到 IntegerCache，而后面两种创建方法可以利用 IntegerCache 缓存，返回共享的对象，以达到节省内存的目的。举一个极端一点的例子，假设程序需要创建 1 万个 -128 到 127 之间的 Integer 对象。使用第一种创建方式，我们需要分配 1 万个 Integer 对象的内存空间；使用后两种创建方式，我们最多只需要分配 256 个 Integer 对象的内存空间。</p><h2 id="5、享元模式在-Java-String-中的应用"><a href="#5、享元模式在-Java-String-中的应用" class="headerlink" title="5、享元模式在 Java String 中的应用"></a>5、享元模式在 Java String 中的应用</h2><p>刚刚提到享元模式在 Java Integer 类中的应用，现在，我们再来看下，享元模式在 Java String 类中的应用。同样，我们还是先来看一段代码，你觉得这段代码输出的结果是什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;哈哈哈&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;哈哈哈&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span>  <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;哈哈哈&quot;</span>);<br><br>System.out.println(s1 == s2);<br>System.out.println(s1 == s3);<br></code></pre></td></tr></table></figure><ol><li>上面代码的运行结果是：一个 true，一个 false。跟 Integer 类的设计思路相似，String 类利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM 会专门开辟一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”。</li><li>不过，String 类的享元模式的设计，跟 Integer 类稍微有些不同。Integer 类中要共享的对象，是在类加载的时候，就集中一次性创建好的。但是，对于字符串来说，我们没法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型 </tag>
            
            <tag> 门面 </tag>
            
            <tag> 组合 </tag>
            
            <tag> 享元 </tag>
            
            <tag> 外观 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-结构型-装饰器-适配器</title>
      <link href="/2022/09/23/04-jie-gou-xing-zhuang-shi-qi-gua-pei-qi/"/>
      <url>/2022/09/23/04-jie-gou-xing-zhuang-shi-qi-gua-pei-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="一、装饰器模式"><a href="#一、装饰器模式" class="headerlink" title="一、装饰器模式"></a>一、装饰器模式</h1><p>通过一个demo来理解装饰器模式。</p><h2 id="1、Demo案例-咖啡订单项目"><a href="#1、Demo案例-咖啡订单项目" class="headerlink" title="1、Demo案例-咖啡订单项目"></a>1、Demo案例-咖啡订单项目</h2><h3 id="1、星巴克订单需求"><a href="#1、星巴克订单需求" class="headerlink" title="1、星巴克订单需求"></a>1、星巴克订单需求</h3><ol><li>咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)</li><li>调料：Milk、Soy(豆浆)、Chocolate</li><li>要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便</li><li>使用 OO 的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡+调料组合。</li></ol><h3 id="2、方案一"><a href="#2、方案一" class="headerlink" title="2、方案一"></a>2、方案一</h3><p><img src="/2022/09/23/04-jie-gou-xing-zhuang-shi-qi-gua-pei-qi/image-20220926165413830.png" alt="方案1"></p><ol><li>Drink 是一个抽象类，表示饮料</li><li>des就是对咖啡的描述, 比如咖啡的名字 </li><li>cost() 方法就是计算费用，Drink 类中做成一个抽象方法</li><li>Decaf 就是单品咖啡， 继承Drink, 并实现cost</li><li>Espress &amp;&amp; Milk 就是单品咖啡+调料， 这个组合很多</li><li><code>问题</code>：这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料， 类的数量就会倍增，就会出现类爆炸</li></ol><h3 id="3、方案二"><a href="#3、方案二" class="headerlink" title="3、方案二"></a>3、方案二</h3><p>前面分析到方案 1 因为咖啡单品+调料组合会造成类的倍增，因此可以做改进，将调料内置到 Drink 类，这样就不会造成类数量过多。从而提高项目的维护性(如图)</p><p><img src="/2022/09/23/04-jie-gou-xing-zhuang-shi-qi-gua-pei-qi/image-20220926165735491.png" alt="方案2"></p><ol><li>方案 2 可以控制类的数量，不至于造成很多的类</li><li>在增加或者删除调料种类时，代码的维护量很大</li><li>考虑到用户可以添加多份调料时，可以将 hasMilk 返回一个对应 int</li><li>考虑使用 <strong>装饰者</strong> 模式</li></ol><blockquote><p>注意：装饰器模式是对功能的增强，而不是附加新的功能。代理模式才是附加新的功能。</p></blockquote><h3 id="4、装饰器模式代码"><a href="#4、装饰器模式代码" class="headerlink" title="4、装饰器模式代码"></a>4、装饰器模式代码</h3><p><img src="/2022/09/23/04-jie-gou-xing-zhuang-shi-qi-gua-pei-qi/image-20220926170746201.png" alt="装饰器模式"></p><h4 id="1、Drink【抽象类-主体Component】"><a href="#1、Drink【抽象类-主体Component】" class="headerlink" title="1、Drink【抽象类-主体Component】"></a>1、Drink【抽象类-主体Component】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Drink</span> &#123;<br><br>   <span class="hljs-keyword">public</span> String des; <span class="hljs-comment">// 描述</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0f</span>;<br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDes</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> des;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDes</span><span class="hljs-params">(String des)</span> &#123;<br>      <span class="hljs-built_in">this</span>.des = des;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> price;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrice</span><span class="hljs-params">(<span class="hljs-type">float</span> price)</span> &#123;<br>      <span class="hljs-built_in">this</span>.price = price;<br>   &#125;<br>   <br>   <span class="hljs-comment">//计算费用的抽象方法</span><br>   <span class="hljs-comment">//子类来实现</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">float</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span>;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、Decorator"><a href="#2、Decorator" class="headerlink" title="2、Decorator"></a>2、Decorator</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Drink</span> &#123;<br>   <span class="hljs-keyword">private</span> Drink obj;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Decorator</span><span class="hljs-params">(Drink obj)</span> &#123; <span class="hljs-comment">//组合</span><br>      <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>      <span class="hljs-built_in">this</span>.obj = obj;<br>   &#125;<br>   <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-comment">// getPrice 自己价格</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getPrice() + obj.cost();<br>   &#125;<br>   <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDes</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-comment">// obj.getDes() 输出被装饰者的信息</span><br>      <span class="hljs-keyword">return</span> des + <span class="hljs-string">&quot; &quot;</span> + getPrice() + <span class="hljs-string">&quot; &amp;&amp; &quot;</span> + obj.getDes();<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、Coffee"><a href="#3、Coffee" class="headerlink" title="3、Coffee"></a>3、Coffee</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Drink</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getPrice();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>单品类</p></blockquote><h4 id="4、ShortBlack"><a href="#4、ShortBlack" class="headerlink" title="4、ShortBlack"></a>4、ShortBlack</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShortBlack</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Coffee</span>&#123;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ShortBlack</span><span class="hljs-params">()</span> &#123;<br>      setDes(<span class="hljs-string">&quot; shortblack &quot;</span>);<br>      setPrice(<span class="hljs-number">4.0f</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、LongBlack"><a href="#5、LongBlack" class="headerlink" title="5、LongBlack"></a>5、LongBlack</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongBlack</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Coffee</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">LongBlack</span><span class="hljs-params">()</span> &#123;<br>      setDes(<span class="hljs-string">&quot; longblack &quot;</span>);<br>      setPrice(<span class="hljs-number">5.0f</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、DeCaf"><a href="#6、DeCaf" class="headerlink" title="6、DeCaf"></a>6、DeCaf</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeCaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Coffee</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">DeCaf</span><span class="hljs-params">()</span> &#123;<br>      setDes(<span class="hljs-string">&quot; 无因咖啡 &quot;</span>);<br>      setPrice(<span class="hljs-number">1.0f</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7、Espresso"><a href="#7、Espresso" class="headerlink" title="7、Espresso"></a>7、Espresso</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Espresso</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Coffee</span> &#123;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Espresso</span><span class="hljs-params">()</span> &#123;<br>      setDes(<span class="hljs-string">&quot; 意大利咖啡 &quot;</span>);<br>      setPrice(<span class="hljs-number">6.0f</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>调味品类</p></blockquote><h4 id="8、Chocolate"><a href="#8、Chocolate" class="headerlink" title="8、Chocolate"></a>8、Chocolate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//具体的Decorator， 这里就是调味品</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Chocolate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chocolate</span><span class="hljs-params">(Drink obj)</span> &#123;<br>      <span class="hljs-built_in">super</span>(obj);<br>      setDes(<span class="hljs-string">&quot; 巧克力 &quot;</span>);<br>      setPrice(<span class="hljs-number">3.0f</span>); <span class="hljs-comment">// 调味品 的价格</span><br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9、Milk"><a href="#9、Milk" class="headerlink" title="9、Milk"></a>9、Milk</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Milk</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Milk</span><span class="hljs-params">(Drink obj)</span> &#123;<br>      <span class="hljs-built_in">super</span>(obj);<br>      <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>      setDes(<span class="hljs-string">&quot; 牛奶 &quot;</span>);<br>      setPrice(<span class="hljs-number">2.0f</span>); <br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10、Soy"><a href="#10、Soy" class="headerlink" title="10、Soy"></a>10、Soy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Soy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span>&#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Soy</span><span class="hljs-params">(Drink obj)</span> &#123;<br>      <span class="hljs-built_in">super</span>(obj);<br>      <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>      setDes(<span class="hljs-string">&quot; 豆浆  &quot;</span>);<br>      setPrice(<span class="hljs-number">1.5f</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>主类调试</p></blockquote><h4 id="11、CoffeeBar"><a href="#11、CoffeeBar" class="headerlink" title="11、CoffeeBar"></a>11、CoffeeBar</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeBar</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-comment">// 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack</span><br><br>      <span class="hljs-comment">// 1. 点一份 LongBlack</span><br>      <span class="hljs-type">Drink</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongBlack</span>();<br>      System.out.println(<span class="hljs-string">&quot;费用1=&quot;</span> + order.cost());<br>      System.out.println(<span class="hljs-string">&quot;描述=&quot;</span> + order.getDes());<br><br>      <span class="hljs-comment">// 2. order 加入一份牛奶</span><br>      order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Milk</span>(order);<br><br>      System.out.println(<span class="hljs-string">&quot;order 加入一份牛奶 费用 =&quot;</span> + order.cost());<br>      System.out.println(<span class="hljs-string">&quot;order 加入一份牛奶 描述 = &quot;</span> + order.getDes());<br><br>      <span class="hljs-comment">// 3. order 加入一份巧克力</span><br><br>      order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chocolate</span>(order);<br><br>      System.out.println(<span class="hljs-string">&quot;order 加入一份牛奶 加入一份巧克力  费用 =&quot;</span> + order.cost());<br>      System.out.println(<span class="hljs-string">&quot;order 加入一份牛奶 加入一份巧克力 描述 = &quot;</span> + order.getDes());<br><br>      <span class="hljs-comment">// 3. order 加入一份巧克力</span><br><br>      order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chocolate</span>(order);<br><br>      System.out.println(<span class="hljs-string">&quot;order 加入一份牛奶 加入2份巧克力   费用 =&quot;</span> + order.cost());<br>      System.out.println(<span class="hljs-string">&quot;order 加入一份牛奶 加入2份巧克力 描述 = &quot;</span> + order.getDes());<br>   <br>      System.out.println(<span class="hljs-string">&quot;===========================&quot;</span>);<br>      <br>      <span class="hljs-type">Drink</span> <span class="hljs-variable">order2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeCaf</span>();<br>      <br>      System.out.println(<span class="hljs-string">&quot;order2 无因咖啡  费用 =&quot;</span> + order2.cost());<br>      System.out.println(<span class="hljs-string">&quot;order2 无因咖啡 描述 = &quot;</span> + order2.getDes());<br>      <br>      order2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Milk</span>(order2);<br>      <br>      System.out.println(<span class="hljs-string">&quot;order2 无因咖啡 加入一份牛奶  费用 =&quot;</span> + order2.cost());<br>      System.out.println(<span class="hljs-string">&quot;order2 无因咖啡 加入一份牛奶 描述 = &quot;</span> + order2.getDes());<br><br>   <br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、装饰者模式原理"><a href="#2、装饰者模式原理" class="headerlink" title="2、装饰者模式原理"></a>2、装饰者模式原理</h2><p>装饰者模式：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更 有弹性，装饰者模式也体现了开闭原则(ocp)</p><ol><li><p>装饰者模式就像打包一个快递</p><p>主体：比如：陶瓷、衣服 (Component) // 被装饰者</p><p>包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator)</p></li><li><p>Component 主体：比如类似前面的 Drink</p></li><li><p>ConcreteComponent 和 Decorator</p><p>ConcreteComponent：具体的主体， 比如前面的各个单品咖啡</p><p>Decorator: 装饰者，比如各调料</p></li><li><p>在Component 与 ConcreteComponent 之间，如果 ConcreteComponent 类很多,还可以设计一个缓冲层，将 共有的部分提取出来，抽象层一个类</p></li></ol><h2 id="3、Java-IO-类的用法"><a href="#3、Java-IO-类的用法" class="headerlink" title="3、Java IO 类的用法"></a>3、Java IO 类的用法</h2><p>Java IO 类库非常庞大和复杂，有几十个类，负责 IO 数据的读取和写入。如果对 Java IO 类做一下分类，我们可以从下面两个维度将它划分为四类。具体如下所示：</p><table><thead><tr><th></th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><p>针对不同的读取和写入场景，Java IO 又在这四个父类基础之上，扩展出了很多子类。具体如下所示：</p><p><img src="/2022/09/23/04-jie-gou-xing-zhuang-shi-qi-gua-pei-qi/image-20220926174459489.png"></p><p><img src="/2022/09/23/04-jie-gou-xing-zhuang-shi-qi-gua-pei-qi/image-20220926175005022.png"></p><blockquote><p>说明</p><ol><li>InputStream 是抽象类, 类似我们前面讲的 Drink</li><li>FileInputStream 是 InputStream 子类，类似我们前面的 DeCaf, LongBlack</li><li>FilterInputStream 是 InputStream 子类：类似我们前面 的 Decorator 修饰者</li><li>DataInputStream 是 FilterInputStream 子类，具体的修饰者，类似前面的 Milk, Soy 等</li><li>FilterInputStream 类 有 protected volatile InputStream in; 即含被装饰者</li><li>分析得出在jdk 的io体系中，就是使用装饰者模式</li></ol></blockquote><p>打开文件 test.txt，从中读取数据。其中，InputStream 是一个抽象类，FileInputStream 是专门用来读取文件流的子类。BufferedInputStream 是一个支持带缓存功能的数据读取类，可以提高数据读取的效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/user/test.txt&quot;</span>);<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(in);<br><span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">128</span>];<br><span class="hljs-keyword">while</span> (bin.read(data) != -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>初看上面的代码，会觉得 Java IO 的用法比较麻烦，需要先创建一个 FileInputStream 对象，然后再传递给 BufferedInputStream 对象来使用。我在想，Java IO 为什么不设计一个继承 FileInputStream 并且支持缓存的 BufferedFileInputStream 类呢？这样我们就可以像下面的代码中这样，直接创建一个 BufferedFileInputStream 类对象，打开文件读取数据，用起来岂不是更加简单？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedFileInputStream</span>(<span class="hljs-string">&quot;/user/test.txt&quot;</span>);<br><span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">128</span>];<br><span class="hljs-keyword">while</span> (bin.read(data) != -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、基于继承的设计方案"><a href="#4、基于继承的设计方案" class="headerlink" title="4、基于继承的设计方案"></a>4、基于继承的设计方案</h2><p>如果 InputStream 只有一个子类 FileInputStream 的话，那我们在 FileInputStream 基础之上，再设计一个孙子类 BufferedFileInputStream，也算是可以接受的，毕竟继承结构还算简单。但实际上，继承 InputStream 的子类有很多。我们需要给每一个 InputStream 的子类，再继续派生支持缓存读取的子类。</p><p>除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的 DataInputStream 类，支持按照基本数据类型（int、boolean、long 等）来读取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/user/test.txt&quot;</span>);<br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">din</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(in);<br><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> din.readInt();<br></code></pre></td></tr></table></figure><p>在这种情况下，如果我们继续按照继承的方式来实现的话，就需要再继续派生出 DataFileInputStream、DataPipedInputStream 等类。如果我们还需要既支持缓存、又支持按照基本类型读取数据的类，那就要再继续派生出 BufferedDataFileInputStream、BufferedDataPipedInputStream 等 n 多类。这还只是附加了两个增强功能，如果我们需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码既不好扩展，也不好维护。这也是我们不推荐使用继承的原因。</p><h2 id="5、基于装饰器模式的设计方案"><a href="#5、基于装饰器模式的设计方案" class="headerlink" title="5、基于装饰器模式的设计方案"></a>5、基于装饰器模式的设计方案</h2><p>前面提到“组合优于继承”，可以“使用组合来替代继承”。针对刚刚的继承结构过于复杂的问题，可以通过将继承关系改为组合关系来解决。下面的代码展示了 Java IO 的这种设计思路。以下是简化了的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStream</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[])</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">return</span> read(b, <span class="hljs-number">0</span>, b.length);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">skip</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">available</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span> readlimit)</span> &#123;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;mark/reset not supported&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">markSupported</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>    <span class="hljs-built_in">this</span>.in = in;<br>  &#125;<br><br>  <span class="hljs-comment">// ...实现基于缓存的读数据接口...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-title function_">DataInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>    <span class="hljs-built_in">this</span>.in = in;<br>  &#125;<br><br>  <span class="hljs-comment">// ...实现读取基本类型数据的接口</span><br>&#125;<br></code></pre></td></tr></table></figure><p>看了上面的代码，可能会问，那装饰器模式就是简单的“用组合替代继承”吗？当然不是。从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。</p><p><strong>第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</strong>比如，下面这样一段代码，我们对 FileInputStream 嵌套了两个装饰器类：BufferedInputStream 和 DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/user/test.txt&quot;</span>);<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(in);<br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">din</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(bin);<br><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> din.readInt();<br></code></pre></td></tr></table></figure><p><strong>第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。</strong>实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，代理模式中，<code>代理类附加的是跟原始类无关的功能</code>，而在装饰器模式中，<code>装饰器类附加的是跟原始类相关的增强功能</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 代理模式的代码结构(下面的接口也可以替换成抽象类)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> impelements IA &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-comment">//... </span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AProxy</span> impements IA &#123;<br>    <span class="hljs-keyword">private</span> IA a;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AProxy</span><span class="hljs-params">(IA a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 新添加的代理逻辑</span><br>        a.f();<br>        <span class="hljs-comment">// 新添加的代理逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 装饰器模式的代码结构(下面的接口也可以替换成抽象类)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> impelements IA &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-comment">//... </span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ADecorator</span> impements IA &#123;<br>    <span class="hljs-keyword">private</span> IA a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ADecorator</span><span class="hljs-params">(IA a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 功能增强代码</span><br>        a.f();<br>        <span class="hljs-comment">// 功能增强代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>实际上，如果去查看 JDK 的源码，会发现BufferedInputStream、DataInputStream 并非继承自 InputStream，而是另外一个叫 FilterInputStream 的类。那这又是出于什么样的设计意图，才引入这样一个类呢？</li><li>再重新来看一下 BufferedInputStream 类的代码。InputStream 是一个抽象类而非接口，而且它的大部分函数（比如 read()、available()）都有默认实现，按理来说，我们只需要在 BufferedInputStream 类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承 InputStream 的默认实现。但实际上，这样做是行不通的。</li><li>对于即便是不需要增加缓存功能的函数来说，BufferedInputStream 还是必须把它重新实现一遍，简单包裹对 InputStream 对象的函数调用。具体的代码示例如下所示。如果不重新实现，那 BufferedInputStream 类就无法将最终读取数据的任务，委托给传递进来的 InputStream 对象来完成。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>.in = in;<br>    &#125;<br><br><span class="hljs-comment">// f()函数不需要增强，只是重新调用一下InputStream in对象的f()</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123; <br>        in.f();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，DataInputStream 也存在跟 BufferedInputStream 同样的问题。为了避免代码重复，Java IO 抽象出了一个装饰器父类 FilterInputStream，代码实现如下所示。InputStream 的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">FilterInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>.in = in;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> in.read();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[])</span> <span class="hljs-keyword">throws</span> IOException &#123; <br>        <span class="hljs-keyword">return</span> read(b, <span class="hljs-number">0</span>, b.length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> in.read(b, off, len);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">skip</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> in.skip(n);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">available</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> in.available();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        in.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span> readlimit)</span> &#123;<br>        in.mark(readlimit);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        in.reset();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">markSupported</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> in.markSupported();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、适配器模式"><a href="#二、适配器模式" class="headerlink" title="二、适配器模式"></a>二、适配器模式</h1><p>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，<strong>主的目的是兼容性</strong>，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper) 。适配器模式属于结构型模式。主要分为三类：<strong>类适配器模式、对象适配器模式、接口适配器模式</strong></p><h2 id="1、Demo案例-充电器"><a href="#1、Demo案例-充电器" class="headerlink" title="1、Demo案例-充电器"></a>1、Demo案例-充电器</h2><p>基本介绍：Adapter 类，通过继承 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配。</p><ul><li>以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们 的目 dst(即 目标)是 5V 直流电</li></ul><h3 id="1、类适配器代码实现"><a href="#1、类适配器代码实现" class="headerlink" title="1、类适配器代码实现"></a>1、类适配器代码实现</h3><h4 id="1、Voltage220V"><a href="#1、Voltage220V" class="headerlink" title="1、Voltage220V"></a>1、Voltage220V</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//被适配的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Voltage220V</span> &#123;<br>   <span class="hljs-comment">//输出220V的电压</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">output220V</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> <span class="hljs-number">220</span>;<br>      System.out.println(<span class="hljs-string">&quot;电压=&quot;</span> + src + <span class="hljs-string">&quot;伏&quot;</span>);<br>      <span class="hljs-keyword">return</span> src;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、IVoltage5V"><a href="#2、IVoltage5V" class="headerlink" title="2、IVoltage5V"></a>2、IVoltage5V</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//适配接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IVoltage5V</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">output5V</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、Phone"><a href="#3、Phone" class="headerlink" title="3、Phone"></a>3、Phone</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;<br><br>   <span class="hljs-comment">//充电</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">charging</span><span class="hljs-params">(IVoltage5V iVoltage5V)</span> &#123;<br>      <span class="hljs-keyword">if</span>(iVoltage5V.output5V() == <span class="hljs-number">5</span>) &#123;<br>         System.out.println(<span class="hljs-string">&quot;电压为5V, 可以充电~~&quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (iVoltage5V.output5V() &gt; <span class="hljs-number">5</span>) &#123;<br>         System.out.println(<span class="hljs-string">&quot;电压大于5V, 不能充电~~&quot;</span>);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、VoltageAdapter"><a href="#4、VoltageAdapter" class="headerlink" title="4、VoltageAdapter"></a>4、VoltageAdapter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//适配器类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoltageAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Voltage220V</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVoltage5V</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">output5V</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-comment">//获取到220V电压</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">srcV</span> <span class="hljs-operator">=</span> output220V();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">dstV</span> <span class="hljs-operator">=</span> srcV / <span class="hljs-number">44</span> ; <span class="hljs-comment">//转成 5v</span><br>      <span class="hljs-keyword">return</span> dstV;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、Client"><a href="#5、Client" class="headerlink" title="5、Client"></a>5、Client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; === 类适配器模式 ====&quot;</span>);<br>      <span class="hljs-type">Phone</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br>      phone.charging(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VoltageAdapter</span>());<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、对象适配器实现"><a href="#2、对象适配器实现" class="headerlink" title="2、对象适配器实现"></a>2、对象适配器实现</h3><p>基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承 src 类，而是持有 src 类的实例，以解决 兼容性的问题。 即：持有 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配 ，在系统中尽量使用<strong>关联关系（聚合，组合）来替代继承</strong>关系。</p><p>上面的例子代码基本没用什么改变，改变的只有以下两个类</p><h4 id="1、VoltageAdapter"><a href="#1、VoltageAdapter" class="headerlink" title="1、VoltageAdapter"></a>1、VoltageAdapter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 适配器类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoltageAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVoltage5V</span> &#123;<br><br>  <span class="hljs-keyword">private</span> Voltage220V voltage220V; <span class="hljs-comment">// 关联关系-聚合</span><br><br>  <span class="hljs-comment">// 通过构造器，传入一个 Voltage220V 实例</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">VoltageAdapter</span><span class="hljs-params">(Voltage220V voltage220v)</span> &#123;<br><br>    <span class="hljs-built_in">this</span>.voltage220V = voltage220v;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">output5V</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dst</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != voltage220V) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> voltage220V.output220V(); <span class="hljs-comment">// 获取220V 电压</span><br>      System.out.println(<span class="hljs-string">&quot;使用对象适配器，进行适配~~&quot;</span>);<br>      dst = src / <span class="hljs-number">44</span>;<br>      System.out.println(<span class="hljs-string">&quot;适配完成，输出的电压为=&quot;</span> + dst);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dst;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、Client"><a href="#2、Client" class="headerlink" title="2、Client"></a>2、Client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    System.out.println(<span class="hljs-string">&quot; === 对象适配器模式 ====&quot;</span>);<br>    <span class="hljs-type">Phone</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br>    phone.charging(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VoltageAdapter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Voltage220V</span>()));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、适配器模式的原理与实现"><a href="#2、适配器模式的原理与实现" class="headerlink" title="2、适配器模式的原理与实现"></a>2、适配器模式的原理与实现</h2><p>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同 工作。其别名为包装器(Wrapper)</p><p>适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。具体的代码实现如下所示。其中，ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 类适配器: 基于继承</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-comment">//... </span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fb</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//... </span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//... </span><br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITarget</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.fa();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...重新实现f2()...</span><br>    &#125;<br><br><span class="hljs-comment">// 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span><br>&#125;<br><br><span class="hljs-comment">// 对象适配器：基于组合</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//... </span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fb</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//... </span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//... </span><br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-keyword">private</span> Adaptee adaptee;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Adaptor</span><span class="hljs-params">(Adaptee adaptee)</span> &#123;<br>        <span class="hljs-built_in">this</span>.adaptee = adaptee;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;<br>        adaptee.fa(); <span class="hljs-comment">//委托给Adaptee</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...重新实现f2()...</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fc</span><span class="hljs-params">()</span> &#123;<br>        adaptee.fc();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有两个，一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度。</p><ul><li>如果 Adaptee 接口并不多，那两种实现方式都可以。</li><li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。</li><li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。</li></ul><h2 id="3、适配器模式应用场景"><a href="#3、适配器模式应用场景" class="headerlink" title="3、适配器模式应用场景"></a>3、适配器模式应用场景</h2><p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p><h3 id="1、封装有缺陷的接口设计"><a href="#1、封装有缺陷的接口设计" class="headerlink" title="1、封装有缺陷的接口设计"></a>1、封装有缺陷的接口设计</h3><p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p><p>比如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CD</span> &#123; <span class="hljs-comment">//这个类来自外部sdk，我们无权修改它的代码</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticFunction1</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>        <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uglyNamingFunction2</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br>        <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tooManyParamsFunction3</span><span class="hljs-params">(<span class="hljs-type">int</span> paramA, <span class="hljs-type">int</span> paramB, ...)</span> &#123; <span class="hljs-comment">//... &#125;</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lowPerformanceFunction4</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//... &#125;</span><br><br>&#125;<br><br><span class="hljs-comment">// 使用适配器模式进行重构</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITarget</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">function1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">function2</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fucntion3</span><span class="hljs-params">(ParamsWrapperDefinition paramsWrapper)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">function4</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">// 注意：适配器类的命名不一定非得末尾带Adaptor</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CDAdaptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CD</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITarget</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.staticFunction1();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.uglyNamingFucntion2();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function3</span><span class="hljs-params">(ParamsWrapperDefinition paramsWrapper)</span> &#123; <br>        <span class="hljs-built_in">super</span>.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function4</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...reimplement it...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、统一多个类的接口设计"><a href="#2、统一多个类的接口设计" class="headerlink" title="2、统一多个类的接口设计"></a>2、统一多个类的接口设计</h3><ol><li>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体还是举个例子来解释一下。</li><li>假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ASensitiveWordsFilter</span> &#123; <span class="hljs-comment">// A敏感词过滤系统提供的接口</span><br>  <span class="hljs-comment">// text是原始文本，函数输出用***替换敏感词之后的文本</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterSexyWords</span><span class="hljs-params">(String text)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterPoliticalWords</span><span class="hljs-params">(String text)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BSensitiveWordsFilter</span> &#123; <span class="hljs-comment">// B敏感词过滤系统提供的接口</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CSensitiveWordsFilter</span> &#123; <span class="hljs-comment">// C敏感词过滤系统提供的接口</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text, String mask)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RiskManagement</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">ASensitiveWordsFilter</span> <span class="hljs-variable">aFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ASensitiveWordsFilter</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">BSensitiveWordsFilter</span> <span class="hljs-variable">bFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BSensitiveWordsFilter</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">CSensitiveWordsFilter</span> <span class="hljs-variable">cFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CSensitiveWordsFilter</span>();<br><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterSensitiveWords</span><span class="hljs-params">(String text)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">maskedText</span> <span class="hljs-operator">=</span> aFilter.filterSexyWords(text);<br>    maskedText = aFilter.filterPoliticalWords(maskedText);<br>    maskedText = bFilter.filter(maskedText);<br>    maskedText = cFilter.filter(maskedText, <span class="hljs-string">&quot;***&quot;</span>);<br>    <span class="hljs-keyword">return</span> maskedText;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用适配器模式进行改造</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISensitiveWordsFilter</span> &#123; <span class="hljs-comment">// 统一接口定义</span><br>  String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ASensitiveWordsFilterAdaptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISensitiveWordsFilter</span> &#123;<br>  <span class="hljs-keyword">private</span> ASensitiveWordsFilter aFilter;<br><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filter</span><span class="hljs-params">(String text)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">maskedText</span> <span class="hljs-operator">=</span> aFilter.filterSexyWords(text);<br>    maskedText = aFilter.filterPoliticalWords(maskedText);<br>    <span class="hljs-keyword">return</span> maskedText;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// ...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...</span><br><span class="hljs-comment">// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，</span><br><span class="hljs-comment">// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RiskManagement</span> &#123;<br>  <span class="hljs-keyword">private</span> List&lt;ISensitiveWordsFilter&gt; filters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSensitiveWordsFilter</span><span class="hljs-params">(ISensitiveWordsFilter filter)</span> &#123;<br>    filters.add(filter);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">filterSensitiveWords</span><span class="hljs-params">(String text)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">maskedText</span> <span class="hljs-operator">=</span> text;<br>    <span class="hljs-keyword">for</span> (ISensitiveWordsFilter filter : filters) &#123;<br>      maskedText = filter.filter(maskedText);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maskedText;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、替换依赖的外部系统"><a href="#3、替换依赖的外部系统" class="headerlink" title="3、替换依赖的外部系统"></a>3、替换依赖的外部系统</h3><p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。具体的代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 外部系统A</span><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">interface</span>  <span class="hljs-title class_">IA</span>  &#123;<br><span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">fa</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">A</span>  <span class="hljs-keyword">implements</span>  <span class="hljs-title class_">IA</span>  &#123;<br><span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">fa</span><span class="hljs-params">()</span>  &#123; <br>    <span class="hljs-comment">//... </span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 在我们的项目中，外部系统A的使用示例</span><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Demo</span>  &#123;<br>  <span class="hljs-keyword">private</span> IA a;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-title function_">Demo</span><span class="hljs-params">(IA a)</span>  &#123;<br>    <span class="hljs-built_in">this</span>.a = a;<br>  &#125;<br>  <span class="hljs-comment">//... </span><br><br>&#125;<br><br><span class="hljs-type">Demo</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>());<br><br><span class="hljs-comment">// 将外部系统A替换成外部系统B</span><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">BAdaptor</span>  implemnts  IA  &#123;<br>  <span class="hljs-keyword">private</span> B b;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-title function_">BAdaptor</span><span class="hljs-params">(B b)</span>  &#123;<br>    <span class="hljs-built_in">this</span>.b= b;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">fa</span><span class="hljs-params">()</span>  &#123;<br>  <span class="hljs-comment">//...</span><br>    b.fb();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，</span><br><span class="hljs-comment">// 只需要将BAdaptor如下注入到Demo即可。</span><br><span class="hljs-type">Demo</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BAdaptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>()));<br></code></pre></td></tr></table></figure><h3 id="4、兼容老版本接口"><a href="#4、兼容老版本接口" class="headerlink" title="4、兼容老版本接口"></a>4、兼容老版本接口</h3><ol><li>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。同样，还是通过一个例子，来进一步解释一下。</li><li>JDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它改名为 Iterator 类，并且对它的代码实现做了优化。但是考虑到如果将 Enumeration 直接从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过。为了避免这种情况的发生，我们必须把项目中所有使用到 Enumeration 的地方，都修改为使用 Iterator 才行。</li><li>单独一个项目做 Enumeration 到 Iterator 的替换，勉强还能接受。但是，使用 Java 开发的项目太多了，一次 JDK 的升级，导致所有的项目不做代码修改就会编译报错，这显然是不合理的。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本 JDK 的老代码，我们可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor。代码示例如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Collections</span>  &#123;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> Emueration <span class="hljs-title function_">emumeration</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Collection c)</span>  &#123;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enumeration</span>() &#123;<br>      <span class="hljs-type">Iterator</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> c.iterator();<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasMoreElments</span><span class="hljs-params">()</span>  &#123;<br>        <span class="hljs-keyword">return</span> i.hashNext();<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">nextElement</span><span class="hljs-params">()</span>  &#123;<br>        <span class="hljs-keyword">return</span> i.next():<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、适配不同格式的数据"><a href="#5、适配不同格式的数据" class="headerlink" title="5、适配不同格式的数据"></a>5、适配不同格式的数据</h3><p>前面我们讲到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; stooges = Arrays.asList(<span class="hljs-string">&quot;Larry&quot;</span>, <span class="hljs-string">&quot;Moe&quot;</span>, <span class="hljs-string">&quot;Curly&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="6、适配器模式在-Java-日志中的应用-Slf4j"><a href="#6、适配器模式在-Java-日志中的应用-Slf4j" class="headerlink" title="6、适配器模式在 Java 日志中的应用(Slf4j)"></a>6、适配器模式在 Java 日志中的应用(Slf4j)</h3><ol><li>Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等。</li><li>大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不像 JDBC 那样，一开始就制定了数据库操作的接口规范。</li><li>如果我们只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback 随便选一个就好。但是，如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。</li><li>比如，项目中用到的某个组件使用 log4j 来打印日志，而我们项目本身使用的是 logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比如，日志存储的文件地址、打印日志的格式）。如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要统一日志打印框架。</li><li>如果是做 Java 开发的，那 Slf4j 这个日志框架肯定不陌生，它相当于 JDBC 规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用。</li><li>不仅如此，Slf4j 的出现晚于 JUL、JCL、log4j 等日志框架，所以，这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合 Slf4j 接口规范。Slf4j 也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的 Slf4j 接口定义。具体的代码示例如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// slf4j统一的接口定义</span><br><span class="hljs-keyword">package</span> org.slf4j;<br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Logger</span> &#123;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTraceEnabled</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String msg)</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String format, Object arg)</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String format, Object arg1, Object arg2)</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String format, Object[] argArray)</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String msg, Throwable t)</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDebugEnabled</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg)</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg)</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg1, Object arg2)</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object[] argArray)</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg, Throwable t)</span>;<br><br><span class="hljs-comment">//...省略info、warn、error等一堆接口</span><br>&#125;<br><br><br><span class="hljs-comment">// log4j日志框架的适配器</span><br><span class="hljs-comment">// Log4jLoggerAdapter实现了LocationAwareLogger接口，</span><br><span class="hljs-comment">// 其中LocationAwareLogger继承自Logger接口，</span><br><span class="hljs-comment">// 也就相当于Log4jLoggerAdapter实现了Logger接口。</span><br><span class="hljs-keyword">package</span> org.slf4j.impl;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log4jLoggerAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MarkerIgnoringBase</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LocationAwareLogger</span>, Serializable &#123;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> org.apache.log4j.Logger logger; <span class="hljs-comment">// log4j</span><br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDebugEnabled</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> logger.isDebugEnabled();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg)</span> &#123;<br>    logger.log(FQCN, Level.DEBUG, msg, <span class="hljs-literal">null</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>      <span class="hljs-type">FormattingTuple</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> MessageFormatter.format(format, arg);<br>      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object arg1, Object arg2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>      <span class="hljs-type">FormattingTuple</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> MessageFormatter.format(format, arg1, arg2);<br>      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String format, Object\[\] argArray)</span> &#123;<br>    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>      <span class="hljs-type">FormattingTuple</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> MessageFormatter.arrayFormat(format, argArray);<br>      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg, Throwable t)</span> &#123;<br>    logger.log(FQCN, Level.DEBUG, msg, t);<br>  &#125;<br><br><span class="hljs-comment">//...省略一堆接口的实现...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以，在开发业务系统或者开发框架、组件的时候，我们统一使用 Slf4j 提供的接口来编写打印日志的代码，具体使用哪种日志框架实现（log4j、logback……），是可以动态地指定的（使用 Java 的 SPI 技术），只需要将相应的 SDK 导入到项目中即可。</p><h2 id="4、代理、桥接、装饰器、适配器-4-种设计模式的区别"><a href="#4、代理、桥接、装饰器、适配器-4-种设计模式的区别" class="headerlink" title="4、代理、桥接、装饰器、适配器 4 种设计模式的区别"></a>4、代理、桥接、装饰器、适配器 4 种设计模式的区别</h2><ol><li>代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。</li><li>尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。</li></ol><ul><li>代理模式：在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</li><li>桥接模式：目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</li><li>装饰者模式：在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</li><li>适配器模式：是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型 </tag>
            
            <tag> 装饰器 </tag>
            
            <tag> 适配器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-结构型-代理-桥接</title>
      <link href="/2022/09/23/03-jie-gou-xing-dai-li-qiao-jie/"/>
      <url>/2022/09/23/03-jie-gou-xing-dai-li-qiao-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="一、代理模式【常用】"><a href="#一、代理模式【常用】" class="headerlink" title="一、代理模式【常用】"></a>一、代理模式【常用】</h2><ol><li>创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</li><li>其中，单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</li><li>另外一种类型的设计模式：结构型模式。结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。代理模式是在实际开发中经常被用到的一种设计模式。</li><li>代理模式有不同的形式, 主要有三种 <strong>静态代理</strong>、<strong>动态代理</strong> (JDK 代理、接口代理)和 <strong>Cglib</strong> <strong>代理</strong> (可以在内存 动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴) 。</li></ol><h3 id="1、静态代理"><a href="#1、静态代理" class="headerlink" title="1、静态代理"></a>1、静态代理</h3><p>实例具体要求</p><ol><li>定义一个接口:ITeacherDao</li><li>目标对象 TeacherDAO 实现接口 ITeacherDAO</li><li>使用静态代理方式,就需要在代理对象 TeacherDAOProxy 中也实现 ITeacherDAO</li><li>调用的时候通过调用代理对象的方法来调用目标对象</li><li>特别提醒：静态代理类与被代理类要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法</li></ol><blockquote><p><strong>ITeacherDao</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITeacherDao</span> &#123;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 授课的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>TeacherDao</strong> —&gt; 被代理类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TeacherDao</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITeacherDao</span> &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>System.out.println(<span class="hljs-string">&quot; 老师授课中  。。。。。&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>TeacherDaoProxy</strong> —&gt; 代理类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//代理对象,静态代理</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TeacherDaoProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITeacherDao</span>&#123;<br><br><span class="hljs-keyword">private</span> ITeacherDao target; <span class="hljs-comment">// 目标对象，通过接口来聚合</span><br><br><span class="hljs-comment">//构造器</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TeacherDaoProxy</span><span class="hljs-params">(ITeacherDao target)</span> &#123;<br><span class="hljs-built_in">this</span>.target = target;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>System.out.println(<span class="hljs-string">&quot;开始代理  完成某些操作。。。。。 &quot;</span>);<span class="hljs-comment">//方法</span><br>target.teach();<br>System.out.println(<span class="hljs-string">&quot;提交。。。。。&quot;</span>);<span class="hljs-comment">//方法</span><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Client</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-comment">//创建目标对象(被代理对象)</span><br><span class="hljs-type">TeacherDao</span> <span class="hljs-variable">teacherDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TeacherDao</span>();<br><br><span class="hljs-comment">//创建代理对象, 同时将被代理对象传递给代理对象</span><br><span class="hljs-type">TeacherDaoProxy</span> <span class="hljs-variable">teacherDaoProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TeacherDaoProxy</span>(teacherDao);<br><br><span class="hljs-comment">//通过代理对象，调用到被代理对象的方法</span><br><span class="hljs-comment">//即：执行的是代理对象的方法，代理对象再去调用目标对象的方法 </span><br>teacherDaoProxy.teach();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、动态代理"><a href="#2、动态代理" class="headerlink" title="2、动态代理"></a>2、动态代理</h3><ol><li>代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理</li><li>代理对象的生成，是利用 JDK 的 API，动态的在内存中构建代理对象</li><li>动态代理也叫做：<strong>JDK 代理</strong>、<strong>接口代理</strong></li><li>代理类所在包:java.lang.reflect.Proxy</li><li>JDK 实现代理只需要使用 <strong>newProxyInstance</strong> 方法,但是该方法需要接收三个参数,完整的写法是:</li></ol><p>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</p><blockquote><p>ITeacherDao</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITeacherDao</span> &#123;<br><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 授课方法</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>TeacherDao</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TeacherDao</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITeacherDao</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; 老师授课中.... &quot;</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot;hello &quot;</span> + name);<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ProxyFactory</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactory</span> &#123;<br><br>   <span class="hljs-comment">//维护一个目标对象 , Object</span><br>   <span class="hljs-keyword">private</span> Object target;<br><br>   <span class="hljs-comment">//构造器 ， 对target 进行初始化</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyFactory</span><span class="hljs-params">(Object target)</span> &#123;<br>      <br>      <span class="hljs-built_in">this</span>.target = target;<br>   &#125; <br>   <br>   <span class="hljs-comment">//给目标对象 生成一个代理对象</span><br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">()</span> &#123;<br>      <br>      <span class="hljs-comment">/* 说明</span><br><span class="hljs-comment">         public static Object newProxyInstance(ClassLoader loader,</span><br><span class="hljs-comment">                                          Class&lt;?&gt;[] interfaces,</span><br><span class="hljs-comment">                                          InvocationHandler h)</span><br><span class="hljs-comment">                                          </span><br><span class="hljs-comment">            1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span><br><span class="hljs-comment">            2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</span><br><span class="hljs-comment">            3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, </span><br><span class="hljs-comment">             会把当前执行的目标对象方法作为参数传入</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), <br>            target.getClass().getInterfaces(), <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>               <br>               <span class="hljs-meta">@Override</span><br>               <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                  <span class="hljs-comment">// TODO Auto-generated method stub</span><br>                  System.out.println(<span class="hljs-string">&quot;JDK代理开始~~&quot;</span>);<br>                  <span class="hljs-comment">//反射机制调用目标对象的方法</span><br>                  <span class="hljs-type">Object</span> <span class="hljs-variable">returnVal</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>                  System.out.println(<span class="hljs-string">&quot;JDK代理提交&quot;</span>);<br>                  <span class="hljs-keyword">return</span> returnVal;<br>               &#125;<br>            &#125;); <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Client</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-comment">//创建目标对象</span><br>      <span class="hljs-type">ITeacherDao</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TeacherDao</span>();<br>      <br>      <span class="hljs-comment">//给目标对象，创建代理对象, 可以转成 ITeacherDao</span><br>      <span class="hljs-type">ITeacherDao</span> <span class="hljs-variable">proxyInstance</span> <span class="hljs-operator">=</span> (ITeacherDao)<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>(target).getProxyInstance();<br>   <br>      <span class="hljs-comment">// proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象</span><br>      System.out.println(<span class="hljs-string">&quot;proxyInstance=&quot;</span> + proxyInstance.getClass());<br>      <br>      <span class="hljs-comment">//通过代理对象，调用目标对象的方法</span><br>      <span class="hljs-comment">//proxyInstance.teach();</span><br>      <br>      proxyInstance.sayHello(<span class="hljs-string">&quot; tom &quot;</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、Cglib代理"><a href="#3、Cglib代理" class="headerlink" title="3、Cglib代理"></a>3、Cglib代理</h3><ol><li><p>静态代理和 JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候可使用目标对象子类来实现代理-这就是Cglib代理</p></li><li><p>Cglib代理也叫作<strong>子类代理</strong>，它是在内存中构建一个子类对象从而实现对目标对象功能扩展, 有些书也将Cglib代理归属到动态代理。</p></li><li><p>Cglib 是一个强大的高性能的代码生成包,它可以在运行期扩展 java 类与实现 java 接口.它广泛的被许多 AOP 的 框架使用,例如 Spring AOP，实现方法拦截</p></li><li><p>在 AOP 编程中如何选择代理模式：</p><ul><li>目标对象需要实现接口，用 JDK 代理</li><li>目标对象不需要实现接口，用 Cglib 代理</li></ul></li><li><p>Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类</p></li><li><p>需要引入 cglib 的 jar 文件，在内存中动态构建子类，注意代理的类不能为 final，否则报错</p><p><code>java.lang.IllegalArgumentException</code>，目标对象的方法如果为 final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法。</p></li></ol><blockquote><p>TeacherDao</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TeacherDao</span> &#123;<br><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">teach</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot; 老师授课中  ， 我是cglib代理，不需要实现接口 &quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ProxyFactory</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br><br>   <span class="hljs-comment">//维护一个目标对象</span><br>   <span class="hljs-keyword">private</span> Object target;<br>   <br>   <span class="hljs-comment">//构造器，传入一个被代理的对象</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyFactory</span><span class="hljs-params">(Object target)</span> &#123;<br>      <span class="hljs-built_in">this</span>.target = target;<br>   &#125;<br><br>   <span class="hljs-comment">//返回一个代理对象:  是 target 对象的代理对象</span><br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//1. 创建一个工具类</span><br>      <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>      <span class="hljs-comment">//2. 设置父类</span><br>      enhancer.setSuperclass(target.getClass());<br>      <span class="hljs-comment">//3. 设置回调函数</span><br>      enhancer.setCallback(<span class="hljs-built_in">this</span>);<br>      <span class="hljs-comment">//4. 创建子类对象，即代理对象</span><br>      <span class="hljs-keyword">return</span> enhancer.create();<br>      <br>   &#125;<br>   <br><br>   <span class="hljs-comment">//重写  intercept 方法，会调用目标对象的方法</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object arg0, Method method, Object[] args, MethodProxy arg3)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot;Cglib代理模式 ~~ 开始&quot;</span>);<br>      <span class="hljs-type">Object</span> <span class="hljs-variable">returnVal</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>      System.out.println(<span class="hljs-string">&quot;Cglib代理模式 ~~ 提交&quot;</span>);<br>      <span class="hljs-keyword">return</span> returnVal;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Client</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      <span class="hljs-comment">//创建目标对象</span><br>      <span class="hljs-type">TeacherDao</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TeacherDao</span>();<br>      <span class="hljs-comment">//获取到代理对象，并且将目标对象传递给代理对象</span><br>      <span class="hljs-type">TeacherDao</span> <span class="hljs-variable">proxyInstance</span> <span class="hljs-operator">=</span> (TeacherDao)<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>(target).getProxyInstance();<br><br>      <span class="hljs-comment">//执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> proxyInstance.teach();<br>      System.out.println(<span class="hljs-string">&quot;res=&quot;</span> + res);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、代理模式的原理解析"><a href="#4、代理模式的原理解析" class="headerlink" title="4、代理模式的原理解析"></a>4、代理模式的原理解析</h3><ol><li>代理模式（Proxy Design Pattern）的原理和代码实现都不难掌握。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能【<strong>装饰器是增强功能，代理是附加新的功能</strong>】。我们通过一个简单的例子来解释一下这段话。</li><li>我们开发了一个 MetricsCollector 类，用来收集接口请求的原始数据，比如访问时间、处理时长等。在业务系统中，我们采用如下方式来使用这个 MetricsCollector 类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>  <span class="hljs-comment">//...省略其他属性和方法...</span><br>  <span class="hljs-keyword">private</span> MetricsCollector metricsCollector; <span class="hljs-comment">// 依赖注入</span><br><br>  <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>    <span class="hljs-comment">// ... 省略login逻辑...</span><br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>    <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;login&quot;</span>, responseTime, startTimestamp);<br>    metricsCollector.recordRequest(requestInfo);<br><br>    <span class="hljs-comment">//...返回UserVo数据...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>    <span class="hljs-comment">// ... 省略register逻辑...</span><br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>    <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;register&quot;</span>, responseTime, startTimestamp);<br>    metricsCollector.recordRequest(requestInfo);<br><br>    <span class="hljs-comment">//...返回UserVo数据...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>很明显，上面的写法有两个问题。第一，性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。第二，收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理。</li><li>为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。具体的代码实现如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserController</span> &#123;<br>  UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span>;<br>  UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserController</span> &#123;<br>  <span class="hljs-comment">//...省略其他属性和方法...</span><br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-comment">//...省略login逻辑...</span><br>    <span class="hljs-comment">//...返回UserVo数据...</span><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-comment">//...省略register逻辑...</span><br>    <span class="hljs-comment">//...返回UserVo数据...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserControllerProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserController</span> &#123;<br>  <span class="hljs-keyword">private</span> MetricsCollector metricsCollector;<br>  <span class="hljs-keyword">private</span> UserController userController;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserControllerProxy</span><span class="hljs-params">(UserController userController)</span> &#123;<br>    <span class="hljs-built_in">this</span>.userController = userController;<br>    <span class="hljs-built_in">this</span>.metricsCollector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollector</span>();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>    <span class="hljs-comment">// 委托</span><br>    <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> userController.login(telephone, password);<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>    <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;login&quot;</span>, responseTime, startTimestamp);<br>    metricsCollector.recordRequest(requestInfo);<br><br>    <span class="hljs-keyword">return</span> userVo;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>    <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> userController.register(telephone, password);<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>    <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;register&quot;</span>, responseTime, startTimestamp);<br>    metricsCollector.recordRequest(requestInfo);<br><br>    <span class="hljs-keyword">return</span> userVo;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//UserControllerProxy使用举例</span><br><span class="hljs-comment">//因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span><br><span class="hljs-comment">//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span><br><span class="hljs-type">IUserController</span> <span class="hljs-variable">userController</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserControllerProxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserController</span>());<br></code></pre></td></tr></table></figure><ol><li>参照基于==接口==而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下，我们该如何实现代理模式呢？</li><li><code>对于这种外部类的扩展，我们一般都是采用继承的方式</code>。这里也不例外。我们让代理类继承原始类，然后扩展附加功能。原理很简单，直接看代码。具体代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserControllerProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UserController</span> &#123;<br>  <span class="hljs-keyword">private</span> MetricsCollector metricsCollector;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserControllerProxy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.metricsCollector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollector</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">login</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>    <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.login(telephone, password);<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>    <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;login&quot;</span>, responseTime, startTimestamp);<br>    metricsCollector.recordRequest(requestInfo);<br><br>    <span class="hljs-keyword">return</span> userVo;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> UserVo <span class="hljs-title function_">register</span><span class="hljs-params">(String telephone, String password)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>    <span class="hljs-type">UserVo</span> <span class="hljs-variable">userVo</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.register(telephone, password);<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>    <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(<span class="hljs-string">&quot;register&quot;</span>, responseTime, startTimestamp);<br>    metricsCollector.recordRequest(requestInfo);<br><br>    <span class="hljs-keyword">return</span> userVo;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//UserControllerProxy使用举例</span><br><span class="hljs-type">UserController</span> <span class="hljs-variable">userController</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserControllerProxy</span>();<br></code></pre></td></tr></table></figure><h3 id="5、动态代理的原理解析"><a href="#5、动态代理的原理解析" class="headerlink" title="5、动态代理的原理解析"></a>5、动态代理的原理解析</h3><ol><li>不过，刚刚的代码实现还是有点问题。一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。</li><li>如果有 50 个要添加附加功能的原始类，那我们就要创建 50 个对应的代理类。这会导致项目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式的“重复”代码，也增加了不必要的开发成本。那这个问题怎么解决呢？</li><li>我们可以使用动态代理来解决这个问题。所谓动态代理（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。那如何实现动态代理呢？</li><li>如果你熟悉的是 Java 语言，实现动态代理就是件很简单的事情。因为 Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java 的反射语法）。我们来看一下，如何用 Java 的动态代理来实现刚刚的功能。具体的代码如下所示。其中，MetricsCollectorProxy 作为一个动态代理类，动态地给每个需要收集接口请求信息的类创建代理类。、</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MetricsCollectorProxy</span> &#123;<br>  <span class="hljs-keyword">private</span> MetricsCollector metricsCollector;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">MetricsCollectorProxy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.metricsCollector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollector</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">createProxy</span><span class="hljs-params">(Object proxiedObject)</span> &#123;<br>    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();<br>    <span class="hljs-type">DynamicProxyHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicProxyHandler</span>(proxiedObject);<br>    <span class="hljs-keyword">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicProxyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> Object proxiedObject;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DynamicProxyHandler</span><span class="hljs-params">(Object proxiedObject)</span> &#123;<br>      <span class="hljs-built_in">this</span>.proxiedObject = proxiedObject;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>      <span class="hljs-type">long</span> <span class="hljs-variable">startTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>      <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(proxiedObject, args);<br>      <span class="hljs-type">long</span> <span class="hljs-variable">endTimeStamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>      <span class="hljs-type">long</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> endTimeStamp - startTimestamp;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">apiName</span> <span class="hljs-operator">=</span> proxiedObject.getClass().getName() + <span class="hljs-string">&quot;:&quot;</span> + method.getName();<br>      <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">requestInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInfo</span>(apiName, responseTime, startTimestamp);<br>      metricsCollector.recordRequest(requestInfo);<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//MetricsCollectorProxy使用举例</span><br><span class="hljs-type">MetricsCollectorProxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricsCollectorProxy</span>();<br><span class="hljs-type">IUserController</span> <span class="hljs-variable">userController</span> <span class="hljs-operator">=</span> (IUserController) proxy.createProxy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserController</span>());<br></code></pre></td></tr></table></figure><p>实际上，Spring AOP 底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring 为这些类创建动态代理对象，并在 JVM 中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。</p><h3 id="6、代理模式的应用场景"><a href="#6、代理模式的应用场景" class="headerlink" title="6、代理模式的应用场景"></a>6、代理模式的应用场景</h3><h4 id="1、业务系统的非功能性需求开发"><a href="#1、业务系统的非功能性需求开发" class="headerlink" title="1、业务系统的非功能性需求开发"></a>1、业务系统的非功能性需求开发</h4><p>代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的例子，就是这个应用场景的一个典型例子。</p><p>如果你熟悉 Java 语言和 Spring 开发框架，这部分工作都是可以在 Spring AOP 切面中完成的。前面我们也提到，Spring AOP 底层的实现原理就是基于动态代理。</p><h4 id="2、代理模式在-RPC、缓存中的应用"><a href="#2、代理模式在-RPC、缓存中的应用" class="headerlink" title="2、代理模式在 RPC、缓存中的应用"></a>2、代理模式在 RPC、缓存中的应用</h4><p>实际上，RPC 框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。</p><h4 id="3、代理模式在缓存中的应用"><a href="#3、代理模式在缓存中的应用" class="headerlink" title="3、代理模式在缓存中的应用"></a>3、代理模式在缓存中的应用</h4><ol><li>假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。那如何来实现接口请求的缓存功能呢？</li><li>最简单的实现方法就是刚刚我们讲到的，给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存接口）、集中配置（比如配置每个接口缓存过期时间）。</li><li>针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于 Spring 框架来开发的话，那就可以在 AOP 切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如 http://…?..&amp;cached=true），我们便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回。</li></ol><h2 id="二、桥接模式【常用】"><a href="#二、桥接模式【常用】" class="headerlink" title="二、桥接模式【常用】"></a>二、桥接模式【常用】</h2><ol><li>已经了解了第一种结构型模式：代理模式。它在不改变原始类（或者叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。代理模式在平时的开发经常被用到，常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。</li><li>另一种结构型模式：桥接模式。桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相当于代理模式来说，桥接模式在实际的项目中并没有那么常用，见到能认识就可以。</li></ol><h3 id="1、Demo案例-手机操作问题"><a href="#1、Demo案例-手机操作问题" class="headerlink" title="1、Demo案例-手机操作问题"></a>1、Demo案例-手机操作问题</h3><h4 id="1、需求"><a href="#1、需求" class="headerlink" title="1、需求"></a>1、需求</h4><p>现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)，如图:</p><p><img src="/2022/09/23/03-jie-gou-xing-dai-li-qiao-jie/image-20220926161449612.png"></p><h4 id="2、传统方案解决手机操作问题分析"><a href="#2、传统方案解决手机操作问题分析" class="headerlink" title="2、传统方案解决手机操作问题分析"></a>2、传统方案解决手机操作问题分析</h4><p>传统方法对应的类图</p><p><img src="/2022/09/23/03-jie-gou-xing-dai-li-qiao-jie/image-20220926161534523.png" alt="类图"></p><ol><li>扩展性问题(<strong>类爆炸</strong>)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。</li><li>违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本.</li><li>解决方案-使用<strong>桥接模</strong>式</li><li>Bridge 模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把<code>抽象(Abstraction)与行为实现(Implementation)分离开来</code>，从而可以保持各部分的独立性以及应对他们的功能扩展</li></ol><h4 id="3、使用桥接模式的代码"><a href="#3、使用桥接模式的代码" class="headerlink" title="3、使用桥接模式的代码"></a>3、使用桥接模式的代码</h4><h5 id="1、brand接口"><a href="#1、brand接口" class="headerlink" title="1、brand接口"></a>1、brand接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Brand</span> &#123;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span>;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、Phone【抽象类】"><a href="#2、Phone【抽象类】" class="headerlink" title="2、Phone【抽象类】"></a>2、Phone【抽象类】</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;<br>   <br>   <span class="hljs-comment">//组合品牌</span><br>   <span class="hljs-keyword">private</span> Brand brand;<br><br>   <span class="hljs-comment">//构造器</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Phone</span><span class="hljs-params">(Brand brand)</span> &#123;<br>      <span class="hljs-built_in">super</span>();<br>      <span class="hljs-built_in">this</span>.brand = brand;<br>   &#125;<br>   <br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-built_in">this</span>.brand.open();<br>   &#125;<br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>      brand.close();<br>   &#125;<br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>      brand.call();<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、Vivo"><a href="#3、Vivo" class="headerlink" title="3、Vivo"></a>3、Vivo</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vivo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Brand</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; Vivo手机开机 &quot;</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; Vivo手机关机 &quot;</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; Vivo手机打电话 &quot;</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4、XiaoMi"><a href="#4、XiaoMi" class="headerlink" title="4、XiaoMi"></a>4、XiaoMi</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaoMi</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Brand</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; 小米手机开机 &quot;</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; 小米手机关机 &quot;</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// TODO Auto-generated method stub</span><br>      System.out.println(<span class="hljs-string">&quot; 小米手机打电话 &quot;</span>);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5、FoldedPhone"><a href="#5、FoldedPhone" class="headerlink" title="5、FoldedPhone"></a>5、FoldedPhone</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//折叠式手机类，继承 抽象类 Phone</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FoldedPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Phone</span> &#123;<br><br>   <span class="hljs-comment">//构造器</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">FoldedPhone</span><span class="hljs-params">(Brand brand)</span> &#123;<br>      <span class="hljs-built_in">super</span>(brand);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-built_in">super</span>.open();<br>      System.out.println(<span class="hljs-string">&quot; 折叠样式手机 &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-built_in">super</span>.close();<br>      System.out.println(<span class="hljs-string">&quot; 折叠样式手机 &quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-built_in">super</span>.call();<br>      System.out.println(<span class="hljs-string">&quot; 折叠样式手机 &quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6、UpRightPhone"><a href="#6、UpRightPhone" class="headerlink" title="6、UpRightPhone"></a>6、UpRightPhone</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpRightPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Phone</span> &#123;<br>   <br>      <span class="hljs-comment">//构造器</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">UpRightPhone</span><span class="hljs-params">(Brand brand)</span> &#123;<br>         <span class="hljs-built_in">super</span>(brand);<br>      &#125;<br>      <br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-built_in">super</span>.open();<br>         System.out.println(<span class="hljs-string">&quot; 直立样式手机 &quot;</span>);<br>      &#125;<br>      <br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-built_in">super</span>.close();<br>         System.out.println(<span class="hljs-string">&quot; 直立样式手机 &quot;</span>);<br>      &#125;<br>      <br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-built_in">super</span>.call();<br>         System.out.println(<span class="hljs-string">&quot; 直立样式手机 &quot;</span>);<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="7、Client"><a href="#7、Client" class="headerlink" title="7、Client"></a>7、Client</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <br>      <span class="hljs-comment">//获取折叠式手机 (样式 + 品牌 )</span><br>      <br>      <span class="hljs-type">Phone</span> <span class="hljs-variable">phone1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FoldedPhone</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">XiaoMi</span>());<br>      <br>      phone1.open();<br>      phone1.call();<br>      phone1.close();<br>      <br>      System.out.println(<span class="hljs-string">&quot;=======================&quot;</span>);<br>      <br>      <span class="hljs-type">Phone</span> <span class="hljs-variable">phone2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FoldedPhone</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vivo</span>());<br>      <br>      phone2.open();<br>      phone2.call();<br>      phone2.close();<br>      <br>      System.out.println(<span class="hljs-string">&quot;==============&quot;</span>);<br>      <br>      <span class="hljs-type">UpRightPhone</span> <span class="hljs-variable">phone3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpRightPhone</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">XiaoMi</span>());<br>      <br>      phone3.open();<br>      phone3.call();<br>      phone3.close();<br>      <br>      System.out.println(<span class="hljs-string">&quot;==============&quot;</span>);<br>      <br>      <span class="hljs-type">UpRightPhone</span> <span class="hljs-variable">phone4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpRightPhone</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vivo</span>());<br>      <br>      phone4.open();<br>      phone4.call();<br>      phone4.close();<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、桥接模式的原理解析"><a href="#2、桥接模式的原理解析" class="headerlink" title="2、桥接模式的原理解析"></a>2、桥接模式的原理解析</h3><ol><li>桥接模式，也叫作桥梁模式，英文是Bridge Design Pattern。</li><li>在 GoF 的《设计模式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。”</li><li>关于桥接模式，很多书籍、资料中，还有另外一种理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。</li><li>GoF 给出的定义非常的简短，单凭这一句话，估计没几个人能看懂是什么意思。所以，我们通过 JDBC 驱动的例子来解释一下。JDBC 驱动是桥接模式的经典应用。我们先来看一下，如何利用 JDBC 驱动来查询数据库。具体的代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>); <span class="hljs-comment">// 加载及注册JDBC驱动程序</span><br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_password&quot;</span>;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url);<br><span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> con.createStatement();<br><span class="hljs-type">String</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from test&quot;</span>;<br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery(query);<br><span class="hljs-keyword">while</span> (rs.next()) &#123;<br>  rs.getString(<span class="hljs-number">1</span>);<br>  rs.getInt(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>如果我们想要把 MySQL 数据库换成 Oracle 数据库，只需要把第一行代码中的 com.mysql.jdbc.Driver 换成 oracle.jdbc.driver.OracleDriver 就可以了。当然，也有更灵活的实现方式，我们可以把需要加载的 Driver 类写到配置文件中，当程序启动的时候，自动从配置文件中加载，这样在切换数据库的时候，我们都不需要修改代码，只需要修改配置文件就可以了。</li><li>不管是改代码还是改配置，在项目中，从一个数据库切换到另一种数据库，都只需要改动很少的代码，或者完全不需要改动代码，那如此优雅的数据库切换是如何实现的呢？</li><li>先从 com.mysql.jdbc.Driver 这个类的代码看起。部分相关代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mysql.jdbc;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NonRegisteringDriver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.sql.Driver &#123;<br>  <span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      java.sql.DriverManager.registerDriver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>());<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException E) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Construct a new driver and register it with DriverManager</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@throws</span> SQLException if a database error occurs.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Driver</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>  <span class="hljs-comment">// Required for Class.forName().newInstance()</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结合 com.mysql.jdbc.Driver 的代码实现，可以发现，当执行 Class.forName(“com.mysql.jdbc.Driver”) 这条语句的时候，实际上是做了两件事情。第一件事情是要求 JVM 查找并加载指定的 Driver 类，第二件事情是执行该类的静态代码，也就是将 MySQL Driver 注册到 DriverManager 类中。</p><p>现在，我们再来看一下，DriverManager 类是干什么用的。具体的代码如下所示。当我们把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后，后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DriverManager</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span>  CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers =  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>();<br><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">static</span> &#123;<br>    loadInitialDrivers();<br>    println(<span class="hljs-string">&quot;JDBC DriverManager initialized&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerDriver</span><span class="hljs-params">(java.sql.Driver driver)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-keyword">if</span> (driver != <span class="hljs-literal">null</span>) &#123;<br>      registeredDrivers.addIfAbsent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DriverInfo</span>(driver));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">(String url, String user, String password)</span><br>      <span class="hljs-keyword">throws</span> SQLException &#123;<br>    java.util.<span class="hljs-type">Properties</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Properties();<br>    <span class="hljs-keyword">if</span> (user != <span class="hljs-literal">null</span>) &#123;<br>      info.put(<span class="hljs-string">&quot;user&quot;</span>, user);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (password != <span class="hljs-literal">null</span>) &#123;<br>      info.put(<span class="hljs-string">&quot;password&quot;</span>, password);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。那弄懂定义中“抽象”和“实现”两个概念，就是理解桥接模式的关键。那在 JDBC 这个例子中，什么是“抽象”？什么是“实现”呢？</p><p>实际上，JDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。JDBC 和 Driver 独立开发，通过对象之间的组合关系，组装在一起。JDBC 的所有逻辑操作，最终都委托给 Driver 来执行。</p><h3 id="3、桥接模式的应用举例"><a href="#3、桥接模式的应用举例" class="headerlink" title="3、桥接模式的应用举例"></a>3、桥接模式的应用举例</h3><p>在前面，有一个 API 接口监控告警的例子：根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如，SERVE（严重）级别的消息会通过“自动语音电话”告知相关人员。</p><p>在当时的代码实现中，关于发送告警信息那部分代码，只给出了粗略的设计，现在一块实现一下。先来看最简单、最直接的一种实现方式。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">NotificationEmergencyLevel</span> &#123;<br>  SEVERE,<br>  URGENCY,<br>  NORMAL,<br>  TRIVIAL<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Notification</span> &#123;<br>  <span class="hljs-keyword">private</span> List&lt;String&gt; emailAddresses;<br>  <span class="hljs-keyword">private</span> List&lt;String&gt; telephones;<br>  <span class="hljs-keyword">private</span> List&lt;String&gt; wechatIds;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Notification</span><span class="hljs-params">()</span> &#123;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEmailAddress</span><span class="hljs-params">(List&lt;String&gt; emailAddress)</span> &#123;<br>    <span class="hljs-built_in">this</span>.emailAddresses = emailAddress;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTelephones</span><span class="hljs-params">(List&lt;String&gt; telephones)</span> &#123;<br>    <span class="hljs-built_in">this</span>.telephones = telephones;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWechatIds</span><span class="hljs-params">(List&lt;String&gt; wechatIds)</span> &#123;<br>    <span class="hljs-built_in">this</span>.wechatIds = wechatIds;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(NotificationEmergencyLevel level, String message)</span> &#123;<br>    <span class="hljs-keyword">if</span> (level.equals(NotificationEmergencyLevel.SEVERE)) &#123;<br>      <span class="hljs-comment">// ...自动语音电话</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level.equals(NotificationEmergencyLevel.URGENCY)) &#123;<br>      <span class="hljs-comment">// ...发微信</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level.equals(NotificationEmergencyLevel.NORMAL)) &#123;<br>      <span class="hljs-comment">// ...发邮件</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level.equals(NotificationEmergencyLevel.TRIVIAL)) &#123;<br>      <span class="hljs-comment">// ...发邮件</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 在API监控告警的例子中，我们如下方式来使用Notification类：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorAlertHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AlertHandler</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ErrorAlertHandler</span><span class="hljs-params">(AlertRule rule, Notification notification)</span> &#123;<br>    <span class="hljs-built_in">super</span>(rule, notification);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(ApiStatInfo apiStatInfo)</span> &#123;<br>    <span class="hljs-keyword">if</span> (apiStatInfo.getErrorCount()<br>        &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;<br>      notification.notify(NotificationEmergencyLevel.SEVERE, <span class="hljs-string">&quot;...&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>Notification 类的代码实现有一个最明显的问题，那就是有很多 if-else 分支逻辑。实际上，如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能（增加更多 if-else 分支判断），那这样的设计问题并不大，没必要非得一定要摒弃 if-else 分支逻辑。</li><li>不过，Notification 的代码显然不符合这个条件。因为每个 if-else 分支中的代码逻辑都比较复杂，发送通知的所有逻辑都扎堆在 Notification 类中。我们知道，类的代码越多，就越难读懂，越难修改，维护的成本也就越高。很多设计模式都是试图将庞大的类拆分成更细小的类，然后再通过某种更合理的结构组装在一起。</li><li>针对 Notification 的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender 相关类）。其中，Notification 类相当于抽象，MsgSender 类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以<code>动态</code>地去指定（比如，通过读取配置来获取对应关系）。</li></ol><p>按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MsgSender</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TelephoneMsgSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MsgSender</span> &#123;<br>  <span class="hljs-keyword">private</span> List&lt;String&gt; telephones;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">TelephoneMsgSender</span><span class="hljs-params">(List&lt;String&gt; telephones)</span> &#123;<br>    <span class="hljs-built_in">this</span>.telephones = telephones;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailMsgSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MsgSender</span> &#123;<br>  <span class="hljs-comment">// 与TelephoneMsgSender代码结构类似，所以省略...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WechatMsgSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MsgSender</span> &#123;<br>  <span class="hljs-comment">// 与TelephoneMsgSender代码结构类似，所以省略...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Notification</span> &#123;<br>  <span class="hljs-keyword">protected</span> MsgSender msgSender;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Notification</span><span class="hljs-params">(MsgSender msgSender)</span> &#123;<br>    <span class="hljs-built_in">this</span>.msgSender = msgSender;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SevereNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">SevereNotification</span><span class="hljs-params">(MsgSender msgSender)</span> &#123;<br>    <span class="hljs-built_in">super</span>(msgSender);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message)</span> &#123;<br>    msgSender.send(message);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UrgencyNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br>  <span class="hljs-comment">// 与SevereNotification代码结构类似，所以省略...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br>  <span class="hljs-comment">// 与SevereNotification代码结构类似，所以省略...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrivialNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Notification</span> &#123;<br>  <span class="hljs-comment">// 与SevereNotification代码结构类似，所以省略...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、桥接模式的注意事项和细节"><a href="#4、桥接模式的注意事项和细节" class="headerlink" title="4、桥接模式的注意事项和细节"></a>4、桥接模式的注意事项和细节</h3><ol><li>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。</li><li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。</li><li>桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本</li><li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程</li><li>桥接模式要求**正确识别出系统中两个独立变化的维度(抽象、和实现)**，因此其使用范围有一定的局限性，即需要有这样的应用场景。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型 </tag>
            
            <tag> 代理 </tag>
            
            <tag> 桥接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-创建型-工厂&amp;建造者&amp;原型</title>
      <link href="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/"/>
      <url>/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="一、工厂模式【常用】"><a href="#一、工厂模式【常用】" class="headerlink" title="一、工厂模式【常用】"></a>一、工厂模式【常用】</h2><ol><li>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。</li><li>在这三种细分的工厂模式中，简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。所以，重点是前两种工厂模式。对于抽象工厂，稍微了解一下即可。</li></ol><h3 id="1、简单工厂"><a href="#1、简单工厂" class="headerlink" title="1、简单工厂"></a>1、简单工厂</h3><p>什么是简单工厂模式？</p><p>简单来说，就是定义一个工厂类，它可以根据不同的参数返回不同类的实例，被创建的实例通常都具有共同的父类。</p><p>通过一个例子来解释一下简单工厂。在下面这段代码中，我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>  <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<br>             <span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>    <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>    <span class="hljs-keyword">return</span> ruleConfig;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>    <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及 parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。重构之后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> createParser(ruleConfigFileExtension);<br>    <span class="hljs-keyword">if</span> (parser == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<br>              <span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>    <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>    <span class="hljs-keyword">return</span> ruleConfig;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>    <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">(String configFormat)</span> &#123;<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> parser;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了让类的职责更加单一(<strong>设计模式原则中的单一职责</strong>，)、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>  <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> RuleConfigParserFactory.createParser(ruleConfigFileExtension);<br>    <span class="hljs-keyword">if</span> (parser == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<br>              <span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>    <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>    <span class="hljs-keyword">return</span> ruleConfig;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>    <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigParserFactory</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">(String configFormat)</span> &#123;<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;<br>      parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> parser;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。</li><li>实际上，如果 parser 可以复用，为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。在接下来的讲解中，我们把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作简单工厂模式的第二种实现方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigParserFactory</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">static</span> &#123;<br>    cachedParsers.put(<span class="hljs-string">&quot;json&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>());<br>    cachedParsers.put(<span class="hljs-string">&quot;xml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>());<br>    cachedParsers.put(<span class="hljs-string">&quot;yaml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>());<br>    cachedParsers.put(<span class="hljs-string">&quot;properties&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>());<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">(String configFormat)</span> &#123;<br>    <span class="hljs-keyword">if</span> (configFormat == <span class="hljs-literal">null</span> || configFormat.isEmpty()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//返回null还是IllegalArgumentException全凭你自己说了算</span><br>    &#125;<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> cachedParsers.get(configFormat.toLowerCase());<br>    <span class="hljs-keyword">return</span> parser;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>对于上面两种简单工厂模式的实现方法，如果我们要添加新的 parser，那势必要改动到 RuleConfigParserFactory 的代码，那这是不是违反开闭原则呢？实际上，如果不是需要频繁地添加新的 parser，只是偶尔修改一下 RuleConfigParserFactory 代码，稍微不符合开闭原则，也是完全可以接受的。</li><li>除此之外，在 RuleConfigParserFactory 的第一种代码实现中，有一组 if 分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？实际上，如果 if 分支并不是很多，代码中有 if 分支也是完全可以接受的。应用多态或设计模式来替代 if 分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合<strong>开闭原则</strong>，但也增加了类的个数，牺牲了代码的可读性。</li></ol><h3 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h3><p>看一个需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪pizza、 北京的胡椒pizza 或者是伦敦的奶酪pizza、伦敦的胡椒pizza。</p><p>如何实现？</p><p>思路一：使用简单工厂模式，创建不同的简单工厂类，比如BJPizzaSimpleFactory、 LDPizzaSimpleFactory 等等.从当前这个案例来说，也是可以的，但是考虑到项目的 规模，以及软件的可维护性、可扩展性并不是特别好</p><p>思路二：使用工厂模式</p><p>工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点 餐子类中具体实现。 </p><p>工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。</p><p>再接着上述简单工厂模式的例子，若是非要去掉if呢，怎么办？将代码重构后，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>  IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YamlRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParser</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PropertiesRuleConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRuleConfigParserFactory</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParser</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模式比起简单工厂模式更加符合开闭原则。</p><p>但是上述代码存在很大的问题。问题存在于这些工厂类的使用上。接下来，我们看一下，如何用这些工厂类来实现 RuleConfigSource 的 load() 函数。具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>  <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br><br>    <span class="hljs-type">IRuleConfigParserFactory</span> <span class="hljs-variable">parserFactory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parserFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParserFactory</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parserFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParserFactory</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parserFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParserFactory</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;<br>      parserFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParserFactory</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);<br>    &#125;<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> parserFactory.createParser();<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>    <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>    <span class="hljs-keyword">return</span> ruleConfig;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>    <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 load() 函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。</li><li>我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。这段话听起来有点绕，代码实现出来，一看就能明白。其中，RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，getParserFactory() 返回的是缓存好的单例工厂对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigSource</span> &#123;<br>  <span class="hljs-keyword">public</span> RuleConfig <span class="hljs-title function_">load</span><span class="hljs-params">(String ruleConfigFilePath)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ruleConfigFileExtension</span> <span class="hljs-operator">=</span> getFileExtension(ruleConfigFilePath);<br><br>    <span class="hljs-type">IRuleConfigParserFactory</span> <span class="hljs-variable">parserFactory</span> <span class="hljs-operator">=</span> RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);<br>    <span class="hljs-keyword">if</span> (parserFactory == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidRuleConfigException</span>(<span class="hljs-string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);<br>    &#125;<br>    <span class="hljs-type">IRuleConfigParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> parserFactory.createParser();<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">configText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span><br>    <span class="hljs-type">RuleConfig</span> <span class="hljs-variable">ruleConfig</span> <span class="hljs-operator">=</span> parser.parse(configText);<br>    <span class="hljs-keyword">return</span> ruleConfig;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileExtension</span><span class="hljs-params">(String filePath)</span> &#123;<br>    <span class="hljs-comment">//...解析文件名获取扩展名，比如rule.json，返回json</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;json&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//因为工厂类只包含方法，不包含成员变量，完全可以复用，</span><br><span class="hljs-comment">//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleConfigParserFactoryMap</span> &#123; <span class="hljs-comment">//工厂的工厂</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">static</span> &#123;<br>    cachedFactories.put(<span class="hljs-string">&quot;json&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParserFactory</span>());<br>    cachedFactories.put(<span class="hljs-string">&quot;xml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParserFactory</span>());<br>    cachedFactories.put(<span class="hljs-string">&quot;yaml&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlRuleConfigParserFactory</span>());<br>    cachedFactories.put(<span class="hljs-string">&quot;properties&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesRuleConfigParserFactory</span>());<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IRuleConfigParserFactory <span class="hljs-title function_">getParserFactory</span><span class="hljs-params">(String type)</span> &#123;<br>    <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span> || type.isEmpty()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-type">IRuleConfigParserFactory</span> <span class="hljs-variable">parserFactory</span> <span class="hljs-operator">=</span> cachedFactories.get(type.toLowerCase());<br>    <span class="hljs-keyword">return</span> parserFactory;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则。</li><li>实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性，而且，每个 Factory 类只是做简单的 new 操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。</li></ol><p>问题来了：什么时候用简单工厂模式，什么时候用工厂模式？</p><ol><li>前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。</li><li>基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</li><li>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。</li></ol><h3 id="3、抽象工厂"><a href="#3、抽象工厂" class="headerlink" title="3、抽象工厂"></a>3、抽象工厂</h3><p>抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类 </p><p>抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。</p><p>从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。 </p><p>将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以 根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇， 更利于代码的维护和扩展。</p><p>抽象工厂没有前两者常用，简单了解即可。</p><p>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">针对规则配置的解析器：基于接口IRuleConfigParser<br>JsonRuleConfigParser<br>XmlRuleConfigParser<br>YamlRuleConfigParser<br>PropertiesRuleConfigParser<br><br>针对系统配置的解析器：基于接口ISystemConfigParser<br>JsonSystemConfigParser<br>XmlSystemConfigParser<br>YamlSystemConfigParser<br>PropertiesSystemConfigParser<br></code></pre></td></tr></table></figure><ol><li>针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编写一个工厂类，也就是要编写 8 个工厂类。如果我们未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。而我们知道，过多的类也会让系统难维护。这个问题该怎么解决呢？</li><li>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IConfigParserFactory</span> &#123;<br>  IRuleConfigParser <span class="hljs-title function_">createRuleParser</span><span class="hljs-params">()</span>;<br>  ISystemConfigParser <span class="hljs-title function_">createSystemParser</span><span class="hljs-params">()</span>;<br>  <span class="hljs-comment">//此处可以扩展新的parser类型，比如IBizConfigParser</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IConfigParserFactory</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createRuleParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonRuleConfigParser</span>();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> ISystemConfigParser <span class="hljs-title function_">createSystemParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonSystemConfigParser</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlConfigParserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IConfigParserFactory</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> IRuleConfigParser <span class="hljs-title function_">createRuleParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlRuleConfigParser</span>();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> ISystemConfigParser <span class="hljs-title function_">createSystemParser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlSystemConfigParser</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span><br></code></pre></td></tr></table></figure><h3 id="4、DI容器"><a href="#4、DI容器" class="headerlink" title="4、DI容器"></a>4、DI容器</h3><p>当创建对象是一个“大工程”的时候，我们一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。那何为“大工程”呢？上面我们讲了两种情况，一种是创建过程涉及复杂的 if-else 分支判断，另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程。</p><p>今天，我们再来讲一个创建对象的“大工程”，依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称 DI 容器。</p><p>DI 容器跟我们讲的工厂模式又有何区别和联系？DI 容器的核心功能有哪些，以及如何实现一个简单的 DI 容器？</p><h4 id="1、工厂模式和DI容器有何区别"><a href="#1、工厂模式和DI容器有何区别" class="headerlink" title="1、工厂模式和DI容器有何区别"></a>1、工厂模式和DI容器有何区别</h4><ol><li>实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</li><li>DI 容器相对于我们上面讲的工厂模式的例子来说，它处理的是更大的对象创建工程。上面讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。</li><li>除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。接下来，我们就详细讲讲，一个简单的 DI 容器应该包含哪些核心功能。</li></ol><h4 id="2、DI容器的核心功能"><a href="#2、DI容器的核心功能" class="headerlink" title="2、DI容器的核心功能"></a>2、DI容器的核心功能</h4><p>一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。</p><blockquote><p>配置解析</p></blockquote><ol><li>在上面讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，我们需要通过一种形式，让应用告知 DI 容器要创建哪些对象。这种形式就是我们要讲的配置。</li><li>我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。</li><li>下面是一个典型的 Spring 容器的配置文件。Spring 容器读取这个配置文件，解析出要创建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：rateLimiter 依赖 redisCounter。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiter</span> &#123;<br>  <span class="hljs-keyword">private</span> RedisCounter redisCounter;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">RateLimiter</span><span class="hljs-params">(RedisCounter redisCounter)</span> &#123;<br>    <span class="hljs-built_in">this</span>.redisCounter = redisCounter;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisCounter</span> &#123;<br>  <span class="hljs-keyword">private</span> String ipAddress;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisCounter</span><span class="hljs-params">(String ipAddress, <span class="hljs-type">int</span> port)</span> &#123;<br>    <span class="hljs-built_in">this</span>.ipAddress = ipAddress;<br>    <span class="hljs-built_in">this</span>.port = port;<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br>配置文件beans.xml：<br>&lt;beans&gt;<br>   &lt;bean id=<span class="hljs-string">&quot;rateLimiter&quot;</span> class=<span class="hljs-string">&quot;com.zb.RateLimiter&quot;</span>&gt;<br>      &lt;constructor-arg ref=<span class="hljs-string">&quot;redisCounter&quot;</span>/&gt;<br>   &lt;/bean&gt;<br> <br>   &lt;bean id=<span class="hljs-string">&quot;redisCounter&quot;</span> class=<span class="hljs-string">&quot;com.zb.redisCounter&quot;</span>&gt;<br>     &lt;constructor-arg type=<span class="hljs-string">&quot;String&quot;</span> value=<span class="hljs-string">&quot;127.0.0.1&quot;</span>&gt;<br>     &lt;constructor-arg type=<span class="hljs-string">&quot;int&quot;</span> value=<span class="hljs-number">1234</span>&gt;<br>   &lt;/bean&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><blockquote><p>对象创建</p></blockquote><ol><li>在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。</li><li>你可能会说，如果要创建的类对象非常多，BeansFactory 中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）呢？实际上并不会。待会讲到 DI 容器的具体实现的时候，我们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。</li></ol><blockquote><p>对象的声明周期管理</p></blockquote><ol><li>上面我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope=prototype 表示返回新创建的对象，scope=singleton 表示返回单例对象。</li><li>除此之外，我们还可以配置对象是否支持懒加载。如果 lazy-init=true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好。</li><li>不仅如此，我们还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。</li></ol><h3 id="5、实现简单的DI容器"><a href="#5、实现简单的DI容器" class="headerlink" title="5、实现简单的DI容器"></a>5、实现简单的DI容器</h3><p>用 Java 语言来实现一个简单的 DI 容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象。</p><h4 id="1、最小原型设计"><a href="#1、最小原型设计" class="headerlink" title="1、最小原型设计"></a>1、最小原型设计</h4><p>因为我们主要是讲解设计模式，所以，在今天的讲解中，我们只实现一个 DI 容器的最小原型。像 Spring 框架这样的 DI 容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">配置文件beans.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rateLimiter&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zb.RateLimiter&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;redisCounter&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;redisCounter&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zb.redisCounter&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span> <span class="hljs-attr">lazy-init</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;127.0.0.1&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">1234</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>&lt;/bean<br></code></pre></td></tr></table></figure><p>最小原型的使用方式跟 Spring 框架非常类似，示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<br>            <span class="hljs-string">&quot;beans.xml&quot;</span>);<br>    <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> (RateLimiter) applicationContext.getBean(<span class="hljs-string">&quot;rateLimiter&quot;</span>);<br>    rateLimiter.test();<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、提供执行入口"><a href="#2、提供执行入口" class="headerlink" title="2、提供执行入口"></a>2、提供执行入口</h4><p>面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类。通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext 和 ClassPathXmlApplicationContext。其中，ApplicationContext 是接口，ClassPathXmlApplicationContext 是接口的实现类。两个类具体实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApplicationContext</span> &#123;<br>  Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanId)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContext</span> &#123;<br>  <span class="hljs-keyword">private</span> BeansFactory beansFactory;<br>  <span class="hljs-keyword">private</span> BeanConfigParser beanConfigParser;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPathXmlApplicationContext</span><span class="hljs-params">(String configLocation)</span> &#123;<br>    <span class="hljs-built_in">this</span>.beansFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeansFactory</span>();<br>    <span class="hljs-built_in">this</span>.beanConfigParser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanConfigParser</span>();<br>    loadBeanDefinitions(configLocation);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(String configLocation)</span> &#123;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      in = <span class="hljs-built_in">this</span>.getClass().getResourceAsStream(<span class="hljs-string">&quot;/&quot;</span> + configLocation);<br>      <span class="hljs-keyword">if</span> (in == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Can not find config file: &quot;</span> + configLocation);<br>      &#125;<br>      List&lt;BeanDefinition&gt; beanDefinitions = beanConfigParser.parse(in);<br>      beansFactory.addBeanDefinitions(beanDefinitions);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">if</span> (in != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          in.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> log error</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanId)</span> &#123;<br>    <span class="hljs-keyword">return</span> beansFactory.getBean(beanId);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的代码中，我们可以看出，ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程：从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后，BeansFactory 根据 BeanDefinition 来创建对象。</p><h4 id="3、配置文件解析"><a href="#3、配置文件解析" class="headerlink" title="3、配置文件解析"></a>3、配置文件解析</h4><p>配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。配置文件的解析比较繁琐，不涉及我们要讲的理论知识，不是我们讲解的重点，所以这里我只给出两个类的大致设计思路，并未给出具体的实现代码。具体的代码框架如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanConfigParser</span> &#123;<br>  List&lt;BeanDefinition&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(InputStream inputStream)</span>;<br>  List&lt;BeanDefinition&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(String configContent)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlBeanConfigParser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanConfigParser</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> List&lt;BeanDefinition&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(InputStream inputStream)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>...</span><br>    <span class="hljs-keyword">return</span> parse(content);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> List&lt;BeanDefinition&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(String configContent)</span> &#123;<br>    List&lt;BeanDefinition&gt; beanDefinitions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>...</span><br>    <span class="hljs-keyword">return</span> beanDefinitions;<br>  &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanDefinition</span> &#123;<br>  <span class="hljs-keyword">private</span> String id;<br>  <span class="hljs-keyword">private</span> String className;<br>  <span class="hljs-keyword">private</span> List&lt;ConstructorArg&gt; constructorArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">Scope</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> Scope.SINGLETON;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">lazyInit</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// 省略必要的getter/setter/constructors</span><br> <br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> scope.equals(Scope.SINGLETON);<br>  &#125;<br><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Scope</span> &#123;<br>    SINGLETON,<br>    PROTOTYPE<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstructorArg</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isRef;<br>    <span class="hljs-keyword">private</span> Class type;<br>    <span class="hljs-keyword">private</span> Object arg;<br>    <span class="hljs-comment">// 省略必要的getter/setter/constructors</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、核心工厂类设计"><a href="#4、核心工厂类设计" class="headerlink" title="4、核心工厂类设计"></a>4、核心工厂类设计</h4><ol><li>最后，我们来看，BeansFactory 是如何设计和实现的。这也是我们这个 DI 容器最核心的一个类了。它负责根据从配置文件解析得到的 BeanDefinition 来创建对象。</li><li>如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中，下次再请求此对象的时候，直接从 map 中取出返回，不需要重新创建。如果对象的 scope 属性是 prototype，那每次请求对象，BeansFactory 都会创建一个新的对象返回。</li><li>实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的==反射==语法：<code>一种动态加载类和创建对象的机制</code>。我们知道，JVM 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 帮我们自动完成了，我们需要利用 Java 提供的反射语法自己去编写代码。</li><li>搞清楚了反射的原理，BeansFactory 的代码就不难看懂了。具体代码实现如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeansFactory</span> &#123;<br>  <span class="hljs-keyword">private</span> ConcurrentHashMap&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBeanDefinitions</span><span class="hljs-params">(List&lt;BeanDefinition&gt; beanDefinitionList)</span> &#123;<br>    <span class="hljs-keyword">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;<br>      <span class="hljs-built_in">this</span>.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;<br>      <span class="hljs-keyword">if</span> (beanDefinition.isLazyInit() == <span class="hljs-literal">false</span> &amp;&amp; beanDefinition.isSingleton()) &#123;<br>        createBean(beanDefinition);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanId)</span> &#123;<br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> beanDefinitions.get(beanId);<br>    <span class="hljs-keyword">if</span> (beanDefinition == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchBeanDefinitionException</span>(<span class="hljs-string">&quot;Bean is not defined: &quot;</span> + beanId);<br>    &#125;<br>    <span class="hljs-keyword">return</span> createBean(beanDefinition);<br>  &#125;<br><br>  <span class="hljs-meta">@VisibleForTesting</span><br>  <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(BeanDefinition beanDefinition)</span> &#123;<br>    <span class="hljs-keyword">if</span> (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;<br>      <span class="hljs-keyword">return</span> singletonObjects.get(beanDefinition.getId());<br>    &#125;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">Class</span> <span class="hljs-variable">beanClass</span> <span class="hljs-operator">=</span> Class.forName(beanDefinition.getClassName());<br>      List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs();<br>      <span class="hljs-keyword">if</span> (args.isEmpty()) &#123;<br>        bean = beanClass.newInstance();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        Class[] argClasses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[args.size()];<br>        Object[] argObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[args.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.size(); ++i) &#123;<br>          BeanDefinition.<span class="hljs-type">ConstructorArg</span> <span class="hljs-variable">arg</span> <span class="hljs-operator">=</span> args.get(i);<br>          <span class="hljs-keyword">if</span> (!arg.getIsRef()) &#123;<br>            argClasses[i] = arg.getType();<br>            argObjects[i] = arg.getArg();<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">refBeanDefinition</span> <span class="hljs-operator">=</span> beanDefinitions.get(arg.getArg());<br>            <span class="hljs-keyword">if</span> (refBeanDefinition == <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchBeanDefinitionException</span>(<span class="hljs-string">&quot;Bean is not defined: &quot;</span> + arg.getArg());<br>            &#125;<br>            argClasses[i] = Class.forName(refBeanDefinition.getClassName());<br>            argObjects[i] = createBean(refBeanDefinition);<br>          &#125;<br>        &#125;<br>        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | IllegalAccessException<br>            | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationFailureException</span>(<span class="hljs-string">&quot;&quot;</span>, e);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span> &amp;&amp; beanDefinition.isSingleton()) &#123;<br>      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);<br>      <span class="hljs-keyword">return</span> singletonObjects.get(beanDefinition.getId());<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>执行入口那里调用<code>addBeanDefinitions</code></li><li>然后<code>addBeanDefinitions</code>再调用createBean利用反射创建对象，如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中</li><li>最后最小原型设计那里再调用getBean从singletonObjects 获取对象。</li></ol><h2 id="二、建造者模式【常用】"><a href="#二、建造者模式【常用】" class="headerlink" title="二、建造者模式【常用】"></a>二、建造者模式【常用】</h2><p>建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。比如，有没有考虑过这样几个问题：直接使用构造函数或者配合 set 方法就能创建对象，为什么还需要建造者模式来创建呢？建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？</p><p>基本介绍： 建造者模式（Builder Pattern） 又叫生成器模式，是一种对象构建模式。它可以 将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方 法可以构造出不同表现（属性）的对象。建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象 的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p><h3 id="1、为何需要建造者模式？"><a href="#1、为何需要建造者模式？" class="headerlink" title="1、为何需要建造者模式？"></a>1、为何需要建造者模式？</h3><ol><li>在平时的开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。但是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？</li><li>假设有这样一道设计面试题：我们需要定义一个资源池配置类 ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个 ResourcePoolConfig 类。</li></ol><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923155455175.png"></p><p>只要稍微有点开发经验，那实现这样一个类并不是件难事。最常见、最容易想到的实现思路如下代码所示。因为 maxTotal、maxIdle、minIdle 不是必填变量，所以在创建 ResourcePoolConfig 对象的时候，我们通过往构造函数中，给这几个参数传递 null 值，来表示使用默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourcePoolConfig</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_TOTAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MIN_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxTotal</span> <span class="hljs-operator">=</span> DEFAULT_MAX_TOTAL;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxIdle</span> <span class="hljs-operator">=</span> DEFAULT_MAX_IDLE;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">minIdle</span> <span class="hljs-operator">=</span> DEFAULT_MIN_IDLE;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourcePoolConfig</span><span class="hljs-params">(String name, Integer maxTotal, Integer maxIdle, Integer minIdle)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;name should not be empty.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.name = name;<br><br>    <span class="hljs-keyword">if</span> (maxTotal != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (maxTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxTotal should be positive.&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.maxTotal = maxTotal;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (maxIdle != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (maxIdle &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxIdle should not be negative.&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.maxIdle = maxIdle;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (minIdle != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (minIdle &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;minIdle should not be negative.&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.minIdle = minIdle;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//...省略getter方法...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在，ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 bug。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 参数太多，导致可读性差、参数可能传递错误</span><br><span class="hljs-type">ResourcePoolConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcePoolConfig</span>(<span class="hljs-string">&quot;dbconnectionpool&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">8</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span> , <span class="hljs-literal">true</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>，<span class="hljs-literal">false</span>， <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>解决这个问题的办法应该也已经想到了，那就是用 set() 函数来给成员变量赋值，以替代冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项 name 是必填的，所以我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 maxTotal、maxIdle、minIdle 都不是必填的，所以我们通过 set() 函数来设置，让使用者自主选择填写或者不填写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourcePoolConfig</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_TOTAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MIN_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxTotal</span> <span class="hljs-operator">=</span> DEFAULT_MAX_TOTAL;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxIdle</span> <span class="hljs-operator">=</span> DEFAULT_MAX_IDLE;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">minIdle</span> <span class="hljs-operator">=</span> DEFAULT_MIN_IDLE;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourcePoolConfig</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;name should not be empty.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMaxTotal</span><span class="hljs-params">(<span class="hljs-type">int</span> maxTotal)</span> &#123;<br>    <span class="hljs-keyword">if</span> (maxTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxTotal should be positive.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.maxTotal = maxTotal;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMaxIdle</span><span class="hljs-params">(<span class="hljs-type">int</span> maxIdle)</span> &#123;<br>    <span class="hljs-keyword">if</span> (maxIdle &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;maxIdle should not be negative.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.maxIdle = maxIdle;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMinIdle</span><span class="hljs-params">(<span class="hljs-type">int</span> minIdle)</span> &#123;<br>    <span class="hljs-keyword">if</span> (minIdle &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;minIdle should not be negative.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.minIdle = minIdle;<br>  &#125;<br>  <span class="hljs-comment">//...省略getter方法...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们来看新的 ResourcePoolConfig 类该如何使用。我写了一个示例代码，如下所示。没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ResourcePoolConfig使用举例</span><br><span class="hljs-type">ResourcePoolConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcePoolConfig</span>(<span class="hljs-string">&quot;dbconnectionpool&quot;</span>);<br>config.setMaxTotal(<span class="hljs-number">16</span>);<br>config.setMaxIdle(<span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><p>至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过 set() 方法设置可选配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。</p><ul><li>我们刚刚讲到，name 是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。</li><li>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。</li><li>如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。</li></ul><p>为了解决这些问题，建造者模式就派上用场了。我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了。我们用建造者模式重新实现了上面的需求，具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourcePoolConfig</span> &#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxTotal;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxIdle;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> minIdle;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">ResourcePoolConfig</span><span class="hljs-params">(Builder builder)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = builder.name;<br>    <span class="hljs-built_in">this</span>.maxTotal = builder.maxTotal;<br>    <span class="hljs-built_in">this</span>.maxIdle = builder.maxIdle;<br>    <span class="hljs-built_in">this</span>.minIdle = builder.minIdle;<br>  &#125;<br>  <span class="hljs-comment">//...省略getter方法...</span><br><br>  <span class="hljs-comment">//我们将Builder类设计成了ResourcePoolConfig的内部类。</span><br>  <span class="hljs-comment">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_TOTAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MIN_IDLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxTotal</span> <span class="hljs-operator">=</span> DEFAULT_MAX_TOTAL;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxIdle</span> <span class="hljs-operator">=</span> DEFAULT_MAX_IDLE;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">minIdle</span> <span class="hljs-operator">=</span> DEFAULT_MIN_IDLE;<br><br>    <span class="hljs-keyword">public</span> ResourcePoolConfig <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span><br>      <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (maxIdle &gt; maxTotal) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcePoolConfig</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>      <span class="hljs-keyword">if</span> (StringUtils.isBlank(name)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.name = name;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setMaxTotal</span><span class="hljs-params">(<span class="hljs-type">int</span> maxTotal)</span> &#123;<br>      <span class="hljs-keyword">if</span> (maxTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.maxTotal = maxTotal;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setMaxIdle</span><span class="hljs-params">(<span class="hljs-type">int</span> maxIdle)</span> &#123;<br>      <span class="hljs-keyword">if</span> (maxIdle &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.maxIdle = maxIdle;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setMinIdle</span><span class="hljs-params">(<span class="hljs-type">int</span> minIdle)</span> &#123;<br>      <span class="hljs-keyword">if</span> (minIdle &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.minIdle = minIdle;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span><br><span class="hljs-type">ResourcePoolConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcePoolConfig</span>.Builder()<br>        .setName(<span class="hljs-string">&quot;dbconnectionpool&quot;</span>)<br>        .setMaxTotal(<span class="hljs-number">16</span>)<br>        .setMaxIdle(<span class="hljs-number">10</span>)<br>        .setMinIdle(<span class="hljs-number">12</span>)<br>        .build();<br></code></pre></td></tr></table></figure><p>实际上，使用建造者模式创建对象，还可以避免对象存在无效状态。无效状态是指对象没有实例化完全，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Rectangle</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectange</span>(); <span class="hljs-comment">// r is invalid</span><br>r.setWidth(<span class="hljs-number">2</span>); <span class="hljs-comment">// r is invalid</span><br>r.setHeight(<span class="hljs-number">3</span>); <span class="hljs-comment">// r is valid</span><br></code></pre></td></tr></table></figure><ol><li>为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。==(建造者主要解决参数过多、参数检验、控制对象创建后不可变的问题)==</li><li>实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露 set() 方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍。</li></ol><h3 id="2、与工厂模式有何区别？"><a href="#2、与工厂模式有何区别？" class="headerlink" title="2、与工厂模式有何区别？"></a>2、与工厂模式有何区别？</h3><ol><li>从上面的讲解中，我们可以看出，建造者模式是让建造者类来负责对象的创建工作。上面讲到的工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？</li><li>实际上，工厂模式是用来<code>创建不同但是相关类型的对象</code>（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建<code>一种类型的复杂对象</code>，通过设置不同的可选参数，“定制化”地创建不同的对象。</li></ol><p>网上有一个经典的例子很好地解释了两者的区别:</p><blockquote><p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p></blockquote><h2 id="三、原型模式【不常用】"><a href="#三、原型模式【不常用】" class="headerlink" title="三、原型模式【不常用】"></a>三、原型模式【不常用】</h2><p>现有如下需求：现在有一只羊tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和tom 羊 属性完全相同的10只羊。</p><p>思路：Java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以 将一个Java对象复制一份，但是需要实现clone的Java类必须要实现一个接口Cloneable， 该接口表示该类能够复制且具有复制的能力 =&gt; 原型模式</p><h3 id="1、原型模式原理与应用"><a href="#1、原型模式原理与应用" class="headerlink" title="1、原型模式原理与应用"></a>1、原型模式原理与应用</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。</p><ol><li>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。</li><li>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</li></ol><blockquote><p>举个例子</p></blockquote><ol><li>假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建立一个散列表索引。</li><li>如果你熟悉的是 Java 语言，可以直接使用语言中提供的 HashMap 容器来实现。其中，HashMap 的 key 为搜索关键词，value 为关键词详细信息（比如搜索次数）。我们只需要将数据从数据库中读取出来，放入 HashMap 就可以了。</li><li>不过，我们还有另外一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对 v2 版本的数据进行更新，得到 v3 版本的数据。这里我们假设只有更新和新添关键词，没有删除关键词的行为。</li></ol><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923164243728.png"></p><ol><li>为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统 A 需要定期根据数据库中的数据，更新内存中的索引和数据。</li><li>我们该如何实现这个需求呢？实际上，也不难。我们只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta，从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是找出 Va 版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散列表中。</li><li>按照这个设计思路，我给出的示例代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">private</span> ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastUpdateTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到currentKeywords中</span><br>    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">maxNewUpdatedTime</span> <span class="hljs-operator">=</span> lastUpdateTime;<br>    <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>      <span class="hljs-keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;<br>        maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>      &#125;<br>      <span class="hljs-keyword">if</span> (currentKeywords.containsKey(searchWord.getKeyword())) &#123;<br>        currentKeywords.replace(searchWord.getKeyword(), searchWord);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        currentKeywords.put(searchWord.getKeyword(), searchWord);<br>      &#125;<br>    &#125;<br><br>    lastUpdateTime = maxNewUpdatedTime;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">(<span class="hljs-type">long</span> lastUpdateTime)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，现在，我们有一个特殊的要求：任何时刻，系统 A 中的所有数据都必须是同一个版本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。那刚刚的更新方式就不能满足这个要求了（因为数据很多，一个一个的for循环肯定会出现不同数据版本的问题）。除此之外，我们还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据。</p><ol><li>那我们该如何实现现在这个需求呢？</li><li>实际上，也不难。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在。</li><li>按照这个设计思路，示例代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>    HashMap&lt;String, SearchWord&gt; newKeywords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 从数据库中取出所有的数据，放入到newKeywords中</span><br>    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords();<br>    <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>      newKeywords.put(searchWord.getKeyword(), searchWord);<br>    &#125;<br><br>    currentKeywords = newKeywords;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出所有的数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>不过，在上面的代码实现中，newKeywords 构建的成本比较高。我们需要将这 10 万条数据从数据库中读出，然后计算哈希值，构建 newKeywords。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了。</li><li>我们拷贝 currentKeywords 数据到 newKeywords 中，然后从数据库中只捞出新增或者有更新的关键词，更新到 newKeywords 中。而相对于 10 万条数据来说，每次新增或者更新的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。</li><li>按照这个设计思路，我给出的示例代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastUpdateTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 原型模式就这么简单，拷贝已有对象的数据，更新少量差值</span><br>    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();<br><br>    <span class="hljs-comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br>    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">maxNewUpdatedTime</span> <span class="hljs-operator">=</span> lastUpdateTime;<br>    <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>      <span class="hljs-keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;<br>        maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>      &#125;<br>      <span class="hljs-keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;<br>        <span class="hljs-type">SearchWord</span> <span class="hljs-variable">oldSearchWord</span> <span class="hljs-operator">=</span> newKeywords.get(searchWord.getKeyword());<br>        oldSearchWord.setCount(searchWord.getCount());<br>        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        newKeywords.put(searchWord.getKeyword(), searchWord);<br>      &#125;<br>    &#125;<br><br>    lastUpdateTime = maxNewUpdatedTime;<br>    currentKeywords = newKeywords;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">(<span class="hljs-type">long</span> lastUpdateTime)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>这里利用了 Java 中的 clone() 语法来复制一个对象。如果你熟悉的语言没有这个语法，那把数据从 currentKeywords 中一个个取出来，然后再重新计算哈希值，放入到 newKeywords 中也是可以接受的。毕竟，最耗时的还是从数据库中取数据的操作。相对于数据库的 IO 操作来说，内存操作和 CPU 计算的耗时都是可以忽略的。</li><li>不过，不知道你有没有发现，实际上，刚刚的代码实现是有问题的。要弄明白到底有什么问题，我们需要先了解另外两个概念：深拷贝（Deep Copy）和浅拷贝（Shallow Copy）。</li></ol><h3 id="2、原型模式的实现方式：深拷贝与浅拷贝"><a href="#2、原型模式的实现方式：深拷贝与浅拷贝" class="headerlink" title="2、原型模式的实现方式：深拷贝与浅拷贝"></a>2、原型模式的实现方式：深拷贝与浅拷贝</h3><blockquote><p>拷贝的引入</p></blockquote><p>1、引用拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;Taylor&quot;</span>,<span class="hljs-number">26</span>);<br><span class="hljs-type">Teacher</span> <span class="hljs-variable">otherteacher</span> <span class="hljs-operator">=</span> teacher;<br>System.out.println(teacher);<br>System.out.println(otherteacher);<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">blog.Teacher@355da254<br>blog.Teacher@355da254<br></code></pre></td></tr></table></figure><p>由输出结果可以看出，二者的地址值是相同的，那么肯定就是同一个对象，teacher和otherteacher只是不同的引用而已。</p><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923165539504.png" alt="引用拷贝"></p><p>2、对象拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;Swift&quot;</span>,<span class="hljs-number">26</span>);<br><span class="hljs-type">Teacher</span> <span class="hljs-variable">otherteacher</span> <span class="hljs-operator">=</span> (Teacher)teacher.clone();<br>System.out.println(teacher);<br>System.out.println(otherteacher);<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">blog.Teacher@355da254<br>blog.Teacher@4dc63996<br></code></pre></td></tr></table></figure><p>由结果可以看出，地址值不同，也就是说二者是不同的对象，而不是把原对象的地址赋给了一个新的引用变量,这就叫做对象拷贝。</p><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923165730368.png" alt="对象拷贝"></p><p>==注：深拷贝和浅拷贝都是对象拷贝==</p><blockquote><p>浅拷贝</p></blockquote><ul><li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值拷贝，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据</li><li>对于数据类型是引用数据类型的成员变量(也就是子对象，或者数组啥的)，也就是只是将该成员变量的引用值（引用拷贝【并发引用传递，Java本质还是值传递】）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</li></ul><blockquote><p>深拷贝</p></blockquote><ul><li>对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li><li>也就是说浅拷贝对于子对象只是拷贝了引用值，并没有真正的拷贝整个对象。</li></ul><p>在内存中，用散列表组织的搜索关键词信息是如何存储的。从下图中我们可以发现，散列表索引中，每个结点存储的 key 是搜索关键词，value 是 SearchWord 对象的内存地址。SearchWord 对象本身存储在散列表之外的内存空间中。</p><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923171124069.png"></p><p>浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：</p><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923171203280.png" alt="浅拷贝"></p><p><img src="/2022/09/22/02-chuang-jian-xing-gong-han-jian-zao-zhe-yuan-xing/image-20220923171227022.png" alt="深拷贝"></p><ol><li>在 Java 语言中，Object 类的 clone() 方法执行的就是浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。</li><li>在上面的代码中，我们通过调用 HashMap 上的 clone() 浅拷贝方法来实现原型模式。当我们通过 newKeywords 更新 SearchWord 对象的时候（比如，更新“设计模式”这个搜索关键词的访问次数），newKeywords 和 currentKeywords 因为指向相同的一组 SearchWord 对象，就会导致 currentKeywords 中指向的 SearchWord，有的是老版本的，有的是新版本的，就没法满足我们之前的需求：currentKeywords 中的数据在任何时刻都是同一个版本的，不存在介于老版本与新版本之间的中间状态。</li></ol><p>我们可以将浅拷贝替换为深拷贝。newKeywords 不仅仅复制 currentKeywords 的索引，还把 SearchWord 对象也复制一份出来，这样 newKeywords 和 currentKeywords 就指向不同的 SearchWord 对象，也就不存在更新 newKeywords 的数据会导致 currentKeywords 的数据也被更新的问题了。</p><p>如何实现深拷贝，有如下两种方法：</p><p>第一种方法：<code>递归拷贝对象、对象的引用对象以及引用对象的引用对象</code>……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。重构之后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastUpdateTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Deep copy</span><br>    HashMap&lt;String, SearchWord&gt; newKeywords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;<br>      <span class="hljs-type">SearchWord</span> <span class="hljs-variable">searchWord</span> <span class="hljs-operator">=</span> e.getValue();<br>      <span class="hljs-type">SearchWord</span> <span class="hljs-variable">newSearchWord</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchWord</span>(<br>              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());<br>      newKeywords.put(e.getKey(), newSearchWord);<br>    &#125;<br><br>    <span class="hljs-comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br>    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">maxNewUpdatedTime</span> <span class="hljs-operator">=</span> lastUpdateTime;<br>    <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>      <span class="hljs-keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;<br>        maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>      &#125;<br>      <span class="hljs-keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;<br>        <span class="hljs-type">SearchWord</span> <span class="hljs-variable">oldSearchWord</span> <span class="hljs-operator">=</span> newKeywords.get(searchWord.getKeyword());<br>        oldSearchWord.setCount(searchWord.getCount());<br>        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        newKeywords.put(searchWord.getKeyword(), searchWord);<br>      &#125;<br>    &#125;<br><br>    lastUpdateTime = maxNewUpdatedTime;<br>    currentKeywords = newKeywords;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">(<span class="hljs-type">long</span> lastUpdateTime)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>第二种方法：<code>先将对象序列化，然后再反序列化成新的对象</code>。具体的示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deepCopy</span><span class="hljs-params">(Object object)</span> &#123;<br>  <span class="hljs-comment">// 序列化</span><br>  <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>  <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bo);<br>  oo.writeObject(object);<br>  <br>  <span class="hljs-comment">// 反序列化</span><br>  <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bo.toByteArray());<br>  <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">oi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bi);<br>  <br>  <span class="hljs-keyword">return</span> oi.readObject();<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对这个应用场景，有没有更快、更省内存的实现方式呢？</li><li>可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题中讲到的，在这个应用场景下，最快速 clone 散列表的方式。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastUpdateTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Shallow copy</span><br>    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();<br><br>    <span class="hljs-comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span><br>    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">maxNewUpdatedTime</span> <span class="hljs-operator">=</span> lastUpdateTime;<br>    <span class="hljs-keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;<br>      <span class="hljs-keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;<br>        maxNewUpdatedTime = searchWord.getLastUpdateTime();<br>      &#125;<br>      <span class="hljs-keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;<br>        newKeywords.remove(searchWord.getKeyword());<br>      &#125;<br>      newKeywords.put(searchWord.getKeyword(), searchWord);<br>    &#125;<br><br>    lastUpdateTime = maxNewUpdatedTime;<br>    currentKeywords = newKeywords;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> List&lt;SearchWord&gt; <span class="hljs-title function_">getSearchWords</span><span class="hljs-params">(<span class="hljs-type">long</span> lastUpdateTime)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>尊重原创，原著文章链接： <a href="https://imlql.cn/post/ba432704.html">https://imlql.cn/post/ba432704.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 工厂 </tag>
            
            <tag> 建造者 </tag>
            
            <tag> 原型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-创建型-单例</title>
      <link href="/2022/09/21/01-chuang-jian-xing-dan-li/"/>
      <url>/2022/09/21/01-chuang-jian-xing-dan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="一、单例设计模式介绍"><a href="#一、单例设计模式介绍" class="headerlink" title="一、单例设计模式介绍"></a>一、单例设计模式介绍</h2><p>单例设计模式，就是采用一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。</p><p>为什么要使用单例？单例解决哪类问题？</p><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。</p><p>再比如，唯一递增 ID 号码生成器。如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以，我们应该将 ID 生成器类设计为单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>  <span class="hljs-comment">// AtomicLong是一个Java并发库中提供的一个原子变量类型,</span><br>  <span class="hljs-comment">// 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，</span><br>  <span class="hljs-comment">// 比如下面会用到的incrementAndGet().</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IdGenerator</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-keyword">return</span> id.incrementAndGet();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// IdGenerator使用举例</span><br><span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> IdGenerator.getInstance().getId();<br></code></pre></td></tr></table></figure><h2 id="二、实现单例"><a href="#二、实现单例" class="headerlink" title="二、实现单例"></a>二、实现单例</h2><p>实现单例的八种方式</p><h3 id="1、饿汉式（静态变量）"><a href="#1、饿汉式（静态变量）" class="headerlink" title="1、饿汉式（静态变量）"></a>1、<code>饿汉式（静态变量）</code></h3><p>饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到 IdGenerator 的时候，再创建实例），从名字中我们也可以看出这一点。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123; <br>  <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IdGenerator</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-keyword">return</span> id.incrementAndGet();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优缺点说明：</p><ol><li>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</li><li>缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费</li><li>这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法， 但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果</li><li>结论：这种单例模式可用，可能造成内存浪费</li></ol><h3 id="2、饿汉式（静态代码块）"><a href="#2、饿汉式（静态代码块）" class="headerlink" title="2、饿汉式（静态代码块）"></a>2、<code>饿汉式（静态代码块）</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br><span class="hljs-keyword">static</span> &#123;<br>    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>优缺点说明：</p><ol><li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</li><li>结论：这种单例模式可用，但是可能造成内存浪费</li></ol><h3 id="3、懒汉式（线程不安全）"><a href="#3、懒汉式（线程不安全）" class="headerlink" title="3、懒汉式（线程不安全）"></a>3、懒汉式（线程不安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123; <br>  <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IdGenerator instance;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>      instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-keyword">return</span> id.incrementAndGet();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优缺点说明：</p><ol><li>起到了 <strong>Lazy Loading</strong> 的效果，但是只能在单线程下使用。</li><li>如果在多线程下，一个线程进入了 **if (singleton == null)**判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式</li><li>结论：在实际开发中，不要使用这种方式.</li></ol><h3 id="4、懒汉式（线程安全，同步方法）"><a href="#4、懒汉式（线程安全，同步方法）" class="headerlink" title="4、懒汉式（线程安全，同步方法）"></a>4、懒汉式（线程安全，同步方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>)&#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优缺点说明：</p><ol><li>解决了线程安全问题</li><li>效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低</li><li>结论：在实际开发中，不推荐使用这种方式</li></ol><h3 id="5、懒汉式（线程安全，同步代码块）"><a href="#5、懒汉式（线程安全，同步代码块）" class="headerlink" title="5、懒汉式（线程安全，同步代码块）"></a>5、懒汉式（线程安全，同步代码块）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 懒汉式(线程安全，同步代码块)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、-双重检查"><a href="#6、-双重检查" class="headerlink" title="6、==双重检查=="></a>6、==双重检查==</h3><p>饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123; <br>  <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IdGenerator instance;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">synchronized</span>(IdGenerator.class) &#123; <span class="hljs-comment">// 此处为类级别的锁</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>          instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-keyword">return</span> id.incrementAndGet();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。</p><h3 id="7、-静态内部类"><a href="#7、-静态内部类" class="headerlink" title="7、==静态内部类=="></a>7、==静态内部类==</h3><p>我们再来看一种比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类。它有点类似饿汉式，但又能做到了延迟加载。具体是怎么做到的呢？我们先来看它的代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> &#123; <br>  <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">IdGenerator</span><span class="hljs-params">()</span> &#123;&#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IdGenerator</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdGenerator</span>();<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> SingletonHolder.instance;<br>  &#125;<br> <br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-keyword">return</span> id.incrementAndGet();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p><h3 id="8、-枚举"><a href="#8、-枚举" class="headerlink" title="8、==枚举=="></a>8、==枚举==</h3><p>最后，我们介绍一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。具体的代码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">IdGenerator</span> &#123;<br>  INSTANCE;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br> <br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-keyword">return</span> id.incrementAndGet();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上，可以使用：两个饿汉式；推荐使用：双重检查、静态内部类、枚举</p><h2 id="三、单例模式注意事项"><a href="#三、单例模式注意事项" class="headerlink" title="三、单例模式注意事项"></a>三、单例模式注意事项</h2><ol><li>单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</li><li>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new</li><li>单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、<em><strong>session</strong></em> 工厂等)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式概述</title>
      <link href="/2022/09/21/she-ji-mo-shi-gai-shu/"/>
      <url>/2022/09/21/she-ji-mo-shi-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、设计模式定义"><a href="#一、设计模式定义" class="headerlink" title="一、设计模式定义"></a>一、设计模式定义</h2><p>设计模式是在特定环境下为解决某一通用软件设计问题提供的一套定制的解决方案，该方案描述了对象和类之间的相互作用。</p><p>设计模式一般包含模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式，关键元素为：模式名称、问题、解决方案、效果。</p><h2 id="二、设计模式的分类"><a href="#二、设计模式的分类" class="headerlink" title="二、设计模式的分类"></a>二、设计模式的分类</h2><p>根据目的分类，可分为：</p><ol><li>创建型</li><li>结构型</li><li>行为型</li></ol><p>根据范围分类，可分为：</p><ol><li>类模式</li><li>对象模式</li></ol><h2 id="三、GoF设计模式简介"><a href="#三、GoF设计模式简介" class="headerlink" title="三、GoF设计模式简介"></a>三、GoF设计模式简介</h2><p>在GoF的经典著作中一共描述了23种设计模式。</p><p>按目的分类：</p><blockquote><p>创建型模式</p></blockquote><p>1、工厂模式</p><p>工厂模式（Factory Pattern）是Java中最常用的设计模式之一。</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p>2、抽象工厂模式</p><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p>3、单例模式</p><p>单例模式（Singleton Pattern）是Java中最简单的设计模式之一。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>4、建造者（构建者）模式</p><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。</p><p>一个Builder类会一步一步构造最终的对象。该Builder类是独立于其他对象的。</p><p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p>5、原型模式</p><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。</p><p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><blockquote><p>结构型模式</p></blockquote><p>6、适配器模式</p><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。</p><p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。</p><p>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p>7、装饰器模式</p><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><p>8、代理模式</p><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。</p><p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p><p>为其他对象提供一种代理以控制对这个对象的访问。</p><p>9、外观模式</p><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。</p><p>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p><p>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p>10、桥接模式</p><p>桥接模式（Bridge Pattern）是用于把抽象化与实现化解耦，使得二者可以独立变化。它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p><p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p><p>将抽象部分与实现部分分离，使它们都可以独立的变化。</p><p>又称为柄体（Handle and Body）模式或接口（Interface）模式。</p><p>11、组合模式</p><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了<strong>对象组的树形结构</strong>。</p><p>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p><p>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><p>12、享元模式</p><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p><p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。</p><p>运用共享技术有效地支持大量细粒度的对象。</p><blockquote><p>行为型模式</p></blockquote><p>13、策略模式</p><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的context对象。策略对象改变context对象的执行算法。</p><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。</p><p>14、模板模式</p><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>15、观察者模式</p><p>当对象间存在一对多关系时，则使用观察者模式（ObserverPattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。</p><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>16、迭代器模式</p><p>迭代器模式（Iterator Pattern）是Java和.Net编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p><p>迭代器模式属于行为型模式。</p><p>提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。</p><p>17、责任链模式</p><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。</p><p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p><p>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><p>18、命令模式</p><p>命令模式（Command Pattern）是一种数据驱动的设计模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p><p>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p><p>19、备忘录模式</p><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。</p><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p><p>20、状态模式</p><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。</p><p>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的context对象。</p><p>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p><p>21、访问者模式</p><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p><p>主要将数据结构与数据操作分离。</p><p>主要解决：稳定的数据结构和易变的操作耦合问题。</p><p>22、中介者模式</p><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。</p><p>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>23、解释器模式</p><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在SQL解析、符号处理引擎等。</p><p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p><h2 id="四、面向对象设计原则"><a href="#四、面向对象设计原则" class="headerlink" title="四、面向对象设计原则"></a>四、面向对象设计原则</h2><h3 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h3><p>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。</p><h3 id="2、里氏替换原则"><a href="#2、里氏替换原则" class="headerlink" title="2、里氏替换原则"></a>2、里氏替换原则</h3><p>所有引用基类的地方必须能透明地使用其子类的对象。</p><h3 id="3、依赖倒置原则"><a href="#3、依赖倒置原则" class="headerlink" title="3、依赖倒置原则"></a>3、依赖倒置原则</h3><ol><li>上层模块不应该依赖底层模块，它们都应该依赖于抽象。</li><li>抽象不应该依赖于细节，细节应该依赖于抽象。</li></ol><h3 id="4、接口隔离原则"><a href="#4、接口隔离原则" class="headerlink" title="4、接口隔离原则"></a>4、接口隔离原则</h3><p>每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</p><h3 id="5、迪米特法则（最少知道原则）"><a href="#5、迪米特法则（最少知道原则）" class="headerlink" title="5、迪米特法则（最少知道原则）"></a>5、迪米特法则（最少知道原则）</h3><p>一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p><h3 id="6、合成复用原则"><a href="#6、合成复用原则" class="headerlink" title="6、合成复用原则"></a>6、合成复用原则</h3><p>尽量使用对象组合/聚合，而不是继承关系达到软件复用的目的。</p><h3 id="7、开闭原则"><a href="#7、开闭原则" class="headerlink" title="7、开闭原则"></a>7、开闭原则</h3><p>软件实体应该对扩展开放，对修改关闭</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2022/09/21/lian-biao/"/>
      <url>/2022/09/21/lian-biao/</url>
      
        <content type="html"><![CDATA[<h1>一、理论</h1><h2 id="1、链表类型">1、链表类型</h2><h3 id="1、单链表">1、单链表</h3><p><img src="/2022/09/21/lian-biao/image-20221011101058417.png" alt></p><h3 id="2、双链表">2、双链表</h3><p><img src="/2022/09/21/lian-biao/image-20221011101124093.png" alt></p><h3 id="3、循环链表">3、循环链表</h3><p>循环链表可以用来解决<code>约瑟夫环</code>问题</p><p><img src="/2022/09/21/lian-biao/image-20221011101149273.png" alt></p><h2 id="2、链表存储方式">2、链表存储方式</h2><p>数组在内存中是连续分布的，但链表在内存中不是连续分布的。</p><p>链表是通过指针域的指针来连接各个节点。所以链表的分配机制取决于操作系统的内存管理。</p><h2 id="3、链表的定义">3、链表的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-comment">// 结点的值</span><br>    <span class="hljs-type">int</span> val;<br><br>    <span class="hljs-comment">// 下一个结点</span><br>    ListNode next;<br><br>    <span class="hljs-comment">// 节点的构造函数(无参)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 节点的构造函数(有一个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br><br>    <span class="hljs-comment">// 节点的构造函数(有两个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val, ListNode next)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、链表的基本操作">4、链表的基本操作</h2><h3 id="1、删除节点">1、删除节点</h3><p><img src="/2022/09/21/lian-biao/image-20221011101632656.png" alt></p><p>删除D节点，直接将C节点的next节点指向E即可。java有自己的内存回收机制，不用自己手动释放。</p><h3 id="2、添加节点">2、添加节点</h3><p><img src="/2022/09/21/lian-biao/image-20221011101738080.png" alt></p><p>增加F节点，先将F节点的next指向D，再将C节点的next指向F。</p><p>但是有一点需要注意，在C后增加节点，首先得找到C节点，找节点的复杂度是O(n)</p><h2 id="5、链表与数组的性能对比">5、链表与数组的性能对比</h2><p><img src="/2022/09/21/lian-biao/image-20221011102001636.png" alt></p><h1>二、翻转链表</h1><h2 id="1、翻转整个链表">1、翻转整个链表</h2><p>先上<code>本次</code>的链表定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">public</span> Node next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、双指针法</p><p>只需要改变链表的next指向即可</p><p><img src="/2022/09/21/lian-biao/image-20220921114419429.png" alt></p><p>首先定义cur节点，指向head；再定义pre指向null。</p><p>pre节点是cur节点的前序节点</p><p>先将cur.next节点保存在temp里，再进行翻转。保存在temp是为了防止下一个节点丢失。</p><p>到最后cur为null时，pre为最后一个节点，此时返回pre即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reverse</span><span class="hljs-params">(Node head)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;   <span class="hljs-comment">// 以下注释以1 2为例</span><br>        temp = cur.next;   <span class="hljs-comment">// temp指向2</span><br>        cur.next = pre;    <span class="hljs-comment">// 1 和 2 之间已经断链， 1 已经指向了pre，也就是空</span><br><br>        pre = cur;     <span class="hljs-comment">//  同时向后移</span><br>        cur = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、递归法</p><p>递归法其实跟双指针法类似，每一步翻转都有三个过程：</p><ol><li>记录下一个节点</li><li>翻转</li><li>同时往后移</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//  其他代码</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> reverse(<span class="hljs-literal">null</span>, node1);    <span class="hljs-comment">// node1 为已定义好的链表的头结点</span><br>    <span class="hljs-keyword">while</span> (res != <span class="hljs-literal">null</span>) &#123;<br>        System.out.print(res.value + <span class="hljs-string">&quot; &quot;</span>);<br>        res = res.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reverse</span><span class="hljs-params">(Node pre, Node cur)</span> &#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.next;  <span class="hljs-comment">//记录下一个节点</span><br>    cur.next = pre;     <span class="hljs-comment">// 翻转</span><br><br>    <span class="hljs-keyword">return</span> reverse(cur, temp);   <span class="hljs-comment">//向后移</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、翻转部分链表">2、翻转部分链表</h2><p>给定一个链表的头结点，给定m和n，要求翻转m到n之间的链表</p><p>思路：使用头插法</p><ol><li>首先找到m节点的前一个节点，定义为pre，这个pre就相当于头插法的头结点的前序节点</li><li>用一个for循环，遍历从m到n，进行链表的头插</li><li>最后返回头结点即可</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseBetween</span> <span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        res.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            pre = cur;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m; i &lt; n; i++) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = temp.next;<br><br>            temp.next = pre.next;<br>            pre.next = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.next;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>之所以定义res节点，是为了方便操作头结点，即当m为1时不用对头结点进行特殊处理</p></blockquote><h1>三、环形链表</h1><p>环形链表一共有两个问题，第一个问题是验证一个链表是否有环，第二个问题是找到环形链表的入口。</p><p>先来看第一个问题</p><h2 id="1、验证链表是否有环">1、验证链表是否有环</h2><p>判断链表是否有环，可以使用快慢指针法，定义一个fast，以及一个slow，slow每走一步，fast就走两步，若是有环的话，那么最终一定会相遇。</p><p>为什么？</p><p>首先肯定是fast先进环，当slow进环时，slow走一步fast走两步，整体来看就是fast在追赶slow一步，那么只要有环，最终fast就一定会追上slow。</p><h2 id="2、若有环，如何找到入口？">2、若有环，如何找到入口？</h2><p>用公式来表示一下。</p><p>假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：</p><p><img src="/2022/09/21/lian-biao/image-20221013094802419.png" alt></p><p>那么在相遇时，slow走了（x + y），fast走了(x + y + n * (y + z))。fast有可能在环内走了n圈。根据步长，可以看出fast走的距离是slow的二倍，即：</p><p>2 * (x + y) = x + y + n * (y + z)</p><p>两边消去一个 x + y：</p><p>x + y = n * (y + z)</p><p>要找到入口，那就是要求x的距离，将x放在一边：</p><p>x = n * (y + z) - y</p><p>整理之后就是：</p><p>x = (n - 1) * (y + z) + z</p><p>假设n = 1时，n = 1意味着fast在环内走了一圈就碰见slow了，这时候计算入口时(x = z)，<code>只需要在他们相遇的节点处定义一个index1，在头结点处定义一个index2，令他们每次走一步，相遇即为入口节点</code>。</p><p>若是n &gt; 1时，fast指针在环形转n圈之后才遇到 slow指针。该问题也可简化为n = 1，其实本质上都一样，只不过index1在环内多转了几圈，然后碰到index2。</p><blockquote><p>有个疑问：那为什么在环中相遇时，slow走过的距离一定是x + y，而不是 x + 若干环的距离 + y 呢？</p></blockquote><p>因为当slow进环时，fast一定在环内，而fast和slow每走一次就相当于fast在靠近slow一步，所以当slow还没进入到下一次循环的时候，就会被fast追上。</p><h1>四、经典题目</h1><h2 id="1、合并k个已排序的链表">1、合并k个已排序的链表</h2><p>原题链接：<a href="https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6?tpId=295&amp;tqId=724&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj">BM5 合并k个已排序的链表</a></p><p>三种方法</p><h3 id="1、方法一：借用辅助空间">1、方法一：借用辅助空间</h3><p>思路：既然要合并k个链表，那么先定义一个list，将这些链表的值都存入进list，最后对list进行排序，然后一一取出并将其组成链表即可</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ArrayList&lt;ListNode&gt; lists)</span> &#123;<br>    <span class="hljs-comment">// 定义虚拟头结点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        ArrayList&lt;Integer&gt; array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> lists.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> lists.get(i);<br>            <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>                array.add(node.val);<br>                node = node.next;<br>            &#125;<br>        &#125;<br>        Collections.sort(array);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.size(); i++) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">ccc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(array.get(i));<br>            cur.next = ccc;<br>            cur = cur.next;<br>        &#125;<br>    <span class="hljs-comment">// 最后返回虚拟头结点的下一个节点</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br></code></pre></td></tr></table></figure><p>当然时间复杂度是比较高的，排序就需要O(n * log2n)</p><h3 id="2、方法二：优先队列">2、方法二：优先队列</h3><p>优先队列方法类似于双指针，都是从几个中选出最小的。优先队列是一种内置的基于堆排序的容器，分为大顶堆和小顶堆，小顶堆就是堆顶为最小的元素。本题采用小顶堆。</p><p>使用优先队列时，必须要手动<code>重载比较方法</code>。因为容器内部的次序基于堆排序，因此每次插入元素时间复杂度都是O(log2n)，而每次取出堆顶元素都是直接取出。</p><p>思路：</p><ol><li>遍历k个链表头，将不是空节点的节点放进优先队列</li><li>优先队列弹出最小值，并且若弹出的节点的下一个节点不为空，就将下一个节点放进优先队列</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ArrayList&lt;ListNode&gt; lists)</span> &#123;<br>        <span class="hljs-comment">//小顶堆</span><br>        Queue&lt;ListNode&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((v1, v2) -&gt; v1.val - v2.val);<br>        <span class="hljs-comment">//遍历所有链表第一个元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lists.size(); i++)&#123;<br>            <span class="hljs-comment">//不为空则加入小顶堆</span><br>            <span class="hljs-keyword">if</span>(lists.get(i) != <span class="hljs-literal">null</span>)<br>                pq.add(lists.get(i));<br>        &#125;<br>        <span class="hljs-comment">//加一个表头</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-comment">//直到小顶堆为空</span><br>        <span class="hljs-keyword">while</span>(!pq.isEmpty())&#123;<br>            <span class="hljs-comment">//取出最小的元素</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> pq.poll();<br>            <span class="hljs-comment">//连接</span><br>            head.next = temp;<br>            head = head.next;<br>            <span class="hljs-comment">//每次取出链表的后一个元素加入小顶堆</span><br>            <span class="hljs-keyword">if</span>(temp.next != <span class="hljs-literal">null</span>)<br>                pq.add(temp.next);<br>        &#125;<br>        <span class="hljs-comment">//去掉表头</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n * log 2 * k)，每次加入优先队列排序需要O(log2k)</p><h3 id="3、方法三：归并排序思想【推荐】">3、方法三：归并排序思想【推荐】</h3><p>首先需要明确两个概念。</p><p>1、双指针</p><p>双指针指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个指针（特殊情况甚至可以多个），两个指针或是同方向访问两个链表、或是同方向访问一个链表（快慢指针）、或是相反方向扫描（对撞指针），从而达到我们需要的目的。</p><p>2、分治</p><p>分治分治，分而治之。“分”指的是将一个大而复杂的问题划分成多个性质相同但是规模更小的子问题，子问题继续按照这样划分，直到问题可以被轻易解决；“治”指的是将子问题单独进行处理。经过分治后的子问题，需要将解进行合并才能得到原问题的解，因此整个分治过程经常用递归来实现。</p><p>其实这道题也可以两两比较，只要遍历链表数组，取出开头的两个链表，按照上述思路合并，然后新链表再与后一个继续合并，如此循环，知道全部合并完成。但是，太浪费时间。</p><p>可不可以直接归并的分治来做，而不是顺序遍历合并链表呢？可以！</p><p>归并排序简单来说就是将一个数组每次划分成等长的两部分，对两部分进行排序即是子问题。对子问题继续划分，直到子问题只有1个元素。还原的时候呢，将每个子问题和它相邻的另一个子问题利用上述双指针的方式，1个与1个合并成2个，2个与2个合并成4个，因为这每个单独的子问题合并好的都是有序的，直到合并成原本长度的数组。</p><p>对于这k个链表，就相当于上述合并阶段的k个子问题，需要划分为链表数量更少的子问题，直到每一组合并时是两两合并，然后继续往上合并，这个过程基于递归：</p><ul><li><strong>终止条件：</strong> 划分的时候直到左右区间相等或左边大于右边。</li><li><strong>返回值：</strong> 每级返回已经合并好的子问题链表。</li><li><strong>本级任务：</strong> 对半划分，将划分后的子问题合并成新的链表。</li></ul><p>简单画个图来帮助理解一下：</p><p><img src="/2022/09/21/lian-biao/image-20221027112036683.png" alt></p><p>若是有五个链表需要合并，分治就是右边的情况</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//两个链表合并函数</span><br>   <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">Merge</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>       <span class="hljs-comment">//一个已经为空了，直接返回另一个</span><br>       <span class="hljs-keyword">if</span>(list1 == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">return</span> list2;<br>       <span class="hljs-keyword">if</span>(list2 == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">return</span> list1;<br>       <span class="hljs-comment">//加一个表头</span><br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>       <span class="hljs-comment">//两个链表都要不为空</span><br>       <span class="hljs-keyword">while</span>(list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-comment">//取较小值的节点</span><br>           <span class="hljs-keyword">if</span>(list1.val &lt;= list2.val)&#123;<br>               cur.next = list1;<br>               <span class="hljs-comment">//只移动取值的指针</span><br>               list1 = list1.next;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               cur.next = list2;<br>               <span class="hljs-comment">//只移动取值的指针</span><br>               list2 = list2.next;<br>           &#125;<br>           <span class="hljs-comment">//指针后移</span><br>           cur = cur.next;<br>       &#125;<br>       <span class="hljs-comment">//哪个链表还有剩，直接连在后面</span><br>       <span class="hljs-keyword">if</span>(list1 != <span class="hljs-literal">null</span>)<br>           cur.next = list1;<br>       <span class="hljs-keyword">else</span><br>           cur.next = list2;<br>       <span class="hljs-comment">//返回值去掉表头</span><br>       <span class="hljs-keyword">return</span> dummy.next;<br>   &#125;<br>    <br>   <span class="hljs-comment">//划分合并区间函数</span><br>   ListNode <span class="hljs-title function_">divideMerge</span><span class="hljs-params">(ArrayList&lt;ListNode&gt; lists, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>       <span class="hljs-keyword">if</span>(left &gt; right)<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-comment">//中间一个的情况</span><br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == right)<br>           <span class="hljs-keyword">return</span> lists.get(left);<br>       <span class="hljs-comment">//从中间分成两段，再将合并好的两段合并</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>       <span class="hljs-keyword">return</span> Merge(divideMerge(lists, left, mid), divideMerge(lists, mid + <span class="hljs-number">1</span>, right));<br>   &#125;<br>    <br>   <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ArrayList&lt;ListNode&gt; lists)</span> &#123;<br>       <span class="hljs-comment">//k个链表归并排序</span><br>       <span class="hljs-keyword">return</span> divideMerge(lists, <span class="hljs-number">0</span>, lists.size() - <span class="hljs-number">1</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlog2k)</li><li>空间复杂度：O(log2k)</li></ul><p>上述代码中的Merge()方法，可以直接用来对两个有序链表进行合并。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见架构模式</title>
      <link href="/2022/09/20/chang-jian-jia-gou-mo-shi/"/>
      <url>/2022/09/20/chang-jian-jia-gou-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>扫盲！</p><p>几种常见的架构模式：<strong>Client-Server、Peer to Peer、MVC、Layered、Distribute-Cluster、Micro-Service、Even-Source、Hexagonal</strong></p><p>几种架构模式：</p><h3 id="1、Client-Server"><a href="#1、Client-Server" class="headerlink" title="1、Client-Server"></a>1、Client-Server</h3><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20220920190951638.png" alt="cs"></p><p>client-server 模式以请求-响应方式工作，客户端发送请求信息，服务端接受请求，作出相应处理，然后发回响应信息。所有我们访问的互联网网站都是这种架构。在桌面程序流行的时代，互联网还没有当前这么发达的时代。Client-Server 还只代表 Desktop Client-Server 模式，使用浏览器的方式称之为 B-S 模式，即 Browser-Server 模式。如今 Browser、Desktop Application、Mobile Application、Mobile Web 等统称为 Client。</p><h3 id="2、Peer-to-Peer"><a href="#2、Peer-to-Peer" class="headerlink" title="2、Peer to Peer"></a>2、Peer to Peer</h3><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20220920191053669.png" alt="p2p"></p><p>端对端服务模式（Peer to Peer，简称 P2P），亦称为“点对点模式”，是指通过互联网将个人与个人连接起来，绕开中心平台而直接提供服务、完成交易的模式。P2P 的早期含意是计算机通信领域中的“对等网络协议”，它打破了传统的 Client/Server(C/S)模式，使得成千上万台彼此连接的计算机都处于对等地位，网络的参与者直接共享他们所拥有的一部分硬件资源（包括处理能力、存储能力、网络连接能力、打印机等），这些共享资源通过互联网，能被其它对等节点(Peer)直接访问而无需经过统一的中间体。</p><p>P2P 模式流行于文件分享与下载、计算与存储、即时通信和协同共享等领域。</p><h3 id="3、MVC"><a href="#3、MVC" class="headerlink" title="3、MVC"></a>3、MVC</h3><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20220920191214418.png" alt="mvc"></p><p>Model-View-Controller，MVC 架构是面向对象编程的一大进步。服务将逻辑划分为三个不同的组建：Model——模型，即数据，通常存储在数据库中，在内存中进行逻辑操作。View——用户可见的组建，用于用户交互和数据展示，如 Web GUI。Controller——逻辑操作，连接 Model 和 View 的组件，操作 Model 逻辑和 View 交互展示逻辑。</p><h3 id="4、Layered"><a href="#4、Layered" class="headerlink" title="4、Layered"></a>4、Layered</h3><p>说起分层架构，最让人熟知的就是经典的三层架构。经典三层架构自顶向下由用户界面层（User Interface Layer）、业务逻辑层（Business Logic Layer）与数据访问层（Data Access Layer）组成。三层架构是简单 Client-Server 架构的升级。</p><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20220920191630251.png" alt="there layer"></p><h3 id="5、Distribute-Cluster"><a href="#5、Distribute-Cluster" class="headerlink" title="5、Distribute-Cluster"></a>5、Distribute-Cluster</h3><p>之上所提的架构都是在单体架构之下。单体架构和多服务架构是从服务的部署模式、运行模式来考虑。</p><p>单体架构有如下优势：</p><ul><li>易于开发：借助于开发框架，单体应用的开发及其简单，开发人员也很少需要考虑系统、部署、网络等层次的问题。</li><li>易于测试：单体应用部署在一个进程中，环境简单。只要服务启动就可以测试所有的功能。</li><li>易于部署：往往只需要将应用打包成一个简单的包就可。</li><li>易于水平扩展：只需要将程序包部署多个服务即可。</li></ul><p>单体应用的劣势：</p><ul><li>维护成本增加：随着需求的增多，单体系统将越来越臃肿，维护的复杂性也将越来越大。</li><li>持续交互周期长：一方面维护困难，另一方面单体应用在并行开发，并行测试上将十分困难，单体应用十分不适合快速迭代的敏捷开发。</li><li>扩展性差：由于臃肿的系统，将导致系统扩展性变难。系统的升级也需要十分谨慎。</li><li>对新人不友好。</li></ul><p>分布式系统拆分：</p><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20220920191745648.png" alt="service scale"></p><h3 id="6、Micro-Service"><a href="#6、Micro-Service" class="headerlink" title="6、Micro-Service"></a>6、Micro-Service</h3><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调、相互配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常基于 HTTP 的 RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境。</p><p>Spring Cloud 技术栈:</p><ul><li>SpringBoot：单体服务，快速创建项目，快速集成各种框架，易于测试，易于部署。</li><li>Feign：微服务独立部署，通过相关协议通信。Feign 就是一个简单的申明式通信框架，基于 HTTP restful。</li><li>Eureka：独立服务越来越多，服务实例也越来越多。服务治理便是必须的，Eureka 提供高可用的服务注册和服务发现功能。</li><li>Ribbon：Feign 只负责通信，Ribbon 提供客户端负载均衡，是系统优化的部分。</li><li>Hystrix：微服务将带来服务间复杂的依赖关系，分布式和集群的复杂度也将带来许多难以预料的问题。为防止复杂网络和复杂系统某一点的问题导致整个系统的雪崩状态，便有了 Hystrix，Hystrix 是 Spring Cloud 体系中优秀的断路器，可以在系统发生问题时进行服务降级，防止整体系统崩溃。</li><li>Zuul：统一网关，统一网关是以 Facade 模式，对外提供友好的接口，微服务化之后，服务将越来越多，越来越复杂，为了降低外部系统调用的复杂度，统一网关就是常用解决方案。</li><li>Config：服务划分越多，配置将越多，Spring cloud config 提供统一的配置管理。</li><li>Sleuth：服务监控和治理。监控是复杂系统必需的基础设施。系统感知、问题发现、性能定位都需要监控的加持。</li></ul><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20220920191927004.png" alt="micro service"></p><h3 id="7、Even-Source"><a href="#7、Even-Source" class="headerlink" title="7、Even-Source"></a>7、Even-Source</h3><p>事件溯源是最新流行一种应用程序体系结构模式。事件源将应用程序进行的状态更改建模为事件的不可变序列或“日志”。事件源不是在现场修改应用程序的状态，而是将触发状态更改的事件存储在不可变的日志中，并将状态更改建模为对日志中事件的响应。</p><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20221021153056824.png"></p><p>CQRS 模式通常基事件溯源模式。在传统的体系结构中，使用同一数据模型查询和更新数据库。这十分简单，非常适用于基本的 CRUD 操作。但是，在更复杂的应用程序中，此方法会变得难以操作。例如，在读取方面，应用程序可能执行大量不同的查询，返回具有不同形状的数据传输对象 (DTO)。对象映射可能会变得复杂。在写入方面，模型可能实施复杂验证和业务逻辑。结果，模型执行太多操作，过度复杂。</p><p>CQRS（命令查询的责任分离 Command Query Responsibility Segregation ）将读取和写入操作分成不同的模型，使用 <strong>命令</strong> 更新数据，并使用 <strong>查询</strong> 来读取数据。</p><h3 id="8、Hexagonal"><a href="#8、Hexagonal" class="headerlink" title="8、Hexagonal"></a>8、Hexagonal</h3><p><img src="/2022/09/20/chang-jian-jia-gou-mo-shi/image-20221021153305168.png"></p><p>六边形架构又称“端口和适配器模式”，是 Alistair Cockburn 提出的一种具有对称性特征的架构风格。在这种架构中，系统通过适配器的方式与外部交互，将应用服务与领域服务封装在系统内部。</p><p>六边形架构由以下三个组件组成：</p><ul><li>Ports：又可以分为输入端和输出端，是系统与其他系统交互的接口。</li><li>Adapters：与其他系统的适配层，一方面防止核心系统和领域被外部影响，即防腐;另一方面方便 api 使用。</li><li>Domain：应用和模型是程序的核心。</li></ul><p>六边形架构的核心理念是：应用通过”端口”跟外部进行交互。在传统的分层架构中很容易跨越层间的边界，把业务逻辑渗透到其它层中去。六边形架构重要的就是“边界”和“领域”。六边形架构的初衷是为了解决技术与业务系统的解耦合问题，以及技术与技术间的解耦合问题，这一架构从设计模式中来，从业务的实体服务出发，将面向接口的设计具体化的端口协议和适配器实现，服务自身实现独立性和完备性。</p><p>参考：<a href="https://mp.weixin.qq.com/s/NJFJ5UrzGk0cMGL1oZe0Bg">扫个盲先？吹一吹企业常用的软件架构！</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 架构 </tag>
            
            <tag> 分布式/微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Second Test</title>
      <link href="/2022/09/20/second-test/"/>
      <url>/2022/09/20/second-test/</url>
      
        <content type="html"><![CDATA[<p>第二次测试</p><p>托拉拽：</p><p><img src="/2022/09/20/second-test/image-20220920171706059.png" alt="不愧是我"></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test</title>
      <link href="/2022/09/20/test/"/>
      <url>/2022/09/20/test/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/09/20/test/%E5%90%89%E4%BB%964.jpg" alt="图片测试"></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习笔记</title>
      <link href="/2022/09/19/docker-xue-xi/"/>
      <url>/2022/09/19/docker-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、为何要用Docker"><a href="#一、为何要用Docker" class="headerlink" title="一、为何要用Docker?"></a>一、为何要用Docker?</h2><h3 id="1、什么是Docker"><a href="#1、什么是Docker" class="headerlink" title="1、什么是Docker?"></a>1、什么是Docker?</h3><p>Docker 使用 Google 公司推出的 Go 语言  进行开发实现，基于 Linux 内核 的cgroup，namespace，以及 AUFS 类的 UnionFS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。 由于隔离的进程独立于宿主和其它的隔离的进 程，因此也称其为容器。Docker 最初实现是基于 LXC.</p><p>Docker 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上，构建杰出的软件。</p><p>用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><h3 id="2、Docker的优点："><a href="#2、Docker的优点：" class="headerlink" title="2、Docker的优点："></a>2、Docker的优点：</h3><ul><li><p>环境隔离(‘<strong>隔离，安全</strong>‘)</p><p>Docker 实现了资源隔离，一台机器运行多个容器互无影响。</p></li><li><p>更高效的资源利用(<strong>节约成本</strong>)</p><p>Docker 容器的运行不需要额外的虚拟化管理程序的支持，它是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。</p></li><li><p>更快速的交付部署(<strong>敏捷</strong>)</p><p>使用 Docker，开发人员可以利用镜像快速构建一套标准的研发环境，开发完成后，测试和运维人员可以直接通过使用相同的环境来部署代码。</p></li><li><p>更易迁移扩展(<strong>可移植性</strong>)</p><p>Docker 容器几乎可以在任意的平台上运行，包括虚拟机、公有云、私有云、个人电脑、服务器等，这种兼容性让用户可以在不同平台之间轻松的迁移应用。</p></li><li><p>更简单的更新管理(<strong>高效</strong>)</p><p>使用 Dockerfile，只需要很少的配置修改，就可以替代以往大量的更新工作。并且所有修改都是以增量的方式进行分发和更新，从而实现自动化和高效的容器管理。</p></li></ul><h3 id="3、Docker-的基本组成架构"><a href="#3、Docker-的基本组成架构" class="headerlink" title="3、Docker 的基本组成架构"></a>3、Docker 的基本组成架构</h3><p>具体参考<a href="https://juejin.cn/post/6844904035053486087#heading-2">Docker搭建你的第一个 Node 项目到服务器(完整版)</a></p><h4 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h4><p>镜像仓库，存储大量镜像，可以从镜像仓库拉取和推送镜像。</p><h4 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h4><p>类似虚拟机快照，从仓库拉取，或者在现有工具镜像上创建新镜像。通过镜像可以启动容器。</p><h4 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h4><p>从镜像中创建应用环境，以单进程的方式运行。对外公开服务。是一种短暂的和一次性的环境。</p><h4 id="Docker-数据卷"><a href="#Docker-数据卷" class="headerlink" title="Docker 数据卷"></a>Docker 数据卷</h4><p>数据卷可以完成数据持久化，数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>卷会一直存在，直到没有容器使用</li></ul><h4 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h4><p>Docker 容器之间的网络交互，可以使用<code>端口映射</code>的方式，其他容器可以直接通过端口实现。除该方式外还有一个<code>容器连接（linking）系统</code>也可以达到容器交互。（本文中 node 连接 mongodb 使用的是端口映射的方式）</p><p>关于Docker 网络模块，容器连接详情推荐这篇文章: <a href="https://juejin.cn/post/6844903756920782855">Docker的网络模式详解</a></p><h3 id="4、Docker的常用命令（常用）"><a href="#4、Docker的常用命令（常用）" class="headerlink" title="4、Docker的常用命令（常用）"></a>4、Docker的常用命令（常用）</h3><h4 id="镜像常用命令"><a href="#镜像常用命令" class="headerlink" title="镜像常用命令"></a>镜像常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull [镜像名称:版本] 拉取镜像<br>docker images  镜像列表<br>docker rmi [镜像名称:版本] 删除镜像<br>docker <span class="hljs-built_in">history</span> [镜像名称] 镜像操作记录<br>docker tag [镜像名称:版本][新镜像名称:新版本]<br>docker inspect [镜像名称:版本] 查看镜像详细<br>docker search [关键字] 搜索镜像<br>docker login 镜像登陆<br></code></pre></td></tr></table></figure><h4 id="容器常用命令"><a href="#容器常用命令" class="headerlink" title="容器常用命令"></a>容器常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps -a 容器列表(所有容器)<br>docker ps  查看所有(运行的)容器<br>docker <span class="hljs-built_in">exec</span> -ti &lt;<span class="hljs-built_in">id</span>&gt; bash  以 bash 命令进入容器内<br>docker run -ti --name [容器名称][镜像名称:版本] bash 启动容器并进入<br>docker logs 查看容器日志<br>docker top &lt;container_id&gt; 查看容器最近的一个进程<br>docker run -ti --name [容器名称] -p 8080:80 [镜像名称:版本] bash  端口映射<br>docker <span class="hljs-built_in">rm</span> &lt;container_id&gt; 删除容器<br>docker stop &lt;container_id&gt; 停止容器<br>docker start &lt;container_id&gt; 开启容器<br>docker restart &lt;container_id&gt; 重启容器<br>docker inspect &lt;container_id&gt; 查看容器详情<br>docker commit [容器名称] my_image:v1.0  容器提交为新的镜像<br></code></pre></td></tr></table></figure><h4 id="DockerFile常用命令"><a href="#DockerFile常用命令" class="headerlink" title="DockerFile常用命令"></a>DockerFile常用命令</h4><p>见第六节</p><h2 id="二、CentOs-7-上Docker安装部署"><a href="#二、CentOs-7-上Docker安装部署" class="headerlink" title="二、CentOs 7 上Docker安装部署"></a>二、CentOs 7 上Docker安装部署</h2><h3 id="1、若是以前安装过docker，先执行以下步骤"><a href="#1、若是以前安装过docker，先执行以下步骤" class="headerlink" title="1、若是以前安装过docker，先执行以下步骤"></a>1、若是以前安装过docker，先执行以下步骤</h3><ol><li><p>更新yum包（生产环境中慎重）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y update<br></code></pre></td></tr></table></figure><p>此命令不是必须，有服务器重启一下服务器</p></li><li><p>卸载旧版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum remove docker  docker-common docker-selinux docker-engine<br></code></pre></td></tr></table></figure></li></ol><h3 id="2、安装docker的详细步骤"><a href="#2、安装docker的详细步骤" class="headerlink" title="2、安装docker的详细步骤"></a>2、安装docker的详细步骤</h3><ol><li><p>首先安装需要的软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y yum-utils device-mapper-persistent-data lvm2<br></code></pre></td></tr></table></figure></li><li><p>设置yum源，我使用的是阿里仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure></li><li><p>选择docker版本并安装<br>查看可用的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum list docker-ce --showduplicates | <span class="hljs-built_in">sort</span> -r                 <br></code></pre></td></tr></table></figure><p>选择一个版本并安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install docker-ce-版本号<br></code></pre></td></tr></table></figure><p>我安装的是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y install docker-ce-18.03.1.ce<br></code></pre></td></tr></table></figure></li><li><p>启动docker并设置开机自启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start docker<br>systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure></li></ol><h2 id="三、image文件"><a href="#三、image文件" class="headerlink" title="三、image文件"></a>三、image文件</h2><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出本机的所有 image 文件。</span><br>docker image <span class="hljs-built_in">ls</span><br><br><span class="hljs-comment"># 删除 image 文件</span><br>docker image <span class="hljs-built_in">rm</span> [imageName]<br></code></pre></td></tr></table></figure></blockquote><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/">Docker Hub</a> 是最重要、最常用的 image 仓库。</p><h2 id="四、实例：“Hello-world”"><a href="#四、实例：“Hello-world”" class="headerlink" title="四、实例：“Hello world”"></a>四、实例：“Hello world”</h2><p>通过最简单的“Hello world”实例感受一下image文件</p><p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image pull library/hello-world<br></code></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p><p>由于 Docker 官方提供的 image 文件，都放在<a href="https://hub.docker.com/r/library/"><code>library</code></a>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image pull hello-world<br></code></pre></td></tr></table></figure></blockquote><p>抓取成功以后，就可以在本机看到这个 image 文件了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure></blockquote><p>现在，运行这个 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run hello-world<br></code></pre></td></tr></table></figure></blockquote><p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p><p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p><p>如果运行成功，你会在屏幕上读到下面的输出。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run hello-world<br><br>Hello from Docker!<br>This message shows that your installation appears to be working correctly.<br><br>... ...<br></code></pre></td></tr></table></figure></blockquote><p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p><p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run -it ubuntu bash<br></code></pre></td></tr></table></figure></blockquote><p>对于那些不会自动终止的容器，必须使用<a href="https://docs.docker.com/engine/reference/commandline/container_kill/"><code>docker container kill</code></a> 命令手动终止。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">kill</span> [containID]<br></code></pre></td></tr></table></figure></blockquote><h2 id="五、容器文件"><a href="#五、容器文件" class="headerlink" title="五、容器文件"></a>五、容器文件</h2><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出本机正在运行的容器</span><br>$ docker container <span class="hljs-built_in">ls</span><br><br><span class="hljs-comment"># 列出本机所有容器，包括终止运行的容器</span><br>$ docker container <span class="hljs-built_in">ls</span> --all<br></code></pre></td></tr></table></figure></blockquote><p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p><p>终止运行的容器文件，依然会占据硬盘空间，可以使用<a href="https://docs.docker.com/engine/reference/commandline/container_rm/"><code>docker container rm</code></a>命令删除。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">rm</span> [containerID]<br></code></pre></td></tr></table></figure></blockquote><p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p><h2 id="六、Dockerfile部署Spring-Boot-项目"><a href="#六、Dockerfile部署Spring-Boot-项目" class="headerlink" title="六、Dockerfile部署Spring Boot 项目"></a>六、Dockerfile部署Spring Boot 项目</h2><h3 id="1、将已有的spring-boot-项目打包"><a href="#1、将已有的spring-boot-项目打包" class="headerlink" title="1、将已有的spring boot 项目打包"></a>1、将已有的spring boot 项目打包</h3><h3 id="2、在linux中创建一个文件夹，例如我创建为-root-docker-test-jar01"><a href="#2、在linux中创建一个文件夹，例如我创建为-root-docker-test-jar01" class="headerlink" title="2、在linux中创建一个文件夹，例如我创建为 /root/docker_test/jar01"></a>2、在linux中创建一个文件夹，例如我创建为 /root/docker_test/jar01</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /root/docker_test/jar01<br></code></pre></td></tr></table></figure><h3 id="3、将jar包上传到linux文件夹中"><a href="#3、将jar包上传到linux文件夹中" class="headerlink" title="3、将jar包上传到linux文件夹中"></a>3、将jar包上传到linux文件夹中</h3><p>利用MobaxTerm将jar包上传到jar01中</p><h3 id="4、编写DockerFile文件"><a href="#4、编写DockerFile文件" class="headerlink" title="4、编写DockerFile文件"></a>4、编写DockerFile文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 基于java镜像创建新镜像</span><br>FROM openjdk:11<br><span class="hljs-comment"># 作者</span><br>MAINTAINER zbiao<br><span class="hljs-comment"># 将jar包添加到容器中并更名为app.jar</span><br>ADD  demo-helloworld.jar app.jar<br><span class="hljs-comment"># 运行jar包</span><br>ENTRYPOINT [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;app.jar&quot;</span>]<br></code></pre></td></tr></table></figure><p>ADD 后面是源文件，再后面才是目标文件</p><blockquote><p>注意：ADD、COPY 指令用法一样，唯一不同的是 ADD 支持将归档文件（tar, gzip, bzip2, etc）做提取和解压操作。还有需要注意的是，COPY 指令需要复制的目录一定要放在 Dockerfile 文件的同级目录下。</p></blockquote><p>参考：<a href="http://lpxz.work/2022/07/04/Docker%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6-%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2-updating%E2%80%A6">LPxz的个人博客</a></p><h3 id="5、制作镜像"><a href="#5、制作镜像" class="headerlink" title="5、制作镜像"></a>5、制作镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t zbdemo .<br></code></pre></td></tr></table></figure><p>注意是在jar01目录下</p><h3 id="6、启动容器"><a href="#6、启动容器" class="headerlink" title="6、启动容器"></a>6、启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 8080:8080 --name zbdemo03 zbdemo:latest<br></code></pre></td></tr></table></figure><p>命令参数：</p><ul><li>-d：后台运行</li><li>-p：公开指定端口号</li><li>-name：容器命名</li></ul><p>启动后可通过 <code>docker ps</code> 查看正在运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-10-centos jar01]<span class="hljs-comment"># docker ps</span><br>CONTAINER ID        IMAGE               COMMAND               CREATED             STATUS              PORTS                    NAMES<br>618cf8b1a0a8        zbdemo:latest       <span class="hljs-string">&quot;java -jar app.jar&quot;</span>   14 minutes ago      Up 13 minutes       0.0.0.0:8080-&gt;8080/tcp   zbdemo04<br>45d6deb5444a        zbdemo:latest       <span class="hljs-string">&quot;java -jar app.jar&quot;</span>   16 minutes ago      Up 16 minutes       0.0.0.0:8082-&gt;8082/tcp   zbdemo03<br></code></pre></td></tr></table></figure><h3 id="7、查看启动日志"><a href="#7、查看启动日志" class="headerlink" title="7、查看启动日志"></a>7、查看启动日志</h3><p>我们可以通过 <code>docker logs name</code> 查看指定容器的日志，后面name为容器名，如zbdemo03</p><h3 id="8、DockerFile配置参数"><a href="#8、DockerFile配置参数" class="headerlink" title="8、DockerFile配置参数"></a>8、DockerFile配置参数</h3><p>FROM：FROM 是构建镜像的基础源镜像，该 Image 文件继承官方的 node image。</p><p>详细说明：Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令！ 它引入一个镜像作为我们要构建镜像的基础层，就好像我们首先要安装好操作系统，才可以在操作系统上面安装软件一样。</p><p>RUN：后面跟的是在容器中要执行的命令。</p><p>详细说明：每一个 <code>RUN</code> 指令都会新建立一层，在其上执行这些命令，我们频繁使用 <code>RUN</code> 指令会创建大量镜像层，然而 <code>Union FS</code> 是有最大层数限制的，不能超过 <code>127</code> 层，而且我们应该把每一层中我用文件清除，比如一些没用的依赖，来防止镜像臃肿。</p><p>WORKDIR：容器的工作目录</p><p>COPY：拷贝文件至容器的工作目录下，.dockerignore 指定的文件不会拷贝</p><p>EXPOSE：将容器内的某个端口导出供外部访问</p><p>CMD：Dockerfile 执行写一个 CMD 否则后面的会被覆盖，CMD 后面的命令是容器每次启动执行的命令，多个命令之间可以使用 &amp;&amp; 链接，例如 CMD git pull &amp;&amp; npm start</p><p>详细说明:<code>CMD</code> 指令用来在启动容器的时候，指定默认的容器主进程的启动命令和参数。 </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> image </tag>
            
            <tag> dockerfile </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2022/09/16/tan-xin-suan-fa/"/>
      <url>/2022/09/16/tan-xin-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="贪心算法基础知识"><a href="#贪心算法基础知识" class="headerlink" title="贪心算法基础知识"></a>贪心算法基础知识</h2><p>无套路</p><p>大体思路： 求局部最优，进而求全局最优</p><p>贪心算法一般分为如下四步：</p><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><p>个人思路：将两个数组排序，然后饼干那个一一对应孩子的胃口，若是饼干小了，直接饼干后移，若是孩子小了，仍然直接给出，count+1</p><hr><p>但还有种反向操作，先给大的，后给小的；尽可能多的满足孩子的胃口。</p><p>奥，卡哥跟我想的一样，都是用一个index来避免二次遍历，这道题先满足胃口小的和先满足胃口大的都一样</p><h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p>序列还可以删除，一定要注意这一点</p><p>摆动序列可以转化为求峰值和谷底，求出一个峰值或谷底结果就加一</p><p>result初始化为1，是因为如果初始化0的话，就没有考虑到边界，初始化为1就体现了已经处理左边界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((curDiff &gt; <span class="hljs-number">0</span> &amp;&amp; preDiff &lt;= <span class="hljs-number">0</span>) || (curDiff &lt; <span class="hljs-number">0</span> &amp;&amp; preDiff &gt;= <span class="hljs-number">0</span>)) &#123;<br>count++;<br>preDiff = curDiff;<br>&#125;<br></code></pre></td></tr></table></figure><p>pre处写&lt;=   、 &gt;=  是因为要考虑初始化情况，因为pre初始化为0，所以不管当前大于还是小于，都符合</p><p>同时序列还可以删除，这一点体现在pre = cur的放置位置，放在if里面，意思是只找峰值或谷底，而不去管边界；若是放到if外面，意思是每次都要进行处理，很明显，本题我们要选择放在if里面</p><p>另一种解法是DP,以后再说</p><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p>若全是负数？</p><p>想法：跟上题类似，定义pre和cur，再定义一个最大值，最大值一定是从正数开始，但是若全是负数？？</p><p>行不通，否</p><ol><li>思路一：暴力法，两层for循环，外层遍历，内层从外层开始，找出最大连续和；这样就把每个连续和求出来了，直接返回最大</li><li>思路二：贪心法，重点在于想局部最优，局部最优是：一旦加到了负数，则直接从下一个开始；同时用result记录最大值，由此来确定终止区间。</li><li>思路三：动态规划，目前不涉及</li></ol><p>思路二贪心的实现，有一个问题，若是全是负数呢？又回到了我最初的想法，若全是负数的话，那就应该把result初始化为Integer的最小值，然后先加到sum里，再判断result和sum大小，最后再判断sum是否大于0，这样就完美解决了全是负数的问题。</p><p>我最初是先判断sum是否大于0，若不是则直接continue，这样导致出现全是负数的时候就无法解决。</p><p>卡哥厉害！</p><h2 id="买股票的最佳时机II"><a href="#买股票的最佳时机II" class="headerlink" title="买股票的最佳时机II"></a>买股票的最佳时机II</h2><p>真蠢啊！</p><p>我在想：是否可以像以前那样，定义一个cur，一个pre；找谷峰和谷底，但这样极难实现，或者说就不可以实现</p><p>卡哥是通过计算两天之间的差值，只记录正值即可，并相加；</p><p>还有一种的DP,暂时不考虑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prices.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (prices[i + <span class="hljs-number">1</span>] - prices[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                sum += prices[i + <span class="hljs-number">1</span>] - prices[i];<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>我被秀一脸</p><h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p>回溯？</p><p>看起来像是回溯</p><p>本人想法：局部最优：跳到一个方块，然后找这个方块能跳到的范围内的数值最大的，并且如果最大范围超过了数组，则证明可以跳到，反之不行</p><hr><p>我的想法是不正确的，卡哥的思路：局部最优：找最大覆盖范围，每个都得遍历，若是找到了某个元素覆盖范围覆盖了数组的长度，则可以，反之若是遍历完还是没有返回true，那说明不行了。</p><blockquote><p>也可以这样遍历数组：</p></blockquote><p>​    遍历的是coverMax，而不是整个数组，数组的遍历在for循环里面，看似没遍历数组，实则是对数组的每一个元素都遍历了。</p><h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="==跳跃游戏II=="></a>==跳跃游戏II==</h2><p>这下该找最大了吧</p><p>还是不能找最大，但是讲道理，可行，但是就是跑不通</p><p>卡哥思路：依然是找最大覆盖范围，定义当前最大范围和全体最大范围，当走到当前最大范围时，判断全体最大范围是否大于数组长度，若大于的话，直接+1并且break;若是不大于，就更新当前最大范围到全体最大范围</p><blockquote><p>新思路：最大范围</p></blockquote><h2 id="K次取反后最大化的数组和"><a href="#K次取反后最大化的数组和" class="headerlink" title="K次取反后最大化的数组和"></a>K次取反后最大化的数组和</h2><p>想法：其实只分奇数次和偶数次。需要判断负数的数量，若是负数总数小于k，则先将负数全部转正，然后再减二，直到k为0或1，是0的话不用说了，是1的话将最小的翻转；若负数总数大于k，那么更好办了，直接翻转。</p><p>当然排序会更容易处理一些。</p><p>Yes，跟卡哥想的一样，不过排序是按绝对值大小进行排序，但是我觉得也可以直接排序</p><p>最重要的是，按贪心的思路来想，局部最优，全局最优。</p><p>局部最优是：每次翻转最小的整数</p><p>全局最优是：整个数值达到最大</p><p>确实要按绝对值排序！而且是绝对值从大到小！到最后翻转最后一个数即可；反之绝对值从小到大亦可。</p><h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p>无从下手</p><p>贪心法一：</p><p>进行全局贪心</p><ul><li>情况一：如果gas的总和小于cost总和，那么无论从哪里出发，一定是跑不了一圈的</li><li>情况二：rest[i] = gas[i]-cost[i]为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。</li><li>情况三：如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能这个负数填平，能把这个负数填平的节点就是出发节点。</li></ul><p>贪心法二：</p><p>每个加油站的剩余量rest[i]为gas[i] - cost[i]。</p><p>i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。</p><p><strong>局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置</strong>。</p><p>水</p><h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p>求峰值，或者说是附近位置最大值这种，一般都需要从左到右再从右到左两次遍历确定</p><p>第一次从左到右，判断右边比左边大，则右边+1；</p><p>第二次从右到左，判断左边比右边大，则取原来的和右边+1二者最大值</p><p>注意：原数组进行比较，而不是candy数组进行比较；在这纠结了起码十五分钟！</p><h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h2><p>初步思路：维持一个数组，只保存5和10的个数，还可以求一个sum；局部最优：每次先挑最大的数，也即10，再挑5,；全局最优：所有人都可以找零</p><p>Yes。思路一样，只不过卡哥实现是用两个int型，我用数组，其实用int更好一点。卡哥是遇到直接减，不管是否大于零还是小于零，到最后判断这两个是否都大于等于零即可；我是若是减了大于0，则减。</p><p>卡哥代码更易实现</p><h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h2><p>初步思路：先找ki == 0 的人，然后从小打到再排列，先放小的；然后再找ki == 1的，再从小开始放；然后找ki == 2的，以此类推。</p><p>实现：有一种想法是建两个数组，一个存hi，一个存ki，定义一个函数，功能是交换数组某两个位置的元素。</p><p>思路不可行。我的思路相当于按k排序，但是这种会出现一个问题，[5,2],[7,1]到底谁先呢？出现不确定性。</p><p>卡哥：这种两种维度的题一定要先确定一个维度，若是两个维度都想兼顾到的话就会顾此失彼。</p><p>实现：看了卡哥的，真是厉害！使用自定义函数Arrays.sort()进行排序，之后使用list来遍历</p><blockquote><p>注意：从小到大：o1 - o2;从大到小：o2 - o1</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(people, (a, b) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])<br>                <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];   <span class="hljs-comment">//从小到大</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>];   <span class="hljs-comment">//从大到小</span><br>        &#125;);<br></code></pre></td></tr></table></figure><p>==插入操作==</p><p>使用LinkedList.add(index, value)方法进行插入，第一个参数是插入位置</p><p>最后使用toArray方法进行数组转换。</p><p>卡哥方法使用到位！厉害</p><h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h2><p>数组第一个数组进行排序，从小到大；从结尾出判断，若下面有有数组在这个区间，则将这个区间一同删去（或者说往后遍历）</p><p>思路跟卡哥一样，只是实现是个问题</p><p>首先是排序，二维数组经典排序（从小到大）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(points, (o1, o2) -&gt; Integer.compare(o1[<span class="hljs-number">0</span>], o2[<span class="hljs-number">0</span>]));<br></code></pre></td></tr></table></figure><p>实现：从1处开始遍历，判断上一个的结尾和下一个的开头是否有交集，若无交集，直接count++;若有交集，则更新下一个的右边界，更新为上一个和下一个的最小值，最后返回。</p><h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><p>初步思路：仍然是排序，从小到大排序，若是开端相同，则默认删掉结尾长的那个数组；留下来是下一个的开端大于等于上一个的结尾；若是下一个开端小于上一个结尾，说明有重叠，则直接更新下一个结尾。</p><p>试了一下，果然成功了。</p><p>卡哥思路更简单，也更加全面。分按左区间排序和右区间排序；我上面的思路就是按左区间进行排序的，卡哥用了一个int pre来记录上一次结尾的最小值，每次都更新pre</p><h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h2><p>自己没有思路。。</p><p>卡哥思路：总共26个字母，先把这些字母最后出现字母写进数组，然后再遍历一次字符串，每次更新最大右边界，若当前位置等于当前出现最大值，说明已经到了该划分的时候</p><p>贪心，并没有体现，至少我想象不出。</p><p>开拓视野吧。但是很精彩</p><h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p>貌似不难</p><p>初步思路：对左边界进行排序，只需要判断右边界是否大于左边界即可</p><p>==重要：==</p><p>定义二维数组：</p><p>List&lt;int[]&gt; res = new ArrayList&lt;&gt;();</p><p>list添加二维数组：</p><p>res.add(new int[]{start, intervals[i - 1] [1]});</p><p>list转二维数组：</p><p>res.toArray(new int[res.size()] []);</p><blockquote><p>注意</p></blockquote><p>处理的永远是上一层的末尾，所以最后要单独处理一下最后一层</p><h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h2><p>暴力解法：写一个判断是否单调递增的函数，从这个数开始往下遍历，找到一个符合的立刻返回</p><p>结果自然是超时。哈哈哈哈</p><p>贪心解法：局部最优：首先若是str[i - 1] &gt;  str[i]的话，证明前一位数大，则将str[i-1]–,并让str[i] = 9，这样就可保证局部最大；全局最优：遍历，即可达到全局最优。</p><p>问题在于，是从前往后遍历还是从后往前遍历。当然是从后往前遍历，因为从前往后遍历的时候，比如332，  332 -&gt; 329，Out。从后往前遍历，332 -&gt; 329 -&gt; 299</p><p>本题用到的java方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 整形转string</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.valueOf(n);<br><span class="hljs-comment">// 字符串转字符数组</span><br><span class="hljs-type">char</span>[] chars = s.toCharArray();<br><span class="hljs-comment">// 先转字符串再转整形</span><br>Integer.parseInt(String.valueOf(chars));<br></code></pre></td></tr></table></figure><p>以下都可转string</p><p><img src="/2022/09/16/tan-xin-suan-fa/Typora文件\Typora图片\image-20220621143453592.png" alt="image-20220621143453592"></p><h2 id="买卖股票的最佳时机（含手续费）"><a href="#买卖股票的最佳时机（含手续费）" class="headerlink" title="买卖股票的最佳时机（含手续费）"></a>买卖股票的最佳时机（含手续费）</h2><p>初步思路：遇到极小值的就买入，遇到极大值就卖出</p><p>当然也可能有问题</p><p>卡哥思路：不需要计算具体时间，只需要计算连续收获利润即可</p><p>计算收获利润时：</p><ol><li>收获利润这一天并不是最终收获利润的那一天</li><li>前一天是最终收获利润那一天，今天重新计算</li><li>不作操作，不买不卖</li></ol><p>很巧妙</p><p>每次执行操作时都加上fee，初始化一个buy，遍历数组，若是遇到p + fee &lt; buy的，另buy重置为p + fee，说明需要买入；若是遇到p &gt; buy的，说明有利润，直接加到sum里，并重置buy = p；其他的情况可以不管。</p><p>但其实本题用动态规划更好一点</p><h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><p>个人想法：可以发现，每三层必有一个监控，在第二层设置监控即可。另外再设置一个数组，用来标记是否已经监控，连续两层必有监控。</p><p>细节：但是设置标记数组的话，需要知道树的全部子节点，不易实现。</p><p>卡哥思路：从下到上，从最下面的叶子结点开始，对叶子结点的父节点设置监控。局部最优：从叶节点的父节点开始设置监控；全局最优：使用的摄像头最少</p><p>难点：</p><p>如何遍历树</p><p>如何隔两个节点放置监控</p><ol><li><p>如何遍历树<br>使用后序遍历</p></li><li><p>如何隔两个节点放置监控<br>每个节点三个状态：</p><ul><li>0   无覆盖</li><li>1   有摄像头</li><li>2   有覆盖</li></ul><p>单层处理逻辑四种情况：</p><ul><li>左右孩子都有覆盖<br>则中间节点肯定无覆盖</li><li>左右孩子至少有一个无覆盖<br>中间节点应放置摄像头</li><li>左右节点至少有一个摄像头</li><li>处理头结点</li></ul></li></ol><p>总的来说，一共就那几种情况。</p><p>先判断左右孩子是否至少有一个无覆盖，有则直接放置一个摄像头；再判断左右孩子是否都是有覆盖，若全都有覆盖，则中间节点必定是无覆盖；剩下情况直接返回有覆盖。</p><p>这是一道Hard题，==仔细揣摩==。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/2022/09/16/hui-su-suan-fa/"/>
      <url>/2022/09/16/hui-su-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯通常隐藏在递归函数的下面</p><p>==for循环横向遍历，递归纵向遍历==</p><p>回溯法是一个纯暴力搜索，并不是高效的算法</p><p>适用于：</p><ol><li>组合问题</li><li>切割问题</li><li>子集问题</li><li>排列问题</li><li>棋盘问题</li></ol><p>回溯法可以抽象为一个树形结构（n叉树）</p><h2 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="回溯法模板"></a>回溯法模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(参数)</span> &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素(树中结点孩子的数量就是集合的大小)) &#123;<br>        处理结点;<br>        backtracking(路径， 选择列表);   <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>        <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p><img src="/2022/09/16/hui-su-suan-fa/Typora文件\Typora图片\image-20220607093535686.png" alt="image-20220607093535686"></p><h2 id="组合总数III"><a href="#组合总数III" class="headerlink" title="组合总数III"></a>组合总数III</h2><ol><li>两个全局变量<br>List&lt;&gt; path;    List&lt;List&lt;&gt;&gt; res;<br>四个参数<br>n, k, index, sum</li><li>终止条件<br>值总和相等</li><li>单层处理逻辑<br>回溯</li></ol><p>剪枝操作：</p><ol><li>已经选择的元素个数：path.size();</li><li>还需要的元素个数为: k - path.size();</li><li>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li></ol><h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p>本题的难点在于：如何将数字与字母相对应？</p><p>可以用一个二维数组，将数字与字母位置写死，需要时可直接取出来；</p><p>还是递归老三部：</p><ol><li>确定递归参数</li><li>确定终止条件</li><li>确定单层处理逻辑</li></ol><p>本题貌似无法剪枝。</p><p>要进行字符串的增加或者删除时，可以使用StringBuilder，其中增加用append，删除用deleteCharAt()，最后转为String 可以用sb.toString()。</p><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p>依然是递归三部曲</p><p>只是这道题与之前的几道题的区别在于，这道题可以重复使用数字，并且没有限定有几个数；</p><p>首先对数组元素进行排序；解决重复使用数字，使用一个index，index用来定位，以前的不可重复递归的时候是index+1，可重复的话就是index；解决没有限定几个数，可以用sum是否大于target来判断</p><h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h2><p>难点在于，每个数字在组合中只能使用一次，==但是==，会出现重复的。</p><p>比如[1,1,2],target = 3,       处理不好的话[1,2],[1,2]会出现两次，就需要去重。回溯去重有两种去重，一种是树枝去重，另一种是树层去重。</p><p>对于本题来说，树枝是可以重复的，因为人家本来就有重复的元素；树层是不可以重复的。</p><p>有如下==两种办法去重==：</p><ol><li><p>使用数组标记<br>先判断，若i &gt; 0并且本次遍历元素与上一个元素相同，同时标记数组为false，则表明为树层重复，应该去掉，直接continue；<br>解释一下标记数组，若已经使用过，则将标记数组置为1，status[i - 1] == 0代表i-1个元素没有使用过<br>那么肯定，若i-1没有使用过，则本次重复为树层重复；若i-1已使用过，则代表已经使用过，为树枝重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; status[i - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)       <br><span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure></li><li><p>不使用数组标记<br>很简单，若是本次与上一个相等，则就是树层重复</p></li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ( i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] ) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><ul><li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个…..。</li><li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…..。</li></ul><p>亦可以抽象为一颗树形结构</p><p><img src="/2022/09/16/hui-su-suan-fa/Typora文件\Typora图片\image-20220610103125075.png" alt="image-20220610103125075"></p><p>难点：</p><ul><li>切割问题可以抽象为组合问题</li><li>如何模拟那些切割线<br>用index来定位</li><li>切割问题中递归如何终止<br>若index大于s.length()，则加入结果并返回</li><li>在递归循环中如何截取子串<br>用s.substring()</li><li>如何判断回文<br>回文好解决，用双指针解决</li></ul><h2 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h2><p>substring() 前闭后开</p><p>==做这类型题，一定注意区间是开还是闭！！！==</p><p>思路一：</p><p>本题可直接对原字符串s进行操作，因为后续会有回溯操作</p><p>需要写一个判断是否有效的函数，思路为：定义一个sum,令sum = sum * 10 + s.charAt(i) - ‘0’;即可求出数值，然后判断是否大于255即可</p><p>还有一个坑：因为要输出ip的时候ip地址中间有’.’，所以进行递归的时候直接i + 2,例如：backtracking(s, i + 2, pointsum);</p><p>同时，本题与其他的回溯不同的是，本题处理单层逻辑时，若是发现数字不是有效数字，则直接跳出，而不是continue；</p><p>思路二:</p><p>剪枝操作，回溯函数参数附带一个index，以及一个number，代表当前的ip段，一共有四段</p><p>终止条件：如果index == 字符串长度， 并且number == 4， 则是正确的，添加进res并返回，否则直接返回</p><p>单层操作：重点在for循环的第二个条件，在第二个条件里就判断是否有效，而不像思路一那样另写一个方法</p><p>==Integer.parseInt(s.substring(start, i + 1)) &gt;= 0 &amp;&amp; Integer.parseInt(s.substring(start, i + 1)) &lt;= 255；==</p><p>（若是面试华为鸿蒙的时候知道这个，说不定写出来了呢？）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length() &amp;&amp; i - start &lt; <span class="hljs-number">3</span> &amp;&amp; Integer.parseInt(s.substring(start, i + <span class="hljs-number">1</span>)) &gt;= <span class="hljs-number">0</span><br>&amp;&amp; Integer.parseInt(s.substring(start, i + <span class="hljs-number">1</span>)) &lt;= <span class="hljs-number">255</span>; i++) &#123;<br><span class="hljs-comment">// 如果ip段的长度大于1，并且第一位为0的话，continue</span><br>    <span class="hljs-comment">// 也就是说，0在第二位或者第三位，反正不在第一位，则令i++</span><br><span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> - start &gt; <span class="hljs-number">1</span> &amp;&amp; s.charAt(start) - <span class="hljs-string">&#x27;0&#x27;</span> == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>stringBuilder.append(s.substring(start, i + <span class="hljs-number">1</span>));<br><span class="hljs-comment">// 当stringBuilder里的网段数量小于3时，才会加点；如果等于3，说明已经有3段了，最后一段不需要再加点</span><br><span class="hljs-keyword">if</span> (number &lt; <span class="hljs-number">3</span>) &#123;<br>stringBuilder.append(<span class="hljs-string">&quot;.&quot;</span>);<br>&#125;<br>number++;<br>restoreIpAddressesHandler(s, i + <span class="hljs-number">1</span>, number);<br>number--;<br><span class="hljs-comment">// 删除当前stringBuilder最后一个网段，注意考虑点的数量的问题</span><br>stringBuilder.delete(start + number, i + number + <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p>难点在于：树枝上的子节点随时可以停下</p><p>个人思路：遍历一个，就把这个加入进去，碰到最大数即返回；所以可能要排序？</p><p>？？？竟然通过了，神奇！细节我还没有扣</p><hr><p>正确解法：</p><p><img src="/2022/09/16/hui-su-suan-fa/Typora文件\Typora图片\image-20220610151529520.png" alt="image-20220610151529520"></p><p>牛！</p><p>本题的res.add()位置就相当有讲究了</p><p>应该放在回溯的开头，为何？因为放在开头会有[]空这个子集，否则就少了一个子集</p><p>但是为什么不需要排序？是因为nums[i]就已经确定相对位置了，for循环从0开始，而num[]不变，就相当于一直往后遍历。这块有点绕，但精彩</p><h2 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h2><p>这个总要排序了吧？</p><p>这个要不排序的话，那么重复元素怎么解决。</p><p><em>倒是有一种解决办法，若这个元素与上个元素相等，则continue；</em>      ==解决不了==    必须要排序，要么排序，要么新建一个used数组</p><p>看了一眼，果然，是树层去重</p><p>Yes!!!!!!!                                   厉害厉害</p><h2 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h2><p>本题去重</p><p><img src="/2022/09/16/hui-su-suan-fa/Typora文件\Typora图片\image-20220613104412019.png" alt="image-20220613104412019"></p><p>昏过了 头，执行代码一直显示超出时间限制，原因是因为粗心大意而写了个死循环</p><p>map.getOrDefault(nums[i], 0)    厉害（我只会说厉害吗?）</p><p>词穷</p><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>排列问题与组合问题不同，组合问题需要一个index来确定遍历的位置，而排列不同，因为[2,1]和[1,2]是不同的，无法使用index，但是要使用一个used数组，或者其他的map等，用来记录是否已使用过</p><p>还是递归三部曲</p><p>参数不同，不需要index，同时可以定义一个全局变量，这样就不需要传参了。</p><h2 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h2><p>去重的时候，或者剪枝的时候</p><p>非常重要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// used[i - 1] == true，说明同一树枝nums[i - 1]使用过</span><br><span class="hljs-comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span><br></code></pre></td></tr></table></figure><p>树枝去重和树层去重；为什么不判断user[i]而要判断user[i - 1]呢，因为已经到了i这一层，那么i-1就一定已经处理过了</p><p>其余还是递归三部曲</p><h2 id="重新安排行程（重要）"><a href="#重新安排行程（重要）" class="headerlink" title="重新安排行程（重要）"></a>重新安排行程（重要）</h2><p>思路：</p><p>递归三部曲</p><p>可以发现，最终行程数 = 机场数 + 1，由此确定终止条件</p><p>回溯方法只考虑逻辑处理，而不考虑数据的输入，数据的输入在主函数完成</p><p>最重要的是各种集合的使用：</p><ul><li><p>集合的遍历：</p><ul><li><p>使用entry遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br> <br><span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;<br> <br>    System.out.println(<span class="hljs-string">&quot;Key = &quot;</span> + entry.getKey() + <span class="hljs-string">&quot;, Value = &quot;</span> + entry.getValue());<br> <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>遍历key或value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br> <br><span class="hljs-comment">//遍历map中的键</span><br> <br><span class="hljs-keyword">for</span> (Integer key : map.keySet()) &#123;<br> <br>    System.out.println(<span class="hljs-string">&quot;Key = &quot;</span> + key);<br> <br>&#125;<br> <br><span class="hljs-comment">//遍历map中的值</span><br> <br><span class="hljs-keyword">for</span> (Integer value : map.values()) &#123;<br> <br>    System.out.println(<span class="hljs-string">&quot;Value = &quot;</span> + value);<br> <br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>TreeMap的使用<br>会对key进行排序</p></li></ul><p>使用TreeMap，就很好的解决了题目要求的按字母大小排序的要求</p><blockquote><p>在进行插入的时候，逻辑是：1、判断是否存在这个key，如果存在，那么先取出原来的值，再赋值最新的值；若不存在，则建立一个TreeMap，再赋值最新的值。</p></blockquote><p>==遍历的时候总是多进一层==</p><blockquote><p>本题还有另外一个注意事项，就是本题的回溯方法返回值是boolean，为什么呢？</p></blockquote><p>因为我们只需要找出一个行程即可，若是找到行程，一路返回true；同时找行程的过程中使用TreeMap，就可以保证返回的行程是按字母表顺序来的</p><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>回溯法的经典题目</p><p>可以写个函数，来判断该位置是否能放皇后，      ==错误==：<em>斜对角的位置判断：数加起来等于一个定值，就说明该斜对角线已经有皇后了，如res[1] [2] 和res[0] [3],就属于同一条斜线</em></p><p>依然是递归三部曲</p><p>参数可以加一个row，用来遍历当前是第几层，同时若是到了最底层，则就返回；这是终止条件</p><p>┗|｀O′|┛ 嗷~~，知道了，判断是否有效不能简单的那么判断，因为上述没有考虑到另一条斜对角线，所以判断是否有效要分列，45°，135°三种情况</p><blockquote><p>不熟悉的方法：</p><ol><li>Arrays.fill（ a1, value ）;    其中a1是数组，后面value是值，数组赋值</li><li>String.copyValueOf(c)；    其中c是一个一维数组，char[] c， 表示将c转化为一个String类型<br>String.copyValueOf(char[] data, int offset, int count);  第二个参数表示子数组的初始偏移量；count表示子数组的长度</li></ol></blockquote><blockquote><p>新思路（新操作）：</p><ul><li>将数组全部置为’.’，满足要求再将数组置为’Q’</li><li>有些时候回溯算法处理单层逻辑时只考虑成功的情况，如   if () {} </li></ul></blockquote><h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h2><p>本题与以上的回溯法不同之处在于，本题是二重循环来进行遍历</p><p>总觉得时间复杂度会极高</p><p>同样，本题也需要单独写一个判断有效函数，有效函数行和列好判断，问题在于九宫格的判断；可以发现，本题数组下标是从0开始的，也就是说 012     345  678，由此可以想到，val除以3，得到start，然后再*三，就得到九宫格</p><blockquote><p>返回值</p></blockquote><p>回溯函数返回值是boolean，目的是找到一个正确的解，一旦找到正确的解就返回；在两层for循环之后，若是还找不到正确的解，就返回false，所以不需要终止条件！</p><blockquote><p>原创数字</p></blockquote><p>如果不注意，就会把人家的原创数字毁掉，这时就需要用continue来跳过原创数字</p><blockquote><p>单层处理逻辑</p></blockquote><p>在进行单层处理时，可以做如下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">board[i][j] = m;<br><span class="hljs-keyword">if</span> (tracking(board))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br></code></pre></td></tr></table></figure><p>2-3行为什么要用if呢，必须的！若是找到了解，则直接返回true；</p><blockquote><p>递归体现在哪里？</p></blockquote><p>上述有个continue操作，遇到数字就跳过，因为上一层中已经新设定了数字，所以这一层就不会动上一层的数字，从而达到回溯效果</p><h2 id="回溯法总结"><a href="#回溯法总结" class="headerlink" title="回溯法总结"></a>回溯法总结</h2><p>可以解决如下问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>子集问题分析：</p><ul><li>时间复杂度：O(2^n)，因为每一个元素的状态无外乎取与不取，所以时间复杂度为O(2^n)</li><li>空间复杂度：O(n)，递归深度为n，所以系统栈所用空间为O(n)，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为O(n)</li></ul><p>排列问题分析：</p><ul><li>时间复杂度：O(n!)，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ….. 1 = n!。</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>组合问题分析：</p><ul><li>时间复杂度：O(2^n)，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>N皇后问题分析：</p><ul><li>时间复杂度：O(n!) ，其实如果看树形图的话，直觉上是O(n^n)，但皇后之间不能见面所以在搜索的过程中是有剪枝的，最差也就是O（n!），n!表示n * (n-1) * …. * 1。</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>解数独问题分析：</p><ul><li>时间复杂度：O(9^m) , m是’.’的数目。</li><li>空间复杂度：O(n^2)，递归的深度是n^2</li></ul><p><strong>一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括吧！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2022/09/16/er-cha-shu/"/>
      <url>/2022/09/16/er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树最近公共祖先"><a href="#二叉树最近公共祖先" class="headerlink" title="二叉树最近公共祖先"></a>二叉树最近公共祖先</h2><p>思路：</p><p>找p,q;必须要遍历整棵树，自底向上遍历，采用后序遍历</p><p>找到p或q就返回q或q的结点，找不到则返回空；若是发现左子树和右子树都不为空，那就说明，当前结点root就是最近的公共祖先；若是发现左子树为空，右子树不为空，则说明是通过右子树返回的，返回右子树即可</p><p>所以逻辑就很清楚了：</p><ol><li>先判断root是否为p q null 这几种情况 </li><li>left = 递归方法；</li><li>right = 递归方法；</li><li>再判断左右子树是否为空的情况，据此来返回二叉树最近公共祖先</li></ol><h2 id="二叉树搜索最近公共祖先"><a href="#二叉树搜索最近公共祖先" class="headerlink" title="二叉树搜索最近公共祖先"></a>二叉树搜索最近公共祖先</h2><p>一种思路是上述的二叉树最近公共祖先</p><p>另一种思路就是利用二叉搜索树的性质</p><p>思路：</p><p>如果当前结点同时大于p、q，那么就说明应该在左子树找；反之，在右子树找；如果发现一边大一边小，那么直接返回当前结点，当前结点就是最近公共祖先</p><p>第三种思路，迭代法</p><p>迭代法：</p><p>用一个while循环，若当前结点同时大于p、q，往左子树走；反之，往右子树走；否则，直接返回</p><p><strong>秒！！！</strong></p><h2 id="二叉搜索树的插入操作"><a href="#二叉搜索树的插入操作" class="headerlink" title="二叉搜索树的插入操作"></a>二叉搜索树的插入操作</h2><p>我的想法是，首先备份root结点（通过创建一个新节点），然后while写一个死循环，若找到插入位置，则break，最后返回即可。</p><p>上述为迭代法</p><p>下面是递归法：</p><p>若root为空，则创建一个新结点，说明找到位置了</p><p>若root大于当前结点，则递归左子树调用方法</p><p>若root小于当前结点，则递归右子树调用方法</p><h2 id="删除二叉搜索树中的结点"><a href="#删除二叉搜索树中的结点" class="headerlink" title="删除二叉搜索树中的结点"></a>删除二叉搜索树中的结点</h2><p>递归三部曲</p><ul><li>确定递归函数以及返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ul><p>思路：</p><p>一共有五种情况：</p><ol><li>根节点为空，则返回root，说明递归结束（没找到）；</li><li>根节点左右子树都为空，则返回null，说明是叶子结点，直接删掉；</li><li>根节点左子树为空右子树不为空，返回右子树；</li><li>根节点左子树不为空右子树为空，返回左子树；</li><li>根节点左右子树都不为空，则将左子树放到右子树的最左子树处，返回右子树。</li></ol><h2 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h2><p>剪枝操作</p><p>给定范围(low, high)</p><p>若根节点小于low，直接去操作右子树，左子树已然全部挂</p><p>同理，若根节点大于high，直接去操作左子树</p><p>若root在合理范围内，则递归操作左右子树</p><h2 id="将有序数组转为二叉搜索树"><a href="#将有序数组转为二叉搜索树" class="headerlink" title="将有序数组转为二叉搜索树"></a>将有序数组转为二叉搜索树</h2><p>注意数组越界，在二分法时要注意： int mid = left + ((right - left) / 2);</p><p>思路:</p><p>因为是有序，所以直接按区间划分，每次将中间结点赋值给root结点，然后递归的划分区间</p><h2 id="把二叉搜索树转化为累加树"><a href="#把二叉搜索树转化为累加树" class="headerlink" title="把二叉搜索树转化为累加树"></a>把二叉搜索树转化为累加树</h2><p>因为是二叉搜索树，所以中序遍历就是升序。</p><p>因为本题要累加，如果从最小的开始加的话，无法知道后续大于最小的数的累加；所以只能从最大的开始，从最大的开始的话，那直接对中序遍历做一个右中左的处理，即可达到逆序输出；</p><p>处理结点是先创建一个pre，来保存先前的数，而后一直加下去</p><h2 id="二叉树总结"><a href="#二叉树总结" class="headerlink" title="二叉树总结"></a>二叉树总结</h2><h3 id="1、二叉树的理论基础"><a href="#1、二叉树的理论基础" class="headerlink" title="1、二叉树的理论基础"></a>1、二叉树的理论基础</h3><ul><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于二叉树，你该了解这些！ (opens new window)</a>：二叉树的种类、存储方式、遍历方式、定义方式</li></ul><h3 id="2、二叉树的遍历方式"><a href="#2、二叉树的遍历方式" class="headerlink" title="2、二叉树的遍历方式"></a>2、二叉树的遍历方式</h3><ul><li>深度优先遍历<ul><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">二叉树：前中后序递归法 (opens new window)</a>：递归三部曲初次亮相</li><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">二叉树：前中后序迭代法（一） (opens new window)</a>：通过栈模拟递归</li><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html">二叉树：前中后序迭代法（二）统一风格(opens new window)</a></li></ul></li><li>广度优先遍历<ul><li><a href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">二叉树的层序遍历 (opens new window)</a>：通过队列模拟</li></ul></li></ul><h3 id="3、求二叉树的属性"><a href="#3、求二叉树的属性" class="headerlink" title="3、求二叉树的属性"></a>3、求二叉树的属性</h3><ul><li>二叉树：是否对称(opens new window)<ul><li>递归：后序，比较的是根节点的左子树与右子树是不是相互翻转</li><li>迭代：使用队列/栈将两个节点顺序放入容器中进行比较</li></ul></li><li>二叉树：求最大深度(opens new window)<ul><li>递归：后序，求根节点最大高度就是最大深度，通过递归函数的返回值做计算树的高度</li><li>迭代：层序遍历</li></ul></li><li>二叉树：求最小深度(opens new window)<ul><li>递归：后序，求根节点最小高度就是最小深度，注意最小深度的定义</li><li>迭代：层序遍历</li></ul></li><li>二叉树：求有多少个节点(opens new window)<ul><li>递归：后序，通过递归函数的返回值计算节点数量</li><li>迭代：层序遍历</li></ul></li><li>二叉树：是否平衡(opens new window)<ul><li>递归：后序，注意后序求高度和前序求深度，递归过程判断高度差</li><li>迭代：效率很低，不推荐</li></ul></li><li>二叉树：找所有路径(opens new window)<ul><li>递归：前序，方便让父节点指向子节点，涉及回溯处理根节点到叶子的所有路径</li><li>迭代：一个栈模拟递归，一个栈来存放对应的遍历路径</li></ul></li><li>二叉树：递归中如何隐藏着回溯(opens new window)<ul><li>详解<a href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html">二叉树：找所有路径 (opens new window)</a>中递归如何隐藏着回溯</li></ul></li><li>二叉树：求左叶子之和(opens new window)<ul><li>递归：后序，必须三层约束条件，才能判断是否是左叶子。</li><li>迭代：直接模拟后序遍历</li></ul></li><li>二叉树：求左下角的值(opens new window)<ul><li>递归：顺序无所谓，优先左孩子搜索，同时找深度最大的叶子节点。</li><li>迭代：层序遍历找最后一行最左边</li></ul></li><li>二叉树：求路径总和(opens new window)<ul><li>递归：顺序无所谓，递归函数返回值为bool类型是为了搜索一条边，没有返回值是搜索整棵树。</li><li>迭代：栈里元素不仅要记录节点指针，还要记录从头结点到该节点的路径数值总和</li></ul></li></ul><h3 id="4、二叉树的修改与构造"><a href="#4、二叉树的修改与构造" class="headerlink" title="4、二叉树的修改与构造"></a>4、二叉树的修改与构造</h3><ul><li>翻转二叉树(opens new window)<ul><li>递归：前序，交换左右孩子</li><li>迭代：直接模拟前序遍历</li></ul></li><li>构造二叉树(opens new window)<ul><li>递归：前序，重点在于找分割点，分左右区间构造</li><li>迭代：比较复杂，意义不大</li></ul></li><li>构造最大的二叉树(opens new window)<ul><li>递归：前序，分割点为数组最大值，分左右区间构造</li><li>迭代：比较复杂，意义不大</li></ul></li><li>合并两个二叉树(opens new window)<ul><li>递归：前序，同时操作两个树的节点，注意合并的规则</li><li>迭代：使用队列，类似层序遍历</li></ul></li></ul><h3 id="5、求二叉搜索树的属性"><a href="#5、求二叉搜索树的属性" class="headerlink" title="5、求二叉搜索树的属性"></a>5、求二叉搜索树的属性</h3><ul><li><a href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html">二叉搜索树中的搜索(opens new window)</a><ul><li>递归：二叉搜索树的递归是有方向的</li><li>迭代：因为有方向，所以迭代法很简单</li></ul></li><li><a href="https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">是不是二叉搜索树(opens new window)</a><ul><li>递归：中序，相当于变成了判断一个序列是不是递增的</li><li>迭代：模拟中序，逻辑相同</li></ul></li><li><a href="https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html">求二叉搜索树的最小绝对差(opens new window)</a><ul><li>递归：中序，双指针操作</li><li>迭代：模拟中序，逻辑相同</li></ul></li><li><a href="https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html">求二叉搜索树的众数(opens new window)</a><ul><li>递归：中序，清空结果集的技巧，遍历一遍便可求众数集合</li><li><a href="https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html">二叉搜索树转成累加树(opens new window)</a></li><li>递归：中序，双指针操作累加</li><li>迭代：模拟中序，逻辑相同</li></ul></li></ul><h3 id="6、二叉树公共祖先问题"><a href="#6、二叉树公共祖先问题" class="headerlink" title="6、二叉树公共祖先问题"></a>6、二叉树公共祖先问题</h3><ul><li>二叉树的公共祖先问题(opens new window)<ul><li>递归：后序，回溯，找到左子树出现目标值，右子树节点目标值的节点。</li><li>迭代：不适合模拟回溯</li></ul></li><li>二叉搜索树的公共祖先问题(opens new window)<ul><li>递归：顺序无所谓，如果节点的数值在目标区间就是最近公共祖先</li><li>迭代：按序遍历</li></ul></li></ul><h3 id="7、二叉搜索树的修改与构造"><a href="#7、二叉搜索树的修改与构造" class="headerlink" title="7、二叉搜索树的修改与构造"></a>7、二叉搜索树的修改与构造</h3><ul><li>二叉搜索树中的插入操作(opens new window)<ul><li>递归：顺序无所谓，通过递归函数返回值添加节点</li><li>迭代：按序遍历，需要记录插入父节点，这样才能做插入操作</li></ul></li><li>二叉搜索树中的删除操作(opens new window)<ul><li>递归：前序，想清楚删除非叶子节点的情况</li><li>迭代：有序遍历，较复杂</li></ul></li><li>修剪二叉搜索树(opens new window)<ul><li>递归：前序，通过递归函数返回值删除节点</li><li>迭代：有序遍历，较复杂</li></ul></li><li>构造二叉搜索树(opens new window)<ul><li>递归：前序，数组中间节点分割</li><li>迭代：较复杂，通过三个队列来模拟</li></ul></li></ul><h3 id="8、阶段总结"><a href="#8、阶段总结" class="headerlink" title="8、阶段总结"></a>8、阶段总结</h3><p>大家以上题目都做过了，也一定要看如下阶段小结。</p><p><strong>每周小结都会对大家的疑问做统一解答，并且对每周的内容进行拓展和补充，所以一定要看，将细碎知识点一网打尽！</strong></p><ul><li><a href="https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20200927%E4%BA%8C%E5%8F%89%E6%A0%91%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html">本周小结！（二叉树系列一）(opens new window)</a></li><li><a href="https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201003%E4%BA%8C%E5%8F%89%E6%A0%91%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html">本周小结！（二叉树系列二）(opens new window)</a></li><li><a href="https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201010%E4%BA%8C%E5%8F%89%E6%A0%91%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html">本周小结！（二叉树系列三）(opens new window)</a></li><li><a href="https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201017%E4%BA%8C%E5%8F%89%E6%A0%91%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html">本周小结！（二叉树系列四）(opens new window)</a></li></ul><h3 id="9、最后总结"><a href="#9、最后总结" class="headerlink" title="9、最后总结"></a>9、最后总结</h3><p><strong>在二叉树题目选择什么遍历顺序是不少同学头疼的事情，我们做了这么多二叉树的题目了，Carl给大家大体分分类</strong>。</p><ul><li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li><li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li><li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li></ul><p>注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序，<a href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html">二叉树：找所有路径 (opens new window)</a>也用了前序，这是为了方便让父节点指向子节点。</p><p>所以求普通二叉树的属性还是要具体问题具体分析。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="/2022/09/16/dan-diao-zhan/"/>
      <url>/2022/09/16/dan-diao-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>在使用单调栈的时候首先要明确如下几点：</p><ol><li>单调栈里存放的元素是什么？</li></ol><p>单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。</p><ol><li>单调栈里元素是递增呢？ 还是递减呢？</li></ol><p><strong>注意一下顺序为 从栈头到栈底的顺序</strong>，因为单纯的说从左到右或者从前到后，不说栈头朝哪个方向的话，大家一定会越看越懵。</p><h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h2><p>思路一：暴力，两层for循环就可以解决问题</p><p>思路二：单调栈</p><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。</p><p>单调栈时间复杂度为O(n)</p><p>本题使用栈头到栈尾递增，注意单调栈里面放的是元素的下标i</p><p>若是栈尾元素大于等于当前元素，直接进栈；否则栈尾元素小于当前元素的话，先弹出比当前元素小的栈尾（用while判断），再入栈</p><h2 id="下一个更大元素I"><a href="#下一个更大元素I" class="headerlink" title="下一个更大元素I"></a>下一个更大元素I</h2><p>首先想到暴力解法，外层遍历nums1，内层遍历nums2，当然可以，时间复杂度是O(n*2)</p><p>也可使用单调栈</p><p>我是这么想的，先用“每日温度”的思路，把nums2寻找右侧第一个比自己大的元素的位置找到，然后再遍历num1。可以一试；NO，到最后给res赋值的时候，找不到nums2的具体位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(nums2[i] &lt;= nums2[stack.peek()])    <span class="hljs-comment">//  小于等于，继续往里放</span><br>     stack.push(i);<br><span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()]) &#123;<br>           <span class="hljs-keyword">if</span> (hashMap.containsKey(nums2[stack.peek()])) &#123;<br>                  <span class="hljs-type">Integer</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> hashMap.get(nums2[stack.peek()]); <span class="hljs-comment">//先取出nums2的下标，再赋值给nums1</span><br>                  res[index] = nums2[i];<br>           &#125;<br>           stack.pop();<br>     &#125;<br>     stack.push(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>重点是第6、7行的代码</p><p>目的是nums1要从nums2中取出数；比如下面的nums[1],   nums[1] = 1,计算nums2中1的右边第一个大的元素，返回的是nums2[1]而不是下标1</p><p><img src="/2022/09/16/dan-diao-zhan/Typora文件\Typora图片\image-20220915111659905.png" alt="image-20220915111659905"></p><h2 id="下一个更大元素II"><a href="#下一个更大元素II" class="headerlink" title="下一个更大元素II"></a>下一个更大元素II</h2><p>本题加了个循环，个人想法是两遍，数组遍历两遍，当成一个数组来做</p><p>确实可以，但是做了无用功，例如扩充数组，扩充数组就不说了，最后还需要将res数组又缩小</p><p>卡哥思路：跟上题大体上类似，只不过本题是遍历了2倍的数组，然后循环的时候计算用i%size来计算</p><p>这种单调栈，我觉得最重要的是赋值的处理，循环内的关键代码的书写</p><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>三种思路：</p><p>一、双指针法</p><p>要求雨水，按列来求，雨水的高度等于该列左侧最高高度和右侧最高高度中低的那个，只需要将左右侧低的那个柱子的高度减去当前列柱子的高度，就可求出该列的雨水，然后从0循环，求总和</p><p>二、动态规划法</p><p>牛蛙牛蛙</p><p>动态规划思路和双指针法其实差不多，只不过由于双指针法存在着大量重复的操作，动态规划优化了一下而已</p><p>动态规划要求将左侧最高高度和右侧最高高度都保存在对应的一个数组里，如maxleft[], maxright[]</p><p>递推公式：左边的最高高度为上一个的最高高度和当前的高度取最大值，右侧同理</p><p>从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);</p><p>从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);</p><p>最后求和</p><p>本题动态规划最简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] maxleft = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[height.length];<br><span class="hljs-type">int</span>[] maxright = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[height.length];<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>maxleft[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>maxright[height.length - <span class="hljs-number">1</span>] = height[height.length - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; height.length; i++) &#123;<br>     maxleft[i] = Math.max(maxleft[i - <span class="hljs-number">1</span>], height[i]);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> height.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>     maxright[i] = Math.max(maxright[i + <span class="hljs-number">1</span>], height[i]);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; height.length; i++) &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> Math.min(maxleft[i], maxright[i]) - height[i];<br>     <span class="hljs-keyword">if</span> (area &gt; <span class="hljs-number">0</span>)<br>          sum += area;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br></code></pre></td></tr></table></figure><p>三、单调栈法</p><p>单调栈法比较难理解，单调栈法是维持栈内从栈头到栈尾从小到大的顺序排列，一旦发现新入栈的元素值大于栈顶元素，就弹出栈顶元素，此时栈顶元素就是底部，再弹出栈顶元素，栈顶元素就是左侧柱子，新入栈的元素就是右侧柱子；</p><p>思路有了，其中还有一些小细节。</p><p>求雨水的高度就是长乘宽，长是高度，宽是右侧与左侧柱子之间的距离，相加。</p><blockquote><p>关键代码：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stacktop]) &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">bottom</span> <span class="hljs-operator">=</span> stack.pop();    <span class="hljs-comment">//先把底柱的编号取出</span><br>     <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;   <span class="hljs-comment">//若是栈不为空的话，进行操作</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(height[i], height[stack.peek()]);    <span class="hljs-comment">//取出左边和右边的最小值，注意左柱为弹出</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> (min - height[bottom]) * (i - stack.peek() - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 求面积</span><br>          <span class="hljs-keyword">if</span> (area &gt; <span class="hljs-number">0</span>)<br>                sum += area;<br>          stacktop = stack.peek();   <span class="hljs-comment">//注意：左柱并没有弹出，而是更新栈顶元素，接着判断，因为是while</span><br>     &#125;<br>&#125;<br>stack.push(i);   <span class="hljs-comment">//最后再将当前元素进栈，进行下一次循环</span><br></code></pre></td></tr></table></figure><h2 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h2><p>感觉这类题动态规划可能好一点？</p><p>本题跟接雨水那道题类似，只不过本题换成了求当前柱子左右两边第一个小于该柱子的柱子</p><p>还有一个区别，是本题要记录下标，而不是高度</p><blockquote><p>思路一：动态规划</p></blockquote><p>动态规划主要体现在求两侧第一个小于该柱子的柱子上</p><ul><li>求左侧：<br>从0开始遍历，使用一个变量t来记录，碰到大的，再往左走；碰到小的直接赋值</li><li>求右侧：<br>从length-2开始遍历，跟求左侧一样</li></ul><p>最后求和，求最大</p><blockquote><p>思路二：单调栈</p></blockquote><p>也能成功AC，但是很明显，单调栈的用时更长</p><p>维持一个栈头到栈尾由大到小的栈，若是遇到当前元素大于栈头元素的，直接进栈；等于也是直接进栈；当前元素小于栈头元素的，那么当前栈顶元素就是底柱，栈顶弹出后，当前元素的栈顶是左柱，i是右柱；即可求出面积，并同求最大值。</p><p>但是需要数组扩容，两边同时扩一下；可能是为了防止i = 1的时候前面没有元素可弹出现栈溢出的错误吧。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2022/09/16/dong-tai-gui-hua/"/>
      <url>/2022/09/16/dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划通俗来讲就是由上一个状态推导出来的</p><p>状态转移公式</p><p>一般解题步骤有以下五步：</p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p>动态规划Debug</p><p>先确定状态转移公式，做到心中有数；若没通过，打印出来，看看与自己心中所想是否一样；若是一样的，那就是递推公式、初始化或者遍历顺序有问题了。</p><p>==问题要问的专业==</p><h2 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h2><p>DP五部曲：</p><ol><li><p>确定dp数组以及下标含义：dp[i]的定义：第i个数的斐波那契数值是dp[i]</p></li><li><p>确定递推公式：题目已经给了，<strong>状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p></li><li><p>如何初始化：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">dp[0] = 0;<br>dp[1] = 1;<br></code></pre></td></tr></table></figure></li><li><p>确定遍历顺序：从前往后遍历</p></li><li><p>举例推导dp数组：按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p><p>0 1 1 2 3 5 8 13 21 34 55</p></li></ol><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p>dp[i]的定义：  第i个阶梯有多少种爬楼梯的方式</p><p>递推公式：  </p><p>Out！</p><p>卡哥思路：</p><ol><li>dp[i]的定义：  第i个阶梯有多少种爬楼梯的方式</li><li>递推公式：<br>先想dp[i - 1]，dp[i - 1] 再爬上一阶就是dp[i];再想dp[i - 2]，dp[i - 2]再爬上两阶就是dp[i]；<br>所以dp[i] = dp[i - 1] + dp[i - 2];</li><li>初始化就有争议了：但是注意看题目的范围，题目说的是n为整数，那么自然从1开始喽，初始化1、2，然后从3开始遍历</li><li>确定遍历顺序：从前往后遍历</li><li>举例推导dp数组：<br><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220624112625495.png" alt="image-20220624112625495"></li></ol><p>递推公式这样想： i层 = i - 1 层 + i- 2 层的</p><p>有多少种方法达到i-1层，先记为n1,；有多少种方法达到i-2层，再记为n2；让这俩相加即可</p><h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h2><p>但是这道题好像也可以用贪心？</p><ol><li>dp[i]表示前i阶楼梯所用的花费</li><li>递推公式：<br>不会了</li></ol><p>不能用贪心</p><p>接着来</p><ol><li>dp[i]表示前i阶楼梯所用的花费</li><li>递推公式：<br>从i-1和i-2处下手，dp[i] = min(dp[i-1], dp[i - 2]) + cost[i];<br>不会递推公式了就从i-1和i-2下手</li><li>初始化：只需初始化dp[0]和dp[1]即可</li><li>确定遍历顺序，本体显然是从前到后</li><li>举例推导</li></ol><p>个人觉得dp完了之后还要验算一下结尾情况</p><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义，dp[i] [j]表示到达这一步有多少种走法，最后返回dp[m] [n]即可</li><li>递推公式：<br>dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1];</li><li>初始化：<br>dp[0] [0] = 1；dp[0] [1] = 1；dp[1] [0] = 1；</li><li>二维数组进行遍历，双重循环</li><li>举例推导</li></ol><p>上述五部曲中，有问题的是第三点和第四点。首先第三点初始化，初始化只初始化了  0 1   和 1 0，但是要是碰到0 2 和2 0 呢？会报错，所以边界都要考虑到位，至于说是具体是几种走法，当然是一种啦，因为边界，只有从边界这一侧走过来；第四点遍历顺序，不够细致，是从左到右为主呢还是从上到下为主，其实我觉得都可以，但是要写出来，从左到右顺理成章。</p><p>成功AC</p><p>还有一种思路：</p><p>数论方法：</p><p>组合数学中学到的蚂蚁上树问题，厉害厉害！</p><p>组合问题，从（0，0）到（m, n），共需要 m + n - 2步，需要m - 1步的向右，所以就是</p><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220627101912530.png" alt="image-20220627101912530"></p><p>Yse, AC !</p><p>long 转int:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回int型</span><br><span class="hljs-type">long</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">300</span>;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)a;<br></code></pre></td></tr></table></figure><h2 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h2><p>中间有障碍物了；</p><p>个人思路：与上一题dp一样，只不过多了一个障碍物判断</p><ol><li>确定dp数组的含义，dp[i] [j]表示到达这一步有多少种走法，最后返回dp[m] [n]即可</li><li>递推公式：<br>dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1];中间加一个判断是否为障碍物</li><li>初始化：<br>所有边界都初始化为1</li><li>一层一层的来，从左到右，从上到下</li><li>举例推导</li></ol><p>Yes   成功AC，改了半天bug，问题在于初始化，若是碰到在边界的障碍物，该怎么初始化？应该将其以及其后面的边界全置位0</p><p>看了卡哥的代码，感觉自己好蠢啊，其实可以不用分的这么细，只考虑需要的情况即可，例如进行初始化时我是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; obstacleGrid.length; i++) &#123;<br>          <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)<br>              flag = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>)<br>              dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">else</span><br>              dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>      &#125;<br>      flag = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; obstacleGrid[<span class="hljs-number">0</span>].length; j++) &#123;<br>          <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>)<br>              flag = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>)<br>              dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">else</span><br>              dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>      &#125;<br></code></pre></td></tr></table></figure><p>卡哥是这样的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>   <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//一旦遇到障碍，后续都到不了</span><br>   dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>   <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">////一旦遇到障碍，后续都到不了</span><br>   dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      &#125;<br></code></pre></td></tr></table></figure><p>遍历优化,我的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obstacleGrid[i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span> &amp;&amp; obstacleGrid[i][j - <span class="hljs-number">1</span>] != <span class="hljs-number">1</span>)<br>dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obstacleGrid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> &amp;&amp; obstacleGrid[i - <span class="hljs-number">1</span>][j] != <span class="hljs-number">1</span>)<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br><span class="hljs-keyword">else</span><br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>但其实，这三种可以合为一种，因为碰到一种情况时，另一个dp就为0，所以加上也无所谓</p><p>可以直接合为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><p>动态规划五部曲：</p><ol><li>确定dp[i]的意思：dp[i]表示 i可以拆分成的最大乘积。下面想不通了可以回来想想dp[i]的含义；</li><li>确定递推公式：递归公式若是不好想的话，可以往回想想，想想i - 1或者是dp[i]是怎么得来的。可以分为两部分：  j *(i - j)或者 j *dp[i - j]，二者取最大值。这为什么可以呢，第一个是把 i直接分为两个数的乘积，第二个是把i分为两个以上的乘积，j从1开始遍历，一直去最大值即可；</li><li>初始化：dp[1] = 1;dp[2] = 1; dp[3] = 2;</li><li>遍历顺序从前到后，两层遍历；外层是i: 3到i，内层是j: 1到i</li><li>举例推导</li></ol><p>这道题遍历的时候，卡哥内层是从1遍历到i - j，卡哥说是后面重复了，但是由于我还没有相同，所以直接用的 1到i</p><h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h2><p>动态规划五部曲：</p><ol><li>确定dp[i]的意思：dp[i]的意思是i个节点的二叉搜索树共有dp[i]种</li><li>确定递推公式：往回想，如果求dp[3]的时候，先想dp[2],然后再怎么演化为dp[3]，但是演化，我想到的是：分为大于部分和小于部分，但是中间部分呢？<br>dp[i] = 2 * dp[i - 1] + 1？</li><li>初始化：</li></ol><p>卒！</p><p>第二步就错了。</p><p>卡哥思路：画图，先画出一个节点的数量，再画出两个节点的数量；然后画第三个节点的时候，分为几种情况，1为节点头，2为节点头，3为节点头。</p><p>1为节点头时，数量就是dp[2]；2为节点头时，数量就是d[1]*d[1];3为节点头时，数量就是dp[2]。</p><p>所以接着上述：</p><ol><li></li><li>递推公式：dp[i]  += dp[j - 1] * dp[i - j];  j从1开始</li><li>初始化：只需初始化dp[0] = 1即可</li><li>遍历顺序当然是从前往后遍历</li><li>举例推导 </li></ol><p>成功AC！但是递推公式到底怎么想出来的。</p><p>当i = 3时，   0 2；  1 1； 2 0  </p><p>j从0开始，到i - 1。</p><p>递推公式依然是从前面几个入手，从而推出i是怎么来到 。</p><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220628110720342.png" alt="image-20220628110720342"></p><h3 id="01背包问题（二维数组）"><a href="#01背包问题（二维数组）" class="headerlink" title="01背包问题（二维数组）"></a>01背包问题（二维数组）</h3><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>动态规划五部曲：</p><ol><li><p>确定dp数组以及含义：对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p></li><li><p>那么可以有两个方向推出来dp[i] [j]，</p><ul><li><strong>不放物品i</strong>：由dp[i - 1] [j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1] [j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</li><li><strong>放物品i</strong>：由dp[i - 1] [j - weight[i]]推出，dp[i - 1] [j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1] [j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li></ul><p>递归公式： dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);</p></li><li><p>初始化：首先从dp[i] [j]的定义出发，如果背包容量j为0的话，即dp[i] [0]，无论是选取哪些物品，背包价值总和一定为0。</p><p>状态转移方程 dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p><p>dp[0] [j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p><p>那么很明显当 j &lt; weight[0]的时候，dp[0] [j] 应该是 0，因为背包容量比编号0的物品重量还小。</p><p>当j &gt;= weight[0]时，dp[0] [j] 应该是value[0]，因为背包容量放足够放编号0物品。</p><p>代码初始化如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; j &lt; weight[<span class="hljs-number">0</span>]; j++) &#123;  <span class="hljs-comment">// 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。</span><br>    dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 正序遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>其他的下标可以初始化为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化 dp</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(weight.size()</span>, vector&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220628112932740.png" alt="image-20220628112932740"></p></li><li><p>确定遍历顺序，先遍历物品后遍历背包重量和先遍历背包重量后遍历物品都可以，只是先遍历物品更容易理解。<br>先遍历物品：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]; <br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先遍历背包重量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>举例推导</p></li></ol><p>Java完整01背包代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>        <span class="hljs-type">int</span>[] value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bagsize</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>        testweightbagproblem(weight, value, bagsize);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testweightbagproblem</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weight, <span class="hljs-type">int</span>[] value, <span class="hljs-type">int</span> bagsize)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">wlen</span> <span class="hljs-operator">=</span> weight.length, value0 = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//定义dp数组：dp[i][j]表示背包容量为j时，前i个物品能获得的最大价值</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[wlen + <span class="hljs-number">1</span>][bagsize + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//初始化：背包容量为0时，能获得的价值都为0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= wlen; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = value0;<br>        &#125;<br>        <span class="hljs-comment">//遍历顺序：先遍历物品，再遍历背包容量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= wlen; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= bagsize; j++)&#123;<br>                <span class="hljs-keyword">if</span> (j &lt; weight[i - <span class="hljs-number">1</span>])&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i - <span class="hljs-number">1</span>]] + value[i - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//打印dp数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= wlen; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagsize; j++)&#123;<br>                System.out.print(dp[i][j] + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.print(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="01背包问题（滚动数组）"><a href="#01背包问题（滚动数组）" class="headerlink" title="01背包问题（滚动数组）"></a>01背包问题（滚动数组）</h3><p>滚动数组其实就是一维数组</p><p>动态规划五部曲：</p><ol><li><p>确定dp数组的定义<br>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p></li><li><p>一维dp数组的递推公式</p><p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p><p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p><p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1] [j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，所以递归公式为：   dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p></li><li><p>初始化数组，初始化一定要和定义联系在一起<br>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。<br>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p></li><li><p>遍历顺序：遍历顺序一定是先遍历物品，再遍历背包容量。并且遍历背包容量的时候，滚动数组一定是从大到小的遍历。为什么呢？因为滚动数组遍历的时候需要前面的值，但是前面的值一直变化，而从后往前的 话，前面的值就一直为0。</p></li><li><p>举例推导</p><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220629111108557.png" alt="image-20220629111108557"></p></li></ol><p>滚动数组遍历全代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-type">int</span>[] weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>       <span class="hljs-type">int</span>[] value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">bagWight</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>       testWeightBagProblem(weight, value, bagWight);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWeightBagProblem</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weight, <span class="hljs-type">int</span>[] value, <span class="hljs-type">int</span> bagWeight)</span>&#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">wLen</span> <span class="hljs-operator">=</span> weight.length;<br>       <span class="hljs-comment">//定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值</span><br>       <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bagWeight + <span class="hljs-number">1</span>];<br>       <span class="hljs-comment">//遍历顺序：先遍历物品，再遍历背包容量</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; wLen; i++)&#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bagWeight; j &gt;= weight[i]; j--)&#123;<br>               dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">//打印dp数组</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagWeight; j++)&#123;<br>           System.out.print(dp[j] + <span class="hljs-string">&quot; &quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>其实我还没完全理解明白！</p><h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2><p>这完全看不出来是要用动态规划啊。个人思路：先进行排序，然后从中间分成两个数组，每次判断是否相等，若是不相等，则从大的那边匀一个给小的，以此类推；最后要是发现大的那边最终小于小的那边了，则证明没有，返回false。</p><blockquote><p>回溯法：</p><ul><li>698.划分为k个相等的子集</li><li>473.火柴拼正方形</li></ul></blockquote><p>以上我的思路是也称为回溯暴力法，但是超时。直接上01背包</p><p>重点是要理解为何能嵌套01背包，以及重量以及容量都对应着什么。</p><p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p><ul><li>背包的体积为sum / 2</li><li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li><li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。</li><li>背包中每一个元素是不可重复放入。</li></ul><p>动态规划五部曲：</p><ol><li><p>确定dp数组含义：<br>**dp[j]表示 背包总容量是j，最大可以凑成j的子集总和为dp[j]**。</p></li><li><p>确定递推公式：<br>本题相当于背包里放数值，那么重量也就是nums[i]，其价值也是nums[i]<br>dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</p></li><li><p>如何初始化，跟滚动数组初始化一样，0初始化为0，其余整数初始化为0，负数初始化为负无穷</p></li><li><p>遍历顺序，同滚动数组，先遍历物品，放到这道题也就是nums[i]；嵌套遍历价值</p></li><li><p>举例推导</p><p>dp[j]的数值一定是小于等于j的。</p><p><strong>如果dp[j] == j 说明，集合中的子集总和正好可以凑成总和j，理解这一点很重要。</strong></p></li></ol><p>好好想想！！！</p><p>一层遍历最后的结果，也是一层一层，还是相当于两层遍历的结果，只不过最后保存的是i = nums.length 的值</p><h2 id="最后一块石头的重量II"><a href="#最后一块石头的重量II" class="headerlink" title="最后一块石头的重量II"></a>最后一块石头的重量II</h2><p>与昨天的分割等子集和类似，都是分割成两块重量相差最小的块，然后相减即可。<em>不过这道题与上题不同的是，其中一块的具体重量无法确定</em></p><p>本题物品重量store[], 价值也为store[]；对应01背包问题的物品重量和价值</p><ol><li>确定dp数组的含义：dp[j]表示j块石头相加得出来的总重量</li><li>确定递归函数：可以分为两步考虑，一个是不放第j块，另一个是放第j块；不放就是dp[j ], 放就是dp[j - store[j] ] + store[j]<br>所以：dp[j] = max(dp[j], dp[j - store[j] ] + store[j]  )</li><li>初始化：先全部初始化为0，之后肯定会一层一层的遍历；至于dp数组开到多大，一种做法是所有数相加再除以二；还有一种是看题目给的范围，直接范围除以二</li><li>遍历顺序：外层从前往后，内层从后往前</li><li>举例推导</li></ol><p>最后判断的时候，dp[j]表示可以装多大的重量，那么另一边就是sum - dp[j],那么相差最小就是 sum - dp[j] - dp[j]</p><p>上面斜体字写得 那一段，真是愚蠢！</p><p>dp不管如何分，只管target的大小，也就是总和 / 2；</p><p>其实动态规划二维数组和一维数组，本质上还是二维数组，只不过每次二维数组一次遍历，而一维数组进行多次遍历，最后只保留最后一次遍历的那次结果。</p><h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h2><p>瞟了一眼卡哥的思路，我只能说牛</p><p>首先给出了一个target，那么一定会有left 和right；   同时left + right = sum; 但是 target = left - (sum - left); 所以left = (target + sum) / 2,本题也就转换为求数组中有多少个和是left的组合</p><p>同样，动态规划五部曲：</p><ol><li><p>确定dp[]数组的含义：dp[j]数组表示和为j的有多少种方法</p></li><li><p>确定递归函数</p><p>确定递归函数的时候，考虑一下来源；来源有哪些呢？不考虑nums[i]的情况下，填满容量为j - nums[i]的背包，有dp[j - nums[i]]种方法。<br>考虑nums[i]的情况下，凑成dp[j]就有dp[j - nums[i]]种方法。</p><p>例如：dp[j]，j 为5，</p><ul><li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 dp[5]。</li><li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 dp[5]。</li><li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 dp[5]</li><li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 dp[5]</li><li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 dp[5]</li></ul><p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来</p><p>组合问题的公式：dp[j] += dp[j - nums[i]]</p></li><li><p>初始化：全初始化为0</p></li><li><p>遍历顺序：外层从前往后，内层从后往前</p></li><li><p>举例推导</p></li></ol><p>可以记住：在求装满背包有几种方法的时候，递推公式一般为：dp[j] += dp[j - nums[i]];</p><p>到最后动态规划总结的 时候，==一定要多总结各种dp公式==！！</p><h2 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h2><p>动态规划？</p><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]数组表示</li></ol><p>破功</p><p>动规五部曲：</p><ol><li><p>确定dp数组的含义：**dp[i] [j]：最多有i个0和j个1的strs的最大子集的大小为dp[i] [j]**。</p></li><li><p>确定递推公式</p><p>dp[i] [j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。</p><p>dp[i] [j] 就可以是 dp[i - zeroNum] [j - oneNum] + 1。</p><p>然后我们在遍历的过程中，取dp[i] [j]的最大值。</p><p>所以递推公式：dp[i] [j] = max(dp[i][j], dp[i - zeroNum] [j - oneNum] + 1);</p></li><li><p>dp数组如何初始化，初始化为0即可，因为物品重量不可能为0，所以只需初始化为0；</p></li><li><p>确定遍历顺序<br>外层for循环遍历物品，内层for循环遍历背包容量且从后向前遍历！</p></li><li><p>举例推导</p></li></ol><h2 id="零钱兑换II"><a href="#零钱兑换II" class="headerlink" title="零钱兑换II"></a>零钱兑换II</h2><p>一看到题目中的是钱币不限，就知道要用完全背包</p><ol><li>确定dp数组含义：dp[j]表示总金额为j的货币组合数为dp[j]</li><li>确定递推公式：dp[j]就是dp[j - coins[i]]（不考虑coins[i]）相加。<br>所以：dp[j] += dp[j - coins[i]]</li><li>如何初始化：dp[0] = 1,这是开始，其余初始化为0；</li><li>确定遍历顺序<br>到底是先遍历背包再遍历重量还是先遍历重量再遍历背包；先试想一下，若是先遍历背包再遍历重量，那么重量就会遍历好几次，可能就是排列；而先遍历重量再遍历背包的话，就是组合。若是是在无法确定，自己手动演示一遍</li><li>举例推导</li></ol><p>要想清楚，背包和物品套在本题是对应哪一部分</p><blockquote><p>再来理解一下递推公式：     dp[j] += dp[j - coins[i]]   ；代表遍历每个 coins，那么dp[j]就等于 前一个的相加，而前一个就用coins[i]来表示；所以会有   += 的出现。</p></blockquote><p><strong>注意：求装满背包有几种方法类似的题目，递推公式基本都是这样的</strong>。</p><h2 id="组合总和IV"><a href="#组合总和IV" class="headerlink" title="组合总和IV"></a>组合总和IV</h2><p>不对，自己哪里出了问题</p><ol><li>确定dp数组含义：dp[j]表示总和为j的组合数为dp[j]</li><li>确定递推公式：dp[j]就是dp[j - nums[i]]（不考虑nums[i]）相加。<br>所以：dp[j] += dp[j - nums[i]]</li><li>如何初始化：dp[0] = 1,这是开始，其余初始化为0；</li><li>确定遍历顺序<br>到底是先遍历背包再遍历重量还是先遍历重量再遍历背包；先试想一下，若是先遍历背包再遍历重量，那么重量就会遍历好几次，可能就是排列；而先遍历重量再遍历背包的话，就是组合。若是是在无法确定，自己手动演示一遍<br>那么本题，要求的是排列数，那就先遍历背包再遍历重量;</li><li>举例推导</li></ol><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><h2 id="爬楼梯-进阶版"><a href="#爬楼梯-进阶版" class="headerlink" title="爬楼梯(进阶版)"></a>爬楼梯(进阶版)</h2><ol><li>确定dp数组以及下标的含义<br><strong>dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法</strong>。</li><li>确定递推公式：<br>dp[i]有几种来源，dp[i-1],dp[i-2],dp[i-3]等等。dp[i] += dp[i - j]</li><li>dp如何初始化<br>dp[0] = 1,其余都初始化为0</li><li>确定遍历顺序<br>首先明确要求排列还是求组合，这是求排列问题；那么先遍历背包，再遍历重量</li><li>举例推导</li></ol><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>总金额为背包，coins为物品重量；要求件数最少</p><p>动态规划五部曲：</p><ol><li>确定dp数组含义：<br>dp[i]表示总金额为i的最少的硬币个数</li><li>确定递推公式：<br>先考虑dp[i]怎么来的，dp[i]由 dp[i - coins[j]]，然后一直遍历；那么就是dp[i] += dp[i - coins[j]]</li><li>初始化<br>dp[0] = 1,其余都为0</li><li>遍历顺序<br>组合还是排列？组合，那就先物品重量，再背包</li><li>举例推导</li></ol><p>错！</p><ol><li><p>确定dp数组含义：<br>dp[i]表示总金额为i的最少的硬币个数</p></li><li><p>确定递推公式：<br>先考虑dp[j]怎么来的，dp[j]由 dp[j - coins[i]]，</p><p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）</p><p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p><p>递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);</p></li><li><p>初始化<br>dp[0] = 0,其他的初始化的时候，要考虑要求最大值还是求最小值，题目是要求最小值，那么就赋值最大值，否则就会被dp[0]一直覆盖</p></li><li><p>遍历顺序<br>本题组合和排列均可，那就先背包还是先物品都可以</p></li><li><p>举例推导</p></li></ol><p>动态规划就算知道了五部曲，到现在还有两个难点：</p><ul><li>遍历时i 和 j的初始值赋值问题，尤其是内层循环，是从 0开始还是从coins[i]开始</li><li>写递推公式的判定问题，是直接写还是要满足什么条件再写</li></ul><h2 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h2><p>告诉你用动态规划，要怎么套</p><p>背包是整数n，重量是每个完全平方数，完全平方数可以重复使用，相当于完全背包问题；<strong>但是重量需要判断</strong></p><ol><li>确定dp数组的含义：dp[j]表示和为j的完全平方数的最少数量</li><li>确定递推公式：<br>dp[j]可以由dp[j - i *i] 得来，所以dp[j] = min(dp[j], dp[j - i * i] + 1);</li><li>初始化：因为要求最小值，所以初始化为最大值；dp[0] = 0;</li><li>确定遍历顺序：遍历顺序都可，就先遍历背包，再遍历重量吧</li><li>举例推导</li></ol><blockquote><p>突然发现一个特点，那就是遍历的时候，dp[j]还是dp[i]，是谁不知道，但是一定要满足的是，要从头开始遍历，不能断断续续，这也能确定一部分是i还是j</p></blockquote><p>==举例推导也很重要==</p><p>但是本题重要不需要判断，那么题目中要求的完全平方数体现在哪里呢？体现在递推公式上，递推公式是dp[j - i * i]，后面i * i就已经把那些不是完全平方数的排除了，不手动进行筛选，只在for循环里面进行筛选；也是一种思路</p><p>奥！我突然知道了，最内层循环的关键代码，dp[i]还是dp[j]要取决于代表的意义，==若i代表的是背包，则是dp[i]；反之==</p><h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h2><p>套动态规划、</p><p>字符串s相当于背包总重量，wordDict数组相当于物品重量；要求的是排列，组合肯定不行；</p><ol><li>确定dp数组的含义：dp[i]表示第i个位置可以匹配到</li><li></li></ol><p>OUT</p><p>思路不对。我的思路是求排列，但是若是遇到重复的 ？所以只需要组合</p><ol><li>确定dp数组的含义：dp[i]表示第i个位置可以匹配到</li><li>确定递推公式：<br>首先若是dp[j]为true的时候，说明  0-j 都可以遍历成功；那么若是存在   i - j 的字符串，则dp[i ]设置为true；if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true。</li><li>初始化：dp[0] = true；0是一定要初始化的，因为所有的判断都是以前面的为基础</li><li>遍历顺序：先遍历背包和先遍历物品都可以；但是推荐先遍历背包，若是先遍历物品的话，那就需要提前先把所有物品放进容器里</li><li>举例推导</li></ol><p>好难！ </p><h2 id="背包问题总结"><a href="#背包问题总结" class="headerlink" title="==背包问题总结=="></a>==背包问题总结==</h2><p>背包递推公式：</p><ul><li>问能否装满背包：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</li><li>问装满背包有几种方法：dp[j] += dp[j - nums[i]] ；</li><li>问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); </li><li>问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); </li></ul><p>遍历顺序：</p><ol><li><p>01背包<br>二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。</p></li><li><p>完全背包</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。<br>如果求最小数，那么两层for循环的先后顺序就无所谓了。</p></li></ol><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]表示前i个元素可以偷取的最大金额</li><li>确定递推公式：<br>我感觉要建立一个数组，确定是否已经选取；先假定选取第一个，然后不选第二个，再选第三个的时候判断第一个大还是第二个大；<br>dp[j]  += max(dp[j - 1], dp[j] )</li></ol><p>但是判定数组如何使用？</p><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]表示前i个元素可以偷取的最大金额</li><li>确定递推公式：<br>决定dp[i]的因素就是第i房间偷还是不偷。如果偷，那么就dp[i] = dp[i - 2] + nums[i]；若是不偷，则dp[i] = dp[i - 1]。但是这里要判断一下，这俩个那两个大，那么就是：dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])</li><li>初始化：直接初始化dp[0] = nums[0]，dp[1] = max(nums[0], nums[1])</li><li>确定遍历顺序：一层循环？从前往后遍历</li><li>举例推导</li></ol><p>动态规划并不是非要套什么01背包问题，像本题就不用，且单层循环</p><p>还要注意要判空处理，比如数组只有一个数或者是数组为空的情况</p><h2 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a>打家劫舍II</h2><p>本题相比上题，多了一个循环，也就是收尾是相连的；换句话说，就是选首不能选尾，选尾不能选首。可以把第一个数加到最后一个数后面这样处理吗？</p><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]表示前i个元素可以偷取的最大金额</li><li>确定递推公式：<br>决定dp[i]的因素就是第i房间偷还是不偷。如果偷，那么就dp[i] = dp[i - 2] + nums[i]；若是不偷，则dp[i] = dp[i - 1]。但是这里要判断一下，这俩个那两个大，那么就是：dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])</li><li>初始化：直接初始化dp[0] = nums[0]，dp[1] = max(nums[0], nums[1])</li><li>确定遍历顺序：一层循环？从前往后遍历</li><li>举例推导</li></ol><p>卡哥厉害！</p><p>分析如下：</p><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220708113513360.png" alt="image-20220708113513360"></p><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220708113521374.png" alt="image-20220708113521374"></p><p><img src="/2022/09/16/dong-tai-gui-hua/Typora文件\Typora图片\image-20220708113529354.png" alt="image-20220708113529354"></p><p>既然首尾不能同时存在，那么我手动切去首或者尾不就行了。</p><p>情况二三可以包含情况一，所以代码总体逻辑还是跟上题类似，只不过本题需要比较情况二和情况三谁大谁小</p><blockquote><p>两个问题（已理顺）</p></blockquote><ol><li>主函数边界问题<br>主函数边界问题要深入到动态规划函数里面，发现里面的前闭后开的，解决。</li><li>不用数组进行动态规划遍历问题<br>首先要清楚，遍历要用到i-1和i-2的，那么就要定义三个变量，一个是i-2，一个是i-1，一个是i；分别用x,y,z来表示。由于初始化全为0，所以先赋值i - 1；再赋值当前的i，也就是动态规划递推公式，最后更新i -2,也就是x</li></ol><h2 id="打家劫舍III"><a href="#打家劫舍III" class="headerlink" title="打家劫舍III"></a>打家劫舍III</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[j]表示到第j层可以偷到的最大金额</li><li>确定递推公式：  考虑dp[j]，dp[j]要么是j-2个加上j的，要么是j-1的；具体是哪个取决于哪个比较大。<br>所以递推公式：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j])</li><li>初始化：第一层初始化为root，第二层初始化为第一层和第二层的最大值；</li><li>遍历顺序：使用层序遍历，一层一层</li><li>举例推导</li></ol><p>卡哥思路：</p><p>树形动态规划又是另外一种情况：</p><ol><li><p>确定递归函数的参数和返回值<br>返回的就是dp数组</p></li><li><p>确定终止条件<br>在遍历的过程中，若遇到空节点，无论是偷或者不偷，都初始化为0；注意，是数组</p></li><li><p>确定遍历顺序：<br>使用后序遍历；通过递归左节点，得到左节点偷与不偷的金钱；通过递归右节点，得到左节点偷与不偷的金钱</p></li><li><p>确定单层递归的逻辑</p><p>首先明确一点，res[0, 1];res[0]代表不偷当前节点，res[1]代表偷当前节点<br>分两种情况，若是偷当前节点，则左右节点不能偷，val1 = cur-&gt;val + left[0] + right[0];若是不偷当前节点，那么就要偷左右节点，既然是偷左右节点，那当然是要找左右节点的最大值，val2 = max(left[0], left[1]) + max(right[0], right[1])</p></li><li><p>举例推导</p></li></ol><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>贪心：</p><p>牛！计算最左最小值，最优最大值，计算差值即可</p><p>动态规划五部曲：</p><ol><li>确定dp数组含义：dp[i] [0]表示今天持有股票所得的价值；dp[i] [1]表示今天不持有股票所得的价值</li><li>确定动态规划递推公式：首先要明确，持有并不代表今天买入，同样，不持有并不代表是今天卖出的；<br>那么问题明朗了，持有分两种情况，一种是今天买入，一种是今天不买入；所以dp[i] [0] = max(- prices[i], dp[i - 1] [0]);<br>不持有分两种情况，一种是今天卖出，一种是今天不卖出；所以dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</li><li>初始化：从递推公式上可以看出，都是基于前一个来进行递推，所以初始化dp[0] [0] = -prices[0], dp[0] [1] = 0;</li><li>遍历顺序：从前往后遍历</li><li>举例推导</li></ol><blockquote><p>注意，确定动态规划递推公式的时候，注意正负号；</p></blockquote><p>动态规划确定dp数组的时候，思路要打开，有可能二维数组是因为有两个不同的维度，比如物品重量和物品价值；但也有可能是做一个标记，0 和 1；</p><h2 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h2><p>动态规划五部曲：</p><ol><li>确定dp数组含义：dp[i] [0]表示今天持有股票所得的价值；dp[i] [1]表示今天不持有股票所得的价值</li><li>确定动态规划递推公式：首先要明确，持有并不代表今天买入，同样，不持有并不代表是今天卖出的；<br>那么问题明朗了，持有分两种情况，一种是今天买入，一种是今天不买入；今天买入的情况，要用昨天未买入的价值减去prices[i]，<strong>这一点也是与前一道题有所不同</strong>， 所以dp[i] [0] = max(dp[i - 1] [1] - prices[i], dp[i - 1] [0]);<br>不持有分两种情况，一种是今天卖出，一种是今天不卖出；所以dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</li><li>初始化：从递推公式上可以看出，都是基于前一个来进行递推，所以初始化dp[0] [0] = -proces[0], dp[0] [1] = 0;</li><li>遍历顺序：从前往后遍历</li><li>举例推导</li></ol><h2 id="买卖股票的最佳时机III"><a href="#买卖股票的最佳时机III" class="headerlink" title="买卖股票的最佳时机III"></a>买卖股票的最佳时机III</h2><p>动态规划五部曲：</p><ol><li><p>确定dp数组的含义：dp[i] [j], j 从 0 到4 ，分别代表着不操作，第一次买卖股票，第二次买卖股票</p></li><li><p>确定动态规划递推公式：<br>不操作就不用说了，达到dp[i] [1]有两种途径：</p><ul><li>今天购买，dp[i] [1] = dp[i - 1] [0] - prices[i]</li><li>今天沿用昨天的状态，dp[i] [1] = dp[i - 1] [1]</li></ul><p>取最大值：  dp[i] [1] = max(dp[i - 1] [0] - prices[i], dp[i - 1] [1])<br>同样 dp[i] [2] = max(dp[i - 1] [1] + prices[i], dp[i - 1] [2])</p><p>同理 dp[i] [3] = max(dp[i - 1] [2] - prices[i], dp[i - 1] [3])</p><p>​         dp[i] [4] = max(dp[i - 1] [3] + prices[i], dp[i - 1] [4])</p></li><li><p>如何初始化：<br>dp[0] [0] = 0;  dp[0] [1] = -prices[0];  dp[0] [2] = 0; dp[0] [3] = -prices[0];  dp[0] [4] = 0; </p></li><li><p>确定遍历顺序：从前往后遍历</p></li><li><p>举例推导</p></li></ol><h2 id="买卖股票的最佳时机IV-再考虑考虑"><a href="#买卖股票的最佳时机IV-再考虑考虑" class="headerlink" title="买卖股票的最佳时机IV(再考虑考虑)"></a>买卖股票的最佳时机IV(再考虑考虑)</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j],代表第i天的状态为j所剩下的最大现金<ul><li>j的状态表示为：<br>0代表什么都不干，；<br>1代表第一次买入<br>2代表第一次卖出<br>3代表第二次买入<br>4代表第二次卖出    那么j的范围就可以定义为2*k + 1</li></ul></li><li>确定动态规划递推公式：<br>要想达到dp[i] [1]有两种：今天买，或者今天沿用昨天的状态；  dp[i] [1] = dp[i - 1] [0] - prices[i]  ； dp[i] [1] = dp[i - 1] [1]   ，选最大的<br>同样，达到dp[i] [2]也有两种：今天卖，今天沿用昨天的状态；  dp[i] [2] = max(dp[i - 1] [1] + prices[i], dp[i - 1] [2])<br>遍历j，从0到2*k + 1即可</li><li>初始化：<br>dp[0] [0] = 0;   第一次买入的话，dp[0] [1] = -prices[i]  ;第一次卖出的话，dp[0] [2] = 0;同理，之后只要是买入，不管第几次，都是-prices[i]</li><li>确定遍历顺序：从前往后</li><li>举例推导</li></ol><h2 id="最佳买卖股票时机含冷冻期-再考虑考虑"><a href="#最佳买卖股票时机含冷冻期-再考虑考虑" class="headerlink" title="最佳买卖股票时机含冷冻期(再考虑考虑)"></a>最佳买卖股票时机含冷冻期(再考虑考虑)</h2><p>动态规划五部曲：</p><ol><li><p>确定dp数组的含义：dp[i] [j],代表第i天的状态为j所剩下的最大现金</p><ul><li>j的第一个状态：0，表示今天买入</li><li>j的第一个状态：1，表示今天保持卖出状态，且度过冷冻期</li><li>j的第一个状态：2，表示今天卖出</li><li>j的第一个状态：3，表示今天为冷冻期</li></ul></li><li><p>确定递推公式：<br>==!==想想dp[i] [0] 如何来的，也就是今天买入，一种是今天买入，另一种是今天保持买入状态。二者取最大：max(dp[i - 1] [0] + prices[i] , dp[i - 1] [0]);;<br>以上错误，没有考虑到冷冻期的存在</p><p>达到买入股票状态（状态一）即：dp[i] [0]，有两个具体操作：</p><ul><li>操作一：前一天就是持有股票状态（状态一），dp[i] [0] = dp[i - 1] [0]</li><li>操作二：今天买入了，有两种情况<ul><li>前一天是冷冻期（状态四），dp[i - 1] [3] - prices[i]</li><li>前一天是保持卖出股票状态（状态二），dp[i - 1] [1] - prices[i]</li></ul></li></ul><p>所以操作二取最大值，即：max(dp[i - 1] [3], dp[i - 1] [1]) - prices[i]</p><p>那么dp[i] [0] = max(dp[i - 1] [0], max(dp[i - 1] [3], dp[i - 1] [1]) - prices[i]);</p><p>达到保持卖出股票状态（状态二）即：dp[i] [1]，有两个具体操作：</p><ul><li>操作一：前一天就是状态二</li><li>操作二：前一天是冷冻期（状态四）</li></ul><p>dp[i] [1] = max(dp[i - 1] [1], dp[i - 1] [3]);</p><p>达到今天就卖出股票状态（状态三），即：dp[i] [2] ，只有一个操作：</p><ul><li>操作一：昨天一定是买入股票状态（状态一），今天卖出</li></ul><p>即：dp[i] [2] = dp[i - 1] [0] + prices[i];</p><p>达到冷冻期状态（状态四），即：dp[i] [3]，只有一个操作：</p><ul><li>操作一：昨天卖出了股票（状态三）</li></ul><p>dp[i] [3] = dp[i - 1] [2];<br>==注意：讨论的是买卖股票的状态，并不是今天一定要买卖==</p></li><li><p>初始化<br>主要考虑第0天如何初始化即可。<br>dp[0] [0] = -prices[0]<br>dp[0] [1] = 0 ,第0天没有卖出，初始化为0即可<br>dp[0] [2] = 0, dp[0] [3] = 0</p></li><li><p>遍历顺序，从前往后</p></li><li><p>举例推导</p></li></ol><p>本题官方给的答案也很清晰</p><h2 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a>买卖股票的最佳时机含手续费</h2><ol><li><p>确定dp数组的含义：dp[i] [0],  dp[i] [1]，分别代表着持有股票所得的最大收入和不持有股票所得的最大收入</p></li><li><p>确定动态规划递推公式：<br>达到dp[i] [0]有两种途径：</p><ul><li>昨天已购买，dp[i] [0] = dp[i - 1] [0]</li><li>今天购买，dp[i] [0] = dp[i - 1] [1] -  prices[i]</li></ul><p>达到dp[i] [1] 有两种途径</p><ul><li>昨天已卖出，dp[i] [1] = dp[i - 1] [1]</li><li>今天卖出，要加上手续费，dp[i] [1] = dp[i - 1] [0] + prices[i] -fee</li></ul></li><li><p>如何初始化：<br>dp[0] [1] = 0;  dp[0] [0] = -prices[0]; </p></li><li><p>确定遍历顺序：从前往后遍历</p></li><li><p>举例推导</p></li></ol><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]表示i之前包括i的最长递增子序列的个数</li><li>确定递推公式：<br>个人想法是从当前位置向前找第一个小于i的那个，然后+1<br>其实道理都一样，卡哥是用dp[i]和dp[j]+1中取最大值，j的范围是0 到 i - 1</li><li>初始化：先全部初始化为1；   遍历为二次循环，而不是一次循环</li><li>遍历顺序：从前往后    i外层，j内层</li><li>举例推导 </li></ol><h2 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]表示i之前包括i的最长连续递增子序列的个数</li><li>确定递推公式：<br>只需要判断nums[i] 和nums[i-1]谁大谁小，若i大，则dp[i] = dp[i - 1] + 1，否则令dp[i] = 1</li><li>初始化：先全部初始化为1； </li><li>遍历顺序：从前往后   </li><li>举例推导</li></ol><p>So Easy！</p><h2 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j] 表示以下标i-1结尾的a和以下标j-1结尾的b的最长重复子数组</li><li>确定递推公式：<br>通过以前的状态来判断，若是A和B数组相等，那么就令dp[i] [j] = dp[i - 1] [j - 1] + 1;</li><li>初始化：首先dp[0] [0]是无意义的，但为了方便后续，将dp[0] [0]  dp[0] [j] dp[i] [0]全部初始化为0；其实初不初始化的无所谓</li><li>遍历顺序，两层遍历</li><li>举例推导</li></ol><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j]表示从0到i-1的字符串1和从0到j-1的字符串2的最长公共子序列</li><li>确定递推公式：<br>两种结果：相等、不等；相等的情况：dp[i] [j] = dp[i - 1] [j - 1] + 1;不等的情况：取dp[i - 1] [j - 2]和dp[i - 2] [j - 1]的最大值</li><li>初始化：将带0的初始化为0，带0的毫无意义</li><li>遍历顺序：从递推公式可以看出，一定是从前到后，从上到下</li><li>举例推导</li></ol><h2 id="不相交的线"><a href="#不相交的线" class="headerlink" title="不相交的线"></a>不相交的线</h2><p>与上述最长公共子序列代码95%一致</p><h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i]表示前i个数的最大子序和</li><li>确定递推公式：<br>这么想，第i个数有两种情况，一种是直接加入dp[i]，另一种是从头算起，二者取最大</li><li>初始化：dp[0] = nums[0]</li><li>遍历顺序：从前到后</li><li>举例推导</li></ol><h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j]表示前i-1和前j - 1的字符串为子序列的个数</li><li>确定递推公式：<br>考虑两种情况：1、  i - 1 == j - 1，则dp[i] [j] = dp[i - 1] [ j - 1] + 1;2、i - 1 ！= j - 1，若不相等，那么T就要“删除”掉j - 1了，那么从数值上来看就相当于dp[i] [ j] = dp[i] [j - 1]</li><li>初始化：将带0的全部初始化为0</li><li>遍历顺序，两层循环，外层是i，遍历s；</li><li>举例推导</li></ol><p>==注意边界，每次都是边界出错；最后判断的是dp[s.length()] [t.length()]而不是dp[s.length()+1] [t.length()+1]==</p><blockquote><p>因为s.length()本身就不包括最后一个元素，属于是前闭后开</p></blockquote><h2 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j]表示前i-1和前j - 1的字符串为不同子序列的个数</li><li>确定递推公式：<br>两大块：1、相等  2、不等<br>1、相等： 可以用dp[i - 1] [j - 1]，也可以不用，为什么不用呢，是因为不同的子序列，可能得到的结果不同，所以就是dp[i - 2] [j - 1];二者相加，也即dp[i] [j] = dp[i - 1] [j - 1] + dp[i - 1] [j];<br>2、不等： 不等直接就是dp[i - 1] [j]，即dp[i] [j] = dp[i - 1] [j];</li><li>初始化：首先带0的肯定是要初始化的，至于怎么初始化，看dp[i] [0]，代表的含义以i-1为结尾的s可以随便删除元素，出现空字符串的个数；那么s删除所以元素才能 出现空字符串，也就是只有一种情况，所以就是dp[i] [0] = 1; dp[0] [j] 代表的含义是以j-1为结尾的t可以随便删除元素，出现空字符串的个数，那么肯定就是0，因为s为空，是无论如何都不可能变为j的；最后看dp[0] [0]，初始化为1</li><li>遍历顺序：从左到右，从上到下</li><li>举例推导</li></ol><blockquote><p>又是那个问题，边界没有注意到</p></blockquote><h2 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h2><p>两种动态规划的思路：</p><p>思路一：与上述的最长公共子序列相同，只不过多了一步用两个字符串的总长度减去最长公共子序列的长度</p><p>思路二：</p><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</li><li>确定递推公式：<br>word[i] 和word[j]相等：相等好说，直接dp[i] [j] = dp[i - 1] [j - 1]<br>word[i] 和word[j]不等：不等又有三种情况可以操作，删掉i+1，删掉j+1，同时删掉i和j+2；取最小值</li><li>初始化：dp[i] [0] 和dp[j] [0] 和dp[0] [0]是必须要初始化的；dp[i] [0]初始化为i，dp[0] [j]初始化为j，dp[0] [0]初始化为0</li><li>遍历顺序：两层循环，外层i</li><li>举例推导</li></ol><blockquote><p>1、Math.min() 该方法只能比较两个数的大小，碰到三个的就用两次该方法吧</p><p>2、要求最小值，那么每一次操作的+1必不可少</p></blockquote><h2 id="编辑距离-（经典）"><a href="#编辑距离-（经典）" class="headerlink" title="==编辑距离==（经典）"></a>==编辑距离==（经典）</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要操作元素的最少次数。</li><li>确定递推公式：<br>分两种情况：要么相等、要么不等<br>相等的情况：直接dp[i] [j] = dp[i - 1] [j - 1]<br>不等的情况：又分三种情况，需要word1增、删、改<pre><code class="hljs">                   增：word1增也即word2删，即dp[i] [j] = dp[i] [j - 1] + 1                   删：dp[i] [j] = dp[i - 1] [j] + 1                   改：改意思是word1 和 word2 相等，即dp[i] [j] = dp[i - 1] [j - 1] + 1</code></pre>取最小值</li><li>初始化：从递推公式可以看出，带0的必须初始化，dp[i] [0]初始化为i，dp[0] [j] 初始化为j</li><li>遍历顺序：两层循环，外层i</li><li>举例推导</li></ol><p>我愿称之为经典</p><h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j] 表示i到j的回文数</li><li>确定递推公式：<br>同样，s[i] 和s[j] 分相等和不等<br>不等：dp[i] [j] = false<br>相等：i和j相等或相差1，如a,   aa;   i 和j相差大于1，大于1，说明两个边已经是回文了，那么就判断里面是否也是回文，也即判断i+1 和 j - 1；</li><li>初始化：dp[i] [j]初始化为false</li><li>遍历顺序：dp[i] [j] 用到了 dp[i+1] [j-1]。意思是要用到左下角的数据，所以是从下到上，从左到右</li><li>举例推导</li></ol><blockquote><p>if (dp[i] [j])  和 if (dp[i] [j] == true)是判断是否为true<br>if (dp[i] [j] = true) 是赋值</p></blockquote><p>还有一种思路：</p><p>中心扩散法。  遍历每个回文中心，若相等同时向两边扩散，同时总数+1</p><h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p>动态规划五部曲：</p><ol><li>确定dp数组的含义：dp[i] [j] 表示i到j的回文数</li><li>确定递推公式：<br>两种情况，s[i] 和 s[j] 相等，不等<br>相等：  那么向里边扩散，即dp[i] [j] = dp[i + 1] [ j -1] + 2<br>不等： 判断向左大还是向右，即dp[i] [j] = max(dp[i + 1] [j], dp[i] [ j - 1], dp[i] [j])</li><li>初始化：dp[i] [i] 初始化为1，其余初始化为0</li><li>遍历顺序：遍历顺序从递推公式开始，可以看出，这一行用到的数据需要用到下一行的数据，那也就是从下到上，从左到右</li><li>举例推导</li></ol><hr><h4 id="1235-规划兼职工作"><a href="#1235-规划兼职工作" class="headerlink" title="1235. 规划兼职工作"></a><a href="https://leetcode.cn/problems/maximum-profit-in-job-scheduling/">1235. 规划兼职工作</a></h4>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/2022/09/15/wo-de-di-yi-pian-bo-ke-wen-zhang/"/>
      <url>/2022/09/15/wo-de-di-yi-pian-bo-ke-wen-zhang/</url>
      
        <content type="html"><![CDATA[<p>第一章</p><p>第二章</p><p>内容</p><p>参考文献</p><p>域名</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/15/hello-world/"/>
      <url>/2022/09/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
